<!doctype html>
<head>
<meta charset="utf-8">
<title>3 Simics Feature List</title>
<link rel="stylesheet" href="../simics.css">
<script src="../page-script.js"></script>
</head>
<div class="chain">
<a href="standard-limitations.html">2 Standard Limitations</a>
</div>
<div class="path">
<a href="index.html">Product Family Overview</a>
&nbsp;/&nbsp;</div><h1 id="simics-feature-list"><a href="#simics-feature-list">3 Simics Feature List</a></h1>
<p>This section provides a short but comprehensive list of the major product characteristics and features of Simics 6. For more detailed descriptions, refer to the complete Simics documentation.</p>
<h2 id="product-characteristics"><a href="#product-characteristics">3.1 Product Characteristics</a></h2>
<div class="dl">
<ul>
<li>
<p><span class="term" id="dt:deterministic-simulation"><a href="#dt:deterministic-simulation">Deterministic Simulation</a></span><br>
Simics is deterministic, forcing the exact same sequence of simulated instructions and device events to occur when rerunning the simulation. A deterministic simulation greatly simplifies debugging of target systems.</p>
</li>
<li>
<p><span class="term" id="dt:non-intrusive-inspection"><a href="#dt:non-intrusive-inspection">Non-intrusive Inspection</a></span><br>
Observation of the simulated system by scripts, GUI, command line and actions like checkpoint creation is non-intrusive; i.e., the simulation does not change although observation is being done.</p>
</li>
<li>
<p><span class="term" id="dt:well-defined-api"><a href="#dt:well-defined-api">Well-defined API</a></span><br>
Simics exports two well-defined application programming interfaces (APIs) based on C available in C/C++. One for device modeling, the Device API and one for extending the simulator, the Simulator API. The two APIs are also available in Python, and there is a small Python-only API in addition.</p>
</li>
<li>
<p><span class="term" id="dt:api-and-abi-compatibility"><a href="#dt:api-and-abi-compatibility">API and ABI Compatibility</a></span><br>
Simics follows the standard semantic versioning rules. This implies that in minor releases (where only the second digit in the version number changes), there can be additions to the API, but not removals, so Simics maintains ABI compatibility. Hence there is no need to recompile modules when upgrading.</p>
<p>The API remains compatible with previous Simics releases. When building modules written for an older version of Simics, the API to use must be specified.</p>
</li>
<li>
<p><span class="term" id="dt:modular-product-distribution"><a href="#dt:modular-product-distribution">Modular Product Distribution</a></span><br>
The Simics product is distributed as a single common base package, with several add-on packages. There is typically one add-on package for every modeled system architecture. Installing support for a new architecture for example does not require the base package to be re-installed. Add-on packages and the base package can be upgraded independently of each other within the same major release.</p>
</li>
</ul>
</div>
<h2 id="simics"><a href="#simics">3.2 Simics</a></h2>
<h3 id="general-features"><a href="#general-features">3.2.1 General Features</a></h3>
<div class="dl">
<ul>
<li>
<p><span class="term" id="dt:save-and-restore-of-checkpoints"><a href="#dt:save-and-restore-of-checkpoints">Save and Restore of Checkpoints</a></span><br>
The simulation state of an entire Simics simulation can be saved to disk and restored at a later time in a host independent format. Saving a checkpoint can be done at any point in time during a simulation. Checkpoints are stored in a combination of human readable configuration files and binary files for large state (such as simulated disk or memory) and can be annotated with a clear text description. Checkpoints are incremental by default, i.e. only data that has changed since the last checkpoint is saved. But independent, stand-alone checkpoints can also be created. Only the simulated state is saved is a checkpoint; session data such as simulator preferences and statistics is not. It is also possible to include a recording of user and network input in a checkpoint. Old checkpoints can usually be loaded into newer versions of Simics.</p>
</li>
<li>
<p><span class="term" id="dt:snapshots"><a href="#dt:snapshots">Snapshots</a></span><br>
The simulation state can also be saved as in-memory snapshots. This is similar to checkpoints but is used within one simulation session. Snapshots can be loaded later, thus jumping between different points in simulation time.</p>
</li>
<li>
<p><span class="term" id="dt:save-and-restore-of-persistent-data"><a href="#dt:save-and-restore-of-persistent-data">Save and Restore of Persistent Data</a></span><br>
Persistent data, such as disk images and NVRAM contents that survive power-cycling, can be saved and restored at any time without the need to save the complete simulated state.</p>
</li>
<li>
<p><span class="term" id="dt:dynamic-machine-configuration-system"><a href="#dt:dynamic-machine-configuration-system">Dynamic Machine Configuration System</a></span><br>
Simics simulations are configured using objects and object attributes. The configuration language is used to setup machines and connect machines via networks. Configurations are host independent and can be created programmatically. Although editing by hand is possible configurations are typically created by tools, such as the component system. Objects can be added to and removed from the simulation at any time.</p>
</li>
<li>
<p><span class="term" id="dt:high-level-component-configuration-system"><a href="#dt:high-level-component-configuration-system">High-Level Component Configuration System</a></span><br>
The primary configuration system uses components that represent actual replaceable hardware units, such as mother-boards, disks, keyboards, PCI cards and network links. Components support hot-plugging if applicable, and they also make sure that only valid hardware configurations are set up.</p>
</li>
<li>
<p><span class="term" id="dt:hierarchical-configuration-system"><a href="#dt:hierarchical-configuration-system">Hierarchical Configuration System</a></span><br>
The configuration system supports hierarchies of objects as a way to impose structure of large and complex system. Some configuration aspects are inherited based on the hierarchy, simplifying setup.</p>
</li>
<li>
<p><span class="term" id="dt:recording-of-asynchronous-input"><a href="#dt:recording-of-asynchronous-input">Recording of Asynchronous Input</a></span><br>
Simics can record all input coming from the real world, allowing replay of a simulated session. Since the simulation is deterministic, a session can be rerun with the exact same result. Asynchronous input includes network traffic, serial port communication, keyboard and mouse input. The recording can also be saved separately or together with a checkpoint.</p>
</li>
<li>
<p><span class="term" id="dt:hybrid-simulation"><a href="#dt:hybrid-simulation">Hybrid Simulation</a></span><br>
The Hybrid Simulation feature allows integration between Simics and an external, much more timing accurate simulation model. As the accurate model will run significantly slower than a Simics functional model, the functional model can be used for workload positioning. Once this has been done, the simulation state can be transferred (and transformed) into the accurate model, and simulation can be continued.</p>
<p>Integration of external timing accurate models require specific development, please contact Simics Support for more information.</p>
</li>
<li>
<p><span class="term" id="dt:integrated-python-support"><a href="#dt:integrated-python-support">Integrated Python support</a></span><br>
Simics is built and distributed as a binary Python extension module. It can be used with any sufficiently recent Python interpreter that is compatible with standard CPython binary modules.</p>
</li>
<li>
<p><span class="term" id="dt:scripting-languages"><a href="#dt:scripting-languages">Scripting Languages</a></span><br>
In Simics, one can use Python for both simple and more advanced scripting, with access to the full Simics API.</p>
<p>The Simics specific command line interface (CLI) can also be used to write scripts.</p>
</li>
<li>
<p><span class="term" id="dt:quick-start-platform-for-x86"><a href="#dt:quick-start-platform-for-x86">Quick-Start Platform for x86</a></span><br>
The Simics Quick-Start Platform for x86 is a model of a standard IntelÂ®-based personal computer (PC). The virtual platform boots from a TianoCore-based open-source UEFI (Unified Extensible Firmware Interface) and can run modern Linux, Windows*, and other operating system distributions. The platform is highly configurable and includes aspects like the number and types of processor cores, memory size, disks, network setup, PCIe* cards, and more.</p>
</li>
<li>
<p><span class="term" id="dt:network-services"><a href="#dt:network-services">Network Services</a></span><br>
Simics includes a virtual network server which provides a number of common network services over IPv4, and in some cases IPv6, on Ethernet networks. These include BOOTP, DHCP, DHCPv6, DNS, FTP, NTP, RARP, and TFTP.</p>
</li>
<li>
<p><span class="term" id="dt:computer-industry-standards"><a href="#dt:computer-industry-standards">Computer Industry Standards</a></span><br>
A wide range of common computer standards are supported and implemented in Simics in some form. There is often generic support for common protocols that can be extended for specific devices.</p>
</li>
</ul>
</div>
<h3 id="performance"><a href="#performance">3.2.2 Performance</a></h3>
<div class="dl">
<ul>
<li>
<p><span class="term" id="dt:host-multithreading"><a href="#dt:host-multithreading">Host Multithreading</a></span><br>
Simics can utilize more that one host core to get improved simulation performance for both target systems that can be partitioned into multiple machines, called <em>cells</em> in Simics, and for tightly-coupled multi-processor target systems based on the ARM, PPC and x86 architectures.</p>
</li>
<li>
<p><span class="term" id="dt:distributed-simulation"><a href="#dt:distributed-simulation">Distributed Simulation</a></span><br>
A simulation can be distributed over several Simics processes, either running on the same real host or on multiple networked hosts. A distributed simulation keeps the determinism of non-distributed simulations, and maintains global time across all processes. Simulations can be distributed at link boundaries, such as Ethernet and serial port connections.</p>
</li>
<li>
<p><span class="term" id="dt:run-time-code-generation"><a href="#dt:run-time-code-generation">Run-time Code Generation</a></span><br>
Simics uses a run-time code generator to achieve high performance, often better than 10x compute slowdown.</p>
<p>Supported architectures: ARM, MIPS, PPC, RISC-V, SH4, SPARC-V8, x86.</p>
</li>
<li>
<p><span class="term" id="dt:hardware-assisted-virtualization-vmp"><a href="#dt:hardware-assisted-virtualization-vmp">Hardware-assisted Virtualization - VMP</a></span><br>
The Simics VMP feature can improve the simulated performance by utilizing the hardware virtualization support found in modern IntelÂ® processors.</p>
</li>
<li>
<p><span class="term" id="dt:hypersimulation"><a href="#dt:hypersimulation">Hypersimulation</a></span><br>
Hypersimulation, also known as idle-loop-optimization, improves the performance of the simulation by doing fast forward of the virtual time when the target system is running code without side-effects. The system automatically identifies many hypersimulation opportunities of moderate complexity. For more complex opportunities, users can adapt the hypersimulation to match their own target code.</p>
</li>
<li>
<p><span class="term" id="dt:restriction-on-host-memory-consumption"><a href="#dt:restriction-on-host-memory-consumption">Restriction on Host Memory Consumption</a></span><br>
The amount of host memory used by Simics to cache simulated memory and disk images can be limited to avoid memory related performance problems. Excess data is swapped out to files in a user specified directory.</p>
</li>
<li>
<p><span class="term" id="dt:real-time-mode"><a href="#dt:real-time-mode">Real-time Mode</a></span><br>
Simics can be throttled to make sure that virtual time does not run faster than real time, or faster than some fixed ratio compared to real time.</p>
</li>
</ul>
</div>
<h3 id="processor-features"><a href="#processor-features">3.2.3 Processor Features</a></h3>
<div class="dl">
<ul>
<li>
<p><span class="term" id="dt:instruction-set-architectures"><a href="#dt:instruction-set-architectures">Instruction Set Architectures</a></span><br>
Simics implements at least one processor for each of the following instruction set architectures:</p>
<p>ARC, ARMv5, ARMv6, ARMv7, ARMv8, H8, i8051, M68K, MIPS32, MIPS64, NIOS II, NIOS V, PPC32, PPC64, RISC-V, SH4, SPARC-V8, X86, X86-64.</p>
</li>
<li>
<p><span class="term" id="dt:multi-processor-and-multi-core-models"><a href="#dt:multi-processor-and-multi-core-models">Multi-processor and Multi-core Models</a></span><br>
Target systems with multiple processors (SMP, AMP systems and multi-core processors) are supported.</p>
</li>
<li>
<p><span class="term" id="dt:configurable-ratio-between-cycles-and-instructions"><a href="#dt:configurable-ratio-between-cycles-and-instructions">Configurable Ratio Between Cycles and Instructions</a></span><br>
The CPI (cycles per instruction) of a processor can be modified at run-time to get processor timing that is closer to real hardware for example. Both 0 and infinity are valid CPI values.</p>
</li>
<li>
<p><span class="term" id="dt:generic-parameterized-cache"><a href="#dt:generic-parameterized-cache">Generic Parameterized Cache</a></span><br>
Simics includes a simple parameterized cache which can be configured to have parameters similar to a real cache in both single- and multi-processor systems. The parameters include size, associativity, number of levels, replacement policy and replacement algorithm. Simple miss penalties can be configured.</p>
</li>
<li>
<p><span class="term" id="dt:instrumentation-framework"><a href="#dt:instrumentation-framework">Instrumentation Framework</a></span><br>
The instrumentation framework allows flexible extraction of run-time information from the system in an efficient way. The framework supports processor and device instrumentation, including tracing. It provides generic commands for adding and controlling instrumentation in the simulation. Several example <em>tools</em> and <em>filters</em> are provided with source code as examples.</p>
</li>
<li>
<p><span class="term" id="dt:processor-instrumentation"><a href="#dt:processor-instrumentation">Processor Instrumentation</a></span><br>
It is possible to get callbacks on many events in a processor model such as instruction fetches and execution, data accesses, exceptions and interrupts. Data in transactions and default instruction semantics can be overridden.</p>
</li>
<li>
<p><span class="term" id="dt:device-instrumentation"><a href="#dt:device-instrumentation">Device Instrumentation</a></span><br>
It is possible to get callbacks on device register accesses, where data can be overridden. Instrumentation works automatically for devices written in DML or SystemC.</p>
</li>
<li>
<p><span class="term" id="dt:device-register-coverage"><a href="#dt:device-register-coverage">Device Register Coverage</a></span><br>
Simics can generate information about register coverage, i.e. which registers in a system have been read/written during a session. This can for example be used to verify that expected parts of a system has been covered by tests.</p>
</li>
<li>
<p><span class="term" id="dt:magic-instructions"><a href="#dt:magic-instructions">Magic Instructions</a></span><br>
The software on the simulated system can communicate with the simulator by using magic instructions; i.e., instructions that are treated as NOPs on real hardware, but have a special, user defined, meaning in Simics. The Simics Agent, described separately, provides a more high level way of communication between host and target.</p>
</li>
</ul>
</div>
<h3 id="memory-features"><a href="#memory-features">3.2.4 Memory Features</a></h3>
<div class="dl">
<ul>
<li><span class="term" id="dt:generic-address-spaces"><a href="#dt:generic-address-spaces">Generic Address Spaces</a></span><br>
The memory-space abstraction in Simics supports a generic 64-bit address space where memory and devices can be mapped in. Objects can be mapped at multiple addresses and be mapped overlapping with different priorities. Several common byte-swapping operations are supported for mappings. Memory spaces can be mapped in other spaces, with optional address translation being performed between them.</li>
<li><span class="term" id="dt:dynamic-memory-mapping"><a href="#dt:dynamic-memory-mapping">Dynamic Memory Mapping</a></span><br>
Both memory and devices can be mapped and unmapped in memory-spaces at any time during the simulation. This is typically used when simulating system chipsets and host bridges that allow target software to modify the memory and device layout in the physical memory space.</li>
<li><span class="term" id="dt:catch-accesses-to-unmapped-areas"><a href="#dt:catch-accesses-to-unmapped-areas">Catch Accesses to Unmapped Areas</a></span><br>
Memory areas that are not mapped by any device or memory can either be handled as on real hardware or caught by the simulator producing a warning or triggering a user callback.</li>
<li><span class="term" id="dt:memory-access-callbacks"><a href="#dt:memory-access-callbacks">Memory Access Callbacks</a></span><br>
User callbacks can be installed for each memory space and are called on memory accesses.</li>
</ul>
</div>
<h3 id="breakpoint-features"><a href="#breakpoint-features">3.2.5 Breakpoint Features</a></h3>
<div class="dl">
<ul>
<li><span class="term" id="dt:memory-access-breakpoints"><a href="#dt:memory-access-breakpoints">Memory Access Breakpoints</a></span><br>
Breakpoint can be set on reads, writes and execution from memory. Any number of breakpoints can be used and they can be of any size. Breakpoints usually have a very small impact on performance.</li>
<li><span class="term" id="dt:time-breakpoints"><a href="#dt:time-breakpoints">Time Breakpoints</a></span><br>
Breakpoints can be set on cycle or step count for each processor and on time in seconds.</li>
<li><span class="term" id="dt:instruction-breakpoints"><a href="#dt:instruction-breakpoints">Instruction Breakpoints</a></span><br>
Execution breakpoints can be set on instruction disassembly sub-strings and instruction bit patterns.</li>
<li><span class="term" id="dt:processor-register-breakpoints"><a href="#dt:processor-register-breakpoints">Processor Register Breakpoints</a></span><br>
Read and write breakpoints can be set on processor register writes.</li>
<li><span class="term" id="dt:processor-exception-breakpoints"><a href="#dt:processor-exception-breakpoints">Processor Exception Breakpoints</a></span><br>
The execution can be stopped when a processor takes a specific exception.</li>
<li><span class="term" id="dt:device-access-breakpoints"><a href="#dt:device-access-breakpoints">Device Access Breakpoints</a></span><br>
Breakpoints can be set on accesses to memory and port mapped devices.</li>
<li><span class="term" id="dt:notifier-trigger-breakpoints"><a href="#dt:notifier-trigger-breakpoints">Notifier/Trigger Breakpoints</a></span><br>
Breakpoints can be set on notifiers (see Simulation and Simulator Triggers) occurrences.</li>
<li><span class="term" id="dt:console-output-breakpoints"><a href="#dt:console-output-breakpoints">Console Output Breakpoints</a></span><br>
It is possible to set breakpoints on console output. For text consoles, a string to break on is used. Graphical consoles have support for breaking on a rectangular bitmap area.</li>
</ul>
</div>
<h3 id="communication-channels"><a href="#communication-channels">3.2.6 Communication Channels</a></h3>
<p>Communication links in Simics that work with multithreading and distribution. Links provide the only supported target communication between simulated machines that run in different host threads or on different host machines.</p>
<div class="dl">
<ul>
<li><span class="term" id="dt:ethernet"><a href="#dt:ethernet">Ethernet</a></span><br>
Generic models of an Ethernet cable, a switch and a hub.</li>
<li><span class="term" id="dt:i2c"><a href="#dt:i2c">I2C</a></span><br>
A link for I2C communication.</li>
<li><span class="term" id="dt:i3c"><a href="#dt:i3c">I3C</a></span><br>
A link for I3C communication.</li>
<li><span class="term" id="dt:serial"><a href="#dt:serial">Serial</a></span><br>
A serial link that can be connected to UARTs and text consoles.</li>
<li><span class="term" id="dt:signal"><a href="#dt:signal">Signal</a></span><br>
A link for single line signals.</li>
<li><span class="term" id="dt:link-library"><a href="#dt:link-library">Link Library</a></span><br>
A link library is provided for creating new user defined link types, replacing the old generic message link.</li>
</ul>
</div>
<h3 id="host-access"><a href="#host-access">3.2.7 Host Access</a></h3>
<div class="dl">
<ul>
<li><span class="term" id="dt:exported-serial-line"><a href="#dt:exported-serial-line">Exported Serial Line</a></span><br>
A simulated serial port can be made visible to the host system where Simics is running. On Linux systems, this is implemented by connecting the simulated device to a pseudo terminal (pty). On Windows, a virtual COM port on the host is used.</li>
<li><span class="term" id="dt:telnet-to-serial-port"><a href="#dt:telnet-to-serial-port">Telnet to Serial Port</a></span><br>
Simulated serial ports can be accessed using a standard telnet client from a real host.</li>
<li><span class="term" id="dt:vnc-to-graphical-console"><a href="#dt:vnc-to-graphical-console">VNC to Graphical Console</a></span><br>
It is possible to connect to a simulated graphical console from a VNC client.</li>
<li><span class="term" id="dt:host-serial-port"><a href="#dt:host-serial-port">Host Serial Port</a></span><br>
A simulated serial port can be connected to a real serial port on the host. On Windows hosts, additional third-party software is needed.</li>
<li><span class="term" id="dt:the-simics-agent"><a href="#dt:the-simics-agent">The Simics Agent</a></span><br>
The Simics agent runs on the simulated target system and can be controlled from the Simics command line. It supports file transfers between the host and the target machine, without the need for any network connection.</li>
<li><span class="term" id="dt:simics-file-system-for-linux"><a href="#dt:simics-file-system-for-linux">Simics File System for Linux</a></span><br>
The Simics file system is a kernel module for the simulated Linux operating system that gives the target machine access to the host file system.</li>
<li><span class="term" id="dt:iso-file-as-cd-rom-and-dvd-rom-medium"><a href="#dt:iso-file-as-cd-rom-and-dvd-rom-medium">ISO file as CD-ROM and DVD-ROM Medium</a></span><br>
The simulated CD-ROM drive can use a standard ISO 9660 file as CD/DVD-ROM medium.</li>
<li><span class="term" id="dt:host-hard-disk"><a href="#dt:host-hard-disk">Host Hard Disk</a></span><br>
Hard disks and disk partitions on the host can be used as part of a simulated hard disk. The disk can be used in either read-only or read-write mode.</li>
<li><span class="term" id="dt:graphical-display"><a href="#dt:graphical-display">Graphical Display</a></span><br>
Output from simulated graphics devices are displayed in a separate window on the host, a <em>graphical console</em>.</li>
<li><span class="term" id="dt:keyboard-and-mouse"><a href="#dt:keyboard-and-mouse">Keyboard and Mouse</a></span><br>
The keyboard and the mouse of the real host can be used to give input to the simulated keyboard and mouse.</li>
<li><span class="term" id="dt:system-panel"><a href="#dt:system-panel">System Panel</a></span><br>
A System Panel is a graphical interface for controlling and inspecting a specific simulated machine. The panel can either be a concrete panel, which could represent the front of a computer with buttons and blinking LEDs; or it can be an abstract panel that can be, for example, used to inject network traffic or other data into a simulated system.</li>
<li><span class="term" id="dt:port-forwarding-nat"><a href="#dt:port-forwarding-nat">Port-forwarding/NAT</a></span><br>
Port forwarding (incoming) and NAT (outgoing) allow the target systems to communicate with the real network using their own private IP addresses. Simics translates between external and internal IP addresses. Port-forwarding/NAT does not require administrator privileges to setup. Both UDP- and TCP-based protocols are supported, although a few higher level level protocols, such as FTP, may require special support. Common protocols that work are SSH, Telnet, TFTP, FTP and HTTP.</li>
<li><span class="term" id="dt:ethernet-bridge"><a href="#dt:ethernet-bridge">Ethernet Bridge</a></span><br>
Simics can act as an Ethernet bridge between the real and simulated network, where the simulated machines appear to be on the real Ethernet network. Administrator privileges on the host are required for installation. The simulated machines have to be configured with IP addresses matching the real network.</li>
<li><span class="term" id="dt:virtual-host-interface-on-the-simulated-network"><a href="#dt:virtual-host-interface-on-the-simulated-network">Virtual Host Interface on the Simulated Network</a></span><br>
Simics can create a virtual interface (TAP) on the real host that appears as a network device on the simulated network.</li>
</ul>
</div>
<h3 id="remote-interfaces"><a href="#remote-interfaces">3.2.8 Remote Interfaces</a></h3>
<div class="dl">
<ul>
<li><span class="term" id="dt:gdb-remote"><a href="#dt:gdb-remote">GDB Remote</a></span><br>
Simics supports the GDB remote protocol. Multiple GDB debuggers can be connected to Simics simultaneously, one to each target.</li>
<li><span class="term" id="dt:telnet-frontend"><a href="#dt:telnet-frontend">Telnet Frontend</a></span><br>
It is possible to connect to a running Simics using a standard telnet client for access to the command line.</li>
</ul>
</div>
<h3 id="miscellaneous-features"><a href="#miscellaneous-features">3.2.9 Miscellaneous Features</a></h3>
<div class="dl">
<ul>
<li><span class="term" id="dt:simulation-and-simulator-triggers"><a href="#dt:simulation-and-simulator-triggers">Simulation and Simulator Triggers</a></span><br>
Simics defines notifiers as pre-defined conditions in the simulation that trigger the callback of one or more user-installed function. Users may also add new notifiers to the simulation. Notifiers are either simulation or simulator specific. Examples of the first kind are processor interrupt, control register write and magic instruction. Examples of the second kind are configuration object created, simulation stopped and preferences changed.</li>
<li><span class="term" id="dt:time-server"><a href="#dt:time-server">Time Server</a></span><br>
The virtual time can be distributed to externally running tools, allowing them to run with the same virtual time as the simulated session. This is useful for timing sensitive tests, for example, when the real and simulated time differs.</li>
<li><span class="term" id="dt:loading-binary-files-into-simulated-memory"><a href="#dt:loading-binary-files-into-simulated-memory">Loading Binary Files into Simulated Memory</a></span><br>
Simics can load binary files, including executables, directly into the simulated memory, without the need for any initial loader software. The formats supported are raw binary files, ELF, Motorola S-Record, PE32 and PE32+, Intel .obj and Intel HEX.</li>
<li><span class="term" id="dt:compressed-disk-images"><a href="#dt:compressed-disk-images">Compressed Disk Images</a></span><br>
Disk images for simulated systems can be stored in a compressed random access format, called CRAFF, to save disk space on the host. The compression is transparent to the target system. The standard VHDX format is also supported.</li>
<li><span class="term" id="dt:load-and-store-of-memory-and-disk-to-host-file"><a href="#dt:load-and-store-of-memory-and-disk-to-host-file">Load and Store of Memory and Disk to Host File</a></span><br>
Parts of, or complete, memory and disk images in Simics can be saved to a file on the host file system.</li>
<li><span class="term" id="dt:ethernet-frame-injection"><a href="#dt:ethernet-frame-injection">Ethernet Frame Injection</a></span><br>
Frames on the simulated Ethernet link can be inserted, removed and modified by the user. It is possible to inject a stream of frames using the PCAP format.</li>
</ul>
</div>
<h2 id="simics-analyzer"><a href="#simics-analyzer">3.3 Simics Analyzer</a></h2>
<h3 id="general-features-2"><a href="#general-features-2">3.3.1 General Features</a></h3>
<div class="dl">
<ul>
<li><span class="term" id="dt:symbolic-debugging"><a href="#dt:symbolic-debugging">Symbolic Debugging</a></span><br>
Simics has built-in support for source code debugging of programs written in C/C++. The formats supported are ELF with DWARF debug information and PE32 with PDB debug information. Formats such as COFF and STABS are not supported. The debugger works with ARM, PPC, X86, MIPS and ARC targets.</li>
<li><span class="term" id="dt:os-aware-process-tracking"><a href="#dt:os-aware-process-tracking">OS Aware Process Tracking</a></span><br>
Simics can detect when processes start and exist on the simulated machine, and keep track of what process that is currently active. Process tracking is useful for single process debugging, or when collecting statistics on a per process basis. Since knowledge about the target OS is needed, the process tracker has to be extended to support new operating systems. There is also a simple process tracker that only differentiates between user and supervisor mode that can be used if the OS is not supported. See Analyzer User's Guide for list of supported systems, including Linux, UEFI and VxWorks.</li>
<li><span class="term" id="dt:code-coverage"><a href="#dt:code-coverage">Code Coverage</a></span><br>
Simics supports collecting code coverage (statement and branch coverage) on C/C++ and assembler source code for software running on the simulated target without any need to instrument the binary code.</li>
</ul>
</div>
<h2 id="simics-model-builder"><a href="#simics-model-builder">3.4 Simics Model Builder</a></h2>
<p>See <a href="../installation-guide/hardware-and-software-requirements.html"><em>Hardware and Software Requirements</em></a> for supported compilers.</p>
<div class="dl">
<ul>
<li>
<p><span class="term" id="dt:user-developed-devices"><a href="#dt:user-developed-devices">User Developed Devices</a></span><br>
Users can develop their own models of devices by writing DML, Python, SystemC or plain C/C++.</p>
</li>
<li>
<p><span class="term" id="dt:dml"><a href="#dt:dml">DML</a></span><br>
The device modeling tool DML simplifies the task of implementing simulation models at the right level of abstraction and makes it easier to develop models that support standard features such as inspection, checkpointing and snapshots.</p>
</li>
<li>
<p><span class="term" id="dt:systemc-library"><a href="#dt:systemc-library">SystemC Library</a></span><br>
The SystemC library enables a SystemC device to be integrated into a Simics simulation. This is done by compiling the SystemC kernel into a Simics module, together with the SystemC simulation models.</p>
<p>The user will have to write translators between the SystemC and Simics interfaces.</p>
<p><strong>Limitation:</strong> For checkpointing to work, the SystemC model has to be adapted to use the Simics checkpoint mechanism.
Also, it may not use threads or have some other implicit state.</p>
</li>
<li>
<p><span class="term" id="dt:system-panel-build-kit"><a href="#dt:system-panel-build-kit">System Panel Build Kit</a></span><br>
The System Panel Build Kit enables the construction of System Panels. A System Panel is a graphical interface for controlling and inspecting a specific simulated machine.</p>
</li>
<li>
<p><span class="term" id="dt:example-code"><a href="#dt:example-code">Example Code</a></span><br>
There is example code in DML and Python included for several common device classes such as DMA, I2C, PCI, interrupt, serial devices and timers.</p>
</li>
<li>
<p><span class="term" id="dt:multithreaded-user-extensions"><a href="#dt:multithreaded-user-extensions">Multithreaded User Extensions</a></span><br>
Simics extensions may be written using threads, both in C/C++ and in Python. Only a few thread safe functions in the Simics API are then available. The rest of the API can be accessed by synchronizing to the Simics core, which is done using the thread safe functions.</p>
</li>
<li>
<p><span class="term" id="dt:access-to-python-from-c-c"><a href="#dt:access-to-python-from-c-c">Access to Python From C/C++</a></span><br>
The Simics API allows extensions to evaluate Python code in the global Python interpreter environment and to get a return value back.</p>
</li>
<li>
<p><span class="term" id="dt:access-to-c-functions-from-python"><a href="#dt:access-to-c-functions-from-python">Access to C Functions from Python</a></span><br>
User defined Simics <em>interfaces</em> can be called from Python code.</p>
</li>
<li>
<p><span class="term" id="dt:user-defined-commands"><a href="#dt:user-defined-commands">User-defined Commands</a></span><br>
Users can add their own commands to the command line interface. Commands can be added dynamically at any time.</p>
</li>
<li>
<p><span class="term" id="dt:user-defined-processor-instructions"><a href="#dt:user-defined-processor-instructions">User-defined Processor Instructions</a></span><br>
Using the instrumentation framework, a user may override the semantics of existing instructions or define new ones.</p>
</li>
<li>
<p><span class="term" id="dt:user-developed-processors"><a href="#dt:user-developed-processors">User Developed Processors</a></span><br>
Users can plug in their own processor models in Simics using the Simics Processor API.</p>
</li>
<li>
<p><span class="term" id="dt:user-developed-simulator-extensions"><a href="#dt:user-developed-simulator-extensions">User Developed Simulator Extensions</a></span><br>
The simulator can be extended by modules written in Python or C/C++.</p>
</li>
<li>
<p><span class="term" id="dt:simics-as-a-library"><a href="#dt:simics-as-a-library">Simics as a Library</a></span><br>
There is a Simics shared object (DLL/.so) that can be linked with other binaries. This can be used to integrate Simics into another simulator or application.</p>
</li>
<li>
<p><span class="term" id="dt:time-synchronization-library"><a href="#dt:time-synchronization-library">Time Synchronization Library</a></span><br>
The time synchronization library, as its name implies, provides synchronization of the virtual time in Simics with the virtual time in an external simulator. It also provides a deterministic way to exchange information between them, such as network traffic.</p>
</li>
<li>
<p><span class="term" id="dt:hypersimulation-interface"><a href="#dt:hypersimulation-interface">Hypersimulation Interface</a></span><br>
There is an interface for adding user-written hypersimulation patterns (idle loop detectors) to the generic hypersimulation framework.</p>
</li>
</ul>
</div>

<div class="chain">
<a href="standard-limitations.html">2 Standard Limitations</a>
</div>