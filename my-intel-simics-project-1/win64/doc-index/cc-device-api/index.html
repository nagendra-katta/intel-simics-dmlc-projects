<!doctype html>
<head>
<meta charset="utf-8">
<title>C++ Device API v2</title>
<link rel="stylesheet" href="../simics.css">
<script src="../page-script.js"></script>
</head>
<div class="chain"><a href="index.single-page.html" target=_blank>üñ®Ô∏è Single Page</a></div>
<div class="path"></div><h1 id="c-device-api-v2"><a href="#c-device-api-v2">C++ Device API v2</a></h1>
<h2 id="introduction"><a href="#introduction">1 Introduction</a></h2>
<p>This document describes the Simics C++ Device API, which is a C++ layer built on top of the Simics C API. See the
<a href="../model-builder-user-guide/index.html">Model Builder User's Guide</a> for more information about the C API. The C++ Device API is also used when integrating SystemC models into the Simics framework. See the
<a href="../systemc-library/index.html">SystemC Library Programming Guide</a> for more information about Simics and SystemC models.</p>
<p>We recommend that you use DML for writing new simulation models, but it is often necessary to port existing simulations models from a different environment to Simics. If these are written in C++ or SystemC, you can use the <em>C++ Device API</em> to simplify the task. For SystemC there is further support described in the
<a href="../systemc-library/index.html">SystemC Library Programming Guide</a>.</p>
<p>The Simics C++ Device API is a collection of C++ functions, data types, and templates that make it easier to connect a C++ simulation model to the Simics framework. The C++ Device API is implemented as a layer on top of the Simics C API, and the detailed API documentation is found in the <em>Simics C++ Device API Reference Manual</em>. The source code is found in <code>[simics]/src/devices/c++-api</code>.</p>
<p>While this application note aims to cover most aspects of porting C++ device models to the Simics APIs, it is assumed that you are familiar with the Simics device modeling concepts described in the
<a href="../model-builder-user-guide/index.html">Model Builder User's Guide</a>.</p>
<h2 id="about-the-simics-c-device-api-version-2"><a href="#about-the-simics-c-device-api-version-2">2 About the Simics C++ Device API version 2</a></h2>
<p>Version 2 of the Simics C++ Device API replaces the old Simics C++ Device API, which has been retroactively named as the Simics C++ Device API v1. The v1 API was developed before the C++11 standard was introduced. The v1 API also has some technical limitations; for example, no support for Simics port objects that was introduced in Simics version 6.</p>
<h3 id="minimal-requirements"><a href="#minimal-requirements">2.1 Minimal requirements</a></h3>
<p>The v2 API utilizes C++11 and C++14 features to improve productivity. It has been designed to be easier to use and adds support for Simics port objects. To use the v2 API, your C++ compiler must support C++14, which means that the minimal GCC compiler version is 6.3 and the minimal MSVC compiler version is 2015. Later versions are typically used.</p>
<p>Different features have different minimal C++ language standard requirements:</p>
<table><thead><tr><th style="text-align: left">Feature</th><th style="text-align: left">Description</th><th style="text-align: left">Minimal C++ language standard requirement</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>Register Banks</code></td><td style="text-align: left">Used for modelling memory mapped device. The feature is included in a separate header file <code>cc-modeling-api.h</code>. See <a class="reference" href="#register-banks-2">7</a> for how to create and use the <em>register banks</em>.</td><td style="text-align: left">C++17</td></tr>
<tr><td style="text-align: left">Other features</td><td style="text-align: left">Included in header file <code>cc-api.h</code></td><td style="text-align: left">C++14</td></tr>
</tbody></table>
<figure id="api-overview">
<p><img alt="" src="block_diagram.svg"> </p><figcaption>Figure 1. Overview of the Simics C++ device API version 2</figcaption><p></p>
</figure>
<p>Figure <a class="reference" href="#api-overview">1</a> shows the high-level observation of the Simics C++ device API version 2. The v2 API consists of several parts. First it provides support for registration of a Simics class which connects with your C++ device. It also provides <em>Port</em> and <em>Connect</em> concept to communicate with other Simics modules. Then for inspection and checkpointing, it also includes support for <em>Attribute</em>. The <em>Event</em> concept helps to register events which are driven by the Simics scheduler. Last but not the least, a tech-preview feature to support programming registers is included.</p>
<p>To use the v2 API, you must set <code>USE_CC_API = 2</code> in your module's <code>Makefile</code> and <code>#include &lt;simics/cc-api.h&gt;</code> in your C++ source files. The Simics C++ Device API is exported in the <em>simics</em> namespace.</p>
<p>The module <code>sample-device-c++</code> provides source code that shows how to use the API described in this document. Use <code>bin/project-setup --copy-module sample-device-c++</code> to copy the code to your Simics project for easy reference.</p>
<h2 id="preparations"><a href="#preparations">3 Preparations</a></h2>
<p>Before you start to connect your C++ device to the Simics API, you need to consider which the logical components of your device model are, and how they are connected to each other and the rest of the simulation environment.</p>
<p>In Simics, device models are implemented as separate objects that are dynamically connected to each other using the Simics configuration system, and the objects communicate using explicitly requested interfaces. This is in contrast to C++, where the objects are often aggregated at compile time or by running compiled startup code and interfaces are resolved during compilation and linking. The
<em>Model Builder User's Guide</em> has a more complete description of the Simics object system.</p>
<p>Similar to C++, <em>objects</em> in the Simics simulator are instances of <em>classes</em>. However, Simics classes are not C++ classes but instead defined by Simics <em>modules</em>. Simics modules declare Simics classes by calling the Simics API when the module is loaded. Simics classes have attributes, interfaces, port objects, and callbacks to allocate and delete instances of the class. The C++ API provides a convenient way to express these Simics simulator concepts in C++, but there is not a 1-to-1 correspondence between C++ classes and Simics classes.</p>
<h3 id="designing-the-simics-classes"><a href="#designing-the-simics-classes">3.1 Designing the Simics classes</a></h3>
<p>The first step is to decide how the C++ model should appear within Simics. For a simple C++ model that models a small piece of hardware, it is probably sufficient to make the entire model into a single Simics class.</p>
<p>But for a C++ model that consists of several components connected together, it is worth considering exposing it as several Simics classes. One reason for this is that it makes the Simics configuration more natural by creating a model that fits better with the Simics framework. And it allows for future separation of the model parts without major changes to the configurations.</p>
<p>Simply exposing the model as several classes will not automatically make the classes independent under the surface; they are still implemented as one conglomerate of C++ objects inside the implementation. To fully take advantage of the flexibility of the Simics configuration system, the device should be split it to discrete pieces that communicate only using Simics interfaces. By using well-known interfaces, the devices will become replaceable by newer implementations individually, and will allow experimentation in reconfiguration without having to recompile the model sources, or even having access to the source code.</p>
<p>This document focuses on creating Simics modules wrapping simple C++ models which define a single Simics class, but it easily extends to modules with several classes.</p>
<h3 id="defining-attributes"><a href="#defining-attributes">3.2 Defining Attributes</a></h3>
<p>A Simics object <em>attribute</em> is used to accomplish primarily three things. The first is to specify configuration parameters when initially creating the model instance. This includes connections to other configuration objects, model parameters such as frequencies and buffer sizes, but anything is possible.</p>
<p>The other main purpose of attributes is to allow saving and restoring the model state to support checkpointing. This means that the complete state of the model needs to be available to the Simics configuration system as attribute values. Attributes would be read to save the state of the model, and the attributes would then be written to set the state of a new instance of the model to the same state as saved in the checkpoint.</p>
<p>A third use of attributes is to inspect and control the state of the model. This is usually covered by the same attributes used for checkpointing, as it is about the state of the models. Attributes are <em>read</em> in order to inspect the state, and attributes can also be changed (from scripts or CLI) to force changes to the state of the model during a simulation session.</p>
<p>Attributes should never be used to communicate simulation information between objects after instantiation. They are a model-to-simulator mechanism, not a model-to-model mechanism. Models should communicate over interfaces.</p>
<p>State attributes used for checkpointing and/or inspection could also be used to set the initial state of the model at setup time.</p>
<h4 id="configuration-attributes"><a href="#configuration-attributes">3.2.1 Configuration Attributes</a></h4>
<p>The configurable aspects of the C++ model should be available as configuration attributes. In some cases this will mean small changes to the C++ implementation.</p>
<p>The most common configurable parameter is probably references to other Simics configuration objects, such as interrupt targets, memory spaces, or DMA controllers. All references to other Simics simulation objects have to be provided as configuration parameters. Such references are set using object references when a Simics simulation session is set up. The model must never make any assumptions about which other objects are present in the system configuration or there names.</p>
<p>If the C++ model is written with compile-time configuration using the preprocessor, consider rewriting it to be dynamically reconfigurable. This will make the model more versatile, and potentially much more useful to a broader audience. The overhead of runtime checking of these kinds of configuration parameters is negligible in the vast majority of devices, especially when run in the context of full-system simulation.</p>
<p>For example, a parameter to decide which hardware revision to be compatible with may very well be a run-time parameter. Another option is adding configuration parameters that go outside the scope of the known hardware, by allowing buffer sizes and similar parameters to be reconfigured for experimental purposes.</p>
<h4 id="model-state"><a href="#model-state">3.2.2 Model State</a></h4>
<p>To support checkpointing, the model needs to be able to collect a full description of the current model state and it needs to be able to restore the model to the checkpointed state when the Simics object is created.</p>
<p>To support reversible execution, the requirements are stricter. The object needs to be able to restore from a checkpointed state at any time, even when there is a previous state that must be discarded.</p>
<p>An existing C++ model needs to be examined to find how its simulation state is defined. If the model is not written to handle checkpointing, it may need to be updated with a way to extract and restore the state.</p>
<p>The model state is made available to the Simics configuration system using a number of attributes. There should be one attribute for each piece of the model state. It is a good idea to design the set of attributes for the model in a way that allows some separation of the external, checkpointable representation of the state from the implementation details. Ideally, the checkpoint format should not need to be updated when the implementation is changed, including running on a different host platform, using different C++ classes, internal representation or other structural changes. As a minimum requirement the external representation must not depend on what compiler is used, or whether the model is built for a 32-bit or 64-bit environment. Preferably it should be fully portable between platforms regardless of what CPU architecture the simulation is running on. When changes to the checkpoint format is required, Simics provides ways to still be able to read old checkpoints with updated models.</p>
<p>For example, if the model models a device with 16 32-bit registers with different meaning, it is preferably represented as 16 integer-valued attributes, with names that match those used in the device programming manual.</p>
<p>Never save a copy of the binary in-memory representation of a C++ object or <code>struct</code>. This is highly unportable and may break checkpoint compatibility just by recompiling the source with different compiler flags. Pointer variables obviously break in this case.</p>
<h3 id="interfaces"><a href="#interfaces">3.3 Interfaces</a></h3>
<p>A Simics configuration consists of a number of interacting configuration objects, and the interaction between these objects is done through <em>interfaces</em>. The most commonly implemented interfaces are those used to simulate memory transactions between processors, devices, and memory. For more information about Simics interfaces, see the <a href="../model-builder-user-guide/device-modeling-overview.html#simics-interfaces">Model Builder User's Guide</a>.</p>
<p>A Simics <em>interface</em> can be implemented either on the device model itself or on a separate port object. See <a href="#ports-and-interfaces">Ports and Interfaces</a> for details on how to implement a Simics interface.</p>
<p>A Simics C++ model can use the Simics C interface directly, but it can also use the Simics C++ interface provided by the C++ API for a more idiomatic C++ approach. There is a 1-to-1 mapping from each Simics C interface to its corresponding Simics C++ interface. For example, to use the <code>transaction</code> interface, include the header <code>simics/c++/model-iface/transaction.h</code> in your C++ source files. For a user-defined interface, a Simics C++ interface can be generated. See <a href="#user-defined-interface">User-Defined Interface</a> for instructions on creating and using a user-defined Simics C++ interface.</p>
<p>Due to the possible ABI (Application Binary Interface) compatibility issues, calling the Simics C++ interface directly between C++ classes is not allowed unless they are built from the same Simics module. It is recommended to use the <a href="#connect">Connect</a> class which translates C++ method calls into C function calls as expected by the Simics API. This approach leverages the C language's stable and well-defined ABI.</p>
<h3 id="register-banks"><a href="#register-banks">3.4 Register Banks</a></h3>
<p>A memory-mapped I/O Simics device model interacts with the memory bus using <em>register banks</em>. Each <em>register bank</em> is a separate <em>port object</em>. One device model can have many <em>register banks</em>.</p>
<p>The <em>register bank</em> processes the received transaction and passes it down to the related <code>register</code>s on the bank. Each <code>register</code> is generally used to model a hardware register. Typically some model behavior is triggered when the <code>register</code> is being accessed. A <code>register</code> can be further divided into <code>field</code>s on the bit level.</p>
<p>By using <em>register banks</em>, the rich Simics features are automatically enabled. The <em>register banks</em> can be easily inspected, traced and manipulated using Simics tools. The <code>register</code>s are registered as Simics <code>attribute</code>s and automatically saved in a Simics checkpoint. See <a class="reference" href="#register-banks-2">7</a> for how to create and use the <em>register banks</em>.</p>
<p>For more information about how to design a model for Simics, see
<a href="../model-builder-user-guide/index.html">Model Builder User's Guide</a>.</p>
<h2 id="simics-modules"><a href="#simics-modules">4 Simics Modules</a></h2>
<p>The first step of building a C++ simulation model for Simics is to create a Simics <em>module</em>. Typically, you put each Simics class in a module of its own. It is also common to have multiple closely-related classes in a single module (to simplify distribution if the classes would typically be used together anyway).</p>
<p>To create a Simics C++ module skeleton, you use <code>project-setup</code>:</p>
<div class="dl">
<ul>
<li>
<p><span class="term" id="dt:windows"><a href="#dt:windows">Windows</a></span></p>
<pre><code>&gt; cd my-simics-project
project&gt; bin\project-setup --c++-device my_cc_device
</code></pre>
</li>
<li>
<p><span class="term" id="dt:linux"><a href="#dt:linux">Linux</a></span></p>
<pre><code>$ cd my-simics-project
project$ ./bin/project-setup --c++-device my_cc_device
</code></pre>
</li>
</ul>
</div>
<p>See the <a href="../model-builder-user-guide/build-environment.html#build-environment">Build Environment chapter in the Model Builder User's Guide</a> for details on how to set up a project and creating Simics module skeletons.</p>
<p>When a Simics module is loaded into Simics, it should register the Simics classes within the module with the Simics core. Additionally, it can execute other initialization code for these Simics classes. For detailed instructions on registering Simics classes and running their initialization code, see Chapter <a class="reference" href="#defining-the-simics-class">5.1</a>.</p>
<h3 id="module-configuration"><a href="#module-configuration">4.1 Module Configuration</a></h3>
<p>The standard Simics memory tracking allocator is used by Simics C++ device API by default, by providing it as a custom allocator for new and delete. This is done per module. For a module to use its own custom allocators or even the default new allocator, this feature can be disabled.</p>
<p>To disable the feature, set the <code>USE_CC_MEMORY_MANAGEMENT</code> build parameter to <code>no</code> and rebuild the module.</p>
<h2 id="simics-classes"><a href="#simics-classes">5 Simics Classes</a></h2>
<p>A Simics class defines the properties of an object, including its attributes, interfaces, and class name. Objects are created by instantiating a Simics class and setting the required attributes.</p>
<p>For each Simics configuration object created, a corresponding instance of a C++ object is also created. This C++ object is an instance of a model-defined class that must inherit from the <code>simics::ConfObject</code> class.</p>
<p>The C++ class must have a constructor taking a single parameter of type <code>ConfObjectRef</code> which is passed on to the <code>ConfObject</code> constructor. The C++ class constructor is called internally when the corresponding Simics configuration object is created. The destructor of the C++ class is called internally when the corresponding Simics configuration object is deleted.</p>
<p>In addition of the constructor and destructor, user can override two methods <code>finalize</code> and <code>objects_finalized</code> to register additional functionality if needed. The <code>finalize</code> method is called when all attributes have been initialized in the object, and in all other objects that are created at the same time. This method is supposed to do any object initialization that require attribute values. The <code>objects_finalized</code> method is called after <code>finalize</code> has been called on all objects, so in this method the configuration is ready, and communication with other objects is permitted without restrictions.</p>
<pre><code>#include &lt;simics/cc-api.h&gt;

class SampleClass : public simics::ConfObject {
  public:
    using ConfObject::ConfObject;

    // This static method is invoked from simics::make_class
    static void init_class(simics::ConfClass *cls) {
        // register the class properties like attribute, port, event,
        // interface and logging settings
    }
};
</code></pre>
<p>This is the main object of the model instance, and everything goes through this. It should contain or reference anything that the model instance will need. Remember that there can be several instances of the model class, since the configuration allows the user to load multiple systems into the same simulation.</p>
<h3 id="defining-the-simics-class"><a href="#defining-the-simics-class">5.1 Defining the Simics Class</a></h3>
<p>Each Simics class implemented by a module must be registered with Simics using the Simics API. In C++, registration of classes can be done in two ways.</p>
<h4 id="define-the-init_local-c-function"><a href="#define-the-init_local-c-function">5.1.1 Define the <code>init_local</code> C function</a></h4>
<p>One approach is to invoke the <code>simics::make_class</code> function within the <code>init_local</code> function to register the Simics class with the Simics core.</p>
<pre><code>extern "C" void init_local() {
    simics::make_class&lt;SampleClass&gt;(
        // Simics class name
        "sample_device_cxx_class_with_init_class",
        // short description
        "sample C++ class device with init_class",
        // class documentation
        "This is a sample Simics device written in C++.");
}
</code></pre>
<p>The function parameters for <code>simics::make_class</code> are the <code>name</code>, the <code>short_desc</code>, and the <code>description</code>. It also takes an optional forth parameter <code>kind</code> which by default is <code>Sim_Class_Kind_Vanilla</code>. See the documentation of <code>SIM_create_class</code> for more information about these 4 parameters.</p>
<p>The template argument is the C++ class that should be instantiated to represent the Simics object or a port object of the Simics object. It must be derived through public inheritance from <code>simics::ConfObject</code>(for the Simics object) or <code>simics::Port</code>(for port object) as noted above.</p>
<p>Sometimes it is necessary to know the Simics class that is being registered. The function returns a <code>ConfClassPtr</code> which can be used to register attributes, interfaces, log groups and ports. In the example above, the return value is not used, and only the class is registered.</p>
<p>If, during registration, the class passed as template argument defines a static function <code>init_class</code>; that function is called during the registration. It is recommended to perform any class related registration of properties inside this static function, to improve data encapsulation. Other type of registration can be done inside <code>init_local</code> using the return value from <code>make_class</code>.</p>
<pre><code>extern "C" void init_local() {
    auto cls = simics::make_class&lt;SampleClass&gt;(
        "sample_device_cxx_class_without_init_class",
        "sample C++ class device without init_class",
        "This is a sample Simics device written in C++.");

    // use cls to register the class properties like attribute, port,
    // event, interface and logging settings
}
</code></pre>
<h4 id="define-a-static-variable-of-type-registerclasswithsimics"><a href="#define-a-static-variable-of-type-registerclasswithsimics">5.1.2 Define a Static Variable of Type <code>RegisterClassWithSimics</code></a></h4>
<p>Static variables are initialized when the module is loaded. By defining a static variable of type <code>RegisterClassWithSimics</code>, you can register a Simics class automatically.</p>
<pre><code>static simics::RegisterClassWithSimics&lt;SampleClass&gt; init {
    "sample_device_cxx_class_without_init_local",
    "sample C++ class device without init_local",
    "This is a sample Simics device written in C++."
};
</code></pre>
<p>This approach only works for modules built with CMake. For modules built with GNU Make, an empty <code>init_local</code> function is still required.</p>
<h2 id="ports-and-interfaces"><a href="#ports-and-interfaces">6 Ports and Interfaces</a></h2>
<p>As mentioned in <a href="#interfaces">Interfaces</a>, a Simics C++ model can either use the Simics C interface directly, or use the Simics C++ interface provided by the C++ API for a more idiomatic C++ approach. For a user-defined interface, the C++ interface header can be generated from its C interface header using a helper script.</p>
<h3 id="use-simics-c-interface"><a href="#use-simics-c-interface">6.1 Use Simics C interface</a></h3>
<p>A Simics C++ model can use the Simics C interface directly. Below is an example using the Simics <em>signal</em> interface:</p>
<pre><code>class SampleInterfaceC : public simics::ConfObject {
  public:
    using ConfObject::ConfObject;

    static void init_class(simics::ConfClass *cls);

    bool signal_raised {false};
};

static void signal_raise(conf_object_t *obj) {
    simics::from_obj&lt;SampleInterfaceC&gt;(obj)-&gt;signal_raised = true;
}

static void signal_lower(conf_object_t *obj) {
    simics::from_obj&lt;SampleInterfaceC&gt;(obj)-&gt;signal_raised = false;
}

void SampleInterfaceC::init_class(simics::ConfClass *cls) {
    cls-&gt;add(simics::Attribute("signal_raised", "b", "If signal is raised",
                               ATTR_CLS_VAR(SampleInterfaceC, signal_raised)));

    static const signal_interface_t signal_interface = {
        signal_raise,
        signal_lower
    };
    SIM_REGISTER_INTERFACE(*cls, signal, &amp;signal_interface);
}
</code></pre>
<p>The advantages of using the Simics C interface directly are:</p>
<ol>
<li>Simplicity. The registered static function is directly called when the interface is used, with no intermediate layers;</li>
<li>The interface definition is separate from the class behavior. This means the C++ model's behavior is independent of the interfaces exposed to other configuration objects, making it easy to switch to another Simics interface without modifying the behavior.</li>
</ol>
<p>The disadvantages of using the Simics C interface directly are:</p>
<ol>
<li>Limited Access. The registered function calls can only access public members and functions of the C++ model. Non-public members and functions are not accessible;</li>
<li>Lack of C++ Friendliness. The type of the C++ model needs to be explicitly specified in the registered function calls, which means there is no support for C++ polymorphism. For example, another set of function calls is required for a different C++ class that inherits from the <code>SampleDeviceC</code> class.</li>
</ol>
<h3 id="use-simics-c-interface-2"><a href="#use-simics-c-interface-2">6.2 Use Simics C++ interface</a></h3>
<p>A Simics C++ model can use the Simics C++ interfaces provided by the C++ API. The C++ device class or the port object class needs to inherit from the Simics C++ interface class and implement the required interface methods. Additionally, the interface must be registered with the <code>ConfClass</code> instance.</p>
<p>Take the Simics <em>signal</em> interface as an example. The C++ signal interface is declared in the <code>simics::iface::SignalInterface</code> class. The C++ device class needs to inherit from this class and override the two pure virtual methods.</p>
<pre><code>class SampleInterface : public simics::ConfObject,
                        public simics::iface::SignalInterface {
  public:
    using ConfObject::ConfObject;

    static void init_class(simics::ConfClass *cls);

    // simics::iface::SignalInterface
    void signal_raise() override;
    void signal_lower() override;

    bool signal_raised {false};
};
</code></pre>
<pre><code>void SampleInterface::signal_raise() {
    signal_raised = true;
}

void SampleInterface::signal_lower() {
    signal_raised = false;
}

</code></pre>
<p>The interface method declarations are straightforward. They should have the same signature as the interface methods in the <em>Simics Reference Manual</em> (or as shown with the Simics command api-help), except that the first C argument of type <code>conf_object_t *</code> is omitted, as it corresponds to the C++ class instance. The C++ override keyword ensures that the function is virtual and checked by the compiler.</p>
<p>The interface method is called when the Simics interface is accessed. The implementation should handle the call in a device-specific manner.</p>
<p>To expose the interface to other Simics configuration objects, the interface needs to be registered on the <code>ConfClass</code> object using the add function, similar to registering a Simics attribute:</p>
<pre><code>void SampleInterface::init_class(simics::ConfClass *cls) {
    cls-&gt;add(simics::Attribute("signal_raised", "b", "If signal is raised",
                               ATTR_CLS_VAR(SampleInterface, signal_raised)));

    cls-&gt;add(simics::iface::SignalInterface::Info());
}
</code></pre>
<p>The only parameter is an instance of <code>SignalInterface::Info</code>, which provides the registry support for the <code>signal</code> interface.</p>
<p>For better data encapsulation, it is recommended to register the interface in the instance's static method <code>init_class</code>.</p>
<h3 id="user-defined-interface"><a href="#user-defined-interface">6.3 User defined interface</a></h3>
<p>The C++ bindings for interfaces are only available for standard Simics interfaces. To support user defined interfaces new C++ bindings in the form of C++ interface classes must be generated. These classes can either be copied and edited from existing headers, or generated by the <code>bin/gen-cc-interface</code> tool.</p>
<p>For example, <code>sample-interface.h</code> defines the C interface type <code>sample_interface_t</code>.</p>
<pre><code>#if defined(__cplusplus)
extern "C" {
#endif

/* This defines a new interface type. Its corresponding C data type
   will be called "sample_interface_t". */
SIM_INTERFACE(sample) {
    void (*simple_method)(conf_object_t *obj, int arg);
    void (*object_method)(conf_object_t *obj, conf_object_t *arg);
};

/* Use a #define like this whenever you need to use the name of the
   interface type; the C compiler will then catch any typos at
   compile-time. */
#define SAMPLE_INTERFACE "sample"

#if defined(__cplusplus)
}
#endif
</code></pre>
<p>The C interface type <code>sample_interface_t</code> needs to be converted to C++ interface class <code>SampleInterface</code>. This can be done by running the <code>gen-cc-interface</code> tool(for usage, see <a class="reference" href="#generator-of-simics-c-interface-header">12.1</a>):</p>
<pre><code>  project&gt; bin/gen-cc-interface modules/sample-interface/sample-interface.h
</code></pre>
<p>Now the <code>c++/sample-interface.h</code> can be included in the device model providing <code>SampleInterface</code>.</p>
<pre><code>// This c++ file is generated from sample-interface.h by gen_cc_interface.py
#include "c++/sample-interface.h"
</code></pre>
<h3 id="port"><a href="#port">6.4 Port</a></h3>
<p>The same interface cannot be registered twice on a single Simics object. However, port objects can be used to expose the same interface multiple times. They can also be utilized to separate certain functionalities into distinct objects within the namespace of the parent object.</p>
<p>A port object is a child object that is automatically created alongside its parent. For more details about port objects, refer to the <a href="../model-builder-user-guide/port-objects.html">Model Builder User Guide</a>. Port objects are intended to replace port interfaces.</p>
<p>A C++ configuration class that inherits from the <code>simics::ConfObject</code> class can be registered as a port object of another C++ configuration class. Below is an example of this use case:</p>
<pre><code>// An example class derived from ConfObject, designed to be used as a port
// object for SamplePortDeviceUseConfObject
class SamplePortUseConfObject : public simics::ConfObject,
                                public simics::iface::SignalInterface {
  public:
    using ConfObject::ConfObject;

    static void init_class(simics::ConfClass *cls) {
        cls-&gt;add(simics::iface::SignalInterface::Info());
        cls-&gt;add(simics::Attribute(
                         "raised", "b",
                         "Return if signal is raised or not",
                         ATTR_GETTER(SamplePortUseConfObject, raised_),
                         nullptr,
                         Sim_Attr_Pseudo));
    }

    // simics::iface::SignalInterface
    void signal_raise() override {raised_ = true;}
    void signal_lower() override {raised_ = false;}

  private:
    bool raised_ {false};
};

class SamplePortDeviceUseConfObject : public simics::ConfObject {
  public:
    using ConfObject::ConfObject;

    static void init_class(simics::ConfClass *cls) {
        auto port = simics::make_class&lt;SamplePortUseConfObject&gt;(
                cls-&gt;name() + ".sample", "sample C++ port", "");
        // Register port class with the device class
        cls-&gt;add(port, "port.sample");
    }
};

static simics::RegisterClassWithSimics&lt;SamplePortDeviceUseConfObject&gt;
init_port_use_confobject {
    "sample_device_cxx_port_use_confobject",
    "a C++ test device",
    "No description"
};
</code></pre>
<p>The port class is created similarly to a device class by using the <code>make_class</code> function. Interfaces are added in the same way as with device classes, by invoking the <code>add</code> function with the relevant interface information.</p>
<p>Once the port class is defined, it can be registered by calling the <code>add</code> function on its parent class (the device class). This function requires two parameters:</p>
<ul>
<li>The port class itself.</li>
<li>A name for the port object.</li>
</ul>
<p>While a port class can use <code>simics::ConfObject</code>, C++ API also provides the <code>simics::Port</code> template class. It provides utilities to access the parent object from the port object and the ability to retrieve the port array index. The example below demonstrates its usage:</p>
<pre><code>class SamplePortDeviceUsePort : public simics::ConfObject {
  public:
    using ConfObject::ConfObject;

    static void init_class(simics::ConfClass *cls) {
        auto port = simics::make_class&lt;SamplePort&gt;(
                cls-&gt;name() + ".sample", "sample C++ port", "");
        port-&gt;add(simics::iface::SignalInterface::Info());

        // Registers a port class with an array-like naming convention.
        // Upon device creation, two port objects are instantiated with names:
        // &lt;dev_name&gt;.port.sample[0] and &lt;dev_name&gt;.port.sample[1].
        cls-&gt;add(port, "port.sample[2]");

        cls-&gt;add(simics::Attribute("state", "i", "A value",
                                   ATTR_CLS_VAR(SamplePortDeviceUsePort,
                                                state)));
    }

    // Define a C++ port class which implements the signal interface
    class SamplePort : public simics::Port&lt;SamplePortDeviceUsePort&gt;,
                       public simics::iface::SignalInterface {
      public:
        using Port&lt;SamplePortDeviceUsePort&gt;::Port;

        // simics::iface::SignalInterface
        void signal_raise() override;
        void signal_lower() override;
    };

  private:
    // An integer simulates the signal state, each bit represents one signal
    int state {0};
};

void SamplePortDeviceUsePort::SamplePort::signal_raise() {
    // method index() returns the index of the port object array
    if (index() == 0) {
        // method parent() returns pointer to the parent C++ class
        parent()-&gt;state |= 1;
    } else {
        parent()-&gt;state |= 2;
    }
}

void SamplePortDeviceUsePort::SamplePort::signal_lower() {
    if (index() == 0) {
        parent()-&gt;state &amp;= 2;
    } else {
        parent()-&gt;state &amp;= 1;
    }
}

static simics::RegisterClassWithSimics&lt;SamplePortDeviceUsePort&gt;
init_port_use_port {
    "sample_device_cxx_port_use_port",
    "a C++ test device",
    "No description"
};
</code></pre>
<p>The template class typename for <code>simics::Port</code>, <code>TParent</code>, typically represents the C++ class of the port's parent. A complete definition of <code>TParent</code> is necessary, so it is advisable to define the port class after the <code>TParent</code> class or as an inner class within <code>TParent</code> to ensure proper access to its private members.</p>
<p>The helper method <code>parent</code> returns a pointer to the parent object, allowing access to the class members of its Simics parent class. Additionally, the helper method <code>index</code> provides the current index of this port object within the registered port array. For instance, in the example above, these methods can be used to raise different bits based on the port object's index.</p>
<p>It is recommended that port objects follow a designated port namespace for naming. For example, using <code>port.sample</code> indicates that the created port objects will be accessible as <code>&lt;dev_name&gt;.port.sample</code>.</p>
<p>When the name is given in an array format (e.g., <code>port.sample[2]</code>), it signifies that an array of port objects is being created. This allows for easy management and access to multiple port instances associated with the same device.</p>
<h3 id="connect"><a href="#connect">6.5 Connect</a></h3>
<p>To call a Simics interface on another configuration object, the other object must be <code>connected</code> with the current object. This connection is represented by having a <code>Connect</code> instance that points to the other object. The instance is then used to extract the interface pointer used in the interface call.</p>
<p>The template based class <code>Connect</code> performs these two things; it takes an object reference and extracts the interfaces requested from this object. If the object passed to the <code>Connect</code> variable does not provide all required interfaces a Simics log message is emitted indicating which interface is missing and the <code>set</code> ignores the object passed.</p>
<p>The <code>Connect</code> class optionally takes a parameter of type <code>ConnectConfig</code>. It can be used to specify optional interfaces.</p>
<p>The following example shows a <code>Connect</code> instance named <code>irq_dev</code>. When passing a Simics configuration object to it, the object must implement the <code>SimpleInterruptInterface</code>/<code>simple_interrupt</code> interface and in addition optionally can implement the <code>SignalInterface</code>/<code>signal</code> interface as well.</p>
<pre><code>#include &lt;simics/cc-api.h&gt;
#include &lt;simics/c++/devs/signal.h&gt;
#include &lt;simics/c++/devs/interrupt.h&gt;

class SampleConnect : public simics::ConfObject {
  public:
    using ConfObject::ConfObject;

    // use the connect after all objects are finalized
    void objects_finalized() override;

    static void init_class(simics::ConfClass *cls);

    simics::Connect&lt;simics::iface::SimpleInterruptInterface,
                    simics::iface::SignalInterface&gt; irq_dev {
        simics::ConnectConfig::optional&lt;simics::iface::SignalInterface&gt;()
    };
};
</code></pre>
<p>The Simics C++ interface struct is fetched through a template based function <code>iface</code>. The template parameter can be omitted when fetching the first interface type of the template parameter list.</p>
<pre><code>void SampleConnect::objects_finalized() {
    if (irq_dev) {
        if (irq_dev.iface&lt;simics::iface::SignalInterface&gt;().get_iface()) {
            irq_dev.iface&lt;simics::iface::SignalInterface&gt;().signal_raise();
        } else {
            irq_dev.iface().interrupt(0);
        }
    }
}
</code></pre>
<p>In Simics, device models are dynamically connected to each other. To facilitate this dynamic connection, the Connect instance must be registered as a Simics attribute. This allows different objects to be passed dynamically during the simulation. For more details, see the chapter <a href="#connect-as-attribute">Connect as attribute</a>.</p>
<h3 id="methods-collision"><a href="#methods-collision">6.6 Methods collision</a></h3>
<p>In C++ two overloaded functions must not have the same signature. When implementing interfaces that expose the same function this collision can be avoided by introducing an intermediate class that provides the implementation and then inherit from these intermediate classes as shown in the following example. Another option is to implement the interface in a port object.</p>
<pre><code>extern "C" {
SIM_INTERFACE(one) {
    void (*iface_fun)(conf_object_t*);
};
SIM_INTERFACE(another) {
    void (*iface_fun)(conf_object_t*);
};
}

namespace simics {
namespace iface {

class OneInterface {
  public:
    // Function override and implemented by user
    virtual void iface_fun() = 0;
};

class AnotherInterface {
  public:
    // Function override and implemented by user
    virtual void iface_fun() = 0;
};

}  // namespace iface
}  // namespace simics

class ImplementOne : public simics::iface::OneInterface {
    void iface_fun() override {
        // This is implementation for OneInterface
    }
};

class ImplementAnother : public simics::iface::AnotherInterface {
    void iface_fun() override {
        // This is implementation for AnotherInterface
    }
};

class MethodsCollision : public simics::ConfObject,
                         public ImplementOne,
                         public ImplementAnother {
  public:
    explicit MethodsCollision(simics::ConfObjectRef o)
        : simics::ConfObject(o) { }
};

</code></pre>
<h2 id="register-banks-2"><a href="#register-banks-2">7 Register Banks</a></h2>
<div class="note">
<b>Note:</b>
The C++ device API for register banks is currently considered as a technology preview feature and is subject to change without notice.
<p>To use the C++ device API for register banks, you must set <code>USE_CC_MODELING_API = yes</code> in your module's <code>Makefile</code> and <code>#include &lt;simics/cc-modeling-api.h&gt;</code> in your C++ source files.</p>
</div>
<p>Memory-mapped I/O (MMIO) devices are mapped to (associated with) an address space with an address value. The device connects the data bus to the desired device's hardware register banks. In C++, the device API for register banks makes the connection and modeling of such MMIO devices easier.</p>
<p>To enable the support for register banks, <code>cc-modeling-api.h</code> needs to be imported. This header provides several objects types similar to the DML, including <code>bank</code>, <code>register</code> and <code>field</code>. <code>Bank</code> models a hardware register bank but can also contain unmapped registers to help with the modeling. It contains a set of <code>register</code>s. Each <code>register</code> is generally used to model a hardware register. A <code>register</code> can be further divided into <code>field</code>s on the bit level. As the scope of these types represents a hierarchy, they are referred to as <code>hierarchical object</code>s. In addition, the C++ device class needs to be a <code>MappableConfObject</code> to support device level configuration. All these types are described further in the sub sections.</p>
<h3 id="mappableconfobject"><a href="#mappableconfobject">7.1 MappableConfObject</a></h3>
<p>To model an MMIO device, the C++ device class needs to inherit from class <code>simics::MappableConfObject</code> instead of class <code>simics::ConfObject</code>. The class <code>simics::MappableConfObject</code> extends <code>simics::ConfObject</code> class with the support for device level configurations. For example, the bit order representation used for the device.</p>
<p>The bit fields is by default represented in the little endian bit order, i.e, bit number 0 is the least significant bit. It can be changed to big endian bit order by overriding the function <code>big_endian_bitorder</code> from class <code>simics::MappableConfObject</code>. This only affects how bits are represented but not the internal bits implementation.</p>
<p>An instance of the <code>simics::MappableConfObject</code> class maintains a one-to-one mapping between the full name of a hierarchical object and its corresponding access interface. This map is dynamically updated whenever a new hierarchical object instance is created. Hierarchical object instances can be created in various locations, such as within the constructor of base classes of the C++ device class, as class members of the C++ device class, or within the constructor body of the C++ device class.</p>
<p>It is permissible to create hierarchical objects with the same name multiple times; in such cases, the last created instance takes precedence based on the C++ object creation order. This feature is useful for replacing the behavior of an existing hierarchical object without modifying the original implementation, allowing for straightforward substitution. See Figure <a class="reference" href="#creation-flow">2</a> for the order of the object creation flow.</p>
<figure id="creation-flow">
<p><img alt="" src="creation_flow.svg"> </p><figcaption>Figure 2. Creation flow of C++ device and its port object instances</figcaption><p></p>
</figure>
<p>Occasionally, it may be necessary to modify the behavior of the one-to-one map. For instance, you might want to prevent overwriting a hierarchical object once it has been created, even if another object with the same name is instantiated later. To accomplish this, users can utilize the <code>write_protect_iface_maps</code> method to control the write protect status of the interface associated with a hierarchical object.</p>
<div class="note">
<b>Note:</b>
The access interface to the hierarchical object saved in the <tt>map</tt> must be available during the life cycle of the <tt>MappableConfObject</tt>. One way to guarantee that is to instantiate the object as a class member of the C++ device class.
</div>
<p>During the simulation, the access interface for a hierarchical object can be easily retrieved from the map using its name. This is useful for cross-object access inside the device. For example, a register's access side-effect could be to update a field in some other register. If this is a common access pattern this lookup should be cached by storing the interface as a private member.</p>
<h3 id="modeling-the-register-banks"><a href="#modeling-the-register-banks">7.2 Modeling the register banks</a></h3>
<p>The Simics C++ API offers two approaches for modeling register banks, distinguished by how mapping and hierarchy information is provided. The first approach, referred to as "by code," involves supplying mapping information as input to class members within a class hierarchy constructed from C++ code. The second approach, known as "by data," involves providing both mapping and hierarchy information in a separate data structure.</p>
<h4 id="by-code-information-provided-by-c-classes-and-class-hierarchy"><a href="#by-code-information-provided-by-c-classes-and-class-hierarchy">7.2.1 By Code: Information Provided by C++ Classes and Class Hierarchy</a></h4>
<p>In this approach, banks/registers/fields are modeled in C++ by declaring themselves as class members of other classes.</p>
<p>To simplify modeling, several C++ classes are provided. The <code>PortBank&lt;TBank&gt;</code> class facilitates the creation and addition of a bank to a port. The <code>BankRegister&lt;TRegister&gt;</code> class aids in creating and adding a register to a bank, while the <code>RegisterField&lt;TField&gt;</code> class helps create and add a field to a register. These classes use template type parameters to create different object types, defaulting to basic hierarchical object types like <code>simics::Bank</code>. The parameter can be any provided class, such as <code>ReadOnlyRegister</code>, or a user-defined class. For a complete list of provided classes, see <a class="reference" href="#standard-templates">7.4.4</a>.</p>
<p>While nesting classes for banks, registers, and fields using C++ nested class is optional, it can help reduce scope and make the code resemble a corresponding DML device.</p>
<p>Below is an example using this option:</p>
<pre><code>class SampleBank : public simics::PortBank&lt;&gt; {
  public:
    using PortBank::PortBank;

    class SampleRegister : public simics::BankRegister&lt;&gt; {
      public:
        using BankRegister::BankRegister;

        class SampleField : public simics::RegisterField&lt;&gt; {
          public:
            using RegisterField::RegisterField;

            // Override to print a log when being written
            void write(uint64_t value, uint64_t enabled_bits) override {
                SIM_LOG_INFO(3, bank_obj_ref(), 0, "Write to SampleField");
                simics::Field::write(value, enabled_bits);
            }
        };

        uint64_t read(uint64_t enabled_bits) override {
            SIM_LOG_INFO(3, bank_obj_ref(), 0, "Read from SampleRegister");
            return simics::Register::read(enabled_bits);
        }

      private:
        SampleField f0 {
            this, Name("f0"), Description("a sample field"),
            Offset(0), BitWidth(16)
        };
        simics::RegisterField&lt;&gt; f1 {
            this, Name("f1"), Description("a default field"),
            Offset(16), BitWidth(16)
        };
    };

  private:
    SampleRegister r0 {
        this, Name("r[0]"),
        Description("A register with init value 42"),
        Offset(0), ByteSize(4), InitValue(42)
    };
    SampleRegister r1 {
        this, Name("r[1]"),
        Description("A register with init value 42"),
        Offset(0x10), ByteSize(4), InitValue(42)
    };
};
</code></pre>
<p>In this option, the hierarchy of ports, banks, registers, and fields is embedded within the C++ class. Both mapping information and behavior are defined in the code during object creation, hence the term "by code." The Simics C++ API modeling extension is based on this option.</p>
<h4 id="by-data-information-provided-as-a-struct"><a href="#by-data-information-provided-as-a-struct">7.2.2 By Data: Information Provided as a Struct</a></h4>
<p>In the second approach, resource mapping information for banks, registers, and fields is provided as data using an arbitrary format. A data importer converts this data and calls the C++ device API to register the mapping, keeping resource mapping separate from behavior. This allows users to create custom generators to produce data in the required format and enables importers to read data from files, facilitating mapping changes without recompiling the model.</p>
<div class="note">
<b>Note:</b>
Simics does not provide ready-to-use generators; only the API for registering user-defined mapping.
</div>
<p>The API method for registering mapping is <code>create_hierarchy_from_register_data</code>. The first parameter is a pointer to <code>simics::ConfClass</code>, and the second can be either <code>simics::bank_t</code> or a braced-init-list of <code>simics::bank_t</code>. Since the API method must be invoked when the module is loaded into Simics, the most suitable place to call it is <code>init_class</code>. It can be invoked multiple times with different register data. The address of the <code>bank</code> object will be stored and used after the function call, so it must remain valid for the lifetime of the simulation.</p>
<p>The <code>simics::bank_t</code> type describes bank information, including the bank's name, description, and register information. Register information is defined using <code>simics::register_t</code>, which includes name, description, memory address offset, size in bytes, initialized value, and field information. Field information is defined using <code>simics::field_t</code>, including name, description, bit offset, and bit width.</p>
<p>Using the second option, a C++ model with default read/write behavior can run in a Simics simulation without user-defined behaviors. To change default behavior, users can use a standard class from the modeling library or subclass it. For a complete list of standard classes, see <a class="reference" href="#standard-templates">7.4.4</a>. If no customized behavior is registered, the default base class for the corresponding resource is used.</p>
<p>Below is an example using this option. The mapping information for <code>SampleBankByData</code> is registered by calling the <code>import_data</code> method from a data importer, which invokes <code>create_hierarchy_from_register_data</code> with mapping data. Each resource in the example is assigned default behavior (read and write), except for registers <code>b[0].r[0]</code>, <code>b[0].r[1]</code>, <code>b[1].r[0]</code>, and <code>b[1].r[1]</code>, defined as custom write-clear registers.</p>
<div class="note">
<b>Note:</b>
This example demonstrates providing a customized subclass; for write-clear, the <tt>Write1ClearsRegister</tt> class is already available in the modeling library.
</div>
<pre><code>#include &lt;simics/cc-modeling-api.h&gt;

#include "register-as-data.h"

class SampleRegister : public simics::Register {
  public:
    using Register::Register;

    class SampleField : public simics::Field {
      public:
        using Field::Field;

        void write(uint64_t value, uint64_t enabled_bits) override {
            SIM_LOG_INFO(3, bank_obj_ref(), 0, "Write to SampleField");
            simics::Field::write(value, enabled_bits);
        }
    };

    uint64_t read(uint64_t enabled_bits) override {
        SIM_LOG_INFO(3, bank_obj_ref(), 0, "Read from SampleRegister");
        return simics::Register::read(enabled_bits);
    }

  private:
    SampleField f0 {dev_obj(), hierarchical_name() + ".f0"};
};

class DataImporter {
  public:
    explicit DataImporter(simics::MappableConfObject *obj)
        : obj_(obj) {}

    template &lt;typename T&gt;
    static void import_data(simics::ConfClass *cls) {
        simics::create_hierarchy_from_register_data&lt;T&gt;(cls, register_as_data);
    }

  private:
    simics::MappableConfObject *obj_;
    SampleRegister b0_r0 {obj_, "b[0].r[0]"};
    SampleRegister b0_r1 {obj_, "b[0].r[1]"};
    SampleRegister b1_r0 {obj_, "b[1].r[0]"};
    SampleRegister b1_r1 {obj_, "b[1].r[1]"};
};
</code></pre>
<pre><code>#include &lt;simics/cc-api.h&gt;
#include &lt;simics/cc-modeling-api.h&gt;
#include "data-importer.h"

class SampleBankByData : public simics::MappableConfObject,
                         public DataImporter {
  public:
    explicit SampleBankByData(simics::ConfObjectRef obj)
        : MappableConfObject(obj),
          DataImporter(this) {}

    static void init_class(simics::ConfClass *cls) {
        DataImporter::import_data&lt;SampleBankByData&gt;(cls);
    }
};

static simics::RegisterClassWithSimics&lt;SampleBankByData&gt; init_bank_by_data {
    "sample_device_cxx_bank_by_data",
    "sample C++ device with a bank by data",
    "Sample C++ device with a bank by data"
};
</code></pre>
<p>In Simics, the device model is instantiated before port objects, so hierarchical objects defined in the device model are instantiated first. Hierarchical objects with the same name can be instantiated multiple times, with behavior defined by the last instantiation based on C++ object instantiation order.</p>
<p>Default behavior hierarchical objects are instantiated during port object instantiation if no behavior is already defined for them. They are allocated on the heap memory.</p>
<h3 id="bankport"><a href="#bankport">7.3 BankPort</a></h3>
<p>A device can have multiple bank ports, each containing a single bank, which can have multiple registers. Registers are accessible to the simulated system through the Simics <code>transaction</code> interface and are exposed to scripting and user interfaces via the <code>register_view</code>, <code>register_view_read_only</code>, and <code>bank_instrumentation_subscribe</code> Simics interfaces.</p>
<p>The <code>simics::BankPort</code> template class is used to model the bank port object. It inherits from <code>simics::Port</code> and implements the necessary Simics bank interfaces. The template type parameter should be set to the C++ device class. If the bank port is not accessing any class member from the C++ device class, then the template type can be <code>simics::MappableConfObject</code>.</p>
<p>As outlined in the previous section, there are two approaches to modeling register banks. The <code>simics::BankPort</code> template class provides two constructors corresponding to each approach. For the "by-code" option, the constructor requires only a <code>ConfObjectRef</code> parameter, which represents the Simics configuration port object. For the "by-data" option, in addition to the required <code>ConfObjectRef</code> parameter, the constructor accepts a second parameter to provide bank mapping information.</p>
<p>The <code>make_bank_port</code> function facilitates the creation of a Simics port class. The port class is then registered with its parent <code>ConfClass</code> using the <code>add</code> function, typically within the <code>init_class</code> function of the device model class.</p>
<p>Simics attributes can be directly registered on the bank port, which is useful for storing the state of the bank, registers, or fields. Bank attributes are automatically saved to the Simics checkpoint by <code>write-configuration</code>. To register an attribute, simply add an <code>Attribute</code> instance (see <a class="reference" href="#attributes">8</a> for more details).</p>
<p>Banks can also be organized into arrays, with each element in the bank array representing a separate configuration object in Simics. This allows for individual mapping in a memory space. For details on registering a bank array, see <a href="#port">Port</a>.</p>
<div class="note">
<b>Note:</b>
Multidimensional bank array is not supported.
</div>
<p>Instead of defining a custom BankPort class that inherits from <code>simics::BankPort</code>, users can directly utilize the existing <code>simics::SimpleBankPort</code> class to create a bank port. This class is a template class that accepts the type of the port bank as a template parameter. A port bank of the specified type is instantiated as a member of the <code>SimpleBankPort</code>. Additionally, extra arguments can be provided to the bank through a second template parameter. Below is an example of how to use this in code:</p>
<pre><code>void SampleBankByCode::init_class(simics::ConfClass *cls) {
    cls-&gt;add(simics::make_bank_port&lt;simics::SimpleBankPort&lt;SampleBank&gt;&gt;(
                     cls-&gt;name() + ".SampleBank", "sample bank"), "bank.b[2]");
}
</code></pre>
<h3 id="hierarchical-object"><a href="#hierarchical-object">7.4 Hierarchical object</a></h3>
<p>There are 3 kinds of hierarchical objects: <code>bank</code>, <code>register</code> and <code>field</code>. These concepts are the same as the concepts used in the DML. The class hierarchy is shown in <a class="reference" href="#hierarchical-objects">3</a>. The generic <code>HierarchicalObject</code> class serves as the abstract base class.</p>
<figure id="hierarchical-objects">
<p><img alt="" src="hierarchicalobject_classes.svg"> </p><figcaption>Figure 3. Class hierarchy for hierarchical object classes</figcaption><p></p>
</figure>
<p>A hierarchical object is instantiated with a pointer to a <code>MappableConfObject</code> instance and a unique name. As described in the previous section, the <code>MappableConfObject</code> instance maintains a map from the hierarchical object's name to its access interface.</p>
<p>All hierarchical objects in a device should have a unique name that begins with the bank's name. The name should consist of a sequence of characters from the character set [A‚ÄìZ][a‚Äìz][0‚Äì9], underscore(<code>_</code>), square brackets (<code>[]</code>) and dot (<code>.</code>). Square brackets should only be used to represent items in an array. A dot (<code>.</code>) can only be used between different hierarchical levels. For example, following names are invalid to use as a hierarchical object's name:</p>
<pre><code>.bank_x
bank[1].reg2.
_x.._y
*.reg_?.+
</code></pre>
<h4 id="bank"><a href="#bank">7.4.1 Bank</a></h4>
<p>Bank is a hierarchical object that implements the <code>simics::BankInterface</code> interface. Its main role is dispatching the incoming transaction access to the corresponding registers on the bank. The entry point for the transaction access is the function <code>transaction_access</code>.</p>
<p>Simics configuration objects for bank instances are named like the bank but with a <code>bank</code> prefix. For instance, if a device class has added a bank with declaration <code>bank.regs[2]</code>, and a device instance is named <code>dev</code> in Simics, then the two banks are represented in Simics by configuration objects named <code>dev.bank.regs[0]</code> and <code>dev.bank.regs[1]</code>.</p>
<h4 id="register"><a href="#register">7.4.2 Register</a></h4>
<p>A register is an object that contains an integer value. Normally, a register corresponds to a segment of consecutive locations in the address space of the bank; however, it is also possible (and often useful) to have registers that are not mapped to any address within the bank. All registers must be part of a register bank.</p>
<p>The following information is needed in order to map a register to an address space of the enclosing bank.</p>
<ul>
<li>Name</li>
<li>Description</li>
<li>Offset</li>
<li>Size</li>
<li>Initial value</li>
<li>Fields(could be empty)</li>
</ul>
<p>The name of a register follows the Simics naming rules. Description is a short description of the register. Offset is the address of the bank where the register is mapped at. The size is an integral, nonzero number of 8-bit bytes. A single register cannot be wider than 8 bytes. The initial value defines the register's value when the object is created. A register may be optionally divided into several fields. The fields are described in the next section.</p>
<p>To indicate an array, similar to a C array, specify the number of registers between a pair of square brackets, e.g., <code>r[8]</code>. By default the stride of the array is the size of the register, but other values can be chosen as follows, <code>r[8 stride 4]</code>. For multidimensional array, the default stride is deduced from the size of all the registers in the inner dimension. For example, the stride of the outmost dimension for <code>r[2][8 stride 4]</code> is 8 * 4 = 32 bytes.</p>
<h5 id="register-attribute"><a href="#register-attribute">7.4.2.1 Register Attribute</a></h5>
<p>For every register, an attribute of integer type is automatically added to the containing bank. The name of the register is used as the name of the attribute; e.g., a register named <code>r1</code> will get a corresponding attribute on the bank named <code>r1</code>. The register value is automatically saved when Simics creates a checkpoint.</p>
<h5 id="not-mapping-addresses-to-registers"><a href="#not-mapping-addresses-to-registers">7.4.2.2 Not Mapping Addresses To Registers</a></h5>
<p>An important thing to note is that registers do not have to be mapped at all. This may be useful for internal registers that are not directly accessible from software. By using an unmapped register, you can get the advantages of using register, such as automatic checkpointing and register fields. This internal register can then be used from the implementations of other registers, or other parts of the model. For simply storing state, consider using bank port attributes instead.</p>
<p>Please note that <code>register_view</code> interface and breakpoints only work on mapped registers.</p>
<p>To create an unmapped register, simply instantiate a register of type <code>UnmappedRegister</code> (or a subtype of it).</p>
<h4 id="field"><a href="#field">7.4.3 Field</a></h4>
<p>Real hardware registers often have a number of fields with separate meaning. For example, the lowest three bits of the register could be a status code, the next six bits could be a set of flags, and the rest of the bits could be reserved.</p>
<p>To make this easy to express, a <code>register</code> object can contain a number of <code>field</code> objects. Each <code>field</code> corresponds to a bit range of the enclosing register.</p>
<p>The value of a field is stored in the corresponding bits of the containing register's storage. The easiest way to access the value of a register or field is to use the <code>get</code> and <code>set</code> methods.</p>
<p>To indicate an array, similar to a C array, specify the number of fields between a pair of square brackets, e.g., <code>f[8]</code>. By default the stride of the array is the size of the field, but other values can be chosen as follows, <code>f[8 stride 4]</code>. For multidimensional array, the default stride is deduced from the size of all the fields in the inner dimension. For example, the stride of the outmost dimension for <code>f[2][8 stride 4]</code> is 8 * 4 = 32 bits.</p>
<h4 id="standard-templates"><a href="#standard-templates">7.4.4 Standard Templates</a></h4>
<p>This chapter describes the standard templates for C++ registers and fields.</p>
<p>Note that many standard templates have the same functionality and only differ by name or log-messages printed when writing or reading them. The name of the template helps developers to get a quick overview of the device functionality. Two such examples are the <code>undocumented</code> and <code>reserved</code> templates. Both have the same functionality. However, the <code>undocumented</code> template hints that something in the device documentation is unclear or missing, and the <code>reserved</code> template that the register or field should not be used by software.</p>
<p>Software reads and writes are defined as accesses using the <code>transaction</code> interface (write/reads to memory/io mapped device). Software reads and writes use the built-in <code>read</code> and <code>write</code> methods. Hardware access is defined as access made from within the model itself, using either <code>set/get</code> for side-effect free access or <code>read/write</code> for an access with side-effects.</p>
<h5 id="templates-for-banks"><a href="#templates-for-banks">7.4.4.1 Templates for banks</a></h5>
<p>The default class <code>Bank</code> models a bank of little endian byte order. To model a big endian byte order bank, the class <code>BigEndianBank</code> can be used. It does not affect the internal data representation, only matters when the data is read out and presented in some format. For example, the <code>Bank</code> method <code>read</code> returns a vector of <code>uint8_t</code>. The output of this method is by default a little endian byte ordered vector of bytes, while a big endian byte order bank has the order reversed.</p>
<p>By default, reading an address range on a bank which is not fully mapped by registers triggers <code>unmapped_read</code>. It prints a spec-violation log and fail the read transaction. This behavior can be altered by using class <code>MissPatternBank</code>. Its constructor takes an extra third parameter called <code>miss_pattern</code> which is used to fill the unmapped bytes in the read transaction. With this, the function <code>unmapped_read</code> is not triggered, thus no spec-violation log is printed and the read transaction does not fail. This parameter defaults to zero if not set.</p>
<p>Typically, each bank has its own memory dedicated to storing its registers. The memory is identified by a unique ID, which is the bank's name. However, in certain cases, multiple banks can share the same memory. This functionality is supported by the <code>SharedMemoryBank</code> class. The third parameter of the class constructor, <code>name_of_bank_memory</code>, is a string that serves as the unique ID for this shared memory across different banks. By specifying a common <code>name_of_bank_memory</code>, multiple banks can access and manipulate the shared memory collectively.</p>
<h5 id="templates-for-registers-and-fields"><a href="#templates-for-registers-and-fields">7.4.4.2 Templates for registers and fields</a></h5>
<p>The read and write behaviour of registers and fields is in most cases controlled by class inheritance and method overriding. The <code>read</code> and <code>write</code> provided in <code>Register</code> and <code>Field</code> is virtual and can be override by an implementation in a derived class. The default implementation can still be referenced using a explicit namespace from the base class.</p>
<p>The following templates are provided and most of them can be applied to both registers and fields. The section use <code>object</code> as a combined name for registers and fields. Most of them affect either the write or read operation; if applied on a register it will disregard fields. For instance, when inheriting from the <code>ReadUnimplRegister</code> class on a register with fields, then the read will ignore any implementations of read overrides in fields, and return the current register value (through <code>get</code>). However, writes will still propagate to the fields.</p>
<table><thead><tr><th style="text-align: left">Class name</th><th style="text-align: left">Description</th><th style="text-align: left">Log output</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>IgnoreWriteRegister</code>, <code>IgnoreWriteField</code></td><td style="text-align: left">Writes are ignored. This template might also be useful for read-only fields inside an otherwise writable register. See the documentation for the <code>ReadOnlyRegister</code> template for more information.</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>Read0Register</code>, <code>Read0Field</code></td><td style="text-align: left">Reads return 0, regardless of register/field value. Writes are unaffected by this template.</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>ReadOnlyRegister</code>, <code>ReadOnlyField</code></td><td style="text-align: left">The object value is read-only for software, the object value can be modified by hardware.</td><td style="text-align: left">First software write results in a spec_violation log-message on log-level 1, remaining writes on log-level 2. Fields will only log if the written value is different from the old value. <br><br> If the register containing the read-only field also contains writable fields, it may be better to use the <code>IgnoreWriteRegister</code> template instead, since software often do not care about what gets written to a read-only field, causing unnecessary logging.</td></tr>
<tr><td style="text-align: left"><code>WriteOnlyRegister</code>, <code>WriteOnlyField</code></td><td style="text-align: left">The register/field value can be modified by software but can't be read back, reads return 0 regardless of register/field value. Writes are unaffected by this template.</td><td style="text-align: left">For register, the first time the object is read there is a spec_violation log-message on log-level 1, remaining reads on log-level 2. For field, only logs on log-level 4.</td></tr>
<tr><td style="text-align: left"><code>Write1ClearsRegister</code>, <code>Write1ClearsField</code></td><td style="text-align: left">Software can only clear bits. This feature is often used when hardware sets bits and software clears them to acknowledge. Software write 1's to clear bits. The new object value is a bitwise AND of the old object value and the bitwise complement of the value written by software.</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>ClearOnReadRegister</code>, <code>ClearOnReadField</code></td><td style="text-align: left">Software reads return the object value. The object value is then reset to 0 as a side-effect of the read.</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>Write1OnlyRegister</code>, <code>Write1OnlyField</code></td><td style="text-align: left">Software can only set bits to 1. The new object value is the bitwise OR of the old object value and the value written by software.</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>Write0OnlyRegister</code>, <code>Write0OnlyField</code></td><td style="text-align: left">Software can only set bits to 0. The new object value is the bitwise AND of the old object value and the value written by software.</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>ReadConstantRegister</code>, <code>ReadConstantField</code></td><td style="text-align: left">Reads return a constant value. <br><br> Writes are unaffected by this template. The read value is unaffected by the value of the register or field. <br><br> The template is intended for registers or fields that have a stored value that is affected by writes, but where reads disregard the stored value and return a constant value. The attribute for the register will reflect the stored value, not the value that is returned by read operations. For constant registers or fields that do not store a value, use the <code>Constant</code> template instead.</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>ConstantRegister</code>, <code>ConstantField</code></td><td style="text-align: left">Writes are forbidden and have no effect. <br><br> The object still has backing storage, which affects the value being read. Thus, an end-user can modify the constant value by writing to the register's attribute. Such tweaks will survive a reset. <br><br> Using the <code>Constant</code> template marks that the object is intended to stay constant, so the model should not update the register value, and not override the <code>read</code> method. Use the template <code>ReadOnly</code> if that is desired.</td><td style="text-align: left">First write to register or field (if field value is not equal to write value) results in a spec_violation log-message on log-level 1, remaining writes on log-level 2.</td></tr>
<tr><td style="text-align: left"><code>SilentConstantRegister</code>, <code>SilentConstantField</code></td><td style="text-align: left">The object value will remain constant. Writes are ignored and do not update the object value. <br><br> The end-user can tweak the constant value; any tweaks will survive a reset. <br><br> By convention, the object value should not be modified by the model; if that behaviour is wanted, use the <code>IgnoreWrite</code> template instead.</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>ZerosRegister</code>, <code>ZerosField</code></td><td style="text-align: left">The object value is constant 0. Software writes are forbidden and do not update the object value.</td><td style="text-align: left">First software write to register or field (if field value is not equal to write value) results in a spec_violation log-message on log-level 1, remaining writes on log-level 2.</td></tr>
<tr><td style="text-align: left"><code>OnesRegister</code>, <code>OnesField</code></td><td style="text-align: left">The object is constant all 1's. Software writes do not update the object value. The object value is all 1's.</td><td style="text-align: left">First software write to register or field (if field value is not equal to write value) results in a spec_violation log-message on log-level 1, remaining writes on log-level 2.</td></tr>
<tr><td style="text-align: left"><code>IgnoreRegister</code>, <code>IgnoreField</code></td><td style="text-align: left">The object's functionality is unimportant. Reads return 0. Writes are ignored.</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>ReservedRegister</code>, <code>ReservedField</code></td><td style="text-align: left">The object is marked reserved and should not be used by software. Writes update the object value. Reads return the object value.</td><td style="text-align: left">First software write to register or field (if field value is not equal to write value) results in a `spec-viol` log-message on log-level 2. No logs on subsequent writes.</td></tr>
<tr><td style="text-align: left"><code>UnimplRegister</code>, <code>UnimplField</code></td><td style="text-align: left">The object functionality is unimplemented. Warn when software is using the object. Writes and reads are implemented as default writes and reads.</td><td style="text-align: left">First read from a register results in an unimplemented log-message on log-level 1, remaining reads on log-level 3. Reads from a field does not result in a log-message. First write to a register results in an unimplemented log-message on log-level 1, remaining writes on log-level 3. First write to a field (if field value is not equal to write value) results in an unimplemented log-message on log-level 1, remaining writes on log-level 3.</td></tr>
<tr><td style="text-align: left"><code>ReadUnimplRegister</code>, <code>ReadUnimplField</code></td><td style="text-align: left">The object functionality associated to a read access is unimplemented. Write access is using default implementation and can be overridden (for instance by the <code>ReadOnly</code> template).</td><td style="text-align: left">First software read to a register results in an unimplemented log-message on log-level 1, remaining reads on log-level 3. Software reads to fields does not result in a log-message.</td></tr>
<tr><td style="text-align: left"><code>WriteUnimplRegister</code>, <code>WriteUnimplField</code></td><td style="text-align: left">The object functionality associated to a write access is unimplemented. Read access is using default implementation and can be overridden (for instance by the <code>WriteOnly</code> template).</td><td style="text-align: left">First software write to registers results in an unimplemented log-message on log-level 1, remaining writes on log-level 3. First write to a field (if field value is not equal to write value) results in an unimplemented log-message on log-level 1, remaining writes on log-level 3.</td></tr>
<tr><td style="text-align: left"><code>SilentUnimplRegister</code>, <code>SilentUnimplField</code></td><td style="text-align: left">The object functionality is unimplemented, but do not print a lot of log-messages when reading or writing. Writes and reads are implemented as default writes and reads.</td><td style="text-align: left">First software read to a register results in an unimplemented log-message on log-level 2, remaining reads on log-level 3. Software reads to fields does not result in a log-message. First software write to a register results in an unimplemented log-message on log-level 2, remaining writes on log-level 3. First write to a field (if field value is not equal to write value) results in an unimplemented log-message on log-level 2, remaining writes on log-level 3.</td></tr>
<tr><td style="text-align: left"><code>UndocumentedRegister</code>, <code>UndocumentedField</code></td><td style="text-align: left">The object functionality is undocumented or poorly documented. Writes and reads are implemented as default writes and reads.</td><td style="text-align: left">First software write and read result in a spec_violation log-message on log-level 1, remaining on log-level 2.</td></tr>
<tr><td style="text-align: left"><code>UnmappedRegister</code></td><td style="text-align: left">The register is excluded from the address space of the containing bank.</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>DesignLimitationRegister</code>, <code>DesignLimitationField</code></td><td style="text-align: left">The object's functionality is not in the model's scope and has been left unimplemented as a design decision. Software and hardware writes and reads are implemented as default writes and reads. Debug registers are a prime example of when to use this template. This is different from <em>unimplemented</em> which is intended to be implement (if required) but is a limitation in the current model.</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>AliasRegister</code></td><td style="text-align: left">The register is an alias for another register. All operations are forwarded to the other register.</td><td style="text-align: left"></td></tr>
</tbody></table>
<h2 id="attributes"><a href="#attributes">8 Attributes</a></h2>
<p>Unlike previous C++ API, there is only one way to define attributes. The attribute is defined by creating an object of type <code>Attribute</code> and adding it to the <code>ConfClass</code> instance using the <code>add</code> function.</p>
<p>There are several constructors with different sets of parameters. The following parameters must be provided for all constructors: a string <code>name</code>, a string <code>type</code> and a string <code>doc</code>. These parameters have the same meaning as in <code>SIM_register_attribute</code>. The <code>name</code> specifies the attribute name, and must be unique for the class and stable between revisions of the model. The <code>type</code> is the type which describes the data type of the attribute, and should also be stable between revisions of the model to support Simics configuration scripts and checkpointing. The macro <code>ATTR_TYPE_STR</code> can be used to auto generate the type string from a C++ variable. The <code>doc</code> describes the attribute.</p>
<p>Get and set callbacks can be registered for the attribute through <code>getter</code> and <code>setter</code> parameters. For a C++ class member variable, <code>AttributeAccessor</code> can be used for the registration.</p>
<p>There is an optional <code>attr</code> parameter which is one of <code>Sim_Attr_Required</code>, <code>Sim_Attr_Optional</code> or <code>Sim_Attr_Pseudo</code>. This can be used to indicate that an attribute is required (<code>Sim_Attr_Required</code>) or that it should not be part of checkpoints (<code>Sim_Attr_Pseudo</code>). The default value is <code>Sim_Attr_Optional</code> if no explicit value is set.</p>
<p>A required attribute (<code>attr</code> set to <code>Sim_Attr_Required</code>) will be initialized to the value given by the configuration. For attribute of other types the initial value must be explicitly initialized by the C++ class that owns the member pointed to by the attribute. In C++, unlike DML, the variables are not zero-initialized implicitly.</p>
<p>Depending on how the state variable is stored in the C++ class, there are different ways to register the attribute.</p>
<pre><code>class SampleAttributeClassMemberVariable : public simics::ConfObject {
  public:
    using ConfObject::ConfObject;

    static void init_class(simics::ConfClass *cls) {
        cls-&gt;add(simics::Attribute(
                         "flags", "[bb]", "Two boolean flags in an array",
                         ATTR_CLS_VAR(SampleAttributeClassMemberVariable,
                                      flags)));
    }

    std::array&lt;bool, 2&gt; flags {false, false};
};

static simics::RegisterClassWithSimics&lt;SampleAttributeClassMemberVariable&gt;
init_class_member_variable {
    "sample_device_cxx_attribute_class_member_variable",
    "sample C++ attr device use cls member variable",
    "Sample C++ attribute device use cls member variable"
};
</code></pre>
<p>This example uses <code>ATTR_CLS_VAR(SampleAttributeClassMemberVariable, flags)</code> to locate the flags variable, given an instance of <code>SampleAttributeClassMemberVariable</code>. The macro <code>ATTR_CLS_VAR</code> expands to an <code>AttributeAccessor</code>.</p>
<p>A public state variable member of a C++ build-in type or a C++ standard container of build-in type can be registered directly using <code>ATTR_CLS_VAR</code>. For example, an <code>array</code> of two boolean values.</p>
<p>If a state variable is not in public scope, indirect access is needed. It is quite common that a C++ class provides a public get and set function for its private state variable member. To register the variable as a Simics attribute, simply wrap the public get and set function pointers using macro <code>ATTR_GETTER</code> and <code>ATTR_SETTER</code> respectively and pass them as the parameters to the <code>Attribute</code> constructor.</p>
<pre><code>class SampleAttributeClassMemberMethod : public simics::ConfObject {
  public:
    using ConfObject::ConfObject;

    static void init_class(simics::ConfClass *cls) {
        cls-&gt;add(simics::Attribute(
                         "value", "i", "A value.",
                         ATTR_GETTER(SampleAttributeClassMemberMethod,
                                     get_value),
                         ATTR_SETTER(SampleAttributeClassMemberMethod,
                                     set_value),
                         Sim_Attr_Required));
    }

    int get_value() const;
    void set_value(const int &amp;v);

  private:
    int value {0};
};

// ...

int SampleAttributeClassMemberMethod::get_value() const {
    return value;
}

void SampleAttributeClassMemberMethod::set_value(const int &amp;v) {
    if (v &lt; 256) {
        value = v;
    } else {
        throw std::runtime_error("Too large value");
    }
}

static simics::RegisterClassWithSimics&lt;SampleAttributeClassMemberMethod&gt;
init_class_member_method {
    "sample_device_cxx_attribute_class_member_method",
    "sample C++ attr device use cls member method",
    "Sample C++ attribute device use cls member method"
};
</code></pre>
<p>By wrapping the value with functions, it is also possible to add extra checks. The getter function simply returns the value. The setter function takes a reference to a value, and can accept or reject it by throwing a runtime_error with a string message describing why it was rejected. The exception is caught in the Simics attribute setter function and converted to a proper Simics log message.</p>
<p>Note the use of <code>Sim_Attr_Required</code> when constructing the <code>simics::Attribute</code>. It means a value must be provided when creating the Simics object.</p>
<p>The getter and setter functions can be global functions as well. Then they should take the main C++ object as a function parameter.</p>
<pre><code>class SampleAttributeGlobalMethod : public simics::ConfObject {
  public:
    using ConfObject::ConfObject;

    static void init_class(simics::ConfClass *cls);

    std::string name;
    size_t id {0};
};

// ...

std::pair&lt;std::string, size_t&gt; get_name_and_id(
        const SampleAttributeGlobalMethod &amp;obj) {
    return {obj.name, obj.id};
}

void set_name_and_id(SampleAttributeGlobalMethod &amp;obj,  // NOLINT
                     const std::pair&lt;std::string, size_t&gt; &amp;name_and_id) {
    std::tie(obj.name, obj.id) = name_and_id;
}

void SampleAttributeGlobalMethod::init_class(simics::ConfClass *cls) {
    cls-&gt;add(simics::Attribute("name_and_id", "[si]", "A pair of a name and id",
                               ATTR_GETTER(get_name_and_id),
                               ATTR_SETTER(set_name_and_id)));
}

static simics::RegisterClassWithSimics&lt;SampleAttributeGlobalMethod&gt;
init_global_method {
    "sample_device_cxx_attribute_global_method",
    "sample C++ attr device use global method",
    "Sample C++ attribute device use global method"
};
</code></pre>
<p>The same macros, <code>ATTR_GETTER</code> and <code>ATTR_SETTER</code> are used to help convert getters and setters into the functions required by the Simics attribute.</p>
<p>If the getter is <code>nullptr</code>, it means that the attribute is write-only. If the setter is <code>nullptr</code>, it means that it is read-only. If either is <code>nullptr</code>, the attribute cannot be checkpointed and if <code>attr</code> is left out, <code>Sim_Attr_Pseudo</code> is automatically chosen.</p>
<p>The help macros <code>ATTR_CLS_VAR</code>, <code>ATTR_GETTER</code>, <code>ATTR_SETTER</code> and <code>ATTR_TYPE_STR</code> support all C++ native build-in types or STL containers that consist of them. A complete list of equivalent types supported by the help macros are listed in the following table. The pointer and the <code>enum</code> are supported if the underlying type is one of the types listed in the table.</p>
<table><thead><tr><th><strong>Type category</strong></th><th><strong>Include types</strong></th></tr></thead><tbody>
<tr><td><strong>Boolean type</strong></td><td><code>bool</code></td></tr>
<tr><td><strong>Character types</strong></td><td><code>char</code>, <code>signed char</code>, <code>unsigned char</code></td></tr>
<tr><td><strong>Integer types</strong></td><td><code>short int</code>, <code>unsigned short int</code>, <code>int</code>, <code>unsigned int</code>, <code>long int</code>, <code>unsigned long int</code>, <code>long long int</code>, <code>unsigned long long int</code></td></tr>
<tr><td><strong>Floating-point types</strong></td><td><code>float</code>, <code>double</code></td></tr>
<tr><td><strong>Object type</strong></td><td><code>simics::ConfObjectRef</code>, <code>simics::Connect</code></td></tr>
<tr><td><strong>Container type</strong></td><td><code>array</code>, <code>list</code>, <code>vector</code>, <code>deque</code>, <code>pair</code>, <code>map</code>, <code>tuple</code>, <code>set</code></td></tr>
</tbody></table>
<div class="note">
<b>Note:</b>
Traditional C-style arrays, or Raw Arrays, are only supported by the <tt>ATTR_GETTER</tt> macro (and no other help macro). Either replace them with C++ <tt>array</tt>, or use custom get and set functions as described below.<br>
<b>Note:</b>
The help macros, such as <tt>ATTR_GETTER</tt> and <tt>ATTR_SETTER</tt>, are designed to simplify the registration of Simics attributes. However, they can not address all scenarios. These macros have limitations, such as not supporting overloaded functions. In scenarios where the macros are insufficient, alternative approaches can be employed, such as writing custom getter and setter functions to manage the desired C++ variables.
</div>
<p>Nested STL containers composed of the types listed in the table above are also supported. An example is provided below. For these types, the type string is often too complex, so it is recommended to use the helper macro <code>ATTR_TYPE_STR</code> to construct the type string.</p>
<pre><code>class SampleAttributeNestedStlContainer : public simics::ConfObject {
  public:
    using ConfObject::ConfObject;

    static void init_class(simics::ConfClass *cls) {
        cls-&gt;add(simics::Attribute(
                    "id_strs",
                    ATTR_TYPE_STR(SampleAttributeNestedStlContainer::id_strs),
                    "a map where each ID maps to a list of strings",
                    ATTR_CLS_VAR(SampleAttributeNestedStlContainer,
                                 id_strs)));
    }

    std::map&lt;int, std::vector&lt;std::string&gt;&gt; id_strs;
};
</code></pre>
<h3 id="creating-custom-get-and-set-functions"><a href="#creating-custom-get-and-set-functions">8.1 Creating Custom get and set functions</a></h3>
<p>For other types not listed in table above, including user defined types, there are many ways to support that. Here two of the ways are shown, first way creating custom get and set functions and implement them as shown in the example below:</p>
<pre><code>// The buffer class is used as an example to show how to register
// a custom type Simics attribute. It is not a reference
// implementation of how to write a custom buffer class.
// coverity[rule_of_three_violation:FALSE]
class buffer {
  public:
    buffer(const unsigned char *d, size_t size) {
        aux_.assign(d, d + size);
    }
    buffer(const buffer &amp;other) {
        aux_.assign(other.data(), other.data() + other.size());
    }
    buffer&amp; operator=(const buffer &amp;other) = delete;
    virtual ~buffer() = default;

    const unsigned char *data() const { return aux_.data(); }
    int size() const { return aux_.size(); }

  private:
    std::vector&lt;unsigned char&gt; aux_;
};

class SampleAttributeCustomMethod : public simics::ConfObject {
  public:
    using ConfObject::ConfObject;
    static void init_class(simics::ConfClass *cls);

    buffer get_blob() const;
    void set_blob(const buffer &amp;v);

  private:
    unsigned char blob_[1024] {};
};

buffer SampleAttributeCustomMethod::get_blob() const {
    return buffer(blob_, sizeof blob_);
}

void SampleAttributeCustomMethod::set_blob(const buffer &amp;v) {
    if (v.size() == sizeof blob_) {
        memcpy(blob_, v.data(), v.size());
    } else {
        throw std::runtime_error { "Wrong size of data buffer" };
    }
}

namespace {
attr_value_t get_blob_helper(conf_object_t *obj) {
    auto *o = simics::from_obj&lt;SampleAttributeCustomMethod&gt;(obj);
    return SIM_make_attr_data(1024, o-&gt;get_blob().data());
}

set_error_t set_blob_helper(conf_object_t *obj, attr_value_t *val) {
    auto *o = simics::from_obj&lt;SampleAttributeCustomMethod&gt;(obj);
    try {
        o-&gt;set_blob(buffer(SIM_attr_data(*val), SIM_attr_data_size(*val)));
    } catch (const std::exception &amp;e) {
        SIM_LOG_INFO(1, o-&gt;obj(), 0, "%s", e.what());
        return Sim_Set_Illegal_Value;
    }
    return Sim_Set_Ok;
}
}  // namespace

void SampleAttributeCustomMethod::init_class(simics::ConfClass *cls) {
    cls-&gt;add(simics::Attribute("blob", "d", "Some data",
                               &amp;get_blob_helper, &amp;set_blob_helper));
}

static simics::RegisterClassWithSimics&lt;SampleAttributeCustomMethod&gt;
init_custom_method {
    "sample_device_cxx_attribute_custom_method",
    "sample C++ attr device use custom method",
    "Sample C++ attribute device use custom method"
};
</code></pre>
<p>Besides the above way, it is also possible to specialize the converters to/from the user defined type. An example is shown below:</p>
<pre><code>struct MyType {
    uint64_t ull;
    std::string message;
    simics::ConfObjectRef some_object;
};

class SampleAttributeSpecializedConverter : public simics::ConfObject {
  public:
    using ConfObject::ConfObject;
    static void init_class(simics::ConfClass *cls) {
        cls-&gt;add(simics::Attribute("my_type", "[iso|n]",
                                   "An attribute of MyType",
                                   ATTR_CLS_VAR(
                                           SampleAttributeSpecializedConverter,
                                           my_type)));
    }

    MyType my_type;
};

// Specialize the template converter
namespace simics {
template &lt;&gt;
inline MyType attr_to_std&lt;MyType&gt;(attr_value_t src) {
    MyType result;
    result.ull = attr_to_std&lt;uint64&gt;(SIM_attr_list_item(src, 0));
    result.message = attr_to_std&lt;std::string&gt;(SIM_attr_list_item(src, 1));
    result.some_object = attr_to_std&lt;ConfObjectRef&gt;(SIM_attr_list_item(src, 2));
    return result;
}

template &lt;&gt;
inline attr_value_t std_to_attr&lt;MyType&gt;(const MyType &amp;src) {
    attr_value_t result = SIM_alloc_attr_list(3);
    SIM_attr_list_set_item(&amp;result, 0, std_to_attr&lt;uint64&gt;(src.ull));
    SIM_attr_list_set_item(&amp;result, 1, std_to_attr&lt;std::string&gt;(src.message));
    SIM_attr_list_set_item(&amp;result, 2,
                           std_to_attr&lt;ConfObjectRef&gt;(src.some_object));
    return result;
}
}  // namespace simics

static simics::RegisterClassWithSimics&lt;SampleAttributeSpecializedConverter&gt;
init_specialized_converter {
    "sample_device_cxx_attribute_specialized_converter",
    "sample C++ attr device with specialized converter",
    "Sample C++ attribute device with specialized converter"
};
</code></pre>
<h3 id="connect-as-attribute"><a href="#connect-as-attribute">8.2 Connect as attribute</a></h3>
<p>Registering a <code>Connect</code> variable as an attribute is done the same way as any other variable. User can use the help macros described above. The following code will create an <code>irq_dev</code> attribute that uses the Connect instance shown in <a href="#connect">Connect</a> as a value.</p>
<pre><code>void SampleConnect::init_class(simics::ConfClass *cls) {
    cls-&gt;add(simics::Attribute("irq_dev", "o|n",
                               "IRQ device",
                               ATTR_CLS_VAR(SampleConnect, irq_dev)));
}
</code></pre>
<h4 id="connect-templates"><a href="#connect-templates">8.2.1 Connect templates</a></h4>
<p>The template based class <code>ConnectToDescendant</code> helps to set the connect attribute by default to a automatically created object. It is similar to DML's connect template <code>init_as_subobj</code>. To achieve this, user needs to first register a port object and pass the name of it to the CTOR of class <code>ConnectToDescendant</code>.</p>
<pre><code>class SampleConnectToDescendant : public simics::ConfObject {
  public:
    using ConfObject::ConfObject;
    static constexpr const char * PORT_MEMORY_SPACE = "port.memory_space";
    static void init_class(simics::ConfClass *cls);

    simics::ConnectToDescendant&lt;
        simics::iface::MemorySpaceInterface&gt; target_mem_space {
        this, PORT_MEMORY_SPACE
    };
};

void SampleConnectToDescendant::init_class(simics::ConfClass *cls) {
    // Register the port object as default target memory space
    SIM_register_port(*cls, PORT_MEMORY_SPACE,
                      SIM_get_class("memory-space"),
                      "Target memory space as descendant");
    // It can also be optionally connected to other memory-space
    cls-&gt;add(simics::Attribute("target_mem_space", "o|n",
                               "Target port to a memory space",
                               ATTR_CLS_VAR(SampleConnectToDescendant,
                                            target_mem_space)));
}
</code></pre>
<p>The <code>MapTargetConnect</code> class facilitates the creation and return of a new map target. A map target can be viewed as an opaque representation of an object/interface pair which can function either as an endpoint for a memory transaction or as an address space where a memory transaction can be performed.</p>
<p>When an object is assigned to the MapTargetConnect attribute, it is systematically examined for the presence of specific interfaces in the following order: <code>ram</code>, <code>rom</code>, <code>io_memory</code>, <code>port_space</code>, <code>translator</code>, <code>transaction_translator</code>, <code>transaction</code> or <code>memory_space</code>. The first interface found determines the "type" of the map target. For example, if obj implements both the <code>io_memory</code> and the <code>translator</code> interface, then the created map target will direct memory transactions to the <code>io_memory</code> interface.</p>
<p>The generated map target offers convenient methods such as <code>read</code>, <code>read_bytes</code>, <code>write</code>, and <code>write_bytes</code>. Additionally, users have the option to interact directly with transactions using the <code>issue</code> method, providing flexibility in handling memory operations.</p>
<pre><code>class SampleConnectMapTarget : public simics::ConfObject {
  public:
    using ConfObject::ConfObject;

    static void init_class(simics::ConfClass *cls) {
        cls-&gt;add(simics::Attribute("map_target", "o|n",
                                   "Map Target",
                                   ATTR_CLS_VAR(SampleConnectMapTarget,
                                                map_target)));
    }

    simics::MapTargetConnect map_target {this-&gt;obj()};
};
</code></pre>
<h3 id="class-attribute"><a href="#class-attribute">8.3 Class Attribute</a></h3>
<p>To register a class attribute in Simics, you can use the <code>ClassAttribute</code> class. This class allows you to define attributes that are associated with a Simics class rather than a Simics object.</p>
<p>You need to create an instance of the <code>ClassAttribute</code> class, providing the attribute name, type, description, getter, setter, and attribute type. And then register it with the <code>ConfClass</code> using the <code>add</code> method.</p>
<pre><code>class SampleAttributeClassAttribute : public simics::ConfObject {
  public:
    explicit SampleAttributeClassAttribute(simics::ConfObjectRef obj)
        : ConfObject(obj) {
        ++instance_count_;
    }
    virtual ~SampleAttributeClassAttribute() {
        --instance_count_;
    }

    static attr_value_t get_instance_count(conf_class_t *cls) {
        return simics::std_to_attr&lt;int&gt;(instance_count_);
    }

    static void init_class(simics::ConfClass *cls) {
        cls-&gt;add(simics::ClassAttribute("instance_count", "i",
                                        "Instance count of the class",
                                        get_instance_count, nullptr,
                                        Sim_Attr_Pseudo));
    }

  private:
    static int instance_count_;
};

int SampleAttributeClassAttribute::instance_count_ = 0;

static simics::RegisterClassWithSimics&lt;SampleAttributeClassAttribute&gt;
init_class_attribute {
    "sample_device_cxx_attribute_class_attribute",
    "sample C++ attr device with class attribute",
    "Sample C++ attribute device with class attribute"
};
</code></pre>
<h3 id="attrvalue"><a href="#attrvalue">8.4 AttrValue</a></h3>
<p>The <code>AttrValue</code> class in Simics is a RAII (Resource Acquisition Is Initialization) class designed to manage the lifetime of a <code>attr_value_t</code> object. This class ensures that the memory allocated for the <code>attr_value_t</code> object is properly freed when the <code>AttrValue</code> object is destroyed, preventing memory leaks and ensuring proper resource management.</p>
<p>It is typically constructed or assigned from a Simics API call which returns an <code>attr_value_t</code> object.</p>
<h2 id="logging"><a href="#logging">9 Logging</a></h2>
<p>Logging is an essential tool for tracking the behavior of the model and diagnosing issues. While standard C++ logging mechanisms such as <code>std::cout</code> and <code>std::cerr</code> are available and could be used, leveraging the full power of Simics logging is highly recommended. Simics provides a robust logging system that offers several advantages over standard logging methods. Simics logging supports the selection of log objects, levels, and groups. For more information about Simics logging, see the <a href="../model-builder-user-guide/device-modeling-overview.html#logging">Model Builder User's Guide</a>.</p>
<p>For performance reasons, always use the logging macros below instead of invoking the Simics logging API directly:</p>
<ul>
<li><code>SIM_LOG_&lt;type&gt;</code> basic macros are provided by the Simics C API and have printf-like formatting.</li>
<li><code>SIM_LOG_&lt;type&gt;_STR</code> extended macros are provided by the Simics C++ API and supports string-link object. The strings can be formatted using FMT library that is also shipped with Simics.</li>
</ul>
<p>Both type of macros invoke the corresponding <code>SIM_log_&lt;type&gt;</code> functions internally but are wrapped in an additional layer that does not expand the code when log level conditions are not met.</p>
<p>The macros expect:</p>
<ol>
<li>the log level/verbosity</li>
<li>the log object</li>
<li>the log group (can be ORd to log for multiple groups)</li>
<li>the message</li>
<li>For the C macros, additional arguments for printf-like formatting passed as the 4th argument</li>
</ol>
<p>The <code>type</code> placeholder should be one of the following: INFO, SPEC_VIOLATION, UNIMPLEMENTED, ERROR, WARNING, or CRITICAL.</p>
<h3 id="example-usage"><a href="#example-usage">9.1 Example usage</a></h3>
<p>An example using C++ logging:
</p><pre><code>    SIM_LOG_INFO_STR(1, obj(), GROUP_ID(Signal),
                     fmt::format("Lowering signal (new level: {})", level));
    </code></pre>
<p>An example using C logging:
</p><pre><code>    SIM_LOG_INFO(1, obj(), GROUP_ID(Signal), "Raising signal (new level: %d)",
                 level);
    </code></pre>
<p>New log groups can be registered with the Simics class in the <code>init_class</code> method:
</p><pre><code>void SampleLogging::init_class(simics::ConfClass *cls) {
    simics::LogGroups lg {"CTOR", "Signal"};
    cls-&gt;add(lg);
</code></pre>
<div class="note">
<p><strong>NOTE:</strong> The Simics API <code>SIM_log_register_groups</code> can only be called once per Simics class. If you need to register log groups incrementally, such as adding more groups in an extended C++ class, it is recommended to use <code>cls-&gt;add</code> for registering log groups.</p>
</div>
<h2 id="event"><a href="#event">10 Event</a></h2>
<p>Event is useful to let something happen only after a certain amount of (simulated) time. By posting an event on a queue, a callback function is placed on the queue and will be called later in the simulation. The amount of time can be specified in different units, e.g, seconds, cycles or steps. Users should inherit from one of the Simics provided classes based on their desired timebase:</p>
<ul>
<li>simics::TimeEvent: Used when the delay is measured in seconds</li>
<li>simics::CycleEvent: Used when the delay is measured by the number of cycles</li>
<li>simics::StepEvent: Used when the delay is measured by the number of steps</li>
</ul>
<p>For the sake of clarity and simplicity, the following sections will primarily focus on the <code>TimeEvent</code> class as the primary example. It is important to note that both <code>CycleEvent</code> and <code>StepEvent</code> operate in an analogous manner.</p>
<p>Event support in the C++ API encompasses several key aspects: declaring the behavior of an event, registering the event, and defining and managing it.</p>
<p>The following example demonstrates how to declare, register, and manage an event using the <code>SampleEvent</code> class:</p>
<pre><code>class SampleEvent : public simics::ConfObject {
  public:
    using ConfObject::ConfObject;

    void finalize() override {
        // Post the user_event after 1 second
        user_event.post(1.0);
    }

    class UserTimeEvent : public simics::TimeEvent&lt;SampleEvent&gt; {
      public:
        explicit UserTimeEvent(simics::ConfObject *obj)
            : TimeEvent(obj, event_cls) {}

        // Static member variable for event class registration
        inline static event_class_t *event_cls = nullptr;

        // Callback method invoked when the event is triggered
        void callback(lang_void *data = nullptr) override {
            dev_-&gt;some_side_effects();
        }
    };

    void some_side_effects() {
        // Implementation of side effects goes here
    }

    static void init_class(simics::ConfClass *cls) {
        // Registering the event with a callback
        cls-&gt;add(simics::EventInfo("user_event",
                                   EVENT_CALLBACK(SampleEvent,
                                                  user_event)));
    }

    // Instance of UserTimeEvent initialized with this object
    UserTimeEvent user_event {this};
};
</code></pre>
<h3 id="defining-the-behavior-of-an-event"><a href="#defining-the-behavior-of-an-event">10.1 Defining the Behavior of an Event</a></h3>
<p>The callback for an event is defined within a user-defined event class. In this example, <code>UserTimeEvent</code> inherits from <code>simics::TimeEvent</code>, which allows it to utilize time-based delays.</p>
<p>Requirements for the event class:</p>
<ol>
<li>
<p><strong>Base Class</strong>: The base class <code>simics::TimeEvent</code> is a template class. The template type serves as the type for the member variable <strong>dev_</strong>, which points to the C++ device class containing this event. Thus, the template type must match the C++ device class type.</p>
</li>
<li>
<p><strong>Constructor</strong>: The event class must include a constructor that accepts a pointer to a Simics object (<code>simics::ConfObject</code>).</p>
</li>
<li>
<p><strong>Static Member Variable</strong>: The event class should have a static member variable named <strong>event_cls</strong>. This fixed name is utilized by certain macros during event registration.</p>
</li>
<li>
<p><strong>Passing Static Variable</strong>: The static variable <strong>event_cls</strong> must be passed to the constructor of <code>simics::TimeEvent</code>. This variable points to the <strong>event_class_t</strong> used in calls to the Simics API.</p>
</li>
<li>
<p><strong>Callback Override</strong>: The event class must override the <strong>callback</strong> method, which is invoked when the event is triggered.</p>
</li>
</ol>
<p>The following methods may also be overridden:</p>
<ol>
<li><code>void destroy(void *data)</code>: Called when the event is removed from the queue without being triggered.</li>
<li><code>attr_value_t get_value(void *data)</code>: Converts the event data into a value suitable for saving in a configuration.</li>
<li><code>void *set_value(attr_value_t value)</code>: Converts a configuration value back into event data.</li>
<li><code>char *describe(void *data)</code>: Generates a human-readable description of the event for use with the <strong>print-event-queue</strong> command.</li>
</ol>
<h3 id="registering-the-event"><a href="#registering-the-event">10.2 Registering the Event</a></h3>
<p>To register an event, call <strong>add</strong> on the <code>ConfClass</code> object. An example of how to register an event is shown in <strong>init_class</strong> method above, where an instance of <code>simics::EventInfo</code> is constructed with registration information and passed to add.</p>
<h3 id="posting-and-removing-events"><a href="#posting-and-removing-events">10.3 Posting and Removing Events</a></h3>
<p>Events are posted using the <strong>post(duration)</strong> method:</p>
<ul>
<li>The <strong>duration</strong> parameter specifies how long (in seconds, cycles, or steps) until the event triggers, depending on its type.</li>
</ul>
<p>Events can be canceled before they trigger using <strong>remove(match_data)</strong>:</p>
<ul>
<li>The <strong>match_data</strong> argument is optional; if provided, it matches a specific event; if not given, all events are canceled.</li>
</ul>
<p>In addition to post and remove, users can also utilize:</p>
<ul>
<li><strong>posted(match_data)</strong>: Checks if an event has been posted.</li>
<li><strong>next(match_data)</strong>: Retrieves the time until the next event in the queue.</li>
</ul>
<h2 id="after"><a href="#after">11 After</a></h2>
<p>The <code>after</code> feature is a lightweight event mechanism that schedules a specified method call (the callback) to be executed at a future point with the provided arguments. This feature is particularly useful for managing timed events in simulation environments.</p>
<h3 id="example"><a href="#example">11.1 Example</a></h3>
<p>Here's an example demonstrating how to use the <code>after</code> feature in a Simics C++ device class:</p>
<pre><code>
// Log on sim object. Used from global function since no other Simics
// objects can be used there.
void logOnSim(const std::string &amp;msg) {
    static auto sim_obj = SIM_get_object("sim");
    SIM_LOG_INFO_STR(1, sim_obj, 0, msg);
}

void twoStrsArgumentGlobalFunction(std::string s1, std::string s2) {
    logOnSim("Hello, I am twoStrsArgumentGlobalFunction(" + \
             s1 + ", " + s2 + ")");
}

class SampleAfter : public simics::ConfObject,
                    public simics::EnableAfterCall&lt;SampleAfter&gt; {
  public:
    explicit SampleAfter(simics::ConfObjectRef obj)
        : ConfObject(obj), simics::EnableAfterCall&lt;SampleAfter&gt;(this) {
    }

    void cancel_after(bool trigger) {
        if (trigger) {
            // cancel all suspended method calls associated with
            // this object
            cancel_all();
        }
    }

    void oneUint64ArgumentClassFunction(uint64_t a) {
        logOnSim("Hello, I am oneUint64ArgumentClassFunction("
                 + std::to_string(a) + ")");
    }

    void finalize() override {
        if (SIM_is_restoring_state(obj())) {
            return;
        }

        AFTER_CALL(this, 1.0, &amp;twoStrsArgumentGlobalFunction,
                   std::string("abc"), std::string("def"));
        AFTER_CALL(this, 2.0, &amp;SampleAfter::oneUint64ArgumentClassFunction,
                   obj(), one_uint64_);
    }

    static void init_class(simics::ConfClass *cls);

  private:
    uint64_t one_uint64_ {0xdeadbeef};
};

void SampleAfter::init_class(simics::ConfClass *cls) {
    // Registering functions for later after call invocation
    REGISTER_AFTER_CALL(&amp;twoStrsArgumentGlobalFunction);
    REGISTER_AFTER_CALL(&amp;SampleAfter::oneUint64ArgumentClassFunction);

    // Register the after event on SampleAfter with default name "after_event"
    cls-&gt;add(SampleAfter::afterEventInfo());

    cls-&gt;add(simics::Attribute(
                     "cancel_after", "b",
                     "When being set, cancel all after callbacks",
                     nullptr,
                     ATTR_SETTER(SampleAfter, cancel_after),
                     Sim_Attr_Pseudo));
}
</code></pre>
<h3 id="breakdown-of-the-example"><a href="#breakdown-of-the-example">11.2 Breakdown of the Example</a></h3>
<ol>
<li>
<p><strong>Sample Class</strong>:
The <code>SampleAfter</code> class inherits from <code>simics::ConfObject</code> and <code>simics::EnableAfterCall&lt;SampleAfter&gt;</code>, enabling it to utilize the <code>after</code> feature.</p>
<p>To suspend a method call, a pointer to the class must be passed as the first parameter to the <code>AFTER_CALL</code> macro.</p>
</li>
<li>
<p><strong>Method Calls</strong>:
Two method calls are suspended in this example using the <code>after</code> feature:</p>
<ul>
<li>The <code>twoStrsArgumentGlobalFunction</code> takes two strings as arguments and logs a message indicating its invocation.</li>
<li>The <code>oneUint64ArgumentClassFunction</code> is a class member function which logs a message with a single <code>uint64_t</code> argument.</li>
</ul>
<p>The method call suspended by <code>after</code> can be a free global function, a static class member function, or a class member function. For class member functions, the class must either inherit from <code>simics::ConfObject</code> (indicating it is a Simics C++ device class) or be a Bank/Register/Field class. The method must not return any value and can accept an arbitrary number of arguments. It will be invoked at most once per <code>after</code> statement; it does not recur. If recurring behavior is desired, the method must invoke <code>after</code> to schedule another call to itself.</p>
<p>The function pointer for the method call must be passed to two macros: <code>REGISTER_AFTER_CALL</code> or <code>REGISTER_REG_BANK_AFTER_CALL</code>, as well as to <code>AFTER_CALL</code>.</p>
</li>
<li>
<p><strong>After Call</strong>:
Two method calls are scheduled using the <code>AFTER_CALL</code> macro:</p>
<ul>
<li>The first call to <code>twoStrsArgumentGlobalFunction</code> occurs after 1 second with two string arguments.</li>
<li>The second call to <code>SampleAfter::oneUint64ArgumentClassFunction</code> occurs after 2 seconds with a <code>uint64_t</code> argument.</li>
</ul>
<p>This <code>AFTER_CALL</code> macro requires four parameters:</p>
<ol>
<li>A pointer to the device class that supports <code>after</code> calls.</li>
<li>A delay specified in seconds (as a float) or cycles (as a uint64).</li>
<li>A pointer to the suspended method.</li>
<li>The arguments for the function.</li>
</ol>
</li>
<li>
<p><strong>Class Initialization</strong>:</p>
<ul>
<li>The <code>after</code> feature is built upon an internal event mechanism. To utilize this feature, you must register the event within the Simics class using the <code>add</code> function</li>
<li>The <code>init_class</code> method also registers the functions for later invocation via after calls. This is required by checkpointing to be able to resume a suspended method call after loading a checkpoint. This can be done using another macro: <code>REGISTER_AFTER_CALL</code>, or <code>REGISTER_REG_BANK_AFTER_CALL</code> for methods on Bank/Register/Field classes.</li>
</ul>
</li>
</ol>
<h2 id="utilities"><a href="#utilities">12 Utilities</a></h2>
<h3 id="generator-of-simics-c-interface-header"><a href="#generator-of-simics-c-interface-header">12.1 Generator of Simics C++ interface header</a></h3>
<p>The file <code>bin/gen-cc-interface</code> (or <code>bin/gen-cc-interface.bat</code> on Windows) is used to generate a Simics C++ interface header which is used for a Simics C++ module from the given Simics C interface header. Required argument is the path to the C interface header file.</p>
<p>For instance the following line specifies that <code>example.h</code> should be parsed by the tool and converted to a C++ interface header file.</p>
<pre><code>  project&gt; bin/gen-cc-interface modules/example-interface/example.h
</code></pre>
<p>The generator parses the C interface header, searches for <code>SIM_INTERFACE</code> and generates corresponding C++ interface class to the output C++ header file.</p>
<p>By default, the output C++ interface header is generated under <em>c++</em> subdirectory of where the input C header file is located. This can be altered by providing an optional argument by <code>-o</code> with the desired output location.</p>
<p>By default, the following code is generated to locate the original C interface header in the parent folder:</p>
<pre><code>    #include "../c-header.h"
</code></pre>
<p>When <code>-o</code> is used, the desired include path must be provided by the optional argument <code>-p</code>.</p>
<!--- begin documentation from C++ extension --->
<!--- if updated, please push changes upstream --->
<h2 id="simics-c-api-modeling-extension"><a href="#simics-c-api-modeling-extension">13 Simics C++ API Modeling Extension</a></h2>
<p>The Simics C++ API Modeling Extension (SME) complements the Simics C++ API but is not required for modeling.  The SME adds notification rules, expression logic rules &amp; state machine modeling (using Boost SML) to create a comprehensive behavioral modeling method which can ease the implementation of complex hardware modules.</p>
<h3 id="scaffolding"><a href="#scaffolding">13.1 Scaffolding</a></h3>
<p>Additional information is required by the SME to facilitate consistent execution order of notifications between Register &amp; Field rules which exist for the same field.  Scaffolding provides these mechanics by introducing logic on read/write methods which determines the origin of execution and ensure consistent ordering of rules along with some additional book-keeping.</p>
<p>To enable SME the developer will wrap any register type with <code>sme::reg&lt;&gt;</code> or <code>sme::field&lt;&gt;</code> as appropriate.  Using this approach also allows the developer  to selectively add the modeling extension capability only to those registers where notification rules are useful.</p>
<div class="note">
<p>WARNING: When enabling SME for any entity, the register and all fields associated must be wrapped or the code will not compile.</p>
</div>
<p><em>Register declaration example</em></p>
<pre><code>class EXAMPLE_REGISTER : public simics::BankRegister&lt; sme::reg&lt; simics::Register &gt; &gt; { ... }
</code></pre>
<p><em>Field declaration example</em></p>
<pre><code>class EXAMPLE_FIELD : public simics::RegisterField&lt; sme::field&lt; simics::Field &gt; &gt; { ... }
</code></pre>
<p>Below is a full declaration example within a <code>PortBank</code>.  Note that any <code>simics::Register</code> subtype or <code>simics::Field</code> subtype may be utilized, the <code>sme::reg</code> &amp; <code>sme::field</code> declarations enable scaffolding for notification rules without affecting type customization.</p>
<pre><code class="language-C">class SampleDevice : public simics::MappableConfObject {
public:
    explicit SampleDevice( simics::ConfObjectRef o)
        : simics::MappableConfObject(o) {
    }
    static void init_class(simics::ConfClass *cls);
};

class SampleBank : public simics::PortBank&lt;&gt; {
public:
    using PortBank::PortBank;

    class EXAMPLE_REGISTER : public simics::BankRegister&lt; sme::reg&lt; simics::Register &gt; &gt; {
        public:
        using BankRegister::BankRegister;
                                            
            class EXAMPLE_FIELD_1 : public simics::RegisterField&lt; sme::field&lt; simics::Field &gt; &gt; {
                public:
                using RegisterField::RegisterField;
            };

            class EXAMPLE_FIELD_2 : public simics::RegisterField&lt; sme::field&lt; simics::Field &gt; &gt; {
                public:
                using RegisterField::RegisterField;
            };

        public:
        
        EXAMPLE_FIELD_1 example_field_1 {                                
            this, simics::Name("example_field_1"),                 
            simics::Description("example_field_1"),
            simics::Offset(0), 
            simics::BitWidth(16)
        };
        EXAMPLE_FIELD_2 example_field_2 {                                
            this, simics::Name("example_field_2"),                 
            simics::Description("example_field_2"),
            simics::Offset(15), 
            simics::BitWidth(16)
        };
    };

    EXAMPLE_REGISTER example_register {
        this, simics::Name("example_register"),
        simics::Description("example_register"),
        simics::Offset(0x04),
        simics::ByteSize(4),
        simics::InitValue(0x0)
    };
};

class SampleBankPort : public simics::BankPort&lt;SampleDevice&gt; {
    public:
    using BankPort&lt;SampleDevice&gt;::BankPort;

    SampleBank bank {
        this, simics::Description("Sample Bank")
    };
};
</code></pre>
<p>There is no difference to the actual device initialization code, so this modification is to declaration code only.</p>
<h3 id="notification-rules"><a href="#notification-rules">13.2 Notification Rules</a></h3>
<p>Notification rules provide a means to register a callback at a certain stage of processing register/field transactions, and may include content matching in the form of masks or patterns so that the logic is declarative in nature rather than in algorithm code.</p>
<p>Notification rules must be registered to a particular stage which determines when the rule will be evaluated.  When a notification rule resolves to true, then its associated callback is executed.</p>
<table>
    <tbody><tr>
        <td>Stage</td>
        <td>Description</td>
    </tr>
    <tr>
        <td>sme::stage::PRE_READ</td>
        <td>Occurs prior to the actual data read taking place. <br>
        Only useful in rare cases where a check is required before allowing data to be read. <br>
        NOTE: should only utilize a rule Type of sme::type::NOTIFY, other rule type behavior is undefined.
        </td>
    </tr>
    <tr>
        <td>sme::stage::POST_READ</td>
        <td>Occurs after the read of data and will allow modification of the data to be returned.<br>
        Often utilized to effect state of device when content may need to be flushed or reset.</td>
    </tr>
    <tr>
        <td>sme::stage::PRE_WRITE</td>
        <td>Occurs before the data is committed.<br>
        Useful if particular modes of operation will force particular bits not to accept writes.</td>
    </tr>
    <tr>
        <td>sme::stage::POST_WRITE</td>
        <td>Occurs after data has been committed (write complete) to the register/field.<br>
        Important to note control has not returned to the bus at time of execution.<br>
        Most common stage used to declare notification rules.</td>
    </tr>
</tbody></table>
<p>Notification rules must also define the Type of rule which defines how data will be evaluated to determine if the rule should execute the assigned callback.  The below table provides a reasonable description and details extended parameters required for each type (when necessary).</p>
<table>
    <tbody><tr>
        <td>Type</td>
        <td>Description</td>
    </tr>
    <tr>
        <td>sme::type::NOTIFY</td>
        <td>Executes with no logic evaluation applied.
        </td>
    </tr>
    <tr>
        <td>sme::type::MASKED</td>
        <td>Executes only if positive masked bits change.<br>
        <br>
        PARAMETERS<br>
        uint64_t _mask :: a binary mask which enabled bits (1) will be evaluated.
        </td>
    </tr>
    <tr>
        <td>sme::type::PATTERN</td>
        <td>Executes if masked bits change from one value combination to another value combination.<br>
        Useful for multi-bit changes which modify state or mode of IP.<br>
        <br>
        PARAMETERS<br>
        uint64_t _mask  :: a binary mask which enabled bits (1) will be evaluated.<br>
        uint64_t _start :: value which must match existing stored value with _mask applied.<br>
        uint64_t _end   :: value which must match data (being written) with _mask applied.<br>
        </td>
    </tr>
    <tr>
        <td>sme::type::RISING_BIT</td>
        <td>Executes when the specified bit transitions from 0 to 1.<br>
        <br>
        PARAMETERS<br>
        uint8_t _bit :: bit to evaluate.<br>
        </td>
    </tr>
    <tr>
        <td>sme::type::FALLING_BIT</td>
        <td>Executes when the specified bit transitions from 1 to 0.<br>
        <br>
        PARAMETERS<br>
        uint8_t _bit :: bit to evaluate.<br>
        </td>
    </tr>
</tbody></table>
<h4 id="behavior-model"><a href="#behavior-model">13.2.1 Behavior Model</a></h4>
<p>Before creating notification rules it is common place to create a stand alone class for the behavior so that stimulation from the simulator and the behavior are separated.  This is useful in cases where device/register/field frameworks are auto-generated.</p>
<pre><code class="language-C">class example_behavior {
protected:
    SampleBank * m_bank {nullptr};

public:
    void init( SampleBank * _bank) { m_bank = _bank; }
    
};
</code></pre>
<p>Behavior is implemented in the form of callbacks which the notification rules can execute.  Right now only simple behavior is needed to demonstrate notification rule connectivity.</p>
<p>Important note: If in your callbacks you find you want the old value and compare it to the new value on a change in the register you will want sme::type::PATTERN, sme::type::RISING_BIT, sme::type::FALLING_BIT and not just a simple sme::type::NOTIFY rule.</p>
<pre><code class="language-C">    void on_reg_pre_read() {
        // If you need the value of any registers you have access to your bank and 
        // can scope down to any register to get it's value
        uint32_t val = m_bank-&gt;example_register.get();
        // If you wish to log info you can use SIM_LOG_INFO
        SIM_LOG_INFO(4, this-&gt;obj(), 0,
                     "on_reg_pre_read: %d", val);
    }

    void on_reg_post_read() {
        // You can of course use std::cout prints for quick debug but
        // probably will want to utilize SIM_LOG_INFO for long term
        // as it can be turned on/off at runtime
        std::cout &lt;&lt; "on_reg_post_read()" &lt;&lt; std::endl;
    }

    void on_reg_pre_write() {
        std::cout &lt;&lt; "on_reg_pre_write()" &lt;&lt; std::endl;
    }

    void on_reg_post_write() {
        std::cout &lt;&lt; "on_reg_post_write()" &lt;&lt; std::endl;
    }

    on_reg_mask_change() {
        std::cout &lt;&lt; "on_reg_mask_change()" &lt;&lt; std::endl;
    }

    on_reg_pattern_change() {
        std::cout &lt;&lt; "on_reg_pattern_change()" &lt;&lt; std::endl;
    }

    void on_enable_field_1() {
        std::cout &lt;&lt; "on_enable_field_1()" &lt;&lt; std::endl;
        // You can do calculations with the current value of a field
        uint16_t temp = m_bank-&gt;example_register.example_field_1.get() &amp; 0x7fff;
        // And then use that calculated value to set a new value in the same field/register
        // Or you can set a completely different register/field
        m_bank-&gt;example_register.example_field_1.set(temp);
    }

    void on_enable_field_2() {
        std::cout &lt;&lt; "on_enable_field_2()" &lt;&lt; std::endl;
        uint16_t temp = m_bank-&gt;example_register.example_field_2.get() &amp; 0x7fff;
        m_bank-&gt;example_register.example_field_2.set(0);
    }
</code></pre>
<h4 id="creating-notification-rules"><a href="#creating-notification-rules">13.2.2 Creating Notification Rules</a></h4>
<p>The behavior model can be instantiated in Simics Device or as another class which ties the two together.  For this example an example model will be created.</p>
<pre><code class="language-C">class example_model {
public:
    example_model( SampleDevice * _dev) {
        dev = _dev;
        bank_port = new SampleBankPort { _dev-&gt;obj() };
        beh.init( &amp;bank_port-&gt;bank)
    }

    virtual ~example_model() {
        if( bank_port) {
            delete bank_port;
            bank_port = nullptr;
        }
    }

    void bind() {
        bank_port-&gt;bank.example_register.add_rule(
            [this]()-&gt;void { beh.on_reg_pre_read(); },
            sme::stage::PRE_READ, sme::type::NOTIFY, "on_reg_pre_read"
        );
        bank_port-&gt;bank.example_register.add_rule(
            [this]()-&gt;void { beh.on_reg_post_read(); },
            sme::stage::POST_READ, sme::type::NOTIFY, "on_reg_post_read"
        );
        bank_port-&gt;bank.example_register.add_rule(
            [this]()-&gt;void { beh.on_reg_pre_write(); },
            sme::stage::PRE_WRITE, sme::type::NOTIFY, "on_reg_pre_write"
        );
        bank_port-&gt;bank.example_register.add_rule(
            [this]()-&gt;void { beh.on_reg_post_write(); },
            sme::stage::POST_WRITE, sme::type::NOTIFY, "on_reg_post_write"
        );
        bank_port-&gt;bank.example_register.add_rule(
            [this]()-&gt;void { beh.on_reg_mask_change(); },
            sme::stage::POST_WRITE, sme::type::MASKED, "on_reg_mask_change", 0x0ff00ff0
        );
        bank_port-&gt;bank.example_register.add_rule(
            [this]()-&gt;void { beh.on_reg_pattern_change(); },
            sme::stage::POST_WRITE, sme::type::PATTERN, "on_reg_pattern_change", 0x000f000f, 0x00030002, 0x00040005
        );
        bank_port-&gt;bank.example_register.example_field_1.add_rule(
            [this]()-&gt;void { beh.on_enable_field_1(); },
            sme::stage::POST_WRITE, sme::type::RISING_BIT, "on_enable_field_1", 15
        );
        bank_port-&gt;bank.example_register.example_field_2.add_rule(
            [this]()-&gt;void { beh.on_enable_field_2(); },
            sme::stage::POST_WRITE, sme::type::LOWERING_BIT, "on_enable_field_2", 15
        );
    }

protected:
    SampleDevice * dev;
    SampleBankPort * bank_port;
    example_behavior beh;
}
</code></pre>
<p>The example demonstrates how additional parameters for rule types are added to the end of the list.  Notice that bit based field rules are relative to the field width and not the register width.</p>
<p>There is also the add_user_rule() method which is similar to add_rule except it has access to the register's old value and the register's new value. This allows you to easily create rules that are based on specific value changes.</p>
<pre><code class="language-C">bank_port-&gt;bank.example_register.add_user_rule(
            [this]( uint64_t _old, uint64_t _new)-&gt;void {
                // keep in mind the new value here is what was written in,
                // not what is restricted by register type
                if ((_old != 0x0) || (_old == 0xdeadbeef)) {
                    // Do some stuff
                }
            },
            sme::stage::PRE_WRITE, sme::type::NOTIFY, "on_reg_pre_write", 15
        );
</code></pre>
<h4 id="advanced-features"><a href="#advanced-features">13.2.3 Advanced Features</a></h4>
<p>Notification rules can also be deactivated from within a behavioral callback.</p>
<pre><code class="language-C">    bank_port-&gt;bank.example_register.deactivate_rule( sme::stage::PRE_READ, "on_reg_pre_read");
    bank_port-&gt;bank.example_register.deactivate_rule( sme::stage::POST_READ, "on_reg_post_read");
    bank_port-&gt;bank.example_register.deactivate_rule( sme::stage::PRE_WRITE, "on_reg_pre_write");
    bank_port-&gt;bank.example_register.deactivate_rule( sme::stage::POST_WRITE, "on_reg_post_write");
</code></pre>
<p>And those rules can be re-activated as well, this provides a great deal of flexibility for mode based IP configuration.</p>
<pre><code class="language-C">    bank_port-&gt;bank.example_register.activate_rule( sme::stage::POST_WRITE, "on_reg_post_write");
</code></pre>
<h4 id="simple-side-effect-example"><a href="#simple-side-effect-example">13.2.4 Simple Side Effect Example</a></h4>
<p>To help understand the notification rule techniques, this section shows a very simple side effect and converts it to notification rules. This is not the only way to do the following conversion and is just an example and is not a fully functional C++ model.</p>
<pre><code>Assume we have a device named SimpleDevice and on a field write we want the following to trigger:
- If the current value is zero and the new (written) value is 1
    Set 'field2' to the value of 0x0 and set an array value with index 'reg_idx' to true
- If the current value is one and the new value is zero or the current value is zero and the new value is zero
    Set 'field2' to the value of 0x1 and set an array value with index 'reg_idx' to false
- If the current value is one and the new value is two or the current value is zero and the new value is two:
    Just output a log message saying: "Enabling task #3 %d", reg_idx
</code></pre>
<p>To convert these side effects to base Simics C++ API it would look like:</p>
<pre><code>    void write(uint64_t value, uint64_t enabled_bits) override {
        auto current_value = get();
        if ((current_value == 0) &amp;&amp; (value == 1)) {
            SIM_LOG_INFO(4, bank_obj_ref(), 0, "Enabling task #1 %d", reg_idx);
            field2-&gt;set(0);
            some_array[reg_idx]-&gt;level = true;
        }
        if (((current_value == 1) &amp;&amp; (value == 0))
            || ((current_value == 0) &amp;&amp; (value == 0))) {
            SIM_LOG_INFO(4, bank_obj_ref(), 0, "Enabling task #2 %d", reg_idx);
            field2-&gt;set(1);
            some_array[reg_idx]-&gt;level = false;
        }
        if (((current_value == 1) &amp;&amp; (value == 2))
            || ((current_value == 0) &amp;&amp; (value == 2))) {
            SIM_LOG_INFO(4, bank_obj_ref(), 0, "Enabling task #3 %d", reg_idx);
        }
        Field::write(value, enabled_bits);
    }
    </code></pre>
<p>To convert these side effects to SME you would take each of the if statements and create notification rules out of them and place them into the device and define what to do on each of the callbacks.</p>
<pre><code class="language-c++">class SimpleDevice : public simics::MappableConfObject {
    public:
    explicit SimpleAccessTestSimpleDevice(simics::ConfObjectRef o)
        : simics::MappableConfObject(o) {

            // Add register rules

            // ((this.val == 0) &amp;&amp; (value == 1))
            b-&gt;bank.example_register.idx.add_rule([this]()-&gt;void {this-&gt;enable_task_1(); }, sme::stage::PRE_WRITE, sme::type::RISING_BIT, "idx_rising_bit_0", 0);

            // ((this.val == 1) &amp;&amp; (value == 0))
            b-&gt;bank.example_register.idx.add_rule([this]()-&gt;void {this-&gt;enable_task_2(); }, sme::stage::PRE_WRITE, sme::type::FALLING_BIT, "idx_falling_bit_0", 0);

            // nochange to bit 0 ((this.val == 0) &amp;&amp; (value == 0))
            b-&gt;bank.example_register.idx.add_rule([this]()-&gt;void {this-&gt;enable_task_2(); }, sme::stage::PRE_WRITE, sme::type::PATTERN, "idx_no_change_bit_0", 0x1, 0x0, 0x0);

            // ((this.val == 1) &amp;&amp; (value == 2))
            b-&gt;bank.example_register.idx.add_rule([this]()-&gt;void {this-&gt;enable_task_3(); }, sme::stage::PRE_WRITE, sme::type::PATTERN, "idx_val_1_to_2", 0x3, 0x1, 0x2);

            // ((this.val == 0) &amp;&amp; (value == 2))
            b-&gt;bank.example_register.idx.add_rule([this]()-&gt;void {this-&gt;enable_task_3(); }, sme::stage::PRE_WRITE, sme::type::RISING_BIT, "idx_rising_bit_1", 1);
        };


    // Device init_class
    static void init_class(simics::ConfClass *cls);


    // Start notify rule methods
    void enable_task_1() {
        uint8_t reg_idx = b-&gt;bank.example_register.idx.get();
        SIM_LOG_INFO(4, this-&gt;obj(), 0, "Enabling task #1 %d", reg_idx);
        b-&gt;bank.example_register.field2 = 0;
        some_array[reg_idx]-&gt;level = true;
    }

    void enable_task_2() {
        uint8_t reg_idx = b-&gt;bank.example_register.idx.get();
        SIM_LOG_INFO(4, this-&gt;obj(), 0, "Enabling task #2 %d", reg_idx);
        b-&gt;bank.example_register.field2 = 1;
        some_array[reg_idx]-&gt;level = false;
    }

    void enable_toggle_edge() {
        SIM_LOG_INFO(4, this-&gt;obj(), 0, "Enabling task #3 %d", b-&gt;bank.example_register.idx.get());
    }
};
</code></pre>
<h3 id="expressions"><a href="#expressions">13.3 Expressions</a></h3>
<p>Expression rules provide a way to listen to register, field and (eventually) signal notification rules and then evaluate a compound expression which mirrors a HW SPEC definition.  When the expression evaluates to true a callback is executed where the user only has to be concerned with coding the specific behavior/functionality.  These compound expressions can also be used to walk a state machine.</p>
<p>Expressions will typically be declared in the MODEL definition.</p>
<pre><code class="language-C">    sme::expression expression_example { "expression_example"};
</code></pre>
<p>The <code>sensitive_to</code> statement can bind another expression (via an expression vector) or create a notification rule and bind the notification to this expression (automatically).  The parameter list determines what type of notification rule or binding will occur.</p>
<pre><code class="language-C">		// DEFINE EXPRESSION SENSITIVITIES
            // NOTIFY
        expression_example.sensitive_to( bank.example_register.example_field_1, stage::POST_WRITE);
            // MASK
        expression_example.sensitive_to( bank.example_register.example_field_1, stage::POST_WRITE, 0x0003);
            // PATTERN
        expression_example.sensitive_to( bank.example_register.example_field_1, stage::POST_WRITE, 0x0030, 0x0020, 0x0010);
</code></pre>
<p>The expression does not use a DSL, equation parser or other complex notion.  Instead a standard C boolean expression is used and defined as a lambda to keep the code concise.  This evaluation is defined as the "logic" statement of the expression.  The logic statement may utilize other registers, fields, even banks if you have a reference to them; so it is possible to build very complex logic analysis statements.</p>
<pre><code class="language-C">		// DEFINE EXPRESSION TO EVALUATE
        expression_example.logic( [this]() -&gt; bool {
            bool result = 
                (bank.example_register.example_field_1.get() == 1 &amp;&amp; bank.example_register.example_field_2.get() == 0x011) ||
                (bank.example_register.get() == 0x03320110);
            return( result);
        });
</code></pre>
<p>The 'logic' statement is actually part of an evaluation flow which can activate many different vectors.</p>
<table>
    <tbody><tr>
        <td>Expression Vector</td>
        <td>Description</td>
    </tr>
    <tr>
        <td>eval_true</td>
        <td>Executes every time the logic evaluates to true.</td>
    </tr>
    <tr>
        <td>eval_false</td>
        <td>Executes every time the logic evaluates to false.</td>
    </tr>
    <tr>
        <td>change</td>
        <td>Executes every time the logic changes (true-&gt;false), (false-&gt;true)</td>
    </tr>
    <tr>
        <td>rising</td>
        <td>Executes every time the logic changes from false-&gt;true</td>
    </tr>
    <tr>
        <td>falling</td>
        <td>Executes every time the logic changes from true-&gt;false</td>
    </tr>
</tbody></table>
<p>These expression vectors allow for behavior definition relative to how expression logic should drive the underlying implementation.</p>
<pre><code class="language-C">		// BIND TO DEVELOPER METHOD for FUNCTIONALITY
        expression_example.eval_true.execute( [this]() -&gt; void {
            std::cout &lt;&lt; "expression_example.eval_true" &lt;&lt; std::endl;
        });
        expression_example.eval_false.execute( [this]() -&gt; void {
            std::cout &lt;&lt; "expression_example.eval_false" &lt;&lt; std::endl;
        });
        expression_example.change.execute( [this]() -&gt; void {
            std::cout &lt;&lt; "expression_example.change" &lt;&lt; std::endl;
        });
        expression_example.rising.execute( [this]() -&gt; void {
            std::cout &lt;&lt; "expression_example.rising" &lt;&lt; std::endl;
        });
        expression_example.falling.execute( [this]() -&gt; void {
            std::cout &lt;&lt; "expression_example.falling" &lt;&lt; std::endl;
        });
</code></pre>
<p>It is also possible to make an expression sensitive to another expression via an expression vector.  Imagine if a second register existed, and <code>expression_example_2</code> is only sensitive to <code>expression_example.rising</code>.  One could do
the following to check <code>example_register_2</code> value only when the rising condition of the first expression was met.</p>
<pre><code class="language-C">    sme::expression expression_example_2 { "expression_example_2"};

    expression_example_2.sensitive_to( expression_example.rising);

    expression_example_2.logic( [this]() -&gt; bool {
        bool result = (bank.example_register_2.get() == 0x12345678);
        return( result);
    });
</code></pre>
<p>It is good to make note that you typically will use either notification rules or expressions (which are composed of notification rules) based on the complexity of content evaluation needed.  It may be easier to just use expressions in most cases, but for simple tasks notification rules work fine.</p>
<h3 id="boost-sml-state-machine-library"><a href="#boost-sml-state-machine-library">13.4 Boost SML (State Machine Library)</a></h3>
<p>State machines have long been a cornerstone of modeling complex HW flows in virtual platforms.  Simics currently lacks any API that specifically defines a state machine.  Luckily for us there are several API's developed in the last decade which excel at state machine definition and keeping the footprint and executable code size to a minimum.</p>
<p>Boost SML is probably the most advanced implementation, a highly template meta-programming based implementation which actually treats each state as a type; and the binary code inherently is executing from its state.  This creates a bit of a headache in capturing the active state for save/restore, but otherwise the framework is completely UML declaration compliant and is amazing to work with.</p>
<p>This example will showcase the implementation of a minimal state loop of the following state machine:
<img alt="" src="ip_fsm.svg"></p>
<p>IP_ON_BUSY -&gt; DEASSERT_RESET         : by sending command DEASSERT_RESET</p>
<p>DEASSERT_RESET -&gt; IP_READY_2_RESET   : internal acknowledge of state entered</p>
<p>IP_READY_2_RESET -&gt; IP_RESET_COMPLETE: internal bit write (IP has no power cycle)</p>
<p>IP_RESET_COMPLETE -&gt; IP_ON_BUSY      : timer expired</p>
<p>most of the transitions are pseudo-code because this is C++ test-harness based example.</p>
<p>Example top level: <code>&lt;Simics Base Package&gt;/src/devices/c++-api/extensions/unittests/doc_example.cxx</code></p>
<p>Example sub files:  <code>&lt;Simics Base Package&gt;/src/devices/c++-api/extensions/unittests/doc_example</code></p>
<h4 id="example-logger"><a href="#example-logger">13.4.1 Example Logger</a></h4>
<p>There is an example logger for the state machine events and transitions under <code>third_party_integration/fsm_logger.hpp</code>.  While this is somewhat useful, it may be desirable to create your own logger for BOOST SML, this is defined in the declaration of the SM instance which is covered further down.</p>
<h4 id="example-register-set"><a href="#example-register-set">13.4.2 Example Register Set</a></h4>
<p>For this example we need a few registers (to begin with) that will enable the need for complex expressions to drive the state machine.</p>
<pre><code class="language-C">// Device container class
class FsmRegDevice : public simics::MappableConfObject {
public:
    explicit FsmRegDevice(simics::ConfObjectRef o)
        : simics::MappableConfObject(o) {
    }
    static void init_class(simics::ConfClass *cls);
};

class FsmRegBank : public simics::PortBank&lt;&gt; {
public:
    using PortBank::PortBank;


    void resetAllRegisters() {
        unsigned numOfRegs = number_of_registers();
        for (unsigned i = 0; i &lt; numOfRegs; ++i) {
            std::pair&lt;size_t, simics::RegisterInterface *&gt; reg_pair = register_at_index(i);
            reg_pair.second-&gt;reset();
        }
    }

    class IP_MASK : public simics::BankRegister&lt;sme::reg&lt;simics::Register&gt; &gt; {
        public:
        using BankRegister::BankRegister;
                                            
            class IP_BIT : public simics::RegisterField&lt;sme::field&lt;simics::Field&gt; &gt; {
                public:
                using RegisterField::RegisterField;
            };
                                            
        public:
        
        IP_BIT IP_BIT {                                
            this, simics::Name("IP_BIT"),                 
            simics::Description("Mask bit for IP selection"),
            simics::Offset(15), 
            simics::BitWidth(1)
        };
        
    };

    class STATE_CONTROL : public simics::BankRegister&lt;sme::reg&lt;simics::Register&gt; &gt; {
        public:
        using BankRegister::BankRegister;
                                            
            class COMMAND : public simics::RegisterField&lt;sme::field&lt;simics::Field&gt; &gt; {
                public:
                using RegisterField::RegisterField;
            };

            class EXECUTE : public simics::RegisterField&lt;sme::field&lt;simics::Field&gt; &gt; {
                public:
                using RegisterField::RegisterField;
            };

        public:
        
        COMMAND COMMAND {                                
            this, simics::Name("COMMAND"),                 
            simics::Description("When set, requests IPs move into this state"),
            simics::Offset(0), 
            simics::BitWidth(5)
        };

        EXECUTE EXECUTE {                                
            this, simics::Name("EXECUTE"),                 
            simics::Description("sets command to be executed upon..."),
            simics::Offset(7), 
            simics::BitWidth(1)
        };
    };

    class FSM_ACTIONS : public simics::BankRegister&lt;sme::reg&lt;simics::Register&gt; &gt; {
        public:
        using BankRegister::BankRegister;
                                            
            class GATE_CLK : public simics::RegisterField&lt;sme::field&lt;simics::Field&gt; &gt; {
                public:
                using RegisterField::RegisterField;
            };
                                            
        public:
        
        GATE_CLK GATE_CLK {
            this, simics::Name("GATE_CLK"),                 
            simics::Description("1: Gate output clock, 0: No action"),
            simics::Offset(16), 
            simics::BitWidth(1)
        };
        
    };

    class IP_SLEEP : public simics::BankRegister&lt;sme::reg&lt;simics::Register&gt; &gt; {
        public:
        using BankRegister::BankRegister;
                                            
            class IP_BIT : public simics::RegisterField&lt;sme::field&lt;simics::Field&gt; &gt; {
                public:
                using RegisterField::RegisterField;
            };
                                            
        public:
        
        IP_BIT IP_BIT {                                
            this, simics::Name("IP_BIT"),                 
            simics::Description("IP_BIT will go to sleep"),
            simics::Offset(15), 
            simics::BitWidth(1)
        };
        
    };

    class DRIVER_FSM_STATE_IP_1 : public simics::BankRegister&lt;sme::reg&lt;simics::Register&gt; &gt; {
        public:
        using BankRegister::BankRegister;
                                            
            class state : public simics::RegisterField&lt;sme::field&lt;simics::Field&gt; &gt; {
                public:
                using RegisterField::RegisterField;
            };

        public:
        
        state state {                                
            this, simics::Name("state"),                 
            simics::Description("IP driver FSM Status"),
            simics::Offset(0), 
            simics::BitWidth(5)
        };
    };

    class DRIVER_FSM_STATE_IP_2 : public simics::BankRegister&lt;sme::reg&lt;simics::Register&gt; &gt; {
        public:
        using BankRegister::BankRegister;
                                            
            class state : public simics::RegisterField&lt;sme::field&lt;simics::Field&gt; &gt; {
                public:
                using RegisterField::RegisterField;
            };

        public:
        
        state state {                                
            this, simics::Name("state"),                 
            simics::Description("IP 2 driver FSM Status"),
            simics::Offset(0), 
            simics::BitWidth(5)
        };
    };

    IP_MASK ip_mask {
        this, simics::Name("ip_mask"),
        simics::Description("Mask to target specific IP."),
        simics::Offset(0xddc),
        simics::ByteSize(4),
        simics::InitValue(0x0)
    };
                            
    STATE_CONTROL state_control {
        this, simics::Name("state_control"),
        simics::Description("desired state"),
        simics::Offset(0xde4),
        simics::ByteSize(4),
        simics::InitValue(0x0)
    };

    FSM_ACTIONS fsm_actions {
        this, simics::Name("fsm_actions"),
        simics::Description("fsm actions"),
        simics::Offset(0xb4),
        simics::ByteSize(4),
        simics::InitValue(0x0)
    };

    IP_SLEEP ip_sleep {
        this, simics::Name("ip_sleep"),
        simics::Description("sets which IP will go to sleep."),
        simics::Offset(0x1054),
        simics::ByteSize(4),
        simics::InitValue(0x0)
    };
                            
    DRIVER_FSM_STATE_IP_1 driver_fsm_state_ip_1 {
        this, simics::Name("driver_fsm_state_ip_1"),
        simics::Description("Read IP 1 Driver FSM state"),
        simics::Offset(0xf44),
        simics::ByteSize(4),
        simics::InitValue(0x0)
    };

    DRIVER_FSM_STATE_IP_2 driver_fsm_state_ip_2 {
        this, simics::Name("driver_fsm_state_ip_2"),
        simics::Description("Read IP 2 Driver FSM state"),
        simics::Offset(0xf4c),
        simics::ByteSize(4),
        simics::InitValue(0x0)
    };

};

// BankPort container class
class FsmRegBankPort : public simics::BankPort&lt;FsmRegDevice&gt; {
    public:
    using BankPort&lt;FsmRegDevice&gt;::BankPort;

    FsmRegBank bank {
        this, simics::Description("FSM Register bank")
    };
};
</code></pre>
<h4 id="recommended-source-structure"><a href="#recommended-source-structure">13.4.3 Recommended Source Structure</a></h4>
<p>There are a few additional features which need to be implemented such as save/restore of the state which requires extra work outside of the standard Boost SML definition.  There is also some implications with scoping of callbacks which must be considered.</p>
<ul>
<li>
<p>Declaration - <code>device_declaration.hpp</code> - Declaration of the event &amp; state types, state machine, data &amp; callback target</p>
</li>
<li>
<p>Definition - <code>SM_device_declaration.hpp</code> - Brings the callbacks, state machine instantiation, and get/set state capabilities into a single class for use by developer.</p>
</li>
<li>
<p>Developer Source - As defined above, is the source that the developer should be concerned with, knowing the state machine is declared and defined correctly.</p>
</li>
</ul>
<h5 id="declaration"><a href="#declaration">13.4.3.1 Declaration</a></h5>
<p>The code below defines an enumeration of states, and TYPES for all events and states of the state machine definition.</p>
<pre><code class="language-C">#include &lt;boost/sml.hpp&gt;
#include &lt;iostream&gt;
#include &lt;stdint.h&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;cassert&gt;

namespace sml = boost::sml;

#ifndef __IP_DECLARATION_HPP__
#define __IP_DECLARATION_HPP__

class SM_DEFINITION;

namespace IP
{

struct SM {
    enum E { // This E is a designation for ENUMERATION, not event!!!
        START = 0,
        IP_ON_BUSY,
        DEASSERT_RESET,
        IP_READY_2_RESET,
        IP_RESET_COMPLETE,
        SEND_RESET_PREP,
        WAIT_FOR_ACKNOWLEDGE,
        SEND_POWER_CYCLE,
        RESTORE_IP,
        ERROR_COULD_NOT_DETECT_STATE
    };
};

// special for START state
struct E_INIT {};

// hierarchical events - used at top level and within sub sm
struct E_GOTO_ON_AVAILABLE {};
struct E_TIMER_EXPIRED {};

// top level only events
struct E_FSM_RESET_ASSERTED {};
struct E_ENTER_RESET{};

// sub sm only events
struct E_ENABLE_LOCK {};
struct E_IP_GO_TO_SLEEP {};
struct E_EXECUTE_RESET {};
struct E_RESET_PREP_SENT {};
struct E_ACKNOWLEDGE_RECEIVED {};
struct E_POWER_UP {};
struct E_LOCK_DEASSERTED {};

// states
class START;
class IP_ON_BUSY;

struct IP_IMPL; // sub state machine
class DEASSERT_RESET;
class IP_READY_2_RESET;
class IP_RESET_COMPLETE;
class SEND_RESET_PREP;
class WAIT_FOR_ACKNOWLEDGE;
class SEND_POWER_CYCLE;
class RESTORE_IP;
</code></pre>
<p>Below the type definitions a data type (for storage of interesting SM relevant data) and a bevior class (to facilitate callbacks) are provided as constructs which will be utilized by the state machine.</p>
<pre><code class="language-C">// data and behavior declaration
class behavior_t;

class data_t {
public:
    SM::E state;
    bool lock_in_effect {false};
    bool power_cycle_bypassed {false};
    behavior_t * beh;
};

class behavior_t {
public:
    data_t d;

    behavior_t() { d.beh = this; }

    // State entry / exit callbacks
    virtual void DEASSERT_RESET_on_enter() = 0;
    virtual void DEASSERT_RESET_on_exit() = 0;
    virtual void IP_RESET_COMPLETE_on_enter() = 0;
    virtual void IP_RESET_COMPLETE_on_exit() = 0;
    virtual void IP_ON_BUSY_on_enter() = 0;
    virtual void IP_ON_BUSY_on_exit() = 0;
    virtual void IP_IMPL_on_enter() = 0;
    virtual void IP_IMPL_on_exit() = 0;

    // event callbacks
    virtual void do_initialize() = 0;
    virtual void do_complete_request() = 0;
    virtual void do_deassert_reset() = 0;
    virtual void do_set_lock() = 0;
    virtual void do_send_reset_prep() = 0;
    virtual void do_no_power_cycle() = 0;
    virtual void do_cycle_power() = 0;
    virtual void do_restore_state_if_needed() = 0;
    virtual void do_trigger_timer() = 0;
    virtual void do_is_not_powering_down() = 0;
    
    // Save &amp; Restore methods
    virtual IP::SM::E get_current_state() = 0;
    virtual void set_current_state( IP::SM::E _state) = 0;

    // Accessor Methods
    std::string state_to_string( IP::SM::E _state) {
        std::string retval = "";        
        switch( _state) {
            case IP::SM::E::START:
                retval = "START";
                break;
            case IP::SM::E::IP_ON_BUSY:
                retval = "IP_ON_BUSY";
                break;
            case IP::SM::E::DEASSERT_RESET:
                retval = "DEASSERT_RESET";
                break;
            case IP::SM::E::IP_READY_2_RESET:
                retval = "IP_READY_2_RESET";
                break;
            case IP::SM::E::IP_RESET_COMPLETE:
                retval = "IP_RESET_COMPLETE";
                break;
            case IP::SM::E::SEND_RESET_PREP:
                retval = "SEND_RESET_PREP";
                break;
            case IP::SM::E::WAIT_FOR_ACKNOWLEDGE:
                retval = "WAIT_FOR_ACKNOWLEDGE";
                break;
            case IP::SM::E::SEND_POWER_CYCLE:
                retval = "SEND_POWER_CYCLE";
                break;
            case IP::SM::E::RESTORE_IP:
                retval = "RESTORE_IP";
                break;
            default:
                retval = "ERROR: COULD NOT DETECT STATE";
                break;
        }
        return( retval);
    }

    IP::SM::E string_to_state( std::string _str) {
        if( _str == "START")                        return( IP::SM::E::START);        
        else if( _str == "IP_ON_BUSY")              return( IP::SM::E::IP_ON_BUSY);        
        else if( _str == "DEASSERT_RESET")          return( IP::SM::E::DEASSERT_RESET);        
        else if( _str == "IP_READY_2_RESET")        return( IP::SM::E::IP_READY_2_RESET);        
        else if( _str == "IP_RESET_COMPLETE")       return( IP::SM::E::IP_RESET_COMPLETE);        
        else if( _str == "SEND_RESET_PREP")         return( IP::SM::E::SEND_RESET_PREP);        
        else if( _str == "WAIT_FOR_ACKNOWLEDGE")    return( IP::SM::E::WAIT_FOR_ACKNOWLEDGE);        
        else if( _str == "SEND_POWER_CYCLE")        return( IP::SM::E::SEND_POWER_CYCLE);        
        else if( _str == "RESTORE_IP")              return( IP::SM::E::RESTORE_IP);        
        else                                        return( IP::SM::E::ERROR_COULD_NOT_DETECT_STATE);        
    }
};
</code></pre>
<p>Finally the flow of the state machine is described in BOOST SML which follows a near UML style of definition and includes both sub-state machines and guards.  Notice that lambda's are used to pass the SM data reference to the events, and the actual callback is executed from the data object handler.  This keeps the definition of the state machine clear and separate from the implementation of behavior.</p>
<pre><code class="language-C">struct IP_IMPL
{
    auto operator()() const noexcept {
        using namespace sml;
        return make_transition_table(
            * state&lt;DEASSERT_RESET&gt; + on_entry&lt;_&gt; / []( data_t &amp; d) { d.beh-&gt;DEASSERT_RESET_on_enter(); }
            , state&lt;DEASSERT_RESET&gt; + event&lt;E_ENABLE_LOCK&gt; / []( data_t &amp; d) { d.beh-&gt;do_set_lock(); } = state&lt;IP_READY_2_RESET&gt;
            , state&lt;DEASSERT_RESET&gt; + sml::on_exit&lt;_&gt; / []( data_t &amp; d) { d.beh-&gt;DEASSERT_RESET_on_exit(); }

            , state&lt;IP_READY_2_RESET&gt; + event&lt;E_EXECUTE_RESET&gt; / []( data_t &amp; d) { d.beh-&gt;do_send_reset_prep(); } = state&lt;SEND_RESET_PREP&gt;
            , state&lt;IP_READY_2_RESET&gt; + event&lt;E_IP_GO_TO_SLEEP&gt; / []( data_t &amp; d) { d.beh-&gt;do_no_power_cycle(); } = state&lt;IP_RESET_COMPLETE&gt;

            , state&lt;SEND_RESET_PREP&gt; + event&lt;E_RESET_PREP_SENT&gt; = state&lt;WAIT_FOR_ACKNOWLEDGE&gt;

            , state&lt;WAIT_FOR_ACKNOWLEDGE&gt; + event&lt;E_ACKNOWLEDGE_RECEIVED&gt; / []( data_t &amp; d) { d.beh-&gt;do_cycle_power(); } = state&lt;SEND_POWER_CYCLE&gt;

            , state&lt;SEND_POWER_CYCLE&gt; + event&lt;E_POWER_UP&gt; / []( data_t &amp; d) { d.beh-&gt;do_restore_state_if_needed(); } = state&lt;RESTORE_IP&gt;

            , state&lt;RESTORE_IP&gt; + event&lt;E_LOCK_DEASSERTED&gt; / []( data_t &amp; d) { d.beh-&gt;do_trigger_timer(); } = state&lt;IP_RESET_COMPLETE&gt;

            , state&lt;IP_RESET_COMPLETE&gt; + on_entry&lt;_&gt; / []( data_t &amp; d) { d.beh-&gt;IP_RESET_COMPLETE_on_enter(); }
            , state&lt;IP_RESET_COMPLETE&gt; + sml::on_exit&lt;_&gt; / []( data_t &amp; d) { d.beh-&gt;IP_RESET_COMPLETE_on_exit(); }
        );
    }
};

const auto guard_state_IP_RESET_COMPLETE = []( const auto &amp; event, data_t &amp; d) { return( d.beh-&gt;get_current_state() == IP::SM::E::IP_RESET_COMPLETE); };

struct IP
{
    auto operator()() const noexcept {
        using namespace sml;
        return make_transition_table(

            * state&lt;START&gt; + event&lt;E_INIT&gt; / []( data_t &amp; d) {d.beh-&gt;do_initialize(); } = state&lt;IP_ON_BUSY&gt;

            , state&lt;IP_ON_BUSY&gt; + on_entry&lt;_&gt; / []( data_t &amp; d) { d.beh-&gt;IP_ON_BUSY_on_enter(); }
            , state&lt;IP_ON_BUSY&gt; + event&lt;E_ENTER_RESET&gt; / []( data_t &amp; d) { d.beh-&gt;do_complete_request(); } = state&lt;IP_ON_BUSY&gt;
            , state&lt;IP_ON_BUSY&gt; + event&lt;E_GOTO_ON_AVAILABLE&gt; / []( data_t &amp; d) { d.beh-&gt;do_deassert_reset(); } = state&lt;IP_IMPL&gt;
            , state&lt;IP_ON_BUSY&gt; + sml::on_exit&lt;_&gt; / []( data_t &amp; d) { d.beh-&gt;IP_ON_BUSY_on_exit(); }

            , state&lt;IP_IMPL&gt; + on_entry&lt;_&gt; / []( data_t &amp; d) { d.beh-&gt;IP_IMPL_on_enter(); }
            , state&lt;IP_IMPL&gt; + event&lt;E_TIMER_EXPIRED&gt; [guard_state_IP_RESET_COMPLETE] = state&lt;IP_ON_BUSY&gt;
            , state&lt;IP_IMPL&gt; + event&lt;E_FSM_RESET_ASSERTED&gt; / []( data_t &amp; d) { d.beh-&gt;do_is_not_powering_down(); } = state&lt;IP_ON_BUSY&gt;
            , state&lt;IP_IMPL&gt; + sml::on_exit&lt;_&gt; / []( data_t &amp; d) { d.beh-&gt;IP_IMPL_on_exit(); }
        );
    }
};

}

</code></pre>
<h5 id="definition"><a href="#definition">13.4.3.2 Definition</a></h5>
<p>The <code>SM_DEFINITION</code> is an extension of the <code>IP::behavior_t</code>; where the logger (optional) and state machine instance are declared.</p>
<p>To work with simics replay/stop/reverse a state machine must have a mechanism to save &amp; restore state.  The enumerstion for the state targets is utilized here with developer required methods which must be implemented for Simics.</p>
<pre><code class="language-C">class SM_DEFINITION : public IP::behavior_t {
public:
    extras::fsm_logger logger;
    sml::sm&lt; IP::IP, sml::testing, sml::logger&lt; extras::fsm_logger&gt; &gt; sm{ d, logger};

    SM_DEFINITION() {;}

    IP::SM::E get_current_state() override {
        using namespace sml;
        using namespace IP;
        IP::SM::E retval = IP::SM::E::ERROR_COULD_NOT_DETECT_STATE;
        if( sm.is( state&lt;IP_ON_BUSY&gt;))                                                  retval = IP::SM::E::IP_ON_BUSY; 
        else if( sm.is( state&lt;START&gt;))                                                  retval = IP::SM::E::START; 
        else if( sm.is( state&lt;IP_IMPL&gt;)) {
            if( sm.is&lt;decltype( state&lt;IP_IMPL&gt;)&gt;( state&lt;DEASSERT_RESET&gt;))               retval = IP::SM::E::DEASSERT_RESET; 
            else if( sm.is&lt;decltype( state&lt;IP_IMPL&gt;)&gt;( state&lt;IP_READY_2_RESET&gt;))        retval = IP::SM::E::IP_READY_2_RESET; 
            else if( sm.is&lt;decltype( state&lt;IP_IMPL&gt;)&gt;( state&lt;IP_RESET_COMPLETE&gt;))       retval = IP::SM::E::IP_RESET_COMPLETE; 
            else if( sm.is&lt;decltype( state&lt;IP_IMPL&gt;)&gt;( state&lt;SEND_RESET_PREP&gt;))         retval = IP::SM::E::SEND_RESET_PREP; 
            else if( sm.is&lt;decltype( state&lt;IP_IMPL&gt;)&gt;( state&lt;WAIT_FOR_ACKNOWLEDGE&gt;))    retval = IP::SM::E::WAIT_FOR_ACKNOWLEDGE; 
            else if( sm.is&lt;decltype( state&lt;IP_IMPL&gt;)&gt;( state&lt;SEND_POWER_CYCLE&gt;))        retval = IP::SM::E::SEND_POWER_CYCLE; 
            else if( sm.is&lt;decltype( state&lt;IP_IMPL&gt;)&gt;( state&lt;RESTORE_IP&gt;))              retval = IP::SM::E::RESTORE_IP; 
        }
        return( retval);
    }

    void set_current_state( IP::SM::E _state) override {
        using namespace sml;
        using namespace IP;
        if( _state == IP::SM::E::IP_ON_BUSY)                        sm.set_current_states( state&lt;IP_ON_BUSY&gt;);
        else if( _state == IP::SM::E::START)                        sm.set_current_states( state&lt;START&gt;);
        else {
            sm.set_current_states( state&lt;IP_IMPL&gt;);
            if( _state == IP::SM::E::DEASSERT_RESET)                sm.set_current_states&lt;decltype( state&lt;IP_IMPL&gt;)&gt;( state&lt;DEASSERT_RESET&gt;);
            else if( _state == IP::SM::E::IP_READY_2_RESET)         sm.set_current_states&lt;decltype( state&lt;IP_IMPL&gt;)&gt;( state&lt;IP_READY_2_RESET&gt;);
            else if( _state == IP::SM::E::IP_RESET_COMPLETE)        sm.set_current_states&lt;decltype( state&lt;IP_IMPL&gt;)&gt;( state&lt;IP_RESET_COMPLETE&gt;);
            else if( _state == IP::SM::E::SEND_RESET_PREP)          sm.set_current_states&lt;decltype( state&lt;IP_IMPL&gt;)&gt;( state&lt;SEND_RESET_PREP&gt;);
            else if( _state == IP::SM::E::WAIT_FOR_ACKNOWLEDGE)     sm.set_current_states&lt;decltype( state&lt;IP_IMPL&gt;)&gt;( state&lt;WAIT_FOR_ACKNOWLEDGE&gt;);
            else if( _state == IP::SM::E::SEND_POWER_CYCLE)         sm.set_current_states&lt;decltype( state&lt;IP_IMPL&gt;)&gt;( state&lt;SEND_POWER_CYCLE&gt;);
            else if( _state == IP::SM::E::RESTORE_IP)               sm.set_current_states&lt;decltype( state&lt;IP_IMPL&gt;)&gt;( state&lt;RESTORE_IP&gt;);
        }
    }

};
</code></pre>
<h5 id="developer-behavior-source"><a href="#developer-behavior-source">13.4.3.3 Developer (Behavior) Source</a></h5>
<p>Developer source is the implementation of behavior for the state machine.  Because this is a unit test (C++) the code will simply print basic messages.</p>
<pre><code class="language-C">class SM_Behavior : public SM_DEFINITION {
public:
    SM_Behavior() : SM_DEFINITION() 
    {;}

    // Developer would override callbacks here...
    // State entry / exit callbacks
    void DEASSERT_RESET_on_enter() override     { std::cout &lt;&lt; "DEASSERT_RESET ***OVERRIDDEN*** on_enter" &lt;&lt; std::endl; }
    void DEASSERT_RESET_on_exit() override      { std::cout &lt;&lt; "DEASSERT_RESET ***OVERRIDDEN*** on_exit" &lt;&lt; std::endl; }
    void IP_RESET_COMPLETE_on_enter() override  { std::cout &lt;&lt; "IP_RESET_COMPLETE ***OVERRIDDEN*** on_enter" &lt;&lt; std::endl; }
    void IP_RESET_COMPLETE_on_exit() override   { std::cout &lt;&lt; "IP_RESET_COMPLETE ***OVERRIDDEN*** on_exit" &lt;&lt; std::endl; }
    void IP_ON_BUSY_on_enter() override         { std::cout &lt;&lt; "IP_ON_BUSY ***OVERRIDDEN*** on_enter" &lt;&lt; std::endl; }
    void IP_ON_BUSY_on_exit() override          { std::cout &lt;&lt; "IP_ON_BUSY ***OVERRIDDEN*** on_exit" &lt;&lt; std::endl; }
    void IP_IMPL_on_enter() override            { std::cout &lt;&lt; "IP_IMPL ***OVERRIDDEN*** on_enter" &lt;&lt; std::endl; }
    void IP_IMPL_on_exit() override             { std::cout &lt;&lt; "IP_IMPL ***OVERRIDDEN*** on_exit" &lt;&lt; std::endl; }

    // event callbacks
    void do_initialize() override               { std::cout &lt;&lt; "EVENT_CALLBACK: ***OVERRIDDEN*** do_initialize" &lt;&lt; std::endl; }
    void do_complete_request() override         { std::cout &lt;&lt; "EVENT_CALLBACK: ***OVERRIDDEN*** do_complete_request" &lt;&lt; std::endl; }
    void do_deassert_reset() override           { std::cout &lt;&lt; "EVENT_CALLBACK: ***OVERRIDDEN*** do_deassert_reset" &lt;&lt; std::endl; }
    void do_set_lock() override                 { std::cout &lt;&lt; "EVENT_CALLBACK: ***OVERRIDDEN*** do_set_lock" &lt;&lt; std::endl; }
    void do_send_reset_prep() override          { std::cout &lt;&lt; "EVENT_CALLBACK: ***OVERRIDDEN*** do_send_reset_prep" &lt;&lt; std::endl; }
    void do_no_power_cycle() override           { std::cout &lt;&lt; "EVENT_CALLBACK: ***OVERRIDDEN*** do_no_power_cycle" &lt;&lt; std::endl; }
    void do_cycle_power() override              { std::cout &lt;&lt; "EVENT_CALLBACK: ***OVERRIDDEN*** do_cycle_power" &lt;&lt; std::endl; }
    void do_restore_state_if_needed() override  { std::cout &lt;&lt; "EVENT_CALLBACK: ***OVERRIDDEN*** do_restore_state_if_needed" &lt;&lt; std::endl; }
    void do_trigger_timer() override            { std::cout &lt;&lt; "EVENT_CALLBACK: ***OVERRIDDEN*** do_trigger_timer" &lt;&lt; std::endl; }
    void do_is_not_powering_down() override     { std::cout &lt;&lt; "EVENT_CALLBACK: ***OVERRIDDEN*** do_is_not_powering_down" &lt;&lt; std::endl; }
};
</code></pre>
<h4 id="implementing-expressions"><a href="#implementing-expressions">13.4.4 Implementing Expressions</a></h4>
<p>For this example the behavior code is written inside the expressions, but in many cases one would want more of the behavior code to exist in the behavior callbacks of the state machine.</p>
<p>Only 2 expressions are required to define the 4 state transitions based on the description in <a class="reference" href="#boost-sml-state-machine-library">13.4</a>.</p>
<p>The <code>...</code> in the code is where you would place your simics module parent type / implementations</p>
<pre><code class="language-C">class doc_example : public ::testing::Test, ... {
  public:
    virtual ~doc_example() {
        if (bank_parent) {
            delete bank_parent;
            bank_parent = nullptr;
        }
        if (bp) {
            delete bp;
            bp = nullptr;
        }
    }

	MockObject *bank_parent;
    FsmRegBankPort *bp;
    SM_Behavior        ip;

    sme::expression     ex__deassert_reset          {"ex__deassert_reset"};
    sme::expression     ex__ip_goto_sleep           {"ex__ip_goto_sleep"};
</code></pre>
<p>The <code>ex__deassert_reset</code> will define both a rising and falling edge event capture.  Technically the "process_event" methods are the only code which should exist in the execute.  Other code should be implemented in the behavior callbacks defined in section <a class="reference" href="#developer-behavior-source">13.4.3.3</a>.</p>
<pre><code class="language-C">    explicit doc_example(const std::string &amp;name = "") {
        ...
		bp = new FsmRegBankPort { bank_parent-&gt;obj() }; 

        // ex_goto_deassert_reset
        ex__deassert_reset.sensitive_to( bp-&gt;bank.state_control.EXECUTE, stage::POST_WRITE);
        ex__deassert_reset.logic( [this]() -&gt; bool {
            bool result = ( bp-&gt;bank.ip_mask.IP_BIT.get() == 1 &amp;&amp; 
                            bp-&gt;bank.state_control.COMMAND.get() == IP::SM::E::DEASSERT_RESET &amp;&amp;
                            bp-&gt;bank.state_control.EXECUTE.get() == 0x01);
            return( result);
        });

        ex__deassert_reset.rising.execute( [this]() -&gt; void {
            bp-&gt;bank.state_control.EXECUTE.set (0);             // reset control (should be a scheduled event as shown in comments below)
//            ex__deassert_reset.process( 1); // which should execute the next line in theory...
//            SIM_realtime_event( 1, &amp;process_ex_goto_deassert_reset, reinterpret_cast&lt; void *&gt;(this),  0, ex_goto_deassert_reset.name().c_str());
            ip.sm.process_event( IP::E_GOTO_ON_AVAILABLE{});    // this will change the SM current state
            bp-&gt;bank.driver_fsm_state_ip_1.state.set( ip.get_current_state()); // relay the new state for driver to read
        });

        // the falling edge can only happen if true was entered, so this is valid assumption caused by timed event
        ex__deassert_reset.falling.execute( [this]() -&gt; void {
            ip.sm.process_event( IP::E_ENABLE_LOCK{});    // this will change the SM current state
            bp-&gt;bank.driver_fsm_state_ip_1.state.set( ip.get_current_state()); // relay the new state for driver to read
        });

        // IP GOTO SLEEP as an expression        
        ex__ip_goto_sleep.sensitive_to( bp-&gt;bank.ip_sleep.IP_BIT, stage::POST_WRITE);
        ex__ip_goto_sleep.logic( [this]() -&gt; bool { 
            return((ip.get_current_state() == IP::SM::E::IP_READY_2_RESET) &amp;&amp; (bp-&gt;bank.ip_sleep.IP_BIT.get() == 1)); 
        });
        ex__ip_goto_sleep.rising.execute( [this]() -&gt; void { 
            bp-&gt;bank.ip_sleep.IP_BIT.set(0);
            ip.sm.process_event( IP::E_IP_GO_TO_SLEEP{});
            bp-&gt;bank.driver_fsm_state_ip_1.state.set( ip.get_current_state());
            // ideally this would schedule a timer before auto-returning to IP_ON_BUSY
            // flush the state &amp; ensure that the falling edge is recorded (i.e. reset)
            ex__ip_goto_sleep.evaluate(true);
        });

    }
};
</code></pre>
<p>Finally we get to the unit test code itself, which is mocking a few different styles of transitions.</p>
<pre><code class="language-C">TEST_F(doc_example, example_bank_created) {
    // GLOBAL INIT
	EXPECT_EQ(bp-&gt;bank.bank_name(), "bar");
    ip.set_current_state( IP::SM::E::START);
    EXPECT_EQ( ip.get_current_state(), IP::SM::E::START);

    // transition to state IP_ON_BUSY
    ip.sm.process_event( IP::E_INIT{});
    EXPECT_EQ( ip.get_current_state(), IP::SM::E::IP_ON_BUSY);

    // transition to state DEASSERT_RESET
    bp-&gt;bank.ip_mask.IP_BIT.write( 0x01);
    EXPECT_EQ( ip.get_current_state(), IP::SM::E::IP_ON_BUSY);
    bp-&gt;bank.state_control.COMMAND.write( IP::SM::E::DEASSERT_RESET);
    EXPECT_EQ( ip.get_current_state(), IP::SM::E::IP_ON_BUSY);
    bp-&gt;bank.state_control.EXECUTE.write( 1); // &lt;-- fire expression.rising
    EXPECT_EQ( bp-&gt;bank.driver_fsm_state_ip_1.state.get(), IP::SM::E::DEASSERT_RESET);
    EXPECT_EQ( ip.get_current_state(), IP::SM::E::DEASSERT_RESET);

    // verify execute cleared but evaluation status unchanged
    EXPECT_EQ( bp-&gt;bank.state_control.EXECUTE.get(), 0);
    EXPECT_EQ( ex__deassert_reset.last_state(), true);
    EXPECT_EQ( ex__deassert_reset.evaluate(), false);
    EXPECT_EQ( ex__deassert_reset.last_state(), true);
    EXPECT_EQ( ip.get_current_state(), IP::SM::E::DEASSERT_RESET);

    // simulate a timed event                          
    ex__deassert_reset.on_sensitivity(); // execute ex__deassert_reset.falling

    // that should have triggered a transition to IP_READY_2_RESET
    EXPECT_EQ( ip.get_current_state(), IP::SM::E::IP_READY_2_RESET);

    // now simulate a go to sleep (short path)
    bp-&gt;bank.ip_sleep.IP_BIT.write( 1);
    EXPECT_EQ( ip.get_current_state(), IP::SM::E::IP_RESET_COMPLETE);

    {    // simulate a timer expiring
        ip.sm.process_event( IP::E_TIMER_EXPIRED{});
    }

    EXPECT_EQ( ip.get_current_state(), IP::SM::E::IP_ON_BUSY);
}
</code></pre>
<!--- end documentation from C++ extension --->
<h2 id="migration-guide-from-c-api-v1"><a href="#migration-guide-from-c-api-v1">14 Migration Guide from C++ API V1</a></h2>
<p>From a device model's point of view there are only a few incompatible changes between Simics C++ API v1 and v2 to consider. Migration should thus be straight forward and trivial.</p>
<p>Here is the list of known changes that can cause problems when migrating from Simics C++ API v1:</p>
<ul>
<li>The C++ compiler must support C++14</li>
<li>Set <code>USE_CC_API</code> to 2 in the Makefile.</li>
<li>The header to include has been changed to <code>simics/cc-api.h</code> instead of <code>simics/c++/device-api.h</code>.</li>
<li>A model-defined class inherits from the <code>simics::ConfObject</code> class instead of <code>simics::SimicsObject</code>.</li>
<li>The C++ class constructor argument type is changed to <code>simics::ConfObjectRef</code> instead of <code>simics::SimicsObjectRef</code>.</li>
<li>Method <code>simics_obj</code> of <code>ConfObject</code> has been renamed to <code>obj</code>.</li>
<li>Use <code>make_class</code> to register a class. The parameters are same as the previous <code>ClassDef</code>.</li>
<li>Register Simics attribute with <code>simics::Attribute</code>.</li>
<li>Register Simics class attribute with <code>simics::ClassAttribute</code></li>
<li>Add attributes, interfaces, port objects and log groups via the <code>add</code> method.</li>
<li>Interfaces are registered with the help of an interface info class.</li>
<li>Port interface is no longer supported. Use port object instead.</li>
<li>The model-defined class is recommended to register its property through its static function <code>init_class</code>, but can use the old way of registering everything in the <code>init_local</code> static function</li>
<li>The state variable set function, or attribute setter, should return <code>void</code> instead of <code>simics::SetResult</code>. If an error occurs during the setting process, a C++ <code>runtime_error</code> exception should be thrown.</li>
<li>There is no need for <code>state_mapper</code> anymore. Any existing <code>state_mapper</code> is dead code and can be removed.</li>
</ul>

<div class="chain">
<span></span>
</div>