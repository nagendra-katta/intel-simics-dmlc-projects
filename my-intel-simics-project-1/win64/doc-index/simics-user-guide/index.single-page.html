<!doctype html>
<meta charset=utf8>
<link rel=stylesheet href="../simics.css">
<title>Simics User's Guide</title>

<section class="page" id="index.html"><h1 id="index.html:simics-user-s-guide"><a href="#index.html:simics-user-s-guide">Simics User's Guide</a></h1>
</section><section class="page" id="introduction.html"><h1 id="introduction.html:introduction"><a href="#introduction.html:introduction">1 Introduction</a></h1>
</section><section class="page" id="afos-introduction.html"><h1 id="afos-introduction.html:introduction"><a href="#afos-introduction.html:introduction">1.1 Introduction</a></h1>
<p>This document describes the features of the Intel® Simics® simulator, with in-depth explanations on their usage and implementation. A gentler introduction is provided in the <a href="../getting-started/index.html">Getting Started</a>.</p>
<p>The first chapters cover various aspects of Simics, from its command-line and scripting to the way simulation can be inspected and manipulated. The second part of the manual is dedicated to software debugging, both with Simics stand-alone or when using it as a back-end for other debuggers, such as Intel® System Debugger or GDB.</p>
<p>A simple virtual platform called Quick-Start Platform (QSP) is available to all users. This platform is used in many examples in the documentation and is intended to help users users familiarize themselves with many features of the Intel Simics simulator.</p>
</section><section class="page" id="simulation-concepts.html"><h1 id="simulation-concepts.html:simulation-concepts"><a href="#simulation-concepts.html:simulation-concepts">1.2 Simulation Concepts</a></h1>
<h2 id="simulation-concepts.html:the-limits-of-simulation"><a href="#simulation-concepts.html:the-limits-of-simulation">1.2.1 The Limits of Simulation</a></h2>
<p>Simics is a system-level instruction set simulator. This means that:</p>
<ul>
<li>Simics models the target system at the level of individual instructions, executing them one at a time.</li>
<li>Simics models the binary interface to hardware in sufficient detail that any software that runs on the real hardware will also run on Simics.</li>
</ul>
<p>In practice, what this means is that there is no code that is too "low-level"—Simics can run, and debug, any kind of software: firmware, hardware drivers, operating systems, user-level applications, whatever. There are some caveats, though:</p>
<ul>
<li>
<p>Simics's model of time is rather simple; for example, it assumes by default that all instructions take the same amount of time to run. It is not difficult to write a program that uses this fact to detect the difference between Simics and real hardware. However, this is seldom a problem with real-world software.</p>
<p>You can read more about Simics and time in the <a href="../understanding-simics-timing/index.html">Understanding Simics Timing</a> application note.</p>
</li>
<li>
<p>The hardware models must be detailed enough. Models of nontrivial pieces of hardware do not typically model all functions and details of that hardware, so it is possible to write a program that detects the difference between Simics and real hardware by probing unimplemented functions. However, any given piece of software can be accommodated by extending the hardware models to cover the missing functions.</p>
<p>You can read more about hardware modeling in the <a href="../model-builder-user-guide/index.html">Model Builder User's Guide</a>.</p>
</li>
</ul>
<h2 id="simulation-concepts.html:non-intrusive-inspection-and-debugging"><a href="#simulation-concepts.html:non-intrusive-inspection-and-debugging">1.2.2 Non-intrusive Inspection and Debugging</a></h2>
<p>Simics has powerful built-in inspection and debugging facilities. These include:</p>
<ul>
<li>Inspecting registers, memory, and hardware state.</li>
<li>Modifying register and memory contents, and hardware state.</li>
<li>Setting (and triggering) breakpoints and watchpoints.</li>
<li>Powerful scripting support for all of this.</li>
</ul>
<p>Because these are implemented in the simulator, no debugging software needs to be on the target at all. As a result, the debugging machinery is completely invisible to the target (and thus to any software running on it).</p>
<h2 id="simulation-concepts.html:simulated-time"><a href="#simulation-concepts.html:simulated-time">1.2.3 Simulated Time</a></h2>
<p>One of the most powerful properties of full-system simulation is that time inside the simulation and time in the real world are two completely different things. This brings a number of substantial benefits:</p>
<ul>
<li>You can pause the simulation at any time, and the software running in the simulation simply <em>cannot</em> detect this. This allows you to inspect (and optionally modify) the state even at points where real hardware would be unable to stop.</li>
<li>You can save the state of the simulation to disk (this is called a <em>checkpoint</em>), and start again from that point at any time, any number of times.</li>
<li>The simulation is completely deterministic. Every time you start from the same state (such as a checkpoint), the <em>exact</em> same thing will happen. This can be tremendously useful when hunting down certain types of bugs.</li>
</ul>
<p>These advantages apply to the entire simulated system, whether it is a single target machine or an entire network.</p>
</section><section class="page" id="feature-overview.html"><h1 id="feature-overview.html:feature-overview"><a href="#feature-overview.html:feature-overview">2 Feature Overview</a></h1>
</section><section class="page" id="startupoptions.html"><h1 id="startupoptions.html:using-simics-from-the-command-line"><a href="#startupoptions.html:using-simics-from-the-command-line">2.1 Using Simics from the Command Line</a></h1>
<p>This chapter describes command line options accepted by Simics.</p>
<p>Even on Windows hosts, running Simics from the command line is useful. For example, when running automatic test scripts, profiling or benchmarking. Whole test sessions can be automated using the CLI or Python, and executed directly from the Window command shell.</p>
<p>Below is an example on how Simics can be started from the command line using a Simics project.</p>
<div class="dl">
<ul>
<li>
<p><span class="term" id="startupoptions.html:dt:windows"><a href="#startupoptions.html:dt:windows">Windows</a></span><br>
Run the <code>simics.bat</code> script in your project directory.</p>
<pre><code>[project]&gt; simics.bat targets\qsp-x86\firststeps.simics
</code></pre>
</li>
<li>
<p><span class="term" id="startupoptions.html:dt:linux"><a href="#startupoptions.html:dt:linux">Linux</a></span><br>
Run the <code>./simics</code> script in your project directory.</p>
<pre><code>joe@computer:[project]$ ./simics targets/qsp-x86/firststeps.simics
</code></pre>
</li>
</ul>
</div>
<p>Simics can also be started by running a similar start script in the <code>[simics]\bin</code> directory (<code>[simics]/bin</code> on Linux). This will run Simics without a project, and is usually not recommended.</p>
<p>This will run the <code>firststeps.simics</code> script, which will start the <code>QSP-x86</code> machine using its default configuration.</p>
<p>To quit the Simics shell you can type <code>quit</code> at the Simics prompt.</p>
<p>The full set of command line options are documented in the <a href="../rm-base/simics.html">simics</a> section in the <a href="../rm-base/index.html">Simics Reference Manual</a>.</p>
</section><section class="page" id="cli.html"><h1 id="cli.html:the-command-line-interface"><a href="#cli.html:the-command-line-interface">2.2 The Command Line Interface</a></h1>
<p>The Simics Command Line Interface (CLI) is an advanced text based user interface with built-in help system, context sensitive tab-completion, and scripting support (both built-in and for use with Python). It is provided as part of Simics.</p>
<p>If Simics graphical user interface (GUI) is used, the CLI is accessible via the Simics Control window (<code>Tools → Command Line Window</code>). When running Simics without a GUI, the CLI is accessible directly at the command line/shell where Simics is started.</p>
<h2 id="cli.html:invoking-commands"><a href="#cli.html:invoking-commands">2.2.1 Invoking Commands</a></h2>
<p>Commands are invoked by typing them at the command line followed by their arguments. The synopsis part of a command documentation explains how to execute a command (you can see many examples in the reference manuals). Here are two examples:</p>
<div class="dl">
<ul>
<li><span class="term" id="cli.html:dt:synopsis"><a href="#cli.html:dt:synopsis"><strong>SYNOPSIS</strong></a></span><br>
<code>command1</code> <em>-x</em> <em>-y</em> <em>-small</em> [<strong>cpu-name</strong>] <strong>address</strong> (<strong>size</strong>|<strong>name</strong>)</li>
</ul>
</div>
<div class="dl">
<ul>
<li><span class="term" id="cli.html:dt:synopsis-2"><a href="#cli.html:dt:synopsis-2"><strong>SYNOPSIS</strong></a></span><br>
<code>command2</code> <strong>files</strong> ...</li>
</ul>
</div>
<p>Arguments starting with a hyphen are flags and are always optional. Flags can be more than one character long, so it is <em>not</em> possible to write <em>-xy</em> for <em>-x -y</em>. The order of the flags is not significant and they can appear anywhere in the argument list.</p>
<p>Arguments enclosed within square brackets are optional; in the example above, it is not necessary to specify <em>cpu-name</em>, but <em>address</em> is required. The last argument to <code>command1</code> is either a size or a name, but not both. Such arguments are called <em>polyvalues</em> and can be of different types. Size and name are called sub-arguments.</p>
<p>If an argument is followed by three dots as the file argument in <code>command2</code> it indicates that the argument can be repeated one or more times.</p>
<p>The type of the arguments; e.g., whether they are integers or strings, should be evident from their names. For example, <em>size</em> should be an integer and <em>name</em> a string if not documented otherwise.</p>
<p>Integers are written as a sequence of digits beginning with an optional minus character for negative numbers. Hexadecimal numbers can be written by prefixing them with <code>0x</code>, octal numbers with <code>0o</code>, and binary numbers with <code>0b</code>. Integers may contain "_" characters to make them easier to read. They are ignored during parsing. For example:</p>
<pre><code class="language-simics">simics&gt; <strong>170_000</strong>
170000
simics&gt; <strong>0xFFFF_C700</strong>
4294952704
</code></pre>
<p>Strings are written as is or within double quotes if they contain spaces or begin with a non-letter. Within double quotes, a backslash (<code>\</code>) is an escape character, which can be used to include special characters in the string.</p>
<p>The supported escape sequences are the usual C ones: <code>\n</code> for newline, <code>\t</code> for tab, <code>\033</code> for the octal ASCII character 33 (27 decimal) escape, etc. <code>\</code> followed by one, two or three octal digits, or <code>\x</code> followed by exactly two hexadecimal digits is the corresponding byte value.</p>
<p><code>\u</code> followed by exactly four hexadecimal digits is the corresponding Unicode character. CLI strings are in the current version of Simics always stored in their UTF-8 encoding, which means that a single <code>\u</code> character can be represented as several bytes in the CLI string. As this is expected to change in a future version of Simics, do not rely on this functionality.</p>
<pre><code class="language-simics">simics&gt; <strong>echo no_quotes_needed</strong>
no_quotes_needed
simics&gt; <strong>echo "first line\nsecond line"</strong>
first line
second line
simics&gt; <strong>echo "Two As: \101 \x41, and a micro sign: \u00b5"</strong>
Two As: A A, and a micro sign: µ
</code></pre>
<div class="note">
<p>On a <strong>Windows</strong> machine, strings used as paths to files can be written in several different ways. If the path does not contain any blank spaces, it can be written without quotes, using backslashes to separate the directories in the path, like <code>C:\temp\file.txt</code>. If the path contains spaces, it has to be written within quote characters, and the directory separators have to be written using double backslashes. This is due to the way that the Simics command line uses backslashes to generate special characters like newline and tab. Such a path would look like <code>"C:\\Users\\joe\\Documents\\file.txt"</code>.</p>
</div>
<p>Here are some possible invocations of the commands above:</p>
<pre><code class="language-simics">simics&gt; <strong>command1 -small board.mb.cpu0.core[0][0] 0x7fff_c000 14 -y</strong>
simics&gt; <strong>command1 0x7fffc000 foo</strong>
simics&gt; <strong>command1 -x "Pentium 4" 0x7fff_c000 -8</strong>
simics&gt; <strong>command2 "/tmp/txt" "../bootdisk" floppy</strong>
</code></pre>
<p>In the first example <code>cpu-name</code> is passed as the string <code>board.mb.cpu0.core[0][0]</code> and <code>size</code> as the integer 14. In the second invocation <code>cpu-name</code> has been omitted and <code>name</code> is set to the string <code>foo</code>. The third example illustrated the use of a string containing a space. In all <code>command1</code> examples the address is set to the hexadecimal value <code>0x7fffc000</code>. <code>command2</code> takes a list of at least 1 string.</p>
<p>A few commonly used commands have aliases. For example, it is possible to write <code>c</code> for <code>continue</code> and <code>si</code> for <code>step-instruction</code> for example. Command aliases are documented with their corresponding command in the <a href="../rm-base/rm-cmds-chapter.html">Simics Reference Manual</a>.</p>
<p>Parenthesis can be used to break a command with its arguments across multiple lines. In the console, the prompt will change to <code>.......</code> for code spanning more than one line. The example shows that use case, as well as how parenthesis are used to encompass expressions.</p>
<pre><code class="language-simics">simics&gt; <strong>(echo 10
....... + (20 - 5)
....... + (max 4 7))</strong>
</code></pre>
<h3 id="cli.html:how-are-arguments-resolved"><a href="#cli.html:how-are-arguments-resolved">2.2.1.1 How are Arguments Resolved?</a></h3>
<p>Simics tries to match the provided arguments in same the order as they appear in the synopsis. If the type of the next argument is identical to what is typed at the command line, the argument will match. If there is a mismatch and the argument is optional, the argument will be skipped and the next argument will be matched, and so on. If a mismatching argument is not optional, the interpreter will fail and explain what it expected. For polyvalues, the argument will match if one of its sub-arguments matches.</p>
<p>There are situations when this method is not sufficient. For example, when two arguments both have the same type and are optional, there is no way to know which argument to match if only one is given. This is resolved by naming the arguments: <code>arg-name=value</code>. For example <code>command1</code> in the example above can be invoked like this:</p>
<pre><code class="language-simics">simics&gt; <strong>command1 size=32 -y address = 0xf000 -small cpu-name=board.mb.cpu0.core[0][0]</strong>
</code></pre>
<p>Thus there is no ambiguity in what is meant and in fact this is the only way to specify a polyvalue with sub-arguments of the same type. Note also that named arguments can be placed in any order.</p>
<h3 id="cli.html:referring-to-simics-objects"><a href="#cli.html:referring-to-simics-objects">2.2.1.2 Referring to Simics Objects</a></h3>
<p>Many Simics commands accept configuration object references as arguments. An object reference is simply a string which contains the fully qualified name of the object. Simics provides a hierarchical namespace for objects. The fully qualified name is similar to a file system path, but with the parts separated by dots. For example, the fully qualified name of <code>cpu0</code> in the <code>system0</code> namespace is <code>system0.cpu0</code>.</p>
<h3 id="cli.html:namespace-commands"><a href="#cli.html:namespace-commands">2.2.1.3 Namespace Commands</a></h3>
<p>Configuration objects (such as devices or CPUs) that define user commands usually place them in a separate namespace. The namespace is the fully qualified name of the object. Interfaces may also define commands, in which case all objects implementing these interfaces will inherit the commands in their own namespace.</p>
<p>Namespace commands are invoked by typing the fully qualified name of the object, followed by a dot and the command name: <em>system</em>.<em>component</em>.<em>object</em>.<em>command</em>, e.g.,</p>
<pre><code class="language-simics">simics&gt; <strong>system0.board0.cache0.print-status</strong>
</code></pre>
<p>All namespace commands are listed in the Simics reference manuals for the class or interface they belong to.</p>
<p>When using large configurations with a hierarchical structure of components and objects it can be inconvenient to type the fully qualified name all the time when invoking namespace commands. You can than use the <code>change-namespace</code> command (alias <code>cn</code>) to set a current namespace just like navigating in a file system with the cd command. From the current namespace you can refer to objects with a relative name, for example:</p>
<pre><code class="language-simics">simics&gt; <strong>cn system0.board0</strong>
simics:system0.board0&gt; cache0.print-status
</code></pre>
<p>Note that the Simics prompt changes to reflect the new position in the hierarchy. You can only change the current namespace to other components. It would have been illegal to do:</p>
<pre><code class="language-simics">simics&gt; <strong>cn system0.board0.cache0</strong>
system0.board0.cache0 is not a component
</code></pre>
<p>Cache0 is not a component, it is an object located in the cache0 slot (see <a class="reference" href="#configuration.html:components">2.4.4</a> and <a class="reference" href="#configuration.html:object-name">2.4.5</a> for more information on how objects are named and referenced).</p>
<p>To go "up" one level in the hierarchy you can type <code>cn ..</code>:</p>
<pre><code class="language-simics">simics:system0.board0&gt; cn ..
simics:system0&gt;
</code></pre>
<p>You can still refer to other components relative to the root by writing a dot before the fully qualified name, e.g.:</p>
<pre><code class="language-simics">simics:system0&gt; .system1.cpu0.ptime
processor     steps  cycles  time [s]
system1.cpu0  14545   14545     0.000
</code></pre>
<p>The command <code>current-namespace</code> is provided to get the current namespace and can be used in scripts to save a location in a CLI variable:</p>
<pre><code class="language-simics">simics:system0&gt; current-namespace
.system0
simics:system0&gt; $location = (current-namespace)
simics:system0&gt; cn ..
simics&gt; <strong>cn $location</strong>
simics:system0&gt;
</code></pre>
<p>See section <a class="reference" href="#script-support-in-simics.html">2.3</a> for more information on Simics scripting and CLI variables.</p>
<h3 id="cli.html:expressions"><a href="#cli.html:expressions">2.2.1.4 Expressions</a></h3>
<p>The CLI allows expressions to be evaluated, for example:</p>
<pre><code class="language-simics">simics&gt; <strong>print -x 2*(0x3e + %cr0) + %dx</strong>
</code></pre>
<p>The precedence order of the operators is as follows (highest first):</p>
<table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td><code>$</code></td><td>variable access</td></tr>
<tr><td><code>%</code></td><td>register access</td></tr>
<tr><td><code>[]</code></td><td>list indexing</td></tr>
<tr><td><code>-&gt;</code></td><td>attribute access</td></tr>
<tr><td><code>pow</code></td><td>power of</td></tr>
<tr><td><code>~</code></td><td>bitwise not</td></tr>
<tr><td><code>*, /, %</code></td><td>multiplication, division, modulo</td></tr>
<tr><td><code>+, -</code></td><td>addition, subtraction</td></tr>
<tr><td><code>&lt;&lt;, &gt;&gt;</code></td><td>left, right shift</td></tr>
<tr><td><code>&amp;</code></td><td>bitwise and</td></tr>
<tr><td><code>^</code></td><td>bitwise xor</td></tr>
<tr><td>`</td><td>`</td></tr>
<tr><td><code>&lt;, &lt;=, ==, !=, &gt;=, &gt;</code></td><td>comparison</td></tr>
<tr><td><code>not</code></td><td>boolean not</td></tr>
<tr><td><code>and</code></td><td>boolean and</td></tr>
<tr><td><code>or</code></td><td>boolean or</td></tr>
</tbody></table>
<p>Parentheses can be used to override the priorities. Commands which return values can also be used in expressions if they are enclosed within parentheses:</p>
<pre><code class="language-simics">simics&gt; <strong>print -x (board.mb.cpu0.core[0][0].read-reg cr0)</strong>
</code></pre>
<p>Values can be saved in variables for later use. You set a variable by simply giving an assignment command such as <code>$var = 15</code>. You can also store a command in a variable such as <code>$my_read_reg =    board.mb.cpu0.core[0][0].read-reg</code> which is different from storing the return value from a command <code>$value_cr0 =    (board.mb.cpu0.core[0][0].read-reg cr0)</code>.</p>
<h3 id="cli.html:interrupting-commands"><a href="#cli.html:interrupting-commands">2.2.1.5 Interrupting Commands</a></h3>
<div class="dl">
<ul>
<li>
<p><span class="term" id="cli.html:dt:gui"><a href="#cli.html:dt:gui">GUI</a></span><br>
Use the <code>stop</code> command at the <code>running&gt;</code> prompt or the <em>stop</em> button in <strong>Simics Control window</strong>.</p>
</li>
<li>
<p><span class="term" id="cli.html:dt:cli-without-gui"><a href="#cli.html:dt:cli-without-gui">CLI without GUI</a></span><br>
Any command which causes the simulation to advance can be interrupted by typing <code>Ctrl-C</code>. The simulator will gracefully stop and prompt for a new command. If Simics hangs for some reason, possibly due to some internal error, you can usually force a return to the command line by pressing <code>Ctrl-C</code> two or more times in a row.</p>
  <div class="note">
<p>Pressing <code>Ctrl-C</code> several times may damage some internal state in the simulator so should be used as a last resort.</p>
  </div>
</li>
</ul>
</div>
<h2 id="cli.html:tab-completion"><a href="#cli.html:tab-completion">2.2.2 Tab Completion</a></h2>
<p>The command line interface has a tab-completion facility. It works not only on commands but on their arguments as well. The philosophy is that the user should be able to press the tab key when uncertain about what to type, and Simics should fill in the text or list alternatives.</p>
<div class="note">
<p>Tab completion on a <strong>Windows</strong> host does not work when running in a Cygwin terminal, but only from the graphical user interface or from a Windows command line console.</p>
</div>
<p>For example <code>com</code>&lt;tab&gt; will expand to the command beginning with <code>com</code> or list all commands with that prefix, if there is not a unique such command. Similarly, <code>disassemble </code>&lt;tab&gt; will display all arguments available for the command. In this case Simics will write:</p>
<pre><code>address =   bytes =   count =   cpu-name =
</code></pre>
<p>to indicate that these alternatives for arguments exists. Typing <code>disassemble cp</code>&lt;tab&gt; will expand to <code>disassemble    cpu-name = </code> and a further tab will fill in the name of the CPU that is defined (or list all of them).</p>
<h2 id="cli.html:help-system"><a href="#cli.html:help-system">2.2.3 Help System</a></h2>
<p>The most useful Simics commands are grouped into categories. To list these categories, just type <code>help</code> at the command prompt. The list should look like this:</p>
<pre><code class="language-simics">simics&gt; <strong>help</strong>
[...]
Type help category to list the commands for a specific category. Here is a list
of command categories:

  Breakpoints    Disks      Inspection       Modules      Probes      Registers
  CLI            Execution  Instrumentation  Networking   Processors
  Components     Files      Logging          Notifiers    Profiling
  Configuration  Help       Matic            Parameters   Python
  Debugging      Image      Memory           Performance  Recording
[...]
</code></pre>
<p>Note that since Simics's configuration can change between sessions and even dynamically through the loading of modules, the list of commands and command categories may look different.</p>
<p>Type <code>help category</code> for a list of commands, e.g., <code>help Help</code> will list all commands belonging to that category:</p>
<pre><code class="language-simics">simics&gt; <strong>help category:Help</strong>
Commands available in the "Help" category:

api-help           get API help
api-search         search API help
copyright          print full Simics copyright information
get-command-args   get list of command arguments
help               help command
help-search        search for text in documentation
license            print Simics license
list-attributes    list all attributes
list-commands      list CLI commands
release-notes      display product release notes
version            display Simics version
</code></pre>
<p>Type <code>help command</code> to print the documentation for a specific command.</p>
<p>The <code>help</code> command can do much more than printing command documentation: it gives you access to nearly all Simics documentation about commands, classes, modules, interfaces, API types and functions, haps and more according to the configuration loaded in the simulator. All documentation is also available in the reference manuals.</p>
<p>Here are some more examples of usage of the <code>help</code> command:</p>
<pre><code class="language-simics">simics&gt; <strong>help print-time</strong>
[... print-time command documentation ...]

simics&gt; <strong>help board.mb.cpu0.core[0][0].disassemble</strong>
[... &lt;processor_info&gt;.disassemble command documentation ...]

simics&gt; <strong>help &lt;processor_info&gt;.disassemble</strong>
[... &lt;processor_info&gt;.disassemble command documentation ...]

simics&gt; <strong>help board.mb.cpu0.core[0][0]</strong>
[... &lt;x86QSP1&gt; class documentation ...]

simics&gt; <strong>help x86QSP1</strong>
[... &lt;x86QSP1&gt; class documentation ...]

simics&gt; <strong>help processor_info</strong>
[... &lt;processor_info&gt; interface documentation ...]

simics&gt; <strong>help board.mb.cpu0.core[0][0].freq_mhz</strong>
[... &lt;x86QSP1&gt;.freq_mhz attribute documentation ...]

simics&gt; <strong>help x86QSP1.freq_mhz</strong>
[... &lt;x86QSP1&gt;.freq_mhz attribute documentation ...]

simics&gt; <strong>help Core_Exception</strong>
[... Core_Exception hap documentation ...]

simics&gt; <strong>help SIM_get_mem_op_type</strong>
[... SIM_get_mem_op_type() function declaration ...]

simics&gt; <strong>help x86-intel64-turbo</strong>
[... x86-intel64-turbo module documentation ...]
</code></pre>
<p>When a name matches several help topics (for example, a command and an attribute, or a module and a class), <code>help</code> will print out the first topic coming in this order: command categories, commands, classes, interfaces, haps, modules, attributes, API functions and symbols. It will also inform you at the end of the documentation output that other topics were matching your search:</p>
<pre><code class="language-simics">simics&gt; <strong>load-module NS16450</strong>
simics&gt; <strong>help NS16450</strong>
[... NS16450 class documentation ...]
     
Note that your request also matched other topics:
  module:NS16450
</code></pre>
<p>If you type <code>help module:NS16450</code>, the module documentation will be printed instead:</p>
<pre><code class="language-simics">simics&gt; <strong>help module:NS16450</strong>
[... NS16450 module documentation ...]
</code></pre>
<p>You can use specifiers like <code>module:</code> or <code>class:</code> at any time. It will also allow the <code>help</code> command to provide you with better tab-completion, since only items in the selected category of documentation will be proposed. The following specifiers are available: <code>object:</code>, <code>class:</code>, <code>command:</code>, <code>attribute:</code>, <code>interface:</code>, <code>module:</code>, <code>api:</code>, <code>hap:</code> and <code>category:</code>.</p>
<div class="note">
<p>By default, <code>help</code> does not propose tab-completion for modules and API symbols, because they tend not to be the most searched for and would clutter the tab-completion propositions unnecessarily. You can get tab-completion for those by specifying <code>module:</code> or <code>api:</code> in front of what you are looking for.</p>
</div>
<p>The <code>help-search</code> command can search for keywords in the documentation provided by <code>help</code>. Type <code>help-search keyword</code> to get a list of all documentation topics matching this keyword. Its alias is <code>apropos</code>, named after the UNIX command-line utility which has similar behavior.</p>
<pre><code class="language-simics">simics&gt; <strong>help-search step</strong>
The text 'step' appears in the documentation
for the following items:
 
Command        &lt;cycle&gt;.cycle-break
Command        &lt;cycle&gt;.cycle-break-absolute
Command        &lt;cycle&gt;.print-time
Command        &lt;cycle&gt;.wait-for-cycle
Command        &lt;cycle&gt;.wait-for-time
[...]
Interface      step_info

simics&gt; <strong>apropos step</strong>
[... yields the same output ...]
</code></pre>
<h2 id="cli.html:simics-s-search-path"><a href="#cli.html:simics-s-search-path">2.2.4 Simics's Search Path</a></h2>
<p>Many Simics commands will look up files based on the current directory. When Simics is launched from the command line, the current directory is the current directory of the shell Simics was launched from. When Simics is launched by double clicking its icon, the current directory is the project directory. This may be impractical when writing scripts or building new configurations, so Simics provides two features to ease directory handling:</p>
<ul>
<li>
<p>Simics recognizes some special path markers that are translated before being used:</p>
  <div class="dl">
<ul>
<li>
<p><span class="term" id="cli.html:dt:simics"><a href="#cli.html:dt:simics"><code>%simics%</code></a></span><br>
This path marker causes Simics to locate the file (following the marker) in the project directory or in any of the installed packages. If not found in the project directory, Simics will start searching in the newest package, i.e. the one with the highest build-id number.</p>
<p>For example, <code>%simics%/scripts/foo.simics</code> could be translated to:</p>
  <div class="dl">
<ul>
<li><span class="term" id="cli.html:dt:windows"><a href="#cli.html:dt:windows">Windows:</a></span><br>
<code>C:\Program   Files\Simics\Simics 6\Simics   6.0.1\scripts\foo.simics</code></li>
<li><span class="term" id="cli.html:dt:linux"><a href="#cli.html:dt:linux">Linux:</a></span><br>
<code>  /opt/simics/simics-6/simics-6.0.1/scripts/foo.simics  </code></li>
</ul>
  </div>
<p>Note that if you change the version of Simics, <code>%simics%</code> will change as well, so you should use it to refer only to files that you know are present in all Simics versions. Notice also that <code>%simics%</code> has no meaning if no file can be found. You can use the command <code>lookup-file</code> to find out how the path will be translated.</p>
</li>
<li>
<p><span class="term" id="cli.html:dt:script"><a href="#cli.html:dt:script"><code>%script%</code></a></span><br>
Translated to the directory where the currently running script is located. A possible usage is to let a script call another one in the same directory, independently of what the current directory is.</p>
<p>For example, if the directory <code>baz</code> contains the scripts <code>foo.simics</code> and <code>bar.simics</code>, even if the user uses Simics with another current directory, it will be possible for <code>foo.simics</code> to call <code>bar.simics</code> by issuing the command:</p>
<pre><code class="language-simics">simics&gt; <strong>run-script %script%/bar.simics</strong>
</code></pre>
</li>
</ul>
  </div>
<p><code>%simics%</code> and <code>%script%</code> are always translated to absolute paths, so they never interact with the next feature, called <em>Simics's search path</em>. One consequence is that they must always be used in double quotes <code>"%simics%/targets/qsp-x86/images"</code> to ensure that escaped characters such as spaces are used correctly.</p>
</li>
<li>
<p>Simics has a list of paths called <em>Simics's search path</em> where files will be looked up when using some specific commands (among others, <code>load-binary</code>, <code>load-file</code> and <code>run-script</code>) and a number of classes (such as the <code>image</code> class and the tftp server implementation in the <code>service-node</code>). The file is first looked up in the current directory, then in all entries of Simics's search path, in order.</p>
  <div class="dl">
<ul>
<li>
<p><span class="term" id="cli.html:dt:windows-2"><a href="#cli.html:dt:windows-2">Windows:</a></span><br>
Let us assume for example that Simics's search path contains<br>
<code>C:\Users\joe\scripts\</code><br>
and that the current directory is<br>
<code>C:\Users\joe\project\</code><br>
If the command:</p>
<pre><code class="language-simics">simics&gt; <strong>run-script test/start-test.simics</strong>
</code></pre>
<p>is issued, Simics will look for the following files to run:</p>
<ol>
<li><code>C:\Users\joe\project\test\start-test.simics</code></li>
<li><code>C:\Users\joe\scripts\test\start-test.simics</code></li>
</ol>
</li>
<li>
<p><span class="term" id="cli.html:dt:linux-2"><a href="#cli.html:dt:linux-2">Linux:</a></span><br>
Let us assume for example that Simics's search path contains<br>
<code>/home/joe/scripts/</code> and that the current directory is <code>/home/joe/project</code>. If the command:</p>
<pre><code class="language-simics">simics&gt; <strong>run-script test/start-test.simics</strong>
</code></pre>
<p>is issued, Simics will look for the following files to run:</p>
<ol>
<li><code>/home/joe/project/test/start-test.simics</code></li>
<li><code>/home/joe/scripts/test/start-test.simics</code></li>
</ol>
</li>
</ul>
  </div>
</li>
</ul>
<p>Simics's search path can be manipulated using the <code>add-directory</code>, <code>clear-directories</code> and <code>list-directories</code> commands. Simics's search path is also used when looking for image files belonging to checkpoints or new configurations. This is described in section <a class="reference" href="#configuration.html:image-search-path">2.4.2.3.1</a>.</p>
<p>Remember that setting a CLI variable to a path with %simics% or %script% does not in itself evaluate the path marker. This means that the path marker may evaluate to another directory than is anticipated. The following two lines evaluate quite differently:</p>
<pre><code class="language-simics">simics&gt; <strong>$just_a_string = "%script%/images/my_image"</strong>
simics&gt; <strong>$absolute_path = (lookup-file "%script%/images/my_image")</strong>
</code></pre>
<p>The first CLI variable reads the given text and may evaluate to wherever. The second variable is evaluated locally and reads the absolute path for the <code>my_image</code> file that is located nearby the script.</p>
<div class="note">
<p>Although the Simics search path is saved in the <code>sim</code> object in checkpoints, allowing image files that were found through it to be opened again by the checkpoint, it is not available until the object creation phase. Module initialization code should not rely on the Simics path since that code is run before the <code>sim</code> object from the checkpoint has been created.</p>
</div>
<h2 id="cli.html:using-the-pipe-command"><a href="#cli.html:using-the-pipe-command">2.2.5 Using the Pipe Command</a></h2>
<p>The <code>pipe</code> command lets you send the output of a Simics command to a shell command through a pipe:</p>
<pre><code class="language-simics">simics&gt; <strong>pipe "help" "grep Tracing"</strong>
</code></pre>
<p>This will run <code>help</code> (which lists all Simics commands categories) and send its output to the standard input of the <code>grep Tracing</code> process. <code>grep</code> will discard all lines not containing "Tracing" and forward the rest to its standard output, which will be printed on the Simics terminal.</p>
<p>The <code>pipe</code> command can be used to send all the output of a command to a file:</p>
<pre><code class="language-simics">simics&gt; <strong>pipe "stepi 1000" "cat &gt; trace.txt"</strong>
</code></pre>
<p>Or you can use it to view information using the shell command <code>more</code>:</p>
<pre><code class="language-simics">simics&gt; <strong>pipe "print-processor-registers -all" more</strong>
</code></pre>
<p>Note that you have to enclose both the Simics command (the first argument) and the shell command (the second argument) in double quotes if they contain whitespace or other non-letter characters.</p>
<h2 id="cli.html:running-shell-commands"><a href="#cli.html:running-shell-commands">2.2.6 Running Shell Commands</a></h2>
<p>The <code>!</code> Simics command can be used to run command line commands. It will take everything after the <code>!</code> sign and run it in a command interpreter (the current shell, on Linux, and <code>cmd.exe</code>, on Windows). For example:</p>
<div class="dl">
<ul>
<li>
<p><span class="term" id="cli.html:dt:windows-3"><a href="#cli.html:dt:windows-3">Windows</a></span></p>
<pre><code class="language-simics">simics&gt; <strong>!dir c:\</strong>
</code></pre>
<p>This will run <code>dir c:\</code> as if typed at the <code>cmd.exe</code> prompt and show the result in the Simics console.</p>
</li>
<li>
<p><span class="term" id="cli.html:dt:linux-3"><a href="#cli.html:dt:linux-3">Linux</a></span></p>
<pre><code class="language-simics">simics&gt; <strong>!uname -a</strong>
</code></pre>
<p>This will run <code>uname -a</code> using the current shell and show the result in the Simics console.</p>
</li>
</ul>
</div>
<h2 id="cli.html:command-line-keyboard-shortcuts"><a href="#cli.html:command-line-keyboard-shortcuts">2.2.7 Command-line Keyboard Shortcuts</a></h2>
<p>The Simics CLI supports two modes with different keyboard shortcuts: <em>Windows</em> and <em>GNU Readline</em> style. Most shortcuts are the same in both modes but there are some minor differences between the two as listed in the following table. The mode can be set in the preferences, via the GUI or the CLI:</p>
<pre><code class="language-simics">simics&gt; <strong>prefs-&gt;readline_shortcuts = TRUE</strong>
simics&gt; <strong>save-preferences</strong>
</code></pre>
<p>The command line in Simics can be accesses in several different ways. The shortcuts are supposed to be the same everywhere, but some terminals and telnet clients may not forward certain key combinations to Simics. A typical example where keyboard shortcuts do not work properly is the Cygwin terminal on Windows hosts. To run Simics in command-line mode on Windows, a standard Windows command line console is recommended.</p>
<h3 id="cli.html:list-of-shortcuts"><a href="#cli.html:list-of-shortcuts">2.2.7.1 List of Shortcuts</a></h3>
<p>The following is a list of all keyboard shortcuts supported in Simics, where some are marked as Windows or GNU Readline only.<br>
<strong>Move Shortcuts</strong></p>
<table><thead><tr><th><strong>Action</strong></th><th><strong>Shortcuts</strong></th></tr></thead><tbody>
<tr><td>Move character left</td><td><code>Ctrl-B, Left</code></td></tr>
<tr><td>Move character right</td><td><code>Ctrl-F, Right</code></td></tr>
<tr><td>Move word left</td><td><code>Alt-B, Ctrl-Left</code></td></tr>
<tr><td>Move word right</td><td><code>Alt-F, Ctrl-Right</code></td></tr>
<tr><td>Move to start of line</td><td><code>Ctrl-A </code>(GNU Readline)<code>, Home</code></td></tr>
<tr><td>Move to end of line</td><td><code>Ctrl-E, End</code></td></tr>
</tbody></table>
<p><strong>Edit Shortcuts</strong></p>
<table><thead><tr><th><strong>Action</strong></th><th><strong>Shortcuts</strong></th></tr></thead><tbody>
<tr><td>Enter line</td><td><code>Ctrl-J, Ctrl-M, Enter</code></td></tr>
<tr><td>Copy</td><td><code>Ctrl-C, Ctrl-Insert</code></td></tr>
<tr><td>Paste</td><td><code>Ctrl-Y </code>(GNU Readline)<code>, Ctrl-V, Shift-Insert</code></td></tr>
<tr><td>Cut</td><td><code>Ctrl-X, Shift-Delete</code></td></tr>
<tr><td>Cut to end of line</td><td><code>Ctrl-K</code></td></tr>
<tr><td>Cut to start of line</td><td><code>Ctrl-U</code></td></tr>
<tr><td>Cut previous word</td><td><code>Ctrl-W</code></td></tr>
<tr><td>Select character left</td><td><code>Shift-Left</code></td></tr>
<tr><td>Select character right</td><td><code>Shift-Right</code></td></tr>
<tr><td>Select word left</td><td><code>Ctrl-Shift-Left</code></td></tr>
<tr><td>Select word right</td><td><code>Ctrl-Shift-Right</code></td></tr>
<tr><td>Select to start of line</td><td><code>Shift-Home</code></td></tr>
<tr><td>Select to end of line</td><td><code>Shift-End</code></td></tr>
<tr><td>Select line</td><td><code>Ctrl-A </code>(Windows)</td></tr>
<tr><td>Delete character left</td><td><code>Ctrl-H, Backspace</code></td></tr>
<tr><td>Delete character right</td><td><code>Ctrl-D, Delete</code></td></tr>
<tr><td>Delete word left</td><td><code>Ctrl-Backspace, Alt-Backspace, Alt-Delete</code></td></tr>
<tr><td>Delete word right</td><td><code>Alt-D, Ctrl-Delete</code></td></tr>
<tr><td>Delete to start of line</td><td><code>Ctrl-Home</code></td></tr>
<tr><td>Delete to end of line</td><td><code>Ctrl-End</code></td></tr>
</tbody></table>
<p><strong>History Shortcuts</strong></p>
<table><thead><tr><th><strong>Action</strong></th><th><strong>Shortcuts</strong></th></tr></thead><tbody>
<tr><td>Next in history</td><td><code>Ctrl-N, Down</code></td></tr>
<tr><td>Previous in history</td><td><code>Ctrl-P, Up</code></td></tr>
<tr><td>First in history</td><td><code>Alt-&lt;, Page Up</code></td></tr>
<tr><td>Last in history</td><td><code>Alt-&gt;, Page Down</code></td></tr>
<tr><td>Reverse search</td><td><code>Ctrl-R</code></td></tr>
<tr><td>Scroll page up</td><td><code>Shift-Page Up</code></td></tr>
<tr><td>Scroll page down</td><td><code>Shift-Page Down</code></td></tr>
</tbody></table>
<p><strong>Completion Shortcuts</strong></p>
<table><thead><tr><th><strong>Action</strong></th><th><strong>Shortcuts</strong></th></tr></thead><tbody>
<tr><td>Auto complete</td><td><code>Ctrl-I, Tab</code></td></tr>
<tr><td>Show completions</td><td><code>Alt-?</code></td></tr>
</tbody></table>
<p><strong>Transpose Shortcuts</strong></p>
<table><thead><tr><th><strong>Action</strong></th><th><strong>Shortcuts</strong></th></tr></thead><tbody>
<tr><td>Uppercase word</td><td><code>Alt-U</code></td></tr>
<tr><td>Lowercase word</td><td><code>Alt-L</code></td></tr>
<tr><td>Capitalize word</td><td><code>Alt-C</code></td></tr>
<tr><td>Transpose characters</td><td><code>Ctrl-T</code></td></tr>
<tr><td>Transpose words</td><td><code>Alt-T, Ctrl-Shift-T</code></td></tr>
</tbody></table>
<p><strong>Undo Shortcuts</strong></p>
<table><thead><tr><th><strong>Action</strong></th><th><strong>Shortcuts</strong></th></tr></thead><tbody>
<tr><td>Cancel multi-line editing</td><td><code>Ctrl-G</code></td></tr>
<tr><td>Undo</td><td><code>Ctrl-_, Ctrl-Z </code>(Windows)</td></tr>
<tr><td>Revert line</td><td><code>Alt-R</code></td></tr>
<tr><td>Clear screen</td><td><code>Ctrl-L</code></td></tr>
</tbody></table>
</section><section class="page" id="script-support-in-simics.html"><h1 id="script-support-in-simics.html:simics-scripting-environment"><a href="#script-support-in-simics.html:simics-scripting-environment">2.3 Simics Scripting Environment</a></h1>
<p>The Command Line Interface in Simics provides scripting capabilities that can be used to write parameterized configurations and scripts that control or inspect simulated sessions. For even more advanced scripting, the Python language can be used.</p>
<p>This chapter describes how to write simple scripts in the Simics command line interface (CLI), using control flow commands, variables and <em>script branches</em>. It also explains how the configuration system can be accessed from scripts, and how Python can be used for more advanced script programming.</p>
<p>All commands can be executed either by typing them at the prompt in the Simics console, or by writing them to a file, e.g., <code>example.simics</code>, and executing the command <code>run-script example.simics</code>, or for Python examples <code>run-script example.py</code>.</p>
<div class="note">
<p>Scripts should normally not start the simulation. If a script starts the simulation, that is a synchronous (blocking) call. Control is not returned to CLI until the simulation is stopped. If the script does not stop itself, the simulation may be stopped by using the GUI controls or by entering <code>Ctrl-C</code> in CLI.</p>
</div>
<h2 id="script-support-in-simics.html:script-support-in-cli"><a href="#script-support-in-simics.html:script-support-in-cli">2.3.1 Script Support in CLI</a></h2>
<h3 id="script-support-in-simics.html:why-use-cli-scripting-instead-of-python"><a href="#script-support-in-simics.html:why-use-cli-scripting-instead-of-python">2.3.1.1 Why Use CLI Scripting Instead of Python</a></h3>
<p>There are a number of situations where it may make sense to use the scripting support in CLI due to its advantages over Python. Still, if the script starts to grow in size and complexity, or if more complete and detail control of the simulation is needed, then Python is the obvious choice.</p>
<div class="dl">
<ul>
<li><span class="term" id="script-support-in-simics.html:dt:same-environment-as-on-the-command-line"><a href="#script-support-in-simics.html:dt:same-environment-as-on-the-command-line">Same environment as on the command line</a></span><br>
CLI is suitable for interactive use with its simple syntax and features such as context sensitive tab completion. Being able to script using the same set of command simplifies script writing.</li>
<li><span class="term" id="script-support-in-simics.html:dt:cli-hides-simics-api-restrictions"><a href="#script-support-in-simics.html:dt:cli-hides-simics-api-restrictions">CLI hides Simics API restrictions</a></span><br>
The Simics API has restrictions on when certain API functions may be called. For example, some functions can not be used while an instruction is executing. The CLI script environment will only run commands in a context where the full API is available, greatly simplifying scripting.</li>
<li><span class="term" id="script-support-in-simics.html:dt:easy-to-write-sequential-code-that-waits-for-events-to-occur"><a href="#script-support-in-simics.html:dt:easy-to-write-sequential-code-that-waits-for-events-to-occur">Easy to write sequential code that waits for events to occur</a></span><br>
By using script branches, it is easy to write sequential code that can wait for various events in the system, postponing the rest of the script until they occur.</li>
</ul>
</div>
<h3 id="script-support-in-simics.html:variables"><a href="#script-support-in-simics.html:variables">2.3.1.2 Variables</a></h3>
<p>The Simics command line has support for string, integer, floating point, list and Boolean variables. Variables are always prefixed with the <code>$</code> character. A variable has to be created by assigning a value to it, before it can be used.</p>
<pre><code class="language-simics">simics&gt; <strong>$foo = "some text"</strong>
simics&gt; <strong>$foo</strong>
"some text"
simics&gt; <strong>echo $not_used_before</strong>
No CLI variable "not_used_before"
</code></pre>
<p>The <code>defined</code> expression can be used to test if a variable has been defined. Note that this command takes the name of the variable only, i.e. without the <code>$</code>.</p>
<pre><code class="language-simics">simics&gt; <strong>$foo = 4711</strong>
simics&gt; <strong>if defined foo { echo "foo is defined"}</strong>
foo is defined
</code></pre>
<p>List variables can be indexed, something that is useful in loops for example.</p>
<pre><code class="language-simics">simics&gt; <strong>$foo = []</strong>
simics&gt; <strong>$foo[0] = 10</strong>
simics&gt; <strong>$foo[1] = 20</strong>
simics&gt; <strong>echo $foo[0] + $foo[1]</strong>
30
simics&gt; <strong>$foo</strong>
[10, 20]
simics&gt; <strong>$foo += ["abc"]</strong>
[10, 20, "abc"]
simics&gt; <strong>list-length $foo</strong>
3
</code></pre>
<p>CLI also has support for local variables, described later in this chapter.</p>
<h3 id="script-support-in-simics.html:command-return-values"><a href="#script-support-in-simics.html:command-return-values">2.3.1.3 Command Return Values</a></h3>
<p>The return value of a command is printed on the console, unless it is used as argument to some other command. Parenthesis <code>()</code> are used to group a command with arguments together, allowing the return value to be used as argument. The return value can also be used as namespace in another command. Variables can be used in the same way.</p>
<pre><code class="language-simics">simics&gt; <strong>$address = 0x7ff00000</strong>
simics&gt; <strong>set $address 20</strong>
simics&gt; <strong>echo "The Value at address " + $address + " is " + (get $address)</strong>
The Value at address 2146435072 is 20

simics&gt; <strong>$id = 0</strong>
simics&gt; <strong>("board.mb.cpu0.core[" + $id + "][" + $id + "]").print-time</strong>
processor                   steps  cycles  time [s]
board.mb.cpu0.core[0][0]        0       0     0.000
</code></pre>
<p>Although in this particular case it is simpler to write:</p>
<pre><code class="language-simics">simics&gt; <strong>board.mb.cpu0.core[$id][$id].print-time</strong>
processor                   steps  cycles  time [s]
board.mb.cpu0.core[0][0]        0       0     0.000
simics&gt; <strong>$cpu = board.mb.cpu0.core[0][0]</strong>
simics&gt; <strong>$cpu.print-time</strong>
processor                   steps  cycles  time [s]
board.mb.cpu0.core[0][0]        0       0     0.000
</code></pre>
<p>Parenthesis can also be used to break a command with its arguments across multiple lines, making it easier to read scripts with expressions and nested command invocations.</p>
<h3 id="script-support-in-simics.html:control-flow-commands"><a href="#script-support-in-simics.html:control-flow-commands">2.3.1.4 Control Flow Commands</a></h3>
<p>The script support in CLI has support for common flow control commands such as <code>if</code>, <code>else</code>, <code>while</code> as well as <code>foreach</code>.</p>
<pre><code class="language-simics">simics&gt; <strong>$value = 10</strong>
simics&gt; <strong>if $value &gt; 5 { echo "Larger than five!" }</strong>
Larger than five!
</code></pre>
<p>The <code>if</code> statement has a return value:</p>
<pre><code class="language-simics">simics&gt; <strong>$num_cpus = 2</strong>
simics&gt; <strong>(if $num_cpus &gt; 1 { "multi" } else { "single" }) + "-pro"</strong>
multi-pro
</code></pre>
<div class="note">
<p>Multi-line <code>if-else</code> statements must have <code>} else {</code> on the same line.</p>
</div>
<p>It is also possible to have <code>else</code> followed by another <code>if</code> statement.</p>
<pre><code class="language-simics">simics&gt; <strong>$b = 0</strong>
simics&gt; <strong>if $b == 1 {</strong>
.......     echo 10
....... } else if $b == 0 {
.......     echo 20
....... } else {
.......     echo 30
....... }
20
</code></pre>
<p>Loops can be written with the <code>while</code> command.</p>
<pre><code class="language-simics">simics&gt; <strong>$loop = 3</strong>
simics&gt; <strong>while $loop {</strong>
.......     echo $loop
.......     $loop -= 1
....... }
3
2
1
</code></pre>
<p>They can also be written using the <code>foreach</code> list iteration command. The <code>range</code> commands in the example returns a list of integers from 0 up to, but not including, 3.</p>
<pre><code class="language-simics">simics&gt; <strong>foreach $loop in (range 3) {</strong>
.......     echo $loop
....... }
0
1
2
</code></pre>
<p>Here is another example that shows how <code>foreach</code> can be used. The <code>get-object-list</code> commands return a list of all objects that implement the processor_internal interface in Simics:</p>
<pre><code class="language-simics">simics&gt; <strong>foreach $cpu in (list-objects -all processor_internal) {</strong>
.......     echo "Cycles on " + ($cpu-&gt;name) + ": " + ($cpu.print-time -c)
....... }
Cycles on board.mb.cpu0.core[0][0]: 0
</code></pre>
<p>Lists can also be written directly, for example:</p>
<pre><code class="language-simics">simics&gt; <strong>foreach $loop in [1, 2, 3] {</strong>
.......     echo $loop
....... }
1
2
3
</code></pre>
<p>Within command blocks, it can be useful to have variables that are local to the scope and thus do not collide with the names of global variables. By adding <code>local</code> before the first assignment of a variable, the variable is made local.</p>
<pre><code class="language-simics">simics&gt; <strong>$global = 10</strong>
simics&gt; <strong>if TRUE {</strong>
.......     local $global = 20
.......     echo $global
....... }
20
simics&gt; <strong>echo $global</strong>
10
</code></pre>
<h3 id="script-support-in-simics.html:integer-conversion"><a href="#script-support-in-simics.html:integer-conversion">2.3.1.5 Integer Conversion</a></h3>
<p>In some cases it is useful to interpret an integer as a signed value of a specific bit size, for example when reading four bytes from memory that should be interpreted as a signed 32 bit integer. The <code>signed</code>, <code>signed8</code>, ..., <code>signed64</code> commands can be used to perform the conversion.</p>
<pre><code class="language-simics">simics&gt; <strong>board.mb.phys_mem.set 0x7fe00000 0xffffffff 4</strong>
simics&gt; <strong>board.mb.phys_mem.get 0x7fe00000 4</strong>
4294967295 (LE)
simics&gt; <strong>signed32 (board.mb.phys_mem.get 0x7fe00000 4)</strong>
-1
</code></pre>
<p>Other useful and related commands are <code>atoi</code>, <code>bits</code>, <code>int-to-*-float</code>, <code>bin</code>, <code>dec</code>, <code>hex</code>, and <code>oct</code>.</p>
<h3 id="script-support-in-simics.html:accessing-configuration-attributes"><a href="#script-support-in-simics.html:accessing-configuration-attributes">2.3.1.6 Accessing Configuration Attributes</a></h3>
<p>Simics configuration attributes that are of string, integer, floating point, Boolean, nil, and list types can be accessed directly from CLI using the <code>-&gt;</code> operator.</p>
<pre><code class="language-simics">simics&gt; <strong>echo "Current project: " + (sim-&gt;project)</strong>
Current project: C:\Users\joe\Desktop\project
</code></pre>
<p>An object referenced with this operator returns the object's name as a string.</p>
<p>A nil attribute value is represented by <code>NIL</code> in CLI.</p>
<p>To access attributes that use other data types than the ones listed above, you need to use Python:</p>
<pre><code class="language-simics">simics&gt; <strong>@conf.myobject.attr.dictionary_attribute = { 1 : "abc" }</strong>
</code></pre>
<p>See chapter <a class="reference" href="#script-support-in-simics.html:configuration-objects">2.3.4.3.1</a> for more information about accessing attributes from Python.</p>
<h3 id="script-support-in-simics.html:error-handling-in-scripts"><a href="#script-support-in-simics.html:error-handling-in-scripts">2.3.1.7 Error Handling in Scripts</a></h3>
<p>When a Simics command encounters an error, an error message is typically printed, and the script execution is interrupted. In some cases the script itself want to handle the error, in order to try some alternative approach, or to present the error message with more context. The <code>try-except</code> statement can be used for this purpose.</p>
<pre><code class="language-simics">simics&gt; <strong>try {</strong>
    load-module my-own-components
} except {
    echo "Simics failed to import my-own components. Perhaps you forgot to "
    echo "install the latest modules from the development team? See the "
    echo "project web-site for more info.\n"

    interrupt-script "Cannot continue"
}
</code></pre>
<p>Without the <code>try-except</code> statement, the example above would print an error message like <code>Error loading module</code> and the script execution would be interrupted with an error.</p>
<p>The error message from the failing command can be obtained inside the <code>except</code> block by calling the <code>get-error-message</code> CLI command. The <code>get-error-line</code> command returns the line of the error in the script file and <code>get-error-file</code> the file name. The <code>get-error-command</code> returns the command name if the error occurred within a command.</p>
<h2 id="script-support-in-simics.html:script-branches"><a href="#script-support-in-simics.html:script-branches">2.3.2 Script Branches</a></h2>
<h3 id="script-support-in-simics.html:introduction-to-script-branches"><a href="#script-support-in-simics.html:introduction-to-script-branches">2.3.2.1 Introduction to Script Branches</a></h3>
<p>Script branches allow the user to write sequences of CLI commands that can be postponed, waiting for things to happen in the simulator, without breaking the sequential flow of commands. This is typically used to avoid breaking a script into many small sections, each run as a callback using Python.</p>
<p>A simple example of a script branch:</p>
<pre><code class="language-simics">simics&gt; <strong>script-branch "script branch description (optional)" {</strong>
    echo "This is a script branch test - going to sleep."
    board.mb.cpu0.core[0][0].wait-for-step 10
    echo "Processor registers after 10 steps:"
    board.mb.cpu0.core[0][0].print-processor-registers
}
</code></pre>
<p>The example above will execute the first <code>echo</code> command at once, and then go to sleep waiting until the first 10 instructions (steps) have run. When the step counter for the processor has reached 10, the branch will wake up and run the next two commands, <code>echo</code> and <code>print-processor-registers</code>.</p>
<p>A big difference between script branches and the main script is that the main script (also called main branch) may be interrupted by the user pressing the stop button or typing Ctrl-C. The script branches are unaffected by such actions and can exist in the background, coexisting with any interactive command line use.</p>
<h3 id="script-support-in-simics.html:how-script-branches-work"><a href="#script-support-in-simics.html:how-script-branches-work">2.3.2.2 How Script Branches Work</a></h3>
<p>When a script branch is started (using <code>script-branch</code>), it begins executing immediately, and runs until a <code>wait-for-</code>, command is issued. Execution is then resumed in the main script; i.e., there is never any concurrent activity. When some activity occurs that a script branch is waiting for, the branch continues executing once the currently simulated instruction is ready.</p>
<div class="note">
<p>Since only one branch can be active at once, any callback to Python from Simics will execute in the currently active branch, i.e., if a branch installs a callback, it is most likely that it will be called when the main branch is active.</p>
</div>
<h3 id="script-support-in-simics.html:script-branch-commands"><a href="#script-support-in-simics.html:script-branch-commands">2.3.2.3 Script Branch Commands</a></h3>
<p>The following is a list of the commands related to script branches.</p>
<div class="dl">
<ul>
<li><span class="term" id="script-support-in-simics.html:dt:script-branch"><a href="#script-support-in-simics.html:dt:script-branch"><code>script-branch</code></a></span><br>
Create a new script branch and start it.</li>
<li><span class="term" id="script-support-in-simics.html:dt:list-script-branches"><a href="#script-support-in-simics.html:dt:list-script-branches"><code>list-script-branches</code></a></span><br>
List all existing, but suspended, branches.</li>
<li><span class="term" id="script-support-in-simics.html:dt:interrupt-script-branch"><a href="#script-support-in-simics.html:dt:interrupt-script-branch"><code>interrupt-script-branch</code></a></span><br>
Interrupt a script-branch, causing it to exit.</li>
<li><span class="term" id="script-support-in-simics.html:dt:create-script-barrier-num_branches"><a href="#script-support-in-simics.html:dt:create-script-barrier-num_branches"><code>create-script-barrier</code> <em>num_branches</em></a></span><br>
Create a script barrier used to synchronize the execution of several script branches. The argument is the number of script branches that must enter the barrier before all of them are released.</li>
<li><span class="term" id="script-support-in-simics.html:dt:wait-for-script-barrier-barrier"><a href="#script-support-in-simics.html:dt:wait-for-script-barrier-barrier"><code>wait-for-script-barrier</code> <em>barrier</em></a></span><br>
Suspend branch until enough branches have reached the script branch barrier.</li>
<li><span class="term" id="script-support-in-simics.html:dt:create-script-pipe"><a href="#script-support-in-simics.html:dt:create-script-pipe"><code>create-script-pipe</code></a></span><br>
Create a script pipe, used to communicate data between script branches and also to synchronize them.</li>
<li><span class="term" id="script-support-in-simics.html:dt:add-data-to-script-pipe-pipe-data"><a href="#script-support-in-simics.html:dt:add-data-to-script-pipe-pipe-data"><code>add-data-to-script-pipe</code> <em>pipe</em> <em>data</em></a></span><br>
Add data (integer, string, floating point value or a list of any of those types) to the specified script pipe.</li>
<li><span class="term" id="script-support-in-simics.html:dt:script-pipe-has-data-pipe"><a href="#script-support-in-simics.html:dt:script-pipe-has-data-pipe"><code>script-pipe-has-data</code> <em>pipe</em></a></span><br>
Check if there is data to read from a script pipe.</li>
<li><span class="term" id="script-support-in-simics.html:dt:wait-for-script-pipe-pipe"><a href="#script-support-in-simics.html:dt:wait-for-script-pipe-pipe"><code>wait-for-script-pipe</code> <em>pipe</em></a></span><br>
Suspend branch until there is data to read on a script pipe. If there already is data in the pipe, return immediately. The return value is the first data item added to the pipe.</li>
<li><span class="term" id="script-support-in-simics.html:dt:wait-for-log-or-conf_object-wait-for-log-object-substring-type-re"><a href="#script-support-in-simics.html:dt:wait-for-log-or-conf_object-wait-for-log-object-substring-type-re"><code>wait-for-log</code> or <code>&lt;conf_object&gt;.wait-for-log</code> [<code>object</code>] [<code>substring</code>] [<code>type</code>] [<code>-re</code>]</a></span><br>
Wait until a log message is generated by an <code>object</code> or any object if the <code>object</code> variable is omitted. The <code>substring</code> and <code>type</code> can specify certain conditions.</li>
<li><span class="term" id="script-support-in-simics.html:dt:bp-wait-for-breakpoint-breakpoint-id"><a href="#script-support-in-simics.html:dt:bp-wait-for-breakpoint-breakpoint-id"><code>bp.wait-for-breakpoint</code> <em>breakpoint-id</em></a></span><br>
Suspend branch until a specified breakpoint is triggered.</li>
<li><span class="term" id="script-support-in-simics.html:dt:processor-bp-wait-for-cycle-cycle-absolute"><a href="#script-support-in-simics.html:dt:processor-bp-wait-for-cycle-cycle-absolute"><code>&lt;processor&gt;.bp-wait-for-cycle</code> <em>cycle</em> [<code>-absolute</code>]</a></span><br>
Suspend branch until the processor has executed <em>cycle</em> number of cycles. If <code>-absolute</code> is specified, the branch will instead be suspended until the processor reaches the specified cycle in the simulation.</li>
<li><span class="term" id="script-support-in-simics.html:dt:processor-bp-wait-for-step-step-absolute"><a href="#script-support-in-simics.html:dt:processor-bp-wait-for-step-step-absolute"><code>&lt;processor&gt;.bp-wait-for-step</code> <em>step</em> [<code>-absolute</code>]</a></span><br>
Suspend branch until the processor has executed <em>step</em> number of steps. If <code>-absolute</code> is specified, the branch will instead be suspended until the processor reaches the specified step in the simulation.</li>
<li><span class="term" id="script-support-in-simics.html:dt:processor-bp-wait-for-time-seconds-absolute"><a href="#script-support-in-simics.html:dt:processor-bp-wait-for-time-seconds-absolute"><code>&lt;processor&gt;.bp-wait-for-time</code> <em>seconds</em> [<code>-absolute</code>]</a></span><br>
Suspend branch until the processor has executed <em>seconds</em> number of seconds. If <code>-absolute</code> is specified, the branch will instead be suspended until the processor reaches the specified time in the simulation.</li>
<li><span class="term" id="script-support-in-simics.html:dt:processor-bp-wait-for-control-register-reg"><a href="#script-support-in-simics.html:dt:processor-bp-wait-for-control-register-reg"><code>&lt;processor&gt;.bp-wait-for-control-register</code> <em>reg</em></a></span><br>
Suspend branch until the register <em>reg</em> is read from or written to. Only registers that are catchable can be waited on. The break condition can be changed to only consider read by specifying <code>-r</code> or only write by specifying <code>-w</code>.</li>
<li><span class="term" id="script-support-in-simics.html:dt:text-console-bp-wait-for-console-string-string"><a href="#script-support-in-simics.html:dt:text-console-bp-wait-for-console-string-string"><code>&lt;text-console&gt;.bp-wait-for-console-string</code> <em>string</em></a></span><br>
Suspend branch until <em>string</em> is printed on the text console.</li>
</ul>
</div>
<h3 id="script-support-in-simics.html:variables-in-script-branches"><a href="#script-support-in-simics.html:variables-in-script-branches">2.3.2.4 Variables in Script Branches</a></h3>
<p>Variable references in CLI are evaluated when accessed. This is important to remember when writing script branches, since some commands are executed when the branch has been suspended, and variables may have been changed. To make sure that CLI variables in script branches are untouched by other scripts, they should be made local.</p>
<p>The following example</p>
<pre><code class="language-simics">simics&gt; <strong>script-branch "sample script branch" {</strong>
    $foo = 20
    board.mb.cpu0.core[0][0].wait-for-step 10
    echo "foo is " + $foo
}
$foo = 15
run
</code></pre>
<p>will produce the output <code>foo is 15</code> while the following script will print <code>foo is 20</code>.</p>
<pre><code class="language-simics">simics&gt; <strong>script-branch "sample script branch" {</strong>
    local $foo = 20
    board.mb.cpu0.core[0][0].wait-for-step 10
    echo "foo is " + $foo
}
$foo = 15
run
</code></pre>
<h3 id="script-support-in-simics.html:script-branches-and-multi-threaded-simulation"><a href="#script-support-in-simics.html:script-branches-and-multi-threaded-simulation">2.3.2.5 Script Branches and Multi-Threaded Simulation</a></h3>
<p>Large system configurations can be split up over several <em>cells</em> where each cell runs in its own host thread to speed up simulation. Care must be taken when writing scripts in such sessions. If the simulation is stopped or paused, for example by a breakpoint, other cells than the one where the breakpoint occurred may be ahead or behind in simulated time. The difference in time between cells is limited by the minimum latency setting. The time where cells are stopped may also differ between runs of the same setup. To ensure deterministic behavior, a script stopping a simulation as result of some event should only access the cell where the event occurred. If the script needs to access the full configuration, i.e. also objects in other cells, then all cells have to be synchronized in time. The <code>wait-for-global-time</code> and <code>wait-for-global-sync</code> commands can be used to run until a point where all cells have synchronized.</p>
<h3 id="script-support-in-simics.html:canceling-script-branches"><a href="#script-support-in-simics.html:canceling-script-branches">2.3.2.6 Canceling Script Branches</a></h3>
<p>It is possible to cancel a suspended script branch by interrupting it using the <code>interrupt-script-branch</code> command. Each branch has an ID associated that can be found using <code>list-script-branches</code>, and that is returned by the <code>script-branch</code> command.</p>
<pre><code class="language-simics">simics&gt; <strong>$id = (script-branch "sample script branch" {</strong>
    bp.wait-for-breakpoint $bp
})

...

simics&gt; <strong>interrupt-script-branch $id</strong>
Command 'wait-for-breakpoint' interrupted.
Script branch 1 interrupted.
</code></pre>
<h3 id="script-support-in-simics.html:script-branch-restrictions"><a href="#script-support-in-simics.html:script-branch-restrictions">2.3.2.7 Script Branch Restrictions</a></h3>
<p>There are a few things related to script branches that are discouraged or not allowed:</p>
<ul>
<li>
<p>Starting and stopping the simulation should be avoided from script branches that run in sessions with interactive use, such as target start scripts. It is only in batch mode that controlling the simulation from script branches is acceptable, but then care should be taken to avoid script branches that conflict with each other.</p>
</li>
<li>
<p>A script branch may not define a new script branch nested inside itself.</p>
</li>
<li>
<p>The <code>wait-for-</code> command can not run in the main branch. The reason is that the main branch may be interrupted by the user pressing the stop button or Ctrl-C, while script branches and the <code>wait-for-</code> commands are unaffected by such actions.</p>
</li>
<li>
<p>The <code>write-configuration</code> command cannot be run while Simics is executing. This is a limitation that will be removed in a future Simics version, but for now the execution has to be stopped first. The following is an example that writes a checkpoint when the simulation reaches a login prompt, and then continues running. It assumes that a text-console called <code>text_console_cmp0.con</code> is used.</p>
<pre><code class="language-simics">
simics&gt; <strong>script-branch "create checkpoint" {</strong>
    board.console.con.bp-wait-for-console-string login
    stop
    write-configuration login.conf
    run
}
  
</code></pre>
<p>This is one of few exceptions to the rule that script branches should not start or stop the simulation.</p>
</li>
</ul>
<h2 id="script-support-in-simics.html:targets-and-parameters"><a href="#script-support-in-simics.html:targets-and-parameters">2.3.3 Targets and parameters</a></h2>
<p>This section describes the Simics <strong>target parameter</strong> framework. For the older <strong>script declaration</strong> system, see chapter <a class="reference" href="#script-decls.html">5.1</a>. The target parameter framework introduces a few concepts:</p>
<ul>
<li>A parameter system for Simics scripts (written in either Python or CLI). Parameters have types, default values, documentation strings <em>etc</em>, and are specified in a <code>YAML</code>-based format. Parameters from other scripts can be imported, which results in a tree structure. At run-time, the resulting parameter tree has write-once semantics, and individual parameters can be accessed from a special singleton Simics object (in CLI), or via a Python object acting as a dictionary, <em>i.e.</em> they are unrelated to CLI variables. In Python one can also pass around handles to parts of the parameter tree as function arguments.</li>
<li>A high-level target concept. A <em>target</em> is defined by its top-level parameter definition file, which refers to any necessary script or preset files. When the top-level parameter file name in the package matches <code>targets/*/*.target.yml</code> then it is considered a <em>target</em>. Simics scans all available packages for targets during startup and keeps track of the target list. A target can be run by only specifying the target name, without having to know the full path.</li>
<li>The concept of parameter <em>presets</em>. A preset is a file specifying arguments to a target. This is also done in the <code>YAML</code>-based format of the parameter system. A preset does not have to specify arguments for all parameters, but can just override some of them and point to another preset for more arguments. The write-once semantics of the parameter system implies that the arguments in the top-level preset takes precedence over any arguments specified in presets that it points to, facilitating easy creation of override presets. When running a target, preset files can also be provided to specify arguments. A preset can also point to a target or script, with the effect that the preset itself can be run as if it was a script. Presets facilitates easy sharing of individual target configurations.</li>
</ul>
<p>The advantages compared with the script declaration system are as follows:</p>
<ul>
<li>YAML is a standard format that people, text editors, config tools, and format linters already know about.</li>
<li>It is not tied to CLI scripts, but can be used directly with Python.</li>
<li>The concept of a <em>target</em> elevates it above ad-hoc scripting.</li>
<li>Parameters are available in their own Python namespace and not just in the global CLI variable namespace.</li>
<li>The parameters values in a session are known after target launch, and can be listed or saved to a file.</li>
<li>Parameters from different targets do not conflict when loading multiple targets into a single session.</li>
<li>There can be a hierarchy of parameters for large, complex systems with 100s of parameters.</li>
<li>Handling parameters when calling scripts from scripts is much simpler.</li>
<li>The script-trampoline files in the project directory are not needed anymore.</li>
<li>The <em>preset</em> concept makes it easy to have different parameter value sets for the same target.</li>
</ul>
<h3 id="script-support-in-simics.html:semantics"><a href="#script-support-in-simics.html:semantics">2.3.3.1 Semantics</a></h3>
<p>Parameters are write-once, hence the first value provided for a parameter is what gets used. I.e. values provided by the user when running a script will take precedence over default values provided in the script. Scripts can also provide new default values for parameters declared by scripts that they include, and those defaults will take precedence over the defaults in the declaring script. Scripts can also set defaults from their script code, to facilitate the provision of default values that require calculations, potentially using other parameters.</p>
<p>The whole parameter tree is exposed to the user running a script, and via the write-once semantics, the user can specify/override arguments for all parameters. Arguments can be provided on the command line, but the more powerful method is to provide them via <em>preset</em> files.</p>
<p>The write-once semantics implies that the "earliest setting wins". Arguments can come from</p>
<ol>
<li>User specification at command line.</li>
<li>User specification via preset files.</li>
<li>(Default) values specified in parameter declarations.</li>
<li>(Default) values specified in script code.</li>
</ol>
<p>and the first argument for a specific parameter sticks, e.g. user input overrides values in scripts (hence they are only default values). Note that this also implies that script code cannot unilaterally set arguments, not even input to another script that it calls, it can only provide default values, which can always be overridden by an earlier setting, such as user input.</p>
<h3 id="script-support-in-simics.html:file-types"><a href="#script-support-in-simics.html:file-types">2.3.3.2 File types</a></h3>
<p>The parameter declarations and the presets are specified in the standard <code>YAML</code> format. Usage of a standard format means that one can easily process the files outside of Simics, although to resolve file paths using <code>%script%</code> or <code>%simics%</code> knowledge of the underlying Simics installation is required.</p>
<p>We have two types of files: <em>scripts</em> and <em>presets</em>.</p>
<h4 id="script-support-in-simics.html:script-files"><a href="#script-support-in-simics.html:script-files">2.3.3.2.1 Script Files</a></h4>
<p>Script files consist of</p>
<ul>
<li>a parameter declaration section under the <code>params</code> key, which can import parameters from other scripts, and/or define individual parameters with names, their types, default values, description strings, and flags indicating if the parameter is required and if it is an output parameter, and</li>
<li>a code section, either Simics CLI or Python code (specified using the <code>code-type</code> key). The code section can either be below the <code>YAML</code> section, inlined using the <code>cmd</code> key, or in a separate file specified by the <code>script</code> key.</li>
</ul>
<p>See section <a class="reference" href="#script-support-in-simics.html:example-target">2.3.3.3</a> for an example of a script.</p>
<h4 id="script-support-in-simics.html:preset-files"><a href="#script-support-in-simics.html:preset-files">2.3.3.2.2 Preset Files</a></h4>
<p>Preset files</p>
<ul>
<li>specify arguments of parameters (or equivalently, default values) under the <code>args</code> key,</li>
<li>can include other preset files, which may specify more arguments, and</li>
<li>have no parameter declarations and no code.</li>
</ul>
<p>See section <a class="reference" href="#script-support-in-simics.html:example-presets">2.3.3.4</a> for an example of a preset.</p>
<p>The write-once semantics implies that the arguments specified in a preset overrides any arguments specified in included presets. This facilitates easily creating more specialized presets where only a few arguments are changed.</p>
<p>Presets can also specify the script where the corresponding parameter declarations are given, using the <code>target</code> key. Such a preset is a simple way to describe a Simics configuration, and can be used to start Simics, meaning that the specified script is run with the arguments from the preset. The script corresponding to the preset can also be specified implicitly by including other presets using the <code>import</code>.</p>
<p>For more details about the syntax, see the <a href="../simics-target-params/index.html">Target parameters reference</a>.</p>
<h3 id="script-support-in-simics.html:example-target"><a href="#script-support-in-simics.html:example-target">2.3.3.3 Example target</a></h3>
<p>Here is a small example that illustrates how to write a target with parameters:</p>
<pre><code>%YAML 1.2
---
# Declaration section
params:
  # A simple parameter
  sigma:
    type: str
    required: true
    default: sigmoid
    description: &gt;-
      A potentially multi-line text
      describing this parameter.
  # List parameters can have typed elements
  resources:
    type: list[list[int]]
    default: []
  # A complex parameter
  epsilon:
    mu:
       type: str
    nu:
       type: int
  tau:
    # Import parameters from other script
    import: inner.yml
    # beta parameter is set by this script, not required
    provides:
    - beta
    # new default value of imported parameter
    defaults:
      gamma: true
# Type of code
code-type: simics
# Code inlined in the YAML section
cmd: |
  echo `params["sigma"]`
  echo (params.get "epsilon:mu")
  echo `params.get("epsilon:nu")`
  params.setdefault "tau:beta" (params.get "sigma")
  run-script script = "inner.yml" namespace = "tau"
...
</code></pre>
<p>And the imported file:</p>
<pre><code>%YAML 1.2
---  
params:
  alpha:
    type: int
  beta:
    type: str
    required: true
  gamma:
    type: bool 
cmd: |
  # Use dict syntax to read parameter
  print(f"beta={params['beta']}")
...
</code></pre>
<p>As can be seen from the example, the target script code can be inlined in the YAML section. One can also place the code in a separate file which is referred from the parameter section using the <code>script</code> tag. A third option is to place the code below the parameter section, but then the file as a whole will typically no longer be valid YAML.</p>
<p>The example also illustrates how to import parameters from other scripts. The result is that the parameter tree defined in the imported script becomes a sub-tree in the current script, in this case with the root node <code>tau</code>. To refer to parameters further down in the tree, the <code>:</code> character is used as separator. Note that importing a parameter tree from another script does not mean that the imported script has to be run, but all scripts that are run must have been imported. When running an imported script, the root node of the imported sub-tree must be provided.</p>
<p>Notice that in the first file we have to declare the code type to be Simics CLI, using the <code>code-type</code> key, since Python is the default. The code type defaults to Simics CLI if the file (or the file specified by the <code>script</code> key) has extension <code>.simics</code> or <code>.include</code> and defaults to Python if the extension is <code>.py</code> or <code>.yml</code>.</p>
<p>Finally, as can be seen, the parameters are accessed via a global object <code>params</code>, both in CLI and in Python. In Python the object acts like a regular Python dictionary and in CLI it is a Simics object with various commands.</p>
<p>Notice how we illustrate different ways to read parameters: one can use the CLI command <code>params.get</code>, or <code>params.get</code> via inline Python, or Python dictionary notation. The latter will throw an exception if the parameter is not assigned.</p>
<p>For more details about the syntax, available types etc, see the <a href="../simics-target-params/index.html">Target parameters reference</a>.</p>
<h3 id="script-support-in-simics.html:example-presets"><a href="#script-support-in-simics.html:example-presets">2.3.3.4 Example presets</a></h3>
<p>Here is an example preset for to the example target. The target is assumed to be a file named <code>example.target.yml</code>:</p>
<pre><code>%YAML 1.2
---
args:
  tau:
    beta: test
  epsilon:
    mu: foo
  import: include.preset.yml
...
</code></pre>
<p>As can be seen, argument values are specified under the <code>args</code> using the parameter names as keys. Also note that presets can include other presets.</p>
<p>Here is the the included preset, <code>include.preset.yml</code>:</p>
<pre><code>%YAML 1.2
---
args:
  sigma: foo
  tau:
    beta: bar

target: example.target.yml
...
</code></pre>
<p>Notice that the first preset overrides the argument <code>beta</code> in the included preset. This illustrates how presets can be stacked on top of each other, only overriding what is necessary. This facilitates easily creating variants of target configurations for runs with different parameters.</p>
<p>Also note that the second preset specifies the target that it is based on. The result is that the preset, and all presets that import it, can be run directly.</p>
<h3 id="script-support-in-simics.html:target-definition"><a href="#script-support-in-simics.html:target-definition">2.3.3.5 Target definition</a></h3>
<p>As mentioned at the top of this section, a <em>target</em> is a file with name that matches <code>targets/*/*.target.yml</code>, located in the Simics project or in a package available in the project.</p>
<p>The intention is that the top level scripts, that should be exposed to the user via the <code>load-target</code> command, are turned into targets by naming them accordingly.</p>
<p>Targets can be listed from the Simics CLI or from the shell as mentioned in <a class="reference" href="#script-support-in-simics.html:run-time-usage">2.3.3.6</a>. The idea is to make it easy to find the main entry points to a hardware model without looking for a particular script name in the package or project.</p>
<h3 id="script-support-in-simics.html:run-time-usage"><a href="#script-support-in-simics.html:run-time-usage">2.3.3.6 Run-time usage</a></h3>
<p>There are two main CLI commands:</p>
<ul>
<li><code>load-target</code>, which can be used to run scripts that have <em>target</em> status, as defined in Section <a class="reference" href="#script-support-in-simics.html:target-definition">2.3.3.5</a>. This command expects a target name as parameter. Available targets is returned by the <code>list-targets</code> command, or when running Simics with the command line flag <code>-l</code>.</li>
<li><code>run-script</code>, which can be used to run scripts specified by file name.</li>
</ul>
<p>Calling <code>load-target</code> with a target name has the same effect as calling <code>run-script</code> on the file that defines the target.</p>
<p>Target names, script file names can also be provided directly to Simics on the command line, in order to run them. Presets for a target can be added using the <code>--preset</code> command line flag.</p>
<p>As mentioned above, the parameters are accessed via a global <code>params</code> object, which has a number of CLI commands as well. These can be discovered using tab completion or by running <code>help</code> on the object.</p>
<h3 id="script-support-in-simics.html:using-parameter-references"><a href="#script-support-in-simics.html:using-parameter-references">2.3.3.7 Using parameter references</a></h3>
<p>Consider the situation where there are two scripts, perhaps hardware and software setup, that are connected by a main target script. Often the software script has parameters that should have the same value as some parameter in the hardware script, and the main script has to make sure this happens.</p>
<p>Here are examples of sub-scripts, <code>alpha.yml</code> and <code>beta.yml</code>.</p>
<pre><code>%YAML 1.2
---
# This is alpha.yml
params:
  foo:
    type: str
    default: alpha
cmd: print(params['foo'])
...
</code></pre>
<pre><code>%YAML 1.2
---
# This is beta.yml
params:
  foo:
    type: str
    required: true
  bar:
    type: int
    required: true
cmd: print(params['foo'])
...
</code></pre>
<p>Without parameter references, the main script can look like this:</p>
<pre><code>%YAML 1.2
---
params:
  bar:
    type: int
    required: true
  alpha:
    import: "%script%/alpha.yml"
  beta:
    import: "%script%/beta.yml"
code-type: simics
cmd: |
  run-script "%script%/alpha.yml" namespace = alpha
  params.setdefault "beta:foo" (params.get "alpha:foo")
  params.setdefault "beta:bar" (params.get "bar")
  run-script "%script%/beta.yml" namespace = beta
...
</code></pre>
<p>Parameter references facilitate avoiding the explicit copying of parameter values, so that the main script can be expressed like this:</p>
<pre><code>%YAML 1.2
---
params:
  bar:
    type: int
    required: true
  alpha:
    import: "%script%/alpha.yml"
  beta:
    import: "%script%/beta.yml"
    defaults:
      foo: ^alpha:foo
      bar: ^bar
code-type: simics
cmd: |
  run-script "%script%/alpha.yml" namespace = alpha
  run-script "%script%/beta.yml" namespace = beta
...
</code></pre>
<h2 id="script-support-in-simics.html:scripting-using-python"><a href="#script-support-in-simics.html:scripting-using-python">2.3.4 Scripting Using Python</a></h2>
<p>The Intel® Simics® simulator provides support for the script language Python (<a href="http://www.python.org" rel="noopener noreferrer" target="_top">http://www.python.org</a>). By using Python the user can extend the simulator, and control it in greater detail. Python code can use functions from the simulator's API.</p>
<h3 id="script-support-in-simics.html:python-in-the-intel-simics-simulator"><a href="#script-support-in-simics.html:python-in-the-intel-simics-simulator">2.3.4.1 Python in the Intel® Simics® Simulator</a></h3>
<p>The Intel® Simics® simulator always contains a Python environment. The simulator's command line interface (CLI) and all commands are implemented in Python. To find the code executed by a command, one can search the Python - <code>.py</code> - files of the corresponding module for the calls to the <code>new_command</code>, <code>new_info_command</code>, and <code>new_status_command</code> functions.</p>
<p>To execute Python code directly from the simulator's CLI, Python code that is to be executed should be prefixed with the <strong>@</strong> character:</p>
<pre><code class="language-simics">simics&gt; <strong>@print("This is a Python line")</strong>
This is a Python line
simics&gt;
</code></pre>
<p>For code spanning more than one line, the prompt will change to <code>.......</code> and more code can be inserted until an empty line is entered. The full code block will then be executed (note that whitespace indentation is significant in Python):</p>
<pre><code class="language-simics">simics&gt; <strong>@if SIM_number_processors() &gt; 1:</strong>
.......     print("Wow, an MP system!")
....... else:
.......     print("Only single pro :-(")
.......
Wow, an MP system!
simics&gt;
</code></pre>
<p>Entering more than one line is useful for defining Python functions. It is also possible to execute Python code from a file, which is done with the <code>run-script</code> command.</p>
<p>If the Python code is an expression that should return a value to the CLI, the <code>python</code> command can be used, or the expression can be back-quoted. The following example selects a file with Python commands to execute depending on the number of processors in the system:</p>
<pre><code class="language-simics">simics&gt; <strong>run-script `"abc-%d.py" % SIM_number_processors()`</strong>
</code></pre>
<p>If the system has 2 processors, the file <code>abc-2.py</code> will be executed.</p>
<p>One can switch the simulator's CLI to Python mode with the <code>python-mode</code> command. In Python mode, indicated by</p>
<pre><code class="language-simics">simics&gt;&gt;&gt;
</code></pre>
<p>prompt, all input is interpreted as Python code, not as simulator's CLI commands. In Python mode, Python code lines should not be prefixed with the <strong>@</strong> character, since that is only used in CLI mode to interpret input as Python code. Example:</p>
<pre><code class="language-simics">simics&gt; <strong>python-mode</strong>
Entering Python mode. Use cli_mode() or Ctrl-D to return to CLI.
simics&gt;&gt;&gt;
</code></pre>
<p>Now Python code can be entered directly:</p>
<pre><code>simics&gt;&gt;&gt; print(f"Simics base package version: {SIM_version_base()}")
Simics base package version: Simics ...
None
simics&gt;&gt;&gt;
</code></pre>
<p>As it was pointed above, to exit Python mode, one can use the <code>cli_mode</code> function or simply enter Ctrl-D:</p>
<pre><code>simics&gt;&gt;&gt; cli_mode()  # we run cli_mode here. Alternatively, enter Ctrl-D
Command line is now in CLI mode.
None
simics&gt;
</code></pre>
<h3 id="script-support-in-simics.html:accessing-cli-variables-from-python"><a href="#script-support-in-simics.html:accessing-cli-variables-from-python">2.3.4.2 Accessing CLI Variables from Python</a></h3>
<p>CLI variables can be accessed from Python via the <code>simenv</code> namespace, for example:</p>
<pre><code class="language-simics">simics&gt; <strong>$cpu = "processor"</strong>
simics&gt; <strong>@simenv.cpu = simenv.cpu.capitalize()</strong>
simics&gt; <strong>$cpu</strong>
Processor
</code></pre>
<p>As we could see in the example, <code>simenv</code> is imported into global namespace by default, but if it is needed elsewhere, it can be imported from the <code>cli</code> module.</p>
<h3 id="script-support-in-simics.html:accessing-the-configuration-from-python"><a href="#script-support-in-simics.html:accessing-the-configuration-from-python">2.3.4.3 Accessing the Configuration from Python</a></h3>
<h4 id="script-support-in-simics.html:configuration-objects"><a href="#script-support-in-simics.html:configuration-objects">2.3.4.3.1 Configuration Objects</a></h4>
<p>All configuration objects are visible as objects in Python. The global Python module <code>conf</code> holds the top level namespace, which contains all top level objects. The objects contain all their subobjects as attributes.</p>
<p>The configuration objects also expose their attributes as Python attributes. The attributes can be accessed via the <code>attr</code> attribute, or, in a legacy way, directly as Python object attributes. Thus the attributes can be both read and written as Python attributes. The following example prints the <code>size</code> attribute from the <code>board.mb.rom_image</code> object of the <code>image</code> class:</p>
<pre><code class="language-simics">simics&gt; <strong>@conf.board.mb.rom_image.attr.size</strong>
262144
</code></pre>
<p>Here is a legacy way to access the same attribute:</p>
<pre><code class="language-simics">simics&gt; <strong>@conf.board.mb.rom_image.size</strong>
262144
</code></pre>
<p>We recommend to access Simics objects' attributes via the <code>attr</code> attribute, except for a few commonly used attributes like <code>name</code> and <code>classname</code>.</p>
<p>If an object contains a subobject and an attribute with the same name, the subobject takes precedence and hides the attribute.</p>
<p>To try the previous example in an arbitrary configuration, run <code>list-objects -all image</code> to find available objects of the <code>image</code> class to use instead of the <code>board.mb.rom_image</code> object.</p>
<p>Any '<code>-</code>' (dash) character in the object name, or in an attribute name, is replaced by '<code>_</code>' (underscore). This substitution is performed because Python always treats the dash character as the minus operator. To avoid confusion the recommendation is to always use underscore.</p>
<p>Indexed attributes can be accessed using <code>[]</code> indexing in Python. It is also possible to index other list attributes this way, but it might be inefficient since the full list is converted to a Python list before the element is extracted. Here are some examples of indexed attributes access (a <code>pcie-bus</code> object, and a <code>memory-space</code> object):</p>
<pre><code class="language-simics">simics&gt; <strong>@conf.board.mb.nb.pci_bus.attr.pci_devices[0]</strong>
[29, 1, &lt;the ich10_usb_uhci 'board.mb.sb.uhci[1]'&gt;, 1]

simics&gt; <strong>@conf.board.mb.phys_mem.attr.memory[0x100:0x10f]</strong>
(89, 236, 0, 240, 61, 0, 0, 158, 83, 255, 0, 240, 144, 37, 0)

simics&gt; <strong>@conf.board.mb.phys_mem.attr.memory[0x10000:0x10003] = (100, 101, 102)</strong>
</code></pre>
<p>If the attribute contains a list, dictionary or data, then an access returns a reference instead of the actual value. This is similar to how container objects such as lists and dictionaries work in Python and allows constructs such as:</p>
<pre><code class="language-simics">simics&gt; <strong>@conf.board.mb.phys_mem.attr.map[0][0] = 0x1000</strong>
</code></pre>
<p>The example modifies the attribute at position [0][0]. To get the copy of the attribute value, the following can be used:</p>
<pre><code class="language-simics">simics&gt; <strong>@memory_map = conf.board.mb.phys_mem.attr.map.copy()</strong>
</code></pre>
<p>Note that there is a difference in how references to Simics attributes work compared to ordinary Python objects: if the attribute access returns a list, dictionary or tuple, then a reference to the full attribute is used and not only to the referenced container objects. The reason is that internally in Simics, the attribute is treated as a single value.</p>
<p>Consider a list of lists, such as <code>a = [[1, 2, 3], [4, 5, 6]]</code>. If this was a Python list, then the following applies:</p>
<pre><code>b = a[0]       # b is a reference to the [1, 2, 3] list.
a[0][1] = 9    # b will now change to [1, 9, 3].
a[0] = [7, 8]  # b still references the [1, 9, 3] list, only a will change.
</code></pre>
<p>If <code>a</code> instead is a Simics attribute:</p>
<pre><code>b = a[0]       # b is a reference to the first list in a, i.e. [1, 2, 3].
a[0][1] = 9    # b will now change to [1, 9, 3].
a[0] = [7, 8]  # b is still a reference to the first list in a, i.e [7, 8].
</code></pre>
<p>As we see, only the last line of the examples differs. The most common situation where this difference is visible is when doing list duplication. In Python a list can be duplicated in whole or part by using slicing to produce a shallow copy. In Simics, that would simply produce a reference to the same list if any of the items in the list is a container object. In this case the <code>.copy()</code> method has to be used.</p>
<h4 id="script-support-in-simics.html:interfaces"><a href="#script-support-in-simics.html:interfaces">2.3.4.3.2 Interfaces</a></h4>
<p>From Python, the <code>iface</code> attribute of a configuration object can be used to access the interfaces it exports. Use <code>obj.iface.name.method</code> to accesses the <code>method</code> function in the <code>name</code> interface of the <code>obj</code> object. Example:</p>
<pre><code class="language-simics">simics&gt; <strong>@conf.board.mb.cpu0.core[0][0].iface</strong>
&lt;interfaces of board.mb.cpu0.core[0][0]&gt;
simics&gt; <strong>@conf.board.mb.cpu0.core[0][0].iface.processor_info</strong>
&lt;processor_info_interface_t interface of board.mb.cpu0.core[0][0]&gt;
simics&gt; <strong>@conf.board.mb.cpu0.core[0][0].iface.processor_info.get_program_counter</strong>
&lt;built-in method logical_address_t (*)([conf_object_t *]) of interface method object at 0x5cb2070&gt;
simics&gt; <strong>@hex(conf.board.mb.cpu0.core[0][0].iface.processor_info.get_program_counter())</strong>
'0xfff0'
</code></pre>
<div class="note">
<p>When called from Python, the first <code>conf_object_t *</code> argument for interface methods should not be used: it is passed automatically.</p>
</div>
<p>The last command corresponds to the following C code (with no error-checking):</p>
<pre><code class="language-C">conf_object_t *obj = SIM_get_object("board.mb.cpu0.core[0][0]");
processor_info_interface_t *iface = 
        SIM_get_interface(obj, PROCESSOR_INFO_INTERFACE);
logical_address_t pc = iface-&gt;get_program_counter(obj);
printf("0x%llx", pc);
</code></pre>
<h4 id="script-support-in-simics.html:ports-and-banks"><a href="#script-support-in-simics.html:ports-and-banks">2.3.4.3.3 Ports and Banks</a></h4>
<p>Port objects in Simics represent ports and banks. For scripting access to objects they work exactly as a sub-object. By convention they are placed in the <code>port</code> and <code>bank</code> namespaces under the object.</p>
<p>Use <code>obj.port.portname.iface.interfacename.method</code> or <code>obj.bank.bankname.iface.interfacename.method</code> to access interface methods in a port object.</p>
<pre><code class="language-simics">simics&gt; <strong>@conf.board.mb.sb.com[0].port</strong>
&lt;the namespace 'board.mb.sb.com[0].port'&gt;
simics&gt; <strong>@conf.board.mb.sb.com[0].port.HRESET</strong>
&lt;the NS16550.HRESET 'board.mb.sb.com[0].port.HRESET'&gt;
simics&gt; <strong>@conf.board.mb.sb.com[0].port.HRESET.iface</strong>
&lt;interfaces of board.mb.sb.com[0].port.HRESET&gt;
simics&gt; <strong>@conf.board.mb.sb.com[0].port.HRESET.iface.signal</strong>
&lt;signal_interface_t interface of board.mb.sb.com[0].port.HRESET&gt;
simics&gt; <strong>@conf.board.mb.sb.com[0].port.HRESET.iface.signal.signal_raise</strong>
&lt;built-in method void (*)([conf_object_t *NOTNULL]) of interface method object at 0x7f90f32f5310&gt;
simics&gt; <strong>@conf.board.mb.sb.com[0].port.HRESET.iface.signal.signal_raise()</strong>
</code></pre>
<p>The last command corresponds to the following C code (with no error-checking):</p>
<pre><code class="language-C">conf_object_t *obj = SIM_get_object("board.mb.sb.com[0].port.HRESET");
signal_interface_t *iface = 
        SIM_get_interface(obj, SIGNAL_INTERFACE);
iface-&gt;signal_raise(obj);
</code></pre>
<h4 id="script-support-in-simics.html:port-interfaces"><a href="#script-support-in-simics.html:port-interfaces">2.3.4.3.4 Port Interfaces</a></h4>
<p>Simics also has a legacy mechanism for providing named entry points to objects, called port interfaces. This mechanism is still used by some models. Named port interfaces are referenced from other objects using a list of <code>[object, portname]</code> instead of just a single object reference. Port interfaces are accessed from Python in a similar way to interfaces.</p>
<p>Use <code>obj.ports.portname.interfacename.method</code> to access the <code>interfacename</code> interface in port <code>portname</code> of the object <code>obj</code>. Example:</p>
<pre><code class="language-simics">simics&gt; <strong>@conf.board.mb.cpu0.core[0][0].ports</strong>
&lt;ports of board.mb.cpu0.core[0][0]&gt;
simics&gt; <strong>@conf.board.mb.cpu0.core[0][0].ports.RESET</strong>
&lt;interfaces of port RESET of board.mb.cpu0.core[0][0]&gt;
simics&gt; <strong>@conf.board.mb.cpu0.core[0][0].ports.RESET.signal</strong>
&lt;signal_interface_t interface of board.mb.cpu0.core[0][0]&gt;
simics&gt; <strong>@conf.board.mb.cpu0.core[0][0].ports.RESET.signal.signal_raise</strong>
&lt;built-in method void (*)([conf_object_t * NOTNULL]) of interface method object at 0x5cb22d0&gt;
simics&gt; <strong>@conf.board.mb.cpu0.core[0][0].ports.RESET.signal.signal_raise()</strong>
</code></pre>
<p>The last command corresponds to the following C code:</p>
<pre><code class="language-C">conf_object_t *obj = SIM_get_object("board.mb.cpu0.core[0][0]");
signal_interface_t *iface = 
        SIM_get_port_interface(obj, SIGNAL_INTERFACE, "RESET");
iface-&gt;signal_raise(obj);
</code></pre>
<h3 id="script-support-in-simics.html:accessing-command-line-commands-from-python"><a href="#script-support-in-simics.html:accessing-command-line-commands-from-python">2.3.4.4 Accessing Command Line Commands from Python</a></h3>
<p>At times, it can be useful to access command line commands from a Python script file. This can be done in two ways which are described below.</p>
<p>The first way to access command-line commands from Python is to use
the <code>run_command(cli_string)</code> function, which takes a string which is
then evaluated by the command line front-end. For example, write
<code>run_command("list-objects")</code> to execute the <code>list-objects</code>
command. Any return value from the command is returned to
Python. There is also the <code>quiet_run_command</code> function, which captures
any output produced by the command and returns a tuple with the
command return value as first entry, and the text output as the
second. More details about both functions can be found in the <a href="../reference-manual-api/command-line-interface.html#CLI-Classes-and-Functions">CLI
Classes and
Functions</a>
in the <a href="../reference-manual-api/index.html">API Reference Manual</a>.</p>
<p>The second way to access command line commands from Python is to use
wrapper functions from two special namespaces. The first namespace is
<code>global_cmds</code> (provided by the <code>cli</code> module). It allows to run
commands which are not tied to any Simics object. For example, the
<code>list-objects</code> command can be executed as
<code>global_cmds.list_objects()</code>. The commands which are tied to Simics
objects (namespace commands) can be executed via the <code>cli_cmds</code>
namespaces which can be accessed through a Python object representing
a Simics objects. For example, the <code>sim.info</code> command can be executed
as <code>conf.sim.cli_cmds.info()</code>.</p>
<ul>
<li>The wrapper function name is usually the same as the name of the command it executes with hyphens replaced with underscores.</li>
<li>The parameters of the wrapper functions are the same as of the corresponding command (again, with hyphens replaced with underscores).</li>
<li>Command flags (the names of the corresponding function parameters start with an underscore) are passed as Python Boolean values.</li>
<li>In the rare case that a wrapper function name or a wrapper function parameter name collides with a Python keyword, the <code>_cmd</code> suffix is appended to the wrapper function name, and the function parameter gets the <code>_</code> suffix.</li>
<li>Wrapper functions return the value returned by the command which they execute.</li>
<li>Wrapper functions have Python docstrings which can be used to get information about the function and its parameters, e.g., by running <code>@help(conf.sim.cli_cmds.info)</code>. The docstrings complement the CLI command documentation (to access the documentation of a command one can run "help <em>command-name</em>" command at Simics CLI).</li>
</ul>
<p>Please note that Simics command-line commands are defined to only be executed in the Simics API execution context known as Global Context. If a command is executed while not in Global Context then Simics will stop with an error message. Though, this doesn't happen often in practice; usually only when CLI commands are be called directly from user callbacks installed for haps or notifiers, or from device models. For more information about Simics execution contexts and how to get to Global Context, please see section "API Execution Contexts" in the Simics API reference manual.</p>
<h3 id="script-support-in-simics.html:the-script-branch-api"><a href="#script-support-in-simics.html:the-script-branch-api">2.3.4.5 The Script Branch API</a></h3>
<p>Script branches can be manipulated from Python using the script branch API. A script branch can be created using <code>sb_create</code>, passing a Python function that defines the script branch.</p>
<p>From the script branch Python function, one can use <code>sb_wait</code> to suspend the script branch. From somewhere else, the branch can be woken up again by calling <code>sb_signal_waiting</code>. Thus one can make the script branch wait on arbitrary conditions. Example:</p>
<pre><code>def script_branch(data):
    print("Branch start")
    wait_id = cli.sb_get_wait_id()
    data.append(wait_id)
    cli.sb_wait("wait", wait_id)
    print("Branch done")

data = []
print("Create branch")
cli.sb_create(lambda: script_branch(data))
wait_id = data[0]
time.sleep(1)
print("Signal branch")
cli.sb_signal_waiting(wait_id)
</code></pre>
<p>One can also access the existing script wait functionality using the ability to run any CLI command, described in <a class="reference" href="#script-support-in-simics.html:accessing-command-line-commands-from-python">2.3.4.4</a>. As an example:</p>
<pre><code># Sample script branch stopping simulation after 5 cycles
# executed on the clock object.
def script_branch():
    clock.cli_cmds.wait_for_cycle(cycle = 5, _relative = True)
    cli.global_cmds.stop()

cli.sb_create(script_branch)
</code></pre>
<h3 id="script-support-in-simics.html:the-simics-api"><a href="#script-support-in-simics.html:the-simics-api">2.3.4.6 The Simics API</a></h3>
<p>The Simics API is a set of functions that provide access to Simics functionality from loadable modules (i.e., devices and extensions), and Python scripts. All functions in the Simics API have a name that starts with "<code>SIM_</code>". They are described in details in the <a href="../reference-manual-api/index.html">API Reference Manual</a>.</p>
<p>By using the <code>api-help</code> and <code>api-search</code> commands you can get the declarations for API functions and data types. <code>api-help     identifier</code> will print the declaration of <code>identifier</code>. <code>api-search     identifier</code> lists all declarations where <code>identifier</code> appears.</p>
<p>Note that while <code>api-help topic</code> does the same thing as <code>help api:topic</code>, the <code>help-search</code> command will not search through the API declarations.</p>
<p>The Simics API functions are available in the <code>simics</code> Python module. This module is imported into the Python environment in the frontend when Simics starts. However, for user-written <code>.py</code> files, the module must be imported explicitly:</p>
<pre><code>from simics import *
</code></pre>
<p>Errors in API functions are reported back to the caller using <em>frontend exceptions</em>. The exception is thrown together with a string that describes the problem more in detail. Examples of exceptions are <code>SimExc_General</code>, <code>SimExc_Memory</code>, <code>SimExc_Index</code>, and <code>SimExc_IOError</code>. In DML and C/C++, these exceptions have to be tested for using <code>SIM_clear_exception</code> or <code>SIM_get_pending_exception</code>. In Python, such exceptions result in regular Python exceptions.</p>
<p>For the Python environment, Simics defines an exception subclass for each of its defined exceptions in the <code>simics</code> module. These are raised to indicate exceptions inside the API functions. When errors occur in the interface between Python and the underlying C API function, the standard Python exceptions are used; e.g., if the C API function requires an <code>int</code> argument, and the Python function is called with a <code>tuple</code>, a Python <code>TypeError</code> exception is raised.</p>
<h3 id="script-support-in-simics.html:haps"><a href="#script-support-in-simics.html:haps">2.3.4.7 Haps</a></h3>
<p>A <em>hap</em> is an event or occurrence in Simics with some specific semantic meaning, either related to the target or to the internals of the simulator.</p>
<p>Examples of simulation haps are:</p>
<ul>
<li>Exception or interrupt</li>
<li>Control register read or write</li>
<li>Breakpoint on read, write, or execute</li>
<li>Execution of a magic instruction (see the <a href="#debug.html:magic-instructions-and-magic-breakpoints">Magic Instructions and Magic Breakpoints</a></li>
<li>Device access</li>
</ul>
<p>There are also haps which are related to the simulator, e.g., (re)starting the simulation or stopping it and returning to prompt.</p>
<div class="note">
<p>In the Simics documentation, the word <em>event</em> is used exclusively for events that occur at a specific point in simulated time, and <em>hap</em> for those that happen in response to other specific conditions (like a state change in the simulator or in the simulated machine).</p>
</div>
<p>A callback can be invoked for all occurrences of the hap, or for a specified range. This range can be a register number, an address, or an exception number, depending on the hap.</p>
<p>A complete reference of the haps available in Simics can be found in the <a href="../reference-manual-api/haps-chapter.html">Haps</a> in the <a href="../rm-base/index.html">Simics Reference Manual</a>.</p>
<h4 id="script-support-in-simics.html:example-of-python-callback-on-a-hap"><a href="#script-support-in-simics.html:example-of-python-callback-on-a-hap">2.3.4.7.1 Example of Python Callback on a Hap</a></h4>
<p>This example uses functions from the Simics API to install a callback on the hap that occurs when a control register is written. It is intended to be part of a <code>.simics</code> script, that extends an <code>QSP-x86</code> machine setup. The <code>SIM_hap_add_callback_index()</code> function sets the index of the control register to listen to, in this case the <code>%ia32_feature_control</code> register in an x86-intel64-turbo processor.</p>
<pre><code>@ia32_feature_control_reg_no = conf.board.mb.cpu0.core[0][0].iface.int_register.get_number("ia32_feature_control")

# print the new value when %ia32_feature_control is changed
@def ctrl_write_ia32_feature_control(user_arg, cpu, reg, val):
    print("[%s] Write to %%ia32_feature_control: 0x%x" % (cpu.name, val))

# install the callback
@SIM_hap_add_callback_index("Core_Control_Register_Write",
                            ctrl_write_ia32_feature_control, None,ia32_feature_control_reg_no)
</code></pre>
<p>In CLI, the same example would look like:</p>
<pre><code class="language-simics">simics&gt; <strong>script-branch {</strong>
    local $cpu = (pselect)
    while TRUE {
        $cpu.bp-wait-for-control-register -w ia32_feature_control
        echo "[" + $cpu + "] Write to %ia32_feature_control: "+ ((hex ($cpu.read-reg ia32_feature_control)))
    }
}
</code></pre>
<h4 id="script-support-in-simics.html:example-of-python-callback-on-core_log_message_extended-hap"><a href="#script-support-in-simics.html:example-of-python-callback-on-core_log_message_extended-hap">2.3.4.7.2 Example of Python Callback on Core_Log_Message_Extended Hap</a></h4>
<p>This example shows how to add a callback to the Core_Log_Message_Extended. This allows for better control when handling log messages. This example writes all log messages to a file that is associated with the <code>cpu</code> object.</p>
<div class="note">
<p>The Core_Log_Message_Extended hap will only be triggered for messages with log level less than or equal to the log level setting of the object.</p>
</div>
<pre><code>from simics import *

class file_log:

    def __init__(self, fname, obj, level):
        # setup logging
        try:
            self.f = open(fname, 'w')
        except Exception as msg:
            raise Exception("Failed to open file %s, %s" % (fname, msg))
        self.obj = obj
        self.level = level

        # install the callback
        SIM_hap_add_callback_obj(
            "Core_Log_Message_Extended", obj, 0, self.log_callback, None)

    def log_callback(self, not_used, obj, log_type, message, level, group):
        type_str = conf.sim.log_types[log_type]
        if level &lt;= self.level:
            self.f.write("[%s %s] %s,  level=%d, group=%d\n" % (
                    obj.name, type_str, message, level, group))

file_log('log_cpu.out', conf.board.mb.cpu0.core[0][0], 1)
</code></pre>
<h2 id="script-support-in-simics.html:simics-as-python-module"><a href="#script-support-in-simics.html:simics-as-python-module">2.3.5 Simics as Python module</a></h2>
<p>Simics is built and exposed as a Python extension module (<a href="https://docs.python.org/3/extending/extending.html" rel="noopener noreferrer" target="_top">https://docs.python.org/3/extending/extending.html</a>). This means that the Python module <code>simics</code> can be imported into any Python, and hence Simics can be easily integrated into a Python-based software project in a similar way as any other Python package.</p>
<p>As examples of how to use this, we exhibit two ways to boot to an UEFI shell using the QSP-x86 package and a user provided Python. The examples use a Linux host, but the steps are analogous on Windows. The examples assume that the necessary Simics packages have been installed and a Simics project created.</p>
<p>The first example shows how to run a Python script booting QSP using a host Python 3.10. The environment variable <code>PYTHONPATH</code> must be set to make Python find the Simics Python module and the <code>site-packages</code> directory that is included in Simics-Base.</p>
<p>Precise paths will naturally not be like in the example when run elsewhere.</p>
<pre><code>$ ./simics  -v
Simics Base             1000    7.0.0     (7006) 2023-12-14
Quick-Start Platform    2096    7.0.0     (7006) 2023-12-14

$ cat qsp.py 
import simics
import conf
import cli
# Turn off all log messages
cli.global_cmds.log_level(level=0)
# Make Simics quit after boot
conf.sim.batch_mode = True
simics.SIM_load_target("qsp-x86/uefi-shell", "", [], [])
conf.bp.console_string.cli_cmds.run_until(
     object=conf.qsp.serconsole.con, string="Shell&gt; ")
print("QSP boot done")

$ PYTHONPATH=../install/simics-7.0.0/linux64 python3.10 qsp.py
QSP boot done
$ 
</code></pre>
<p>Note that if Simics is not run from the created project, the environment variable <code>SIMICS_INIT_PROJECT</code> must be set to the project path.</p>
<p>The previous example is limited in that it uses the <code>site-packages</code> directory, containing Python modules needed by Simics, distributed in the Simics-Base package. These modules are built for Python 3.10.</p>
<p>The standard way to integrate external Python modules into a Python
software project is to install them using <code>pip</code>. Simics and its
dependent Python modules can be installed in that way using the
generated requirements files in the Simics project.</p>
<p>The second example shows how to do that using Python 3.11 and then boot QSP like in the previous example. In addition to the assumptions in the first example, here we also assume that pip packages can be downloaded and installed. The latter may require various libraries to be installed on the host, as well as header files for the host Python 3.11 being used. Note that we have split up the required packages into two files. Installing the packages in <code>gui-requirements.txt</code> is only needed if you want to use the Simics GUI. Those packages require more libraries on the host, such as <code>libgtk</code>.</p>
<pre><code>$ python3.11 -m venv venv
$ source venv/bin/activate
$ python -m pip install wheel
$ python -m pip install --requirement requirements.txt
$ python -m pip install --requirement gui-requirements.txt
$ python qsp.py
QSP boot done
$ 
</code></pre>
<p>Note that there is nothing inherent in this example that prohibits using Python 3.12 or any other newer Python version. However, difficulties may occur when installing the required Python packages if no pre-built wheels are available.</p>
<h3 id="script-support-in-simics.html:launching-the-simulator-from-your-virtual-environment"><a href="#script-support-in-simics.html:launching-the-simulator-from-your-virtual-environment">2.3.5.1 Launching the simulator from your virtual environment</a></h3>
<p>Above we set up a virtual environment which includes the <em>Simics-Base</em> distribution package and its dependencies.
A distribution package in Python can include several Python packages and modules.
Above we saw the use of the <code>simics</code> package, but it also includes a Python module to launch the simulator called <code>runsimics</code>.</p>
<p>If you have set up and activated your virtual environment as above, then you can launch the simulator from it.</p>
<pre><code>python -m runsimics --project your-project
</code></pre>
<p>This will function the same as the <a href="../rm-base/simics.html"><code>simics</code></a> launcher.
You can pass extra command line arguments to the simulator etc. As <code>runsimics</code>
does not go through the trampoline launch scripts in your project you have
to specify the project manually if you want it.</p>
</section><section class="page" id="configuration.html"><h1 id="configuration.html:configuration-and-checkpointing"><a href="#configuration.html:configuration-and-checkpointing">2.4 Configuration and Checkpointing</a></h1>
<p>Simics includes a <em>configuration system</em> used to describe the state of the simulated machines.</p>
<p>Simics's configuration system is object-oriented: a simulated machine is represented as a set of <em>objects</em> that interact when the simulated time advances. Typically, processors, memories and devices are modeled as objects. Each object is defined by a number of properties that are called <em>attributes</em>. A processor object, for example, will have an attribute called <code>freq_mhz</code> to define its clock frequency (in MHz).</p>
<p>Simics's configuration system is flexible: it is possible to create and delete objects dynamically, as well as access the attributes of all objects for reading and writing at any time.</p>
<p>Simics's configuration system allows its elements to be saved so that a complete simulated machine state can be written to a set of files. This set of files is called a <em>checkpoint</em>.</p>
<p>This chapter describes the Simics configuration system as well as the different layers built on top of it to handle more specific tasks:</p>
<ul>
<li>
<p>Checkpoints: how a simulated state is saved and restored via checkpointing;</p>
</li>
<li>
<p>Inspection: how the simulated state can be examined and changed during simulation;</p>
</li>
<li>
<p>Start Scripts: the components and scripts used to define the initial state of a machine in the examples provided with Simics.</p>
  <div class="note">
<p>Not all kinds of connections with real network, or with real file systems, will continue to work properly if you pause the simulation for a shorter or lengthier time. This applies to most stateful connections, for example NFS, TCP, etc.</p>
<p>For the same reason, not all kinds of connections with the real world can be saved in a checkpoint and successfully restored at a later time. Hence, make a habit to disconnect such services before pausing the simulation, or before saving a checkpoint.</p>
  </div>
</li>
</ul>
<h2 id="configuration.html:basics"><a href="#configuration.html:basics">2.4.1 Basics</a></h2>
<p>As mentioned above, Simics's configuration system is object-oriented. A Simics object is instantiated from a Simics <em>class</em>. The core of Simics defines some useful classes, but most of the classes (processors, device models, statistic gathering extensions) are provided by <em>modules</em> that are loaded by the simulator when requested.</p>
<p>For example, the <code>x86-p4</code> module defines, not surprisingly, the <code>x86-p4</code> class. Note that a module may define several classes. Since modules advertise the classes they define, Simics can load modules transparently as objects are instantiated.</p>
<p>A class defines <em>attributes</em> that represent both the static and dynamic state of the instantiated objects. The static state includes information that does not change during the simulation (like a version number in a register) while the dynamic state covers the part of the device that are affected by the simulation (registers, internal state, buffers, etc.).</p>
<p>Let us take the example of an x86-p4 processor and have a closer look at how it can be configured using attributes:</p>
<ul>
<li>We can create an object instantiated from the class <code>x86-p4</code>. Let us call it <code>cpu0</code></li>
<li>The attribute <code>freq_mhz</code> can be set to 1500. It defines the processor clock frequency (in MHz)</li>
<li>The attribute <code>physical_memory</code> can be set to a memory space object, such as <code>phys_mem0</code>. This attribute points to the object that will answer to the memory accesses coming from the processor.</li>
</ul>
<p>As you noticed, attributes may be of various types. A complete description is available in the next section.</p>
<h2 id="configuration.html:checkpointing"><a href="#configuration.html:checkpointing">2.4.2 Checkpointing</a></h2>
<p>Simics's configuration system can save the complete state of a simulation in a portable way. This functionality is known as <em>checkpointing</em>, and the set of files that represent the elements of the systems are called a <em>checkpoint</em>.</p>
<p>Saving and restoring a checkpoint can be done from the command line with the <code>write-configuration</code> and <code>read-configuration</code> commands.</p>
<p>A checkpoint consists of the following files, collected under a directory:</p>
<ul>
<li>A main <em>configuration file</em>, named <code>config</code>. This is a text representation of the objects present in the system.</li>
<li>Optional image files (described in section <a class="reference" href="#configuration.html:images">2.4.2.3</a>), named after each respective image object.</li>
</ul>
<p>Below is a portion of a checkpoint file showing an object. Saved objects are always represented as <code>OBJECT</code> <em>object-name</em> <code>TYPE</code> <em>class-name</em> <code>{</code> <em>attributes</em> <code>}</code>. In this case we have an instance of the <code>DEC21143</code> class (fast Ethernet LAN controller interfacing the PCI bus) named <code>dec0</code>. The attribute <code>pci_bus</code> is used to connect the device to the PCI bus.</p>
<pre><code>OBJECT dec0 TYPE DEC21143 {
        queue: cpu0
        component: eth_adapter_cmp0
        component_slot: "dec"
        object_id: "dec0"
        build_id: 0xbb9
        pci_bus: pci_bus0
        ...
}
OBJECT ... TYPE ... {
...
</code></pre>
<p>Objects are saved in the main checkpoint file in no specific order.</p>
<h3 id="configuration.html:compatibility"><a href="#configuration.html:compatibility">2.4.2.1 Compatibility</a></h3>
<p>Simics maintains checkpoint compatibility with older versions, i.e. it is always possible to continue using checkpoints created in a previous version of Simics when upgrading to a new version. Compatibility is always maintained for one major version older than the oldest of the supported API versions. For checkpoints older than that, load the checkpoint with a newer version of Simics and create a new checkpoint.</p>
<p>The opposite is not true. Trying to load a checkpoint created in a newer version of Simics than the local version will typically not work. The same restriction may apply even between minor Simics releases. For example, a checkpoint created with Simics 3.2.2 is not guaranteed to load correctly in the older Simics 3.2.1 release.</p>
<h3 id="configuration.html:attributes"><a href="#configuration.html:attributes">2.4.2.2 Attributes</a></h3>
<p>The short example of the <code>dec0</code> description only uses a few types of attribute values: strings, objects, and hexadecimal integers. The possible attribute types are:</p>
<div class="dl">
<ul>
<li><span class="term" id="configuration.html:dt:string"><a href="#configuration.html:dt:string">string</a></span><br>
Strings are enclosed in double quotes, with C-style control characters: <code>"a string\n"</code></li>
<li><span class="term" id="configuration.html:dt:integer"><a href="#configuration.html:dt:integer">integer</a></span><br>
Integers can be in hexadecimal (<code>0xfce2</code>) or signed decimal (<code>-17</code>) notation.</li>
<li><span class="term" id="configuration.html:dt:boolean"><a href="#configuration.html:dt:boolean">boolean</a></span><br>
One of <code>TRUE</code> and <code>FALSE</code>.</li>
<li><span class="term" id="configuration.html:dt:floating-point"><a href="#configuration.html:dt:floating-point">floating-point</a></span><br>
Specified in decimal (<code>1.0e-2</code>) or hexadecimal (<code>0x5.a21p-32</code>) style, just like in C.</li>
<li><span class="term" id="configuration.html:dt:object"><a href="#configuration.html:dt:object">object</a></span><br>
The name of a configuration object: <code>cpu0</code>.</li>
<li><span class="term" id="configuration.html:dt:list"><a href="#configuration.html:dt:list">list</a></span><br>
Comma-separated list of any attribute values, enclosed in parentheses. Example: <code>("a string", 4711, (1, 2, 3), cpu0)</code></li>
<li><span class="term" id="configuration.html:dt:dictionary"><a href="#configuration.html:dt:dictionary">dictionary</a></span><br>
The format is a comma-separated list of key/value pairs, like in: <code>{ "master-cpu" : cpu0, "slave-cpu" : cpu1 }</code>. The key should be a string, integer or object, while the value can be of any attribute type. Dictionaries are typically used to save Python dictionaries in a checkpoint. Keys must be unique, although Simics does not enforce this.</li>
</ul>
</div>
<p>Each attribute belongs to one of the following categories. Note that only attributes of the first two categories are saved in checkpoints.</p>
<div class="dl">
<ul>
<li><span class="term" id="configuration.html:dt:required"><a href="#configuration.html:dt:required">Required</a></span><br>
Required attributes must be set when creating an object. They are saved in checkpoints. If you edit a checkpoint, you should never remove a required attribute—Simics will complain and refuse to load the checkpoint if you do.</li>
<li><span class="term" id="configuration.html:dt:optional"><a href="#configuration.html:dt:optional">Optional</a></span><br>
If no other value is provided, optional attributes take their default value when the object is created. They are saved in checkpoints, but if you edit them out they will revert to their default value when the checkpoint is loaded.</li>
<li><span class="term" id="configuration.html:dt:pseudo"><a href="#configuration.html:dt:pseudo">Pseudo</a></span><br>
Pseudo attributes are not saved in checkpoints and usually contain read-only information that does not change, or that is calculated when the attribute is accessed. Pseudo attributes are in some cases used to trigger state changes in the object when written.</li>
</ul>
</div>
<h3 id="configuration.html:images"><a href="#configuration.html:images">2.4.2.3 Images</a></h3>
<p>Simics implements a special class called <code>image</code> for objects that potentially need to save a huge amount of state, like memories and disks. An image represents a big amount of raw data using pages and compression to minimize disk usage.</p>
<p>To save space and time, images do not necessarily save their entire state every time a checkpoint is written. They can work in several ways:</p>
<ul>
<li>Images can save their state <em>incrementally</em>. At each checkpoint, an image saves the difference between its current state and the previously saved state (either the previous checkpoint or the initial state). This is the default behavior implemented by Simics. This allows several checkpoints to be saved and restored using the same base image and a series of difference files.</li>
<li>Images can save their entire current state in the checkpoint. This results in an <em>independent checkpoint</em>, which does not depend on the base image or on earlier checkpoints, and can therefore be easily moved around or shared. However, independent checkpoints are typically much larger than incremental ones, and can be time consuming to save.</li>
<li>Images can be used as <em>read-write</em> media. In that case the file representing the data is always up to date to the current state. However, this prevents the image from being used in a previously saved incremental checkpoint or initial state, since its contents are modified as the simulation advances. When images are used in this way, only independent checkpoints can be saved.</li>
</ul>
<p>It is important to understand that when used in incremental mode, images create <em>dependencies</em> between checkpoints. A checkpoint can only be loaded if all previous checkpoints are intact.</p>
<p>As an example, let us have a look at an assumed disk image:</p>
<pre><code>...
}
OBJECT disk0_image TYPE image {
        ...
	files: (("tango1-fedora5.craff", "ro", 0, 0x4c5abc000, 0),
                ("disk0_image.craff", "ro", 0, 0x4c5abc000, 0))
        ...
}
...
</code></pre>
<p>The checkpointed image is based on the file <code>tango1-fedora5.craff</code>, on top of which is added the file <code>disk0_image.craff</code> that contains the difference between the checkpoint and the initial state.</p>
<p>Files like <code>disk0_image.craff</code> are often called <em>diff files</em> because they contain the difference between the new state and the previous state.</p>
<h4 id="configuration.html:image-search-path"><a href="#configuration.html:image-search-path">2.4.2.3.1 Image Search Path</a></h4>
<p><em>This section contains more in-depth explanations about image handling that you may skip when reading this guide for the first time</em>.</p>
<p>When successive incremental checkpoints are saved, an image object may become dependent on several diff files present in different directories. To keep track of all files, Simics stores in the checkpoint a <em>checkpoint path</em> list that contains the absolute directory paths where image files may be found. Image file names are then saved as <code>%n%\filename</code> where <code>%n%</code> represents the number of the entry in the checkpoint path, counting from zero.</p>
<div class="note">
<p>Simics's checkpoint path is different from Simics's search path (see section <a class="reference" href="#cli.html:simics-s-search-path">2.2.4</a>), although both will be used when looking for image files, as show below.</p>
</div>
<div class="note">
<p>Independent checkpoints do not affect the checkpoint path.</p>
</div>
<p>To summarize, when loading a checkpoint or a new configuration, Simics looks for images in the following way:</p>
<ul>
<li>
<p>If the filename does not contain any path information (like <code>image.craff</code>) or contains a relative path (like <code>test\image.craff</code>), the file is looked up <em>first</em> from the checkpoint directory, <em>then</em> from all the path entries in Simics's search path, <em>in order</em> (see also section <a class="reference" href="#cli.html:simics-s-search-path">2.2.4</a> for more information).</p>
  <div class="dl">
<ul>
<li><span class="term" id="configuration.html:dt:windows-example"><a href="#configuration.html:dt:windows-example">Windows example;</a></span><br>
If Simics's search path contains <code>[project]\targets\qsp-x86\</code> and the checkpoint is located in <code>C:\checkpoints</code>, Simics will look for the file <code>test\image.craff</code> in the following places:
<ol>
<li><code>C:\checkpoints\test\image.craff</code></li>
<li><code>[project]\targets\qsp-x86\test\image.craff</code></li>
</ol>
</li>
</ul>
<ol>
<li><span class="term" id="configuration.html:dt:linux-example"><a href="#configuration.html:dt:linux-example">Linux example;</a></span><br>
If Simics's search path contains <code>[project]/targets/qsp-x86/</code> and the checkpoint is located in <code>/home/joe/checkpoints/</code>, Simics will look for the file <code>test/image.craff</code> in the following places:
<ol>
<li><code>/home/joe/checkpoints/test/image.craff</code></li>
<li><code>[project]/targets/qsp-x86/test/image.craff</code></li>
</ol>
</li>
</ol>
  </div>
</li>
</ul>
<ol>
<li>
<p>If the filename contains a checkpoint path marker (<code>%n%</code>), the marker is translated using Simics's checkpoint path and the file is looked up in the corresponding path.</p>
 <div class="dl">
<ul>
<li><span class="term" id="configuration.html:dt:windows-example-2"><a href="#configuration.html:dt:windows-example-2">Windows example;</a></span><br>
If Simics's checkpoint path contains<br>
<code>C:\checkpoints\c1;C:\checkpoints\c2</code>, the file <code>%1%/image.craff</code> will be translated into <code>C:\checkpoints\c2\image.craff</code>.</li>
<li><span class="term" id="configuration.html:dt:linux-example-2"><a href="#configuration.html:dt:linux-example-2">Linux example;</a></span><br>
If Simics's checkpoint path contains <code>/home/joe/c1:/home/joe/c2</code>, the file <code>%1%/image.craff</code> will be translated into <code>/home/joe/c2/image.craff</code>.</li>
</ul>
 </div>
</li>
</ol>
<ul>
<li>
<p>If the filename contains an absolute path the file path is used as is.</p>
  <div class="dl">
<ul>
<li><span class="term" id="configuration.html:dt:windows-example-3"><a href="#configuration.html:dt:windows-example-3">Windows example;</a></span><br>
<code>C:\checkpoints\image.craff</code></li>
<li><span class="term" id="configuration.html:dt:linux-example-3"><a href="#configuration.html:dt:linux-example-3">Linux example;</a></span><br>
<code>/home/joe/image.craff</code></li>
</ul>
  </div>
</li>
</ul>
<div class="note">
<p>The reason why Simics's search path is involved in the process is that it makes writing new configurations easier. Adding a path to the place where all initial images are located allows you to just specify the image names.</p>
</div>
<h3 id="configuration.html:saving-and-restoring-persistent-data"><a href="#configuration.html:saving-and-restoring-persistent-data">2.4.2.4 Saving and Restoring Persistent Data</a></h3>
<p>As an alternative to checkpointing, Simics allows you to only save the <em>persistent</em> state of a machine, i.e., data that survive when the machine is powered-down. This typically consists of disk images and flash memory or NVRAM contents. A persistent data checkpoint is handled exactly like any other checkpoint and contains the same file set, but only objects containing persistent data are saved. This persistent data checkpoint can be loaded on top of a corresponding configuration later on.</p>
<p>The commands <code>save-persistent-state</code> and <code>load-persistent-state</code> respectively save and load the persistent data in a configuration.</p>
<div class="note">
<p>These commands are often used to save the state and reboot a machine after the disk contents have been modified. Remember that the target OS <strong>might have cached disk contents in memory</strong>. In order to have a clean disk that can be used at boot, you should synchronize the disk, for example by running <code>init 0</code> on a Linux target system, or shutting down the operating system, before you issue the <code>save-persistent-state</code> command.</p>
</div>
<p>Another option is to use the command <code>enable-writable-persistent-state</code>. It saves a persistent state and also switches all saved files to be writable, so that the images are used in read-write mode, as described in section <a class="reference" href="#configuration.html:images">2.4.2.3</a>. All changes to the images done during the simulation are then automatically written to these files, without the need to explicitly save the state.</p>
<p>This command can also load a state which already exists, created by this command. It is meant to be used in a Simics script and facilitates easy handling of the persistent states, either creating a new state or loading an existing state.</p>
<p>The states created by <code>enable-writable-persistent-state</code> can be loaded using <code>load-persistent-state</code>, if read-write mode is no longer desired. States created by <code>save-persistent-state</code> are generally not usable by <code>enable-writable-persistent-state</code>, since it may not be possible to make them writable.</p>
<h3 id="configuration.html:modifying-checkpoints"><a href="#configuration.html:modifying-checkpoints">2.4.2.5 Modifying Checkpoints</a></h3>
<p>Checkpoints are usually created by saving a configuration inside Simics, but it is possible to edit or even create checkpoints yourself. It may even be required to edit file paths in a checkpoint file if it is relocated.</p>
<p>Because a minimal checkpoint only has to include required attributes, <em>creating a checkpoint from scratch</em> works relatively well for small configurations. We suggest you use an existing checkpoint as a starting point if you wish to do that. Note that more advanced layers have been built on top of the configuration system to make the creation of a new machine much easier. Refer to section <a class="reference" href="#configuration.html:ready-to-run-configurations">2.4.6</a> for more information.</p>
<p><em>Modifying checkpoints</em> require some extra care. Adding or removing devices may confuse the operating system, which does not expect devices to appear or disappear while the system is running, and cause it to crash.</p>
<p>Changing the processor frequency may be enough to confuse the operating system. Many operating systems check the CPU frequency at boot time, and base their waiting loops and timing on the value they got. Saving a checkpoint and changing the frequency after boot may affect the simulation and confuse the system. Devices that use processor frequency to trigger events at specific times may also behave strangely when the frequency suddenly changes.</p>
<h3 id="configuration.html:merging-checkpoints"><a href="#configuration.html:merging-checkpoints">2.4.2.6 Merging Checkpoints</a></h3>
<p>If you want to make an incremental checkpoint independent from all previous checkpoints, for example to distribute it, you can use the small <code>checkpoint-merge</code> program in <code>[simics]\bin</code> from your system command line. It merges the checkpoint with all its ancestors to create a checkpoint that has no dependencies. Specify the checkpoint you want to distribute as the first parameter and the name of the new stand-alone checkpoint as the second. This tool can be used in both Linux and Windows environments.</p>
<p>Note that the merged checkpoint still depends on the base image. This differs from independent checkpoints, which are completely standalone.</p>
<h2 id="configuration.html:inspecting-the-configuration"><a href="#configuration.html:inspecting-the-configuration">2.4.3 Inspecting the Configuration</a></h2>
<p>Object attributes that are of type <code>integer</code>, <code>string</code> or <code>object</code> are directly accessible at the <em>command line</em> with the notation <code>object-&gt;attribute</code>:</p>
<pre><code class="language-simics"># reading the EAX register in an x86 processor
simics&gt; <strong>cpu0-&gt;eax</strong>
0
# writing a new value to EAX
simics&gt; <strong>cpu0-&gt;eax = 10</strong>
simics&gt; <strong>cpu0-&gt;eax</strong>
10
simics&gt;
</code></pre>
<p>More information about the command line and scripting is available in chapter <a class="reference" href="#script-support-in-simics.html">2.3</a>.</p>
<p>Finally, objects and attributes (of all types) are also available when <em>scripting Simics directly in Python</em>. Configuration objects are available under the <code>conf</code> namespace:</p>
<pre><code class="language-simics"># reading the EAX register in an x86 processor
simics&gt; <strong>@conf.cpu0.eax</strong>
0
# writing a new value to EAX
simics&gt; <strong>@conf.cpu0.eax = 10</strong>
simics&gt; <strong>@conf.cpu0.eax</strong>
10
simics&gt;
</code></pre>
<p>More information about scripting Simics in Python is available in chapter <a class="reference" href="#script-support-in-simics.html">2.3</a>.</p>
<h2 id="configuration.html:components"><a href="#configuration.html:components">2.4.4 Components</a></h2>
<p>All machines in <code>[simics]\targets\architecture</code> use components to create configurations. A component is typically the smallest hardware unit that can be used when configuring a real machine, and examples include motherboards, PCI cards, hard disks, and backplanes. Components are usually implemented in Simics using several configuration objects and can also contain subcomponents.</p>
<p>Components are intended to reduce the large configuration space provided by Simics's objects and attributes, by only allowing combinations that match real hardware. This greatly simplifies the creation of different systems by catching many misconfigurations.</p>
<p>Components themselves are also configuration objects in Simics. But to avoid confusion, they will always be referred to as components and the objects implementing the actual functionality will be called objects.</p>
<h3 id="configuration.html:component-definitions"><a href="#configuration.html:component-definitions">2.4.4.1 Component Definitions</a></h3>
<p>The <em>component</em> is the basic building block in the component system. When a component is created, it is in a <em>non-instantiated</em> state. At this stage only the component itself exists, not the configuration objects that will implement the actual functionality. Once a complete configuration has been created, all included components can be <em>instantiated</em>. When this happens, all objects are created and their attributes are set.</p>
<p>Components are connected to each other with <em>connectors</em>. Each connector has a <em>connector type</em> which tells what kind of connector it is and a <em>direction</em>, which can be <em>up</em>, <em>down</em>, or <em>any</em>. A connector is either required or optional. If it is optional it does not need to be connected to anything. Unless a connector is specified as <em>hotpluggable</em> it cannot be connected or disconnected after the component is instantiated. If a connection is hotpluggable it must be optional.</p>
<p>Connectors can be connected to each other in <em>connections</em>. Each connection connects an <em>up</em> connector with a <em>down</em> connector. A connection can also include an <em>any</em> connector. If an <em>any</em> connector is connected to an <em>up</em> connector it works exactly like a <em>down</em> connector and if it is connected to a <em>down</em> connector it works exactly like an <em>up</em> connector. The connections in the system must not form a cycle. You can think of the components and connections in the system as a directed acyclic graph with the components as the vertices and the connections as the edges.</p>
<p>Each connected subgraph in the set of components is called a <em>component hierarchy</em>.</p>
<p>A component <em>A</em> is said to be <em>above</em> a component <em>B</em> if it can be reached through up connectors in one or more steps from component <em>B</em>. Analogously, component <em>A</em> is said to be <em>below</em> a component <em>B</em> if <em>B</em> is above <em>A</em>.</p>
<p>A <em>root</em> is a component without any components above it. A component's roots are the roots which are above it.</p>
<p>A component where the <code>top_level</code> attribute returns true is a <em>top-level</em> component. It is often a motherboard, backplane or system chassis. It must be a root.</p>
<p>A <em>standalone</em> component is a component without any required connectors. A typical example is a hotplug device, such as a PC Card (PCMCIA) or an Ethernet link.</p>
<p>To instantiate a set of components, each component which is not standalone or top-level must have a top-level component as a root.</p>
<p>Components are also <em>namespaces</em> and can be nested in a <em>namespace hierarchy</em>, which is separate from the component hierarchy. The root of the hierarchy is the <em>global namespace</em>, and this is the only namespace which is not a component. Each configuration object (including components) lives in a namespace. The object is a <em>child</em> of the namespace and the namespace is the <em>parent</em> of the object. The other objects in the namespace are <em>siblings</em> of the object.</p>
<h3 id="configuration.html:importing-component-commands"><a href="#configuration.html:importing-component-commands">2.4.4.2 Importing Component Commands</a></h3>
<p>Components in Simics are grouped by machine architecture, or by type, into several modules. Before a component can be used in Simics, the corresponding component module has to be loaded. When the component module is loaded, CLI commands for creating components are added to the front end. The most common modules, that are not architecture specific, are <code>memory-comp</code>, <code>pci-comp</code>, <code>std-comp</code>, <code>console-components</code>. To import all modules that are used by the <code>QSP-Simple</code> machine, issue the following commands:</p>
<pre><code class="language-simics">simics&gt; <strong>load-module std-comp</strong>
simics&gt; <strong>load-module memory-comp</strong>
simics&gt; <strong>load-module console-components</strong>
simics&gt; <strong>load-module x58-ich10-comp</strong>
simics&gt; <strong>load-module x86-nehalem-comp</strong>
</code></pre>
<h3 id="configuration.html:creating-components"><a href="#configuration.html:creating-components">2.4.4.3 Creating Components</a></h3>
<p>The <code>create-&lt;component&gt;</code> command is used to create non-instantiated components. There is one create command for each component class. The arguments to the create command represent attributes in the component. Standalone components can be created both non-instantiated and instantiated. To create instantiated components, there are <code>new-</code> commands, similar to the <code>create-</code> commands.</p>
<p>The following code creates a non-instantiated 'motherboard_x58_ich10' component , called 'motherboard0'</p>
<pre><code class="language-simics">simics&gt; <strong>load-module x58-ich10-comp</strong>
simics&gt; <strong>create-motherboard-x58-ich10</strong>
Created non-instantiated 'motherboard_x58_ich10' component 'motherboard0'
</code></pre>
<h3 id="configuration.html:connectors"><a href="#configuration.html:connectors">2.4.4.4 Connectors</a></h3>
<p>A connector provides a means for a component to connect to other components. Connectors have a defined direction: <em>up</em>, <em>down</em>, or <em>any</em>. The direction is <em>up</em> if it needs an existing hierarchy to connect to; for example, the PCI-bus connector in a PCI device must connect to a PCI slot. A connector has a <em>down</em> direction if it extends the hierarchy downwards; for example, a PCI slot is a connection downward from a board to a PCI device. There are also non-directed connectors, with direction <em>any</em>. You can only connect an <em>up</em> to a <em>down</em> connector or to an <em>any</em> connector, and similar for <em>down</em> connectors. Connectors with the <em>any</em> direction can not be connected together.</p>
<p>Many connectors have to be connected before the component is instantiated, while others can be empty. A standalone component, as described above, may have all connectors empty.</p>
<p>A <em>hotplug</em> connector supports connect and disconnect after instantiation. Other connectors can only be connected, or left unconnected, when the configuration is created and may not be modified after that point. A <em>multi</em> connector supports connections to several other connectors. Creating <em>multi</em> connectors should be avoided, it is often better to dynamically create non-<em>multi</em> connectors when new connectors are needed.</p>
<p>It is not possible to connect instantiated components with non-instantiated ones. The reason is that the instantiated component expects the other to have all objects already created, and need to access some of them to finish the connection.</p>
<p>The <code>info</code> command of a component lists all connectors and some information about them:</p>
<pre><code class="language-simics">simics&gt; <strong>motherboard0.info</strong>
Information about motherboard0 [class motherboard_x58_ich10]
============================================================

Slots:
      dimm[0] : motherboard0.dimm[0]
      dimm[1] : motherboard0.dimm[1]
      dimm[2] : motherboard0.dimm[2]
      dimm[3] : motherboard0.dimm[3]
           nb : motherboard0.nb
    reset_bus : motherboard0.reset_bus
           sb : motherboard0.sb
    socket[0] : motherboard0.socket[0]
    socket[1] : motherboard0.socket[1]
    socket[2] : motherboard0.socket[2]
    socket[3] : motherboard0.socket[3]
    socket[4] : motherboard0.socket[4]
    socket[5] : motherboard0.socket[5]
    socket[6] : motherboard0.socket[6]
    socket[7] : motherboard0.socket[7]

Connectors:
      dimm[0] : mem-bus              down
      dimm[1] : mem-bus              down
      dimm[2] : mem-bus              down
      dimm[3] : mem-bus              down
    reset_bus : x86-reset-bus        down
    socket[0] : x86-apic-processor   down
    socket[1] : x86-apic-processor   down
    socket[2] : x86-apic-processor   down
    socket[3] : x86-apic-processor   down
    socket[4] : x86-apic-processor   down
    socket[5] : x86-apic-processor   down
    socket[6] : x86-apic-processor   down
    socket[7] : x86-apic-processor   down

</code></pre>
<p>The board has four slots for memory modules, one north bridge, one reset bus, one south bridge, eight sockets. All slots are not listed as <em>hotplug</em> since they have to be inserted when the machine is configured initially.</p>
<p>Since the machine need a cpu, we also add a x86QSP1 processor to our example. A CLI variable is used to hold the name of the processor component.</p>
<pre><code class="language-simics">simics&gt; <strong>load-module x86-nehalem-comp</strong>
simics&gt; <strong>$cpu = (create-processor-x86QSP1 freq_mhz = 2000)</strong>
simics&gt; <strong>connect motherboard0.socket[0] $cpu.socket</strong>
</code></pre>
<p>To enable input and output for the simulated machine, the following commands create a serial text console and connect it to the <code>serial[0]</code> connector of the south bridge.</p>
<pre><code class="language-simics">simics&gt; <strong>load-module console-components</strong>
simics&gt; <strong>connect motherboard0.sb.serial[0] (create-txt-console-comp).serial</strong>
</code></pre>
<p>Since the machine needs some memory to run, we also add a memory module to our example. A CLI variable is used to hold the name of the memory component.</p>
<pre><code class="language-simics">simics&gt; <strong>load-module memory-comp</strong>
simics&gt; <strong>$dimm = (create-simple-memory-module memory_megs = 2048)</strong>
simics&gt; <strong>connect motherboard0.dimm[0] $dimm.mem_bus</strong>
</code></pre>
<h3 id="configuration.html:instantiation"><a href="#configuration.html:instantiation">2.4.4.5 Instantiation</a></h3>
<p>When a component hierarchy has been created, it can be instantiated using the <code>instantiate-components</code> command. This command will look for all non-instantiated top-level components and instantiate all components below them. The <code>instantiate-components</code> command can also be given a specific component as argument. Then only that component will be instantiated, including its hierarchy if it is a top-level component.</p>
<pre><code class="language-simics">simics&gt; <strong>instantiate-components</strong>
</code></pre>
<p>If there are unconnected connectors left that may not be empty, the command will return with an error.</p>
<p>When the instantiation is ready, all object and attributes have been created and initialized. In our example, a text console window should have opened. The hardware of the simulated motherboard is now properly configured, but since no software is loaded, it will not show any output on the console if the machine is started.</p>
<h3 id="configuration.html:inspecting-component-configurations"><a href="#configuration.html:inspecting-component-configurations">2.4.4.6 Inspecting Component Configurations</a></h3>
<p>The <code>list-components</code> command prints a list of all components in the system. All connectors are included, and information about existing connections between them.</p>
<p>The <code>info</code> namespace command provides static information about a component, such as the slots and a list of connectors.</p>
<p>The <code>status</code> namespace command provides dynamic information about a component, such as attribute values and a list of all current connections. The output from status in the example:</p>
<pre><code class="language-simics">simics&gt; <strong>motherboard0.status</strong>
Status of motherboard0 [class motherboard_x58_ich10]
====================================================

Setup:
         Top component : none
          Instantiated : True

Attributes:
                  acpi : True
                  bios : 
       break_on_reboot : False
           mac_address : 20:20:20:20:20:20
              rtc_time : 2008-06-05 23:52:01
             spi_flash : 
          system_clock : False
    system_clock_class : clock

Connections:
               dimm[0] : dimm0:mem_bus
             socket[0] : processor0:socket
</code></pre>
<h3 id="configuration.html:accessing-objects-from-components"><a href="#configuration.html:accessing-objects-from-components">2.4.4.7 Accessing Objects from Components</a></h3>
<p>When doing more advanced configuration of a machine, it may be necessary to access configuration objects and their attributes directly. Each object in a component has a slot name that can be used for accessing the object. A list of slot names, and their mappings to actual configuration object names, is available from the output of the component's <code>info</code> command. The next example prints the <code>frequency</code> attribute from the <code>core</code> object.</p>
<pre><code class="language-simics">simics&gt; <strong>processor0.core[0][0]-&gt;frequency</strong>
[20000000, 1]
</code></pre>
<p>Accessing objects of non-instantiated components is not possible, since they do not have any associated configuration objects. But it is possible to access the <code>pre_conf_object</code>s of a non-instantiated component from Python. The following example works both for instantiated and non-instantiated components:</p>
<pre><code class="language-simics">simics&gt; <strong>@print(conf.processor0.core[0][0].cpuid_stepping)</strong>
8
</code></pre>
<p>Remember that not all configuration object attributes are available on a <code>pre_conf_object</code>. Only attributes that have been assigned by the component during initialization exists.</p>
<h3 id="configuration.html:available-components"><a href="#configuration.html:available-components">2.4.4.8 Available Components</a></h3>
<p>The <em>Target Guide</em> for each architecture lists and describes all components that are available.</p>
<h2 id="configuration.html:object-name"><a href="#configuration.html:object-name">2.4.5 Object Name</a></h2>
<p>An object can be identified using more than one name. This section describes the different ways of identifying an object.</p>
<p>All objects have a name that is used when printing log messages, writing checkpoints, in CLI commands, etc. The <code>SIM_object_name</code> function returns this object name. This name will be referred to as the <em>object name</em> in this section, even though an object can have several names for identification.</p>
<p>The object name is the name the object is given when created, or the objects location in the hierarchy.</p>
<p>An object can be given a name when created. The <code>SIM_create_object</code>, <code>SIM_add_configuration</code>, or <code>SIM_set_configuration</code> functions takes the object name as argument. The given name can be a string without dots "foo", a string with dots "cmp0.foo", an empty string "", or None. This section will describe how the given name affects the object name.</p>
<p>An object's <em>hierarchical location</em> is defined by its <code>component</code> and <code>component_slot</code> attributes. The hierarchical location for an object is the name of the <code>component</code> that the object's <code>component</code> attribute points at, and the component's <code>component_slot</code> attribute string, concatenated with a dot. For example, an object that belongs to a component named "cmp0" with the slot name "bar" has the hierarchical location "cmp0.bar".</p>
<p>All objects that reside in a slot in a component have valid <code>component</code> and <code>component_slot</code> attributes. It is the component's responsibility that the attributes are valid. The attributes are set when an object is added to a slot. A name that contains dots is a hierarchical location.</p>
<p>All objects also have an ID. The <code>SIM_object_id</code> function returns the object ID as a string. The object ID is unique, never changes, and will be saved in checkpoints. The object ID will not change even if the object is moved around in the hierarchy or is given a new name.</p>
<p>The object name and object ID are always unique. Creating an object and giving it a name that already exist will generate an error.</p>
<p>If the given name is a hierarchical location, an object will be added to that hierarchical location even if the <code>component</code> and <code>component_slot</code> attributes are not set. Simics will extract the component name and slot name from the given name. This information is then used when looking up the component and adding the object to the slot via the <code>component</code> interface. An object given the name "cmp0.cmp1.foo" belongs to the component "cmp0.cmp1" and has the slot name "foo". Note that the component "cmp1" in this example belongs to the component "cmp0".</p>
<p>An object given a name without dots, e.g., "foo", will get a name that is the hierarchical location of the object if the <code>component</code> and <code>component_slot</code> attributes are valid. Otherwise it will get the name "foo", which means that the object does not reside in any slot in a component. The object will also get an automatically assigned unique object ID, unless <code>legacy_object_id</code> is set. In that case the object name is used as object ID.</p>
<p>An object given a name with dots "cmp0.foo" gets the name "cmp0.foo" or, if it is put in the slot "bar", the name "cmp0.bar", its hierarchical location, and an object ID of the form "obj_XYZ".</p>
<p>An object given an empty name "", or None, will get a hierarchical location as name, if the <code>component</code> and <code>component_slot</code> attributes are valid, otherwise a name of the form "obj_XYZ". The object ID will always be of the form "obj_XYZ", identical to the object name if <code>component</code> and <code>component_slot</code> attributes are invalid.</p>
<table><thead><tr><th><strong>Given Name</strong></th><th><strong>Name (Slot = None)</strong></th><th><strong>Name (Slot = bar)</strong></th><th><strong>ID</strong></th><th><strong>Name After Move</strong></th></tr></thead><tbody>
<tr><td>foo</td><td>foo</td><td>cmp0.bar</td><td>obj_XYZ</td><td>cmp1.smurf</td></tr>
<tr><td>cmp0.foo</td><td>cmp0.foo</td><td>cmp0.bar</td><td>obj_XYZ</td><td>cmp1.smurf</td></tr>
<tr><td>None</td><td>obj_XYZ</td><td>cmp0.bar</td><td>obj_XYZ</td><td>cmp1.smurf</td></tr>
</tbody></table>
<p>The <em>given name</em> is the name that the user has provided. <em>Name</em> is the name the object gets when created, depending on if <code>component</code> and <code>component_slot</code> are set: <em>Slot = None</em> when they are not set; <em>Slot = bar</em> when they are set and <code>component_slot</code> is <em>bar</em>. <em>ID</em> is the unique object ID. <em>Name After Move</em> is the name the object gets after being moved to <em>cmp1</em> to a slot named <em>smurf</em>.</p>
<h2 id="configuration.html:ready-to-run-configurations"><a href="#configuration.html:ready-to-run-configurations">2.4.6 Ready-to-run Configurations</a></h2>
<p>Simics includes many customizable ready-to-run configurations. Because checkpoint files are by definition static, these example configurations are not checkpoint-based, but rather built on <em>components</em> and <em>scripts</em> to generate a working simulated machine.</p>
<p>The example configurations are located in separate directories for each system <em>architecture</em>: <code>[simics]\targets\architecture</code>. Each of these directories contains a number of Simics scripts (i.e., files containing Simics commands):</p>
<div class="dl">
<ul>
<li><span class="term" id="configuration.html:dt:machine-common-simics"><a href="#configuration.html:dt:machine-common-simics"><code>&lt;machine&gt;-common.simics</code></a></span><br>
Scripts that define a complete simulated machine, i.e., both hardware and software, that can be run by Simics directly. Each <code>common</code> script uses the corresponding <code>-system.include</code> script to define the hardware, and the <code>-setup.include</code> script for software configuration. The <code>-common.simics</code> scripts may add additional hardware in some cases.</li>
</ul>
<p><em>These are the files you want to use to start the standard example machines in this directory.</em></p>
<pre><code>\&lt;machine\&gt; in the script name is either a Linux machine name, or a some other name that defines the hardware/software combination.  
</code></pre>
<ul>
<li><span class="term" id="configuration.html:dt:machine-feature-common-simics"><a href="#configuration.html:dt:machine-feature-common-simics"><code>&lt;machine&gt;-&lt;feature&gt;-common.simics</code></a></span><br>
A script that extends the <code>-common.simics</code> script with a new feature. Many minor features, such as the processor frequency, can be controlled using parameters to the <code>common</code> script, but features that are mutually exclusive are added as separate scripts. Typical examples are scripts that add different diff-files to the same disk image in the system setup.</li>
<li><span class="term" id="configuration.html:dt:architecture-variant-system-include"><a href="#configuration.html:dt:architecture-variant-system-include"><code>&lt;architecture-variant&gt;-system.include</code></a></span><br>
A script that defines the hardware of a machine. This script can be shared by several simulated machines that are based on the same hardware. The hardware setup is typically configurable using some standard parameters.</li>
<li><span class="term" id="configuration.html:dt:machine-setup-include"><a href="#configuration.html:dt:machine-setup-include"><code>&lt;machine&gt;-setup.include</code></a></span><br>
A script that defines the software and possibly configures the machine to run the selected software, for example setting boot path, and scripting automatic login.</li>
</ul>
</div>
<p>The example configurations are designed to work with the disk images distributed with Simics. The machines are described in the <em>Target Guide</em> corresponding to each architecture.</p>
<p>Several machines may be defined for a given architecture, and thus the corresponding architecture directory will contain several <code>machine-common.simics</code> scripts.</p>
<h3 id="configuration.html:customizing-the-configurations"><a href="#configuration.html:customizing-the-configurations">2.4.6.1 Customizing the Configurations</a></h3>
<p>There are several ways to customize the examples provided with Simics. They are listed below ordered by how simple they are to use.</p>
<div class="dl">
<ul>
<li>
<p><span class="term" id="configuration.html:dt:parameters"><a href="#configuration.html:dt:parameters">Parameters</a></span><br>
The machine scripts distributed with Simics can be modified by setting parameters (CLI variables) before the script is actually run. This is the easiest way to change the default configuration. Parameters can typically be used to change properties such as the amount of memory, the number of processors and the primary MAC address. The available parameters are listed in each <em>Target Guide</em>.</p>
<p>Setting parameters before the script is run can be done in two fashions:</p>
<ol>
<li>
<p>Use the startup flag <code>-e</code>. The flag must be repeated for each parameter to set.
An example on Windows:</p>
<pre><code>$ simics.bat -e '$freq_mhz = 2000' -e '$host_name = "target0"' targets/qsp-x86/firststeps.simics
</code></pre>
<p>An example on Linux:</p>
<pre><code>$ ./simics -e '$freq_mhz = 2000' -e '$host_name = "target0"' targets/qsp-x86/firststeps.simics
</code></pre>
</li>
<li>
<p>Launch Simics without any script, set the parameters at CLI, and run the CLI command<br>
<code>run-script</code>.
An example identical to the one above:</p>
<pre><code class="language-simics">$ simics.bat 
simics&gt; <strong>$freq_mhz = 2000</strong>
simics&gt; <strong>$host_name = "target0"</strong>
simics&gt; <strong>run-script targets/qsp-x86/firststeps.simics</strong>
</code></pre>
</li>
</ol>
</li>
</ul>
<ol>
<li><span class="term" id="configuration.html:dt:scripts"><a href="#configuration.html:dt:scripts">Scripts</a></span><br>
A simulated machine is defined by several scripts, as described above. By replacing the <code>-common.simics</code> file with a user defined script, the system can be configured more in detail while keeping the machine definition provided by the <code>-system.include</code> file. Similarly the <code>-setup.include</code> can be replaced to configure different software on the same machine.</li>
<li><span class="term" id="configuration.html:dt:components"><a href="#configuration.html:dt:components">Components</a></span><br>
Components represents real hardware items such as PCI cards, motherboards, and disks. Using components to configure a machine provides freedom to set up the simulated machine in any way that is supported by the architecture. The <code>-system.include</code> files use components to create their machine definitions. A complete description of components is provided earlier in this chapter.</li>
<li><span class="term" id="configuration.html:dt:objects-and-attributes"><a href="#configuration.html:dt:objects-and-attributes">Objects and Attributes</a></span><br>
A component is implemented by one or more configuration objects in Simics, and each object has several attributes describing it. Configuring machines on the object and attribute level is <em>not</em> supported in Simics, and such configurations may not work in future versions.</li>
</ol>
</div>
<p>Below is another example of a simple configuration based on <code>QSP-x86</code>, that uses parameters to configure two machines slightly differently that both run in the same Simics session.</p>
<pre><code class="language-simics">simics&gt; <strong>$freq_mhz = 2000</strong>
simics&gt; <strong>$host_name = "target0"</strong>
simics&gt; <strong>run-script "%script%/firststeps.simics"</strong>

simics&gt; <strong>$freq_mhz = 3000</strong>
simics&gt; <strong>$host_name = "target1"</strong>
simics&gt; <strong>run-script "%script%/firststeps.simics"</strong>
</code></pre>
<h3 id="configuration.html:adding-devices-to-existing-configurations"><a href="#configuration.html:adding-devices-to-existing-configurations">2.4.6.2 Adding Devices to Existing Configurations</a></h3>
<p>The parameters available for each predefined machine allows the user to do minor modifications. It is also possible to extend the ready-to-run configurations with additional components without creating new machine setups from scratch.</p>
<p>Since the machine setup scripts are located in the read-only master installation of Simics, they should not be modified. User files that add new components should instead be placed in the corresponding <code>[project]\targets\architecture</code> directory.</p>
<p>Here is a short example of how to extend the <code>QSP-x86</code> to add a SATA disk:</p>
<pre><code class="language-simics"># Add disk2
simics&gt; <strong>$disk2 = (create-sata-disk-comp $system.disk2 size = $disk2_size)</strong>
simics&gt; <strong>connect $system.mb.sb.sata_slot[2] $disk2.sata_slot</strong>

simics&gt; <strong>instantiate-components</strong>
</code></pre>
<p>Notice, that script requires you to provide a disk image and a valid disk size. Essentially the script will run another script, <code>firststeps.simics</code>, which will create an instantiated <code>QSP-x86</code> machine, then a SCSI disk is created and connected to that machine, and finally the new disk is instantiated.</p>
<p>It is possible to add many devices to an instantiated Simics machine in a similar manner. In the case a device must be added to the target machine before instantiation, write a script as described above.</p>
</section><section class="page" id="managedisks.html"><h1 id="managedisks.html:moving-data-in-and-out-of-the-simulation"><a href="#managedisks.html:moving-data-in-and-out-of-the-simulation">2.5 Moving Data in and out of the Simulation</a></h1>
<p>In order to use Simics, you must have <em>images</em> (also called <em>disk dumps</em>) with the operating system and the applications you plan to run. Depending on the type of machine you are using, these images will correspond to the contents of a disk, a flash memory, a CD-ROM, etc. There are some images provided that work with the example machines located in the <code>targets</code> directory.</p>
<p>Simics images are usually stored in a special format called <code>craff</code> (for Compressed Random Access File Format) to save disk space. Simics also accepts a raw binary dumps as well as VHDX images. The use of a raw dumps as images can sometimes be more practical if you are manipulating images outside Simics. Simics comes with the <code>craff</code> utility to manipulate and convert images in <code>craff</code> format (see section <a class="reference" href="#managedisks.html:the-craff-utility">2.5.2.8</a>).</p>
<p>This chapter will explain the following:</p>
<ul>
<li>How to use Simics Agent to transfer files</li>
<li>How to use Simics Agent to run commands on target systems</li>
<li>How to work with images in general</li>
<li>How to use CD-ROMs and floppies with Simics</li>
<li>How to use the SimicsFS file system</li>
<li>How to use the Virtio File System device</li>
<li>How to import the contents of a real disk inside Simics</li>
</ul>
<p>To provide you with a more practical overview, here are the ways you can install and modify the operating system and the applications you wish to run:</p>
<div class="dl">
<ul>
<li>
<p><span class="term" id="managedisks.html:dt:using-simics"><a href="#managedisks.html:dt:using-simics">Using Simics:</a></span></p>
<ul>
<li>
<p>You can install a completely new OS or simply copy files using a simulated CD-ROM drive, by linking it to a real CD-ROM drive on your host machine (Linux only) or by using a CD image file (refer to sections <a class="reference" href="#managedisks.html:accessing-a-host-cd-rom-drive">2.5.3.1</a> and <a class="reference" href="#managedisks.html:accessing-a-cd-rom-image-file">2.5.3.2</a>).</p>
</li>
<li>
<p>You can copy files from the simulated floppy drive by linking it to the real host floppy device (Linux only) or by using a floppy image file (see sections <a class="reference" href="#managedisks.html:accessing-a-host-floppy-drive">2.5.3.3</a> and <a class="reference" href="#managedisks.html:accessing-a-floppy-image-file">2.5.3.4</a>).</p>
</li>
<li>
<p>You can use SimicsFS to directly access your host file systems from the simulated machine (see section <a class="reference" href="#managedisks.html:using-simicsfs-with-fuse">2.5.5</a>).</p>
</li>
<li>
<p>You can use VirtioFS to directly access your host file systems from the
simulated machine. The VirtioFS device can also be used as a root file
system device in Linux targets. (see section <a class="reference" href="#managedisks.html:using-virtiofs">2.5.6</a>).</p>
</li>
<li>
<p>You can use the <em>Simics Agent</em> application to copy files and directories between host and target systems, as well as issuing commands to be executed in a shell on the target. Full functionality is available from the Simics command line (see section <a class="reference" href="#managedisks.html:file-transfers-using-the-simics-agent">2.5.1</a>).</p>
<p>You can also run upload and download commands directly from the command-line in the target system shell, using the <em>Simics Agent</em> application.</p>
</li>
<li>
<p>You can download files over the simulated network (see the <a href="../ethernet-networking/index.html">Ethernet Networking Technology Guide</a>).</p>
</li>
</ul>
<p><strong>Do not forget to read more about <em>images</em> in section <a class="reference" href="#managedisks.html:saving-changes-to-an-image">2.5.2.2</a> to learn how to save and re-use your changes.</strong></p>
</li>
<li>
<p><span class="term" id="managedisks.html:dt:using-external-programs"><a href="#managedisks.html:dt:using-external-programs">Using External Programs</a></span></p>
<ul>
<li>You can install a new OS along with new programs on a real machine and create an image from the real machine storage (disk, flash memory, etc.). Section <a class="reference" href="#managedisks.html:importing-a-real-disk-into-simics">2.5.9</a> shows how to perform this with a disk.</li>
<li>You can modify a FAT image directly with Mtools (see section <a class="reference" href="#managedisks.html:editing-fat-images-using-mtools">2.5.2.5</a>). (Linux only)</li>
<li>You can modify an image directly via a loopback device (see section <a class="reference" href="#managedisks.html:editing-images-using-loopback-mounting">2.5.2.6</a>). (Linux only)</li>
<li>Use a tool such as SFMount from PassMark* Software. (Windows only)</li>
</ul>
</li>
</ul>
</div>
<h2 id="managedisks.html:file-transfers-using-the-simics-agent"><a href="#managedisks.html:file-transfers-using-the-simics-agent">2.5.1 File Transfers Using the Simics Agent</a></h2>
<p>Simics Agent is a feature in Simics which can be used to move files and directories in and out of a simulation in a deterministic way, without any network connection or kernel modules. It also provides a deterministic way of executing commands on the target systems and knowing when they finish.</p>
<p>This feature consists of two parts. One part is present inside a Simics simulation session (<code>agent_manager</code> and <code>agent_handler</code> objects) and the other part is the <code>simics-agent</code> application running on the target system.</p>
<p>The <code>simics-agent</code> application must be located on the target system and the user is in charge of starting it. The application as well as the target system must be running for its commands to execute. There is typically just a single Simics Agent in a target system, but there may be more target systems and agents.</p>
<p>The user has to create the <code>agent_manager</code> object with the <code>start-agent-manager</code> Simics command. The object will find running Simics Agents and keep track of them. There can be only one <code>agent_manager</code> in Simics session.</p>
<p>In order to control and issue commands to a Simics Agent, the user must run the <code>&lt;agent_manager&gt;.connect-to-agent</code> command, which returns a unique <code>agent_handle</code> for the Simics Agent. Several handles may be connected to one Simics Agent, which are executing commands concurrently.</p>
<p>All the commands that the <code>agent_handle</code> provides are asynchronous and queued in the handle until they have completed. Handles can be created and used in scripts, script-branches, or interactively on the Simics command-line. The two commands, <code>&lt;agent_handle&gt;.run-until-job</code> and <code>&lt;agent_handle&gt;.wait-for-job</code>, allow the user to wait until a particular or all queued commands have finished.</p>
<p>Exactly <em>when</em> a Simics Agent runs and executes a particular command is defined by the target system, neither Simics nor the user can control it.</p>
<p>A ready-to-use Simics Agent is installed on some virtual platform images. Agents for some architectures are also available on CD (ISO) in the <code>[simics-base]/targets/common/images/</code> directory. For other use cases, the agent source code comes with Simics Base and can be copied onto and compiled for the target system, usually without, or with only minor, adjustments. The source code is located at <code>[simics-base]/src/misc/simics-agent/</code>.</p>
<p>A Simics Agent runs only when needed, otherwise it sleeps and regularly polls for requests. Agent responsiveness versus performance taxing is a trade-off that is controlled by the polling interval, but affects all users of that Simics Agent.</p>
<div class="note">
<p>A checkpoint will contain Simics Agents and the Agent Manager, but not any Agent Handles. Thus, any ongoing transactions or pending commands are lost and must be rerun.</p>
</div>
<p>The following sections shows an example where a binary is uploaded to the target system, started, and its output file downloaded to the host. See the <a href="../rm-base/index.html">Simics Reference Manual</a>
or command-line interface help for details on <code>agent_manager</code> and <code>agent_handle</code> classes and the methods they provide.</p>
<p>The examples assume that a target system is booted and a Simics Agent is running on it. All but the first example expects the simulation to be running.</p>
<p>Creating a Simics Agent Manager is done once per simulation session, both for interactive use and for scripts.</p>
<pre><code class="language-simics">simics&gt; <strong>start-agent-manager</strong>
agent-manager 'agent_manager' is created and enabled.
</code></pre>
<h3 id="managedisks.html:interactive-example"><a href="#managedisks.html:interactive-example">2.5.1.1 Interactive Example</a></h3>
<p>The <code>agent_manager</code> was started above, but the user needs an <code>agent_handle</code> to issue commands to. The connect command below will return immediately, whether the simulation is running or not, and whether there is any known Simics Agents matching the requested identity or not. Since no name was given, the returned handle will have the default name.</p>
<p>It is recommended, but not required, to issue commands while the simulation is stopped, like in this example, for the sake of determinism and repeatability.</p>
<pre><code class="language-simics">simics&gt; <strong>agent_manager.connect-to-agent</strong>
matic0 connected to simics_agent0
simics&gt; <strong>matic0.upload -executable my_test /bin/</strong>
matic0:job 1
simics&gt; <strong>matic0.run "/bin/my_test -out /var/my_test.log"</strong>
matic0:job 2
</code></pre>
<p>Now two commands have been given, but since the simulation is stopped they will not execute yet. The first command will upload the application binary and make it executable (if it isn't already), while the second command will run it. The queued commands can be listed along with their sequence id's.</p>
<pre><code class="language-simics">simics&gt; <strong>matic0.list-jobs</strong>
	#1	upload my_test /bin/my_test, queued
	#2	run "/bin/my_test -out /var/my_test.log", queued
</code></pre>
<p>Note that the <code>&lt;agent_handle&gt;.list-jobs</code> command does not require the simulation to be running (nor even a Simics Agent to exist). Then, run the queued commands and wait for them to complete.</p>
<pre><code class="language-simics">simics&gt; <strong>matic0.run-until-job</strong>
File my_test copied from host to target /bin/my_test
... [the output of the my_test command, if any] ...
matic0:job 2 finished
</code></pre>
<p>The test application produced an output log file that should be downloaded from the simulation to the host. When downloading files the user may want to specify the <code>-overwrite</code> flag. Otherwise the file will not be downloaded on following runs, as the file will persist on the host.</p>
<pre><code class="language-simics">simics&gt; <strong>matic0.download -overwrite /var/my_test.log</strong>
matic0:job 3
simics&gt; <strong>matic0.run-until-job</strong>
File /var/my_test.log copied from target to host ./my_test.log
matic0:job 3 finished
</code></pre>
<h3 id="managedisks.html:example-with-a-script-branch"><a href="#managedisks.html:example-with-a-script-branch">2.5.1.2 Example with a Script Branch</a></h3>
<p>This example will perform the same tasks as the previous example, but in a script-branch. The handle will automatically run the queued commands one after another in strict order, and they will complete in due time. Technically, the script-branch will queue all commands up until a <code>&lt;agent_handle&gt;.wait-for-job</code> command and only then wait for them to finish.</p>
<pre><code class="language-simics">simics&gt; <strong>script-branch "run my_test" {</strong>
    local $matic = (agent_manager.connect-to-agent)
    $matic.upload -executable from = my_test to = /bin/
    $job = ($matic.run -capture "/bin/my_test -out /var/my_test.log")
    $matic.download -overwrite /var/my_test.log
    $matic.wait-for-job  # wait until ALL jobs are done 
    echo ($matic.get-captured-output $job)
    $matic.delete-handle
}
</code></pre>
<p>This example prints the output of the <code>my_test</code> application, but requires a <code>wait-for-job</code> command, because without it the application will not have run before the script-branch reaches the echo statement and then deletes the handle.</p>
<p>It is good practice to delete any lingering objects in the end of a script branch. The output of the my_test command is captured and printed, but can alternatively be written to a file instead.</p>
<pre><code>File my_test copied from host to target /bin/my_test
File /var/my_test.log copied from target to host ./my_test.log
... [the output of the my_test command, if any] ...
</code></pre>
<h3 id="managedisks.html:example-from-the-target-shell"><a href="#managedisks.html:example-from-the-target-shell">2.5.1.3 Example from the target shell</a></h3>
<p>Similar to the previous examples, a test log file will be copied from the target system to the host system. Here, the execution is controlled completely from the command-line in the target system shell.</p>
<div class="note">
<p>The direction of the upload and download commands are reversed, when giving the commands from the target system, compared to the host system.</p>
</div>
<pre><code>~ # simics-agent --executable --download my_test --to /bin/
File my_test copied from host to target /bin/my_test
The Simics target agent has quit.
~ # my_test -out /var/my_test.log
...
~ # simics-agent --overwrite --upload /var/my_test.log
File /var/my_test.log copied from target to host ./my_test.log
The Simics target agent has quit.
</code></pre>
<p>Give the <code>--help</code> argument to the <code>simics-agent</code> for more information on the available commands and options.</p>
<p>For these target initiated commands to work, the Agent Manager must be started on the host, but no Simics Agents are required to be running in the target system. Different Simics Agents and using them will not conflict or interfere with each other.</p>
<h2 id="managedisks.html:working-with-images"><a href="#managedisks.html:working-with-images">2.5.2 Working with Images</a></h2>
<h3 id="managedisks.html:image-file-formats"><a href="#managedisks.html:image-file-formats">2.5.2.1 Image File Formats</a></h3>
<p>For Simics compatibility, a disk image needs to be either in the Simics-specific <code>craff</code> file format, or be a raw (linear) image.</p>
<p>The raw format is what you get when dumping a disk with a utility such as <code>dd</code>. Keeping the image in raw format is useful if you want to be able to loopback mount the image, or if you want to update the image in-place using the read/write option in Simics. For most other use-cases, compressing the image with the <code>craff</code> utility will be beneficial as the host disk requirements will often be dramatically smaller than for raw images. Image file access is usually not frequent enough during simulation to impact performance. The <code>craff</code> format is recommended as the best all-round image file format for Simics. See section <a class="reference" href="#managedisks.html:the-craff-utility">2.5.2.8</a> for more information about the <code>craff</code> utility.</p>
<h3 id="managedisks.html:saving-changes-to-an-image"><a href="#managedisks.html:saving-changes-to-an-image">2.5.2.2 Saving Changes to an Image</a></h3>
<p>If you modify or create new files on a storage device within Simics, you should remember that by default images are <em>read-only</em>. This means that the alterations made when running Simics are <em>not</em> written to the image, and will last only for the current Simics session. As described in the <a class="reference" href="#configuration.html:images">2.4.2.3</a> section, this behavior has many advantages. You may however want to save your changes to the image, in order to re-use them in future simulations.</p>
<p>The first thing you should do is to make sure that all the changes are actually written to the media you are using. In many cases, the simulated operating system caches operations to disks or floppies. A safe way to ensure that all changes are written back is to shutdown the simulated machine.</p>
<p>When all changes have been written to the media <em>in</em> the simulation, you can save the new contents of the image in different ways:</p>
<ul>
<li>
<p>Using the <code>save-persistent-state</code> command, all image changes for persistent storage media are saved to disk as a persistent state. <strong>This is the recommended way of saving your image changes</strong>.</p>
</li>
<li>
<p>Using the <code>&lt;image&gt;.save-diff-file</code> command, you can manually save a diff file for the images you are interested in.</p>
</li>
<li>
<p>Using the <code>&lt;image&gt;.save</code> command, you can create a new image file from the image. This image file is completely independent of all previous images and diff files. By default, the command creates an image file in the raw format. Image files in the raw format don't use compression and may occupy large space on the disk. By passing the <code>-save-craff</code> flag to the command one can create an image file in the compressed Simics-specific craff format.</p>
  <div class="note">
<p>The <code>&lt;image&gt;.save</code> allows also to save a <em>partial</em> dump of an image, which may be useful to dump a specific part of a disk or a floppy.</p>
  </div>
</li>
</ul>
<p>Once you have saved the images, you can do the following:</p>
<ul>
<li>
<p>If you used <code>save-persistent-state</code>, you can issue the <code>load-persistent-state</code> command just after starting the original configuration. This will add the new changes to the persistent storage media images and the machine will boot with the changes included. <strong>This is the recommended way of using a saved persistent state</strong>.</p>
<p>For example, let us suppose that you saved some new files on the disk of the <code>QSP-x86</code> platform (started with the <code>qsp-x86/firststeps</code> target). You saved the persistent state of the machine after stopping it to the file <code>new-files-added</code>. You can easily create a small script to start <code>QSP-x86</code> with the new files:</p>
<pre><code class="language-simics"># QSP-x86-new-files.simics
simics&gt; <strong>load-target qsp-x86/firststeps</strong>
simics&gt; <strong>load-persistent-state new-files-added</strong>
</code></pre>
</li>
<li>
<p>You can also load the original configuration and add the diff files manually to the images, using the <code>&lt;image&gt;.add-diff-file</code> command.</p>
</li>
<li>
<p>If you are building your own configurations (either as scripts or as checkpoints), you can add the diff files to the <code>files</code> attribute of the corresponding <code>image</code> object. This corresponds to what the <code>&lt;image&gt;.add-diff-file</code> command does.</p>
</li>
</ul>
<p>If you save several persistent states or image diff files that are dependent on each other, it may become cumbersome to take care of all these dependencies and to remember which files are important. You can <em>merge</em> the states or image diff files to create a new independent state:</p>
<ul>
<li>If you are working with persistent states, you can use the <code>checkpoint-merge</code> utility to create a persistent state that is independent of all previous files, including the original images provided with Simics. <strong>This is the recommended way of creating a new independent image</strong>. You can load it with the <code>load-persistent-state</code> command.</li>
<li>If you saved some image diff files manually, you can use the <code>craff</code> utility described below to merge the diff files yourself.</li>
</ul>
<h3 id="managedisks.html:reducing-memory-usage-due-to-images"><a href="#managedisks.html:reducing-memory-usage-due-to-images">2.5.2.3 Reducing Memory Usage Due to Images</a></h3>
<p>Although images are divided into pages that are only loaded on request, Simics can run out of host memory if very big images are used, or if the footprint of the software running on the simulated system is bigger than the host memory. To prevent these kind of problems, Simics implements a global image memory limitation controlled by the <code>set-image-memory-limit</code> command.</p>
<p>When Simics is started a default memory-limit is automatically set based on the amount of physical memory available on the host. The default memory-limit does not consider if other applications and users are running on the same host, nor what kind of target system that is simulated in Simics. (For example each target processor will allocate additional non-image memory, so for systems with many processors the default limit could be too high).</p>
<p>When the memory limit is reached, Simics will start swapping out pages to disk very much like an operating system would do. The <code>set-image-memory-limit</code> command lets you specify the maximum amount of memory that can be used, and where swapping should occur.</p>
<div class="note">
<p>This memory limitation only applies to <em>images</em>. Although this is unlikely, Simics can run out of memory due to other data structures becoming too large (for example memory profiling information) even though a memory limit has been set.</p>
</div>
<h3 id="managedisks.html:using-read-write-images"><a href="#managedisks.html:using-read-write-images">2.5.2.4 Using Read/Write Images</a></h3>
<p>As mentioned in section <a class="reference" href="#configuration.html:images">2.4.2.3</a>, images can also work as read-write media, although this is <strong>not</strong> recommended. It can be useful sometimes when planning to make large changes to an image (like installing an operating system on a disk).</p>
<p>To make an image read-write in your own configurations, simply set the second parameter (the "read-only" flag) of the <code>files</code> attribute in the image object to <code>"rw"</code>.</p>
<p>In this example we will use <code>QSP-x86 Firststeps</code> and a raw
file named <code>disk_image.raw</code> located in the project directory.</p>
<pre><code class="language-simics"># launch Firststeps using a raw disk-image file
$ ./simics qsp-x86/firststeps machine:software:linux:os_image=disk_image.raw
# read the 'files' attribute
simics&gt; <strong>@files = conf.board.disk0.hd_image.files</strong>
simics&gt; <strong>@files</strong>
[['%0%/disk_image.raw', 'ro', 0, 214748364800, 0]]
# provide the absolute path to the file
simics&gt; <strong>$img_file = (lookup-file disk_image.raw)</strong>
simics&gt; <strong>@files[-1][0] = simenv.img_file</strong>
# change the second element to make the file read-write
simics&gt; <strong>@files[-1][1] = "rw"</strong>
# check the result
simics&gt; <strong>@conf.board.disk0.hd_image.files</strong>
[['[project]&lt;/i&gt;/disk_image.raw', 'rw', 0, 214748364800, 0]]
</code></pre>
<p>Note that by indexing <code>files</code> with the index <code>-1</code>, the last element of the array is accessed, which is always the one that should be set read-write, in case <code>files</code> is a list of several files.</p>
<p>Simics does not look for files in the Simics search path when the files are used in read-write mode. If you do not provide an absolute path to a read-write file, a new file (in the uncompressed craff format) will be created in the current directory.</p>
<p>If the read/write file already exists, it must be a raw image or an uncompressed craff file. Simics does not support using compressed craff files in read/write mode.</p>
<p><strong>Use this feature with caution</strong>. Make sure to take a copy of the original image before running Simics with the image in read-write mode. Remember to synchronize the storage device within the target OS before exiting Simics, for example by shutting down the simulated machine.</p>
<h3 id="managedisks.html:editing-fat-images-using-mtools"><a href="#managedisks.html:editing-fat-images-using-mtools">2.5.2.5 Editing FAT Images Using Mtools</a></h3>
<p>This is a Linux specific chapter. If you have an image that contains a FAT file system, you can use Mtools (<a href="http://mtools.linux.lu" rel="noopener noreferrer" target="_top">http://mtools.linux.lu</a>) to get read-write access to the image. You must have a raw binary dump of the image for Mtools to work. This can be obtained using the <code>craff</code> utility (see section <a class="reference" href="#managedisks.html:the-craff-utility">2.5.2.8</a>).</p>
<p>A few wrapper scripts around Mtools are included in the Simics distribution in the scripts directory.</p>
<div class="dl">
<ul>
<li><span class="term" id="managedisks.html:dt:create-fat-sh"><a href="#managedisks.html:dt:create-fat-sh">create-fat.sh</a></span><br>
Creates an image with a formatted FAT file system.</li>
<li><span class="term" id="managedisks.html:dt:ls-fat-sh"><a href="#managedisks.html:dt:ls-fat-sh">ls-fat.sh</a></span><br>
Lists files in an image.</li>
<li><span class="term" id="managedisks.html:dt:copy-to-fat-sh"><a href="#managedisks.html:dt:copy-to-fat-sh">copy-to-fat.sh</a></span><br>
Copies one or more files or directories to an image.</li>
<li><span class="term" id="managedisks.html:dt:copy-from-fat-sh"><a href="#managedisks.html:dt:copy-from-fat-sh">copy-from-fat.sh</a></span><br>
Copies a file or directory from an image.</li>
</ul>
</div>
<p>If your image is partitioned (a complete disk for example), you may need to give Mtools special parameters like an <em>offset</em> or a <em>partition</em>. Please see the Mtools documentation for more information.</p>
<h3 id="managedisks.html:editing-images-using-loopback-mounting"><a href="#managedisks.html:editing-images-using-loopback-mounting">2.5.2.6 Editing Images Using Loopback Mounting</a></h3>
<p>This is a Linux specific chapter. If the host OS supports loopback devices, like, e.g., Linux, you can mount an image on your host machine and get direct read/write access to the files within the image. If you have root permissions this allows you to easily and quickly copy files.</p>
<div class="note">
<p>Remember that the image must be a raw binary dump. Disk dumps supplied with Simics are normally in <code>craff</code> format but you can use the <code>craff</code> utility to unpack the disk image to a raw image. The resulting images have the same size as the simulated disk, so you need to have sufficient free space on your host disk to contain the entire simulated disk image.</p>
</div>
<div class="note">
<p>Do not try to loopback mount an image over NFS. This does not work reliably on all operating systems (Linux, for example). Instead, move the image to a local disk and mount it from there.</p>
</div>
<p><strong>On Linux:</strong></p>
<pre><code>mount &lt;disk_dump&gt; mnt_pnt -o loop=/dev/loopn,offset=m
</code></pre>
<p>Example:</p>
<pre><code># mount /disk1/rh6.2-kde-ws /mnt/loop -o loop=/dev/loop0,offset=17063424
# cd /mnt/loop
# ls
bin   dev  home  lost+found  opt   root  tmp  var
boot  etc  lib   mnt         proc  sbin  usr
#
</code></pre>
<p>As shown in the example, the disk dump containing a Red Hat 6.2 KDE WS is mounted on the <code>/mnt/loop</code> directory. The file system mounted on <code>/</code> starts on the offset 17063424 on the disk. Linux autodetects the file system type when mounting (ext2 in this example). If you want to access another kind of file system, use the <em>-t <em>fs</em></em> option to the mount command. Once the file system is mounted, you can copy files in and out of the disk image.</p>
<p>The <code>offset</code> can be calculated by examining the partition table with <code>fdisk</code> (from within Simics). Use <code>mount</code> to find the partition you want to edit or examine (e.g., <code>/dev/hda2</code> is mounted on <code>/usr</code> which you want to modify). Next, run <code>fdisk</code> on the device handling this partition (such as <code>fdisk /dev/hda</code>). From within <code>fdisk</code>, change the display unit to sectors instead of cylinders with the <code>u</code> command and print the partition table with <code>p</code>. You will now see the start and end sectors of the partitions; you can get the offset by taking the start sector multiplied with the sector size (512).</p>
<p>When you have finished examining or modifying the disk, unmount it and touch the disk image. For example:</p>
<pre><code>cd
umount /mnt/loop
touch /disk1/rh6.2-kde-ws
</code></pre>
<p>The modification date of the disk image does not change when you modify the disk via the loopback device. Thus, if you have run Simics on the disk image earlier, the OS might have cached disk pages from the now modified disk image in RAM. This would cause a new Simics session to still use the old disk pages instead of the newly modified pages. Touching the image file should ensure that the OS rereads each page.</p>
<h3 id="managedisks.html:constructing-a-disk-from-multiple-files"><a href="#managedisks.html:constructing-a-disk-from-multiple-files">2.5.2.7 Constructing a Disk from Multiple Files</a></h3>
<p>In some cases, you may want to populate a simulated disk from multiple files covering different parts of the disk. For example, the partition table and boot sectors could be stored in a different disk image file than the main contents of the disk. If that is the case, you cannot use the <code>&lt;image&gt;.add-diff-file</code> command: you must set manually the disk image <code>files</code> attribute to put each image file at its appropriate location.</p>
<p>Assume you are simulating a PC and want to build a disk from a main file called <code>hda1_partition.img</code> and a master boot record image file called <code>MBR.img</code>. The main partition will start at offset 32256 of the disk, and the MBR (Master Boot Record) covers the first 512 bytes of the disk (typically, you would get the contents of these image files from the real disk as detailed in section <a class="reference" href="#managedisks.html:importing-a-real-disk-into-simics">2.5.9</a>). The following command in Simics's start-up script will build the disk from these two files.</p>
<pre><code class="language-simics">simics&gt; <strong>load-module std-comp</strong>
simics&gt; <strong>create-ide-disk-comp disk2 size = 2559836160</strong>
simics&gt; <strong>@image = get_component_object(conf.disk2, 'hd_image')</strong>
simics&gt; <strong>@image.files = [["hda1_partition.img", "ro", 32256, 1032151040, 0],</strong>
                  ["MBR.img",            "ro",     0,        512, 0]]
</code></pre>
<p>Note that the two image files cover non-overlapping and non-contiguous sections of the disk.</p>
<h3 id="managedisks.html:the-craff-utility"><a href="#managedisks.html:the-craff-utility">2.5.2.8 The Craff Utility</a></h3>
<p>The images distributed with Simics, and in general most of the images created by Simics, are in the <code>craff</code> file format. The <code>craff</code> utility can convert files to and from the <code>craff</code> format, and also merge several <code>craff</code> files into a single file.</p>
<p>In your Simics distribution you will find <code>craff</code> in <strong>Windows:</strong><code>[simics]\bin</code>, <strong>Linux:</strong><code>[simics]/bin</code>. The examples below assume that <code>craff</code> is present in your shell path.</p>
<div class="dl">
<ul>
<li>
<p><span class="term" id="managedisks.html:dt:convert-a-raw-dump-to-craff-format"><a href="#managedisks.html:dt:convert-a-raw-dump-to-craff-format">Convert a raw dump to <code>craff</code> format</a></span></p>
<pre><code>&gt; craff -o mydisk.craff mydisk.img
</code></pre>
</li>
<li>
<p><span class="term" id="managedisks.html:dt:convert-a-single-craff-file-to-a-raw-file"><a href="#managedisks.html:dt:convert-a-single-craff-file-to-a-raw-file">Convert a single <code>craff</code> file to a raw file</a></span></p>
<pre><code>&gt; craff --decompress -o mydisk.img mydisk.craff
</code></pre>
</li>
<li>
<p><span class="term" id="managedisks.html:dt:merge-multiple-craff-files-into-a-single-craff-file"><a href="#managedisks.html:dt:merge-multiple-craff-files-into-a-single-craff-file">Merge multiple craff files into a single <code>craff</code> file</a></span><br>
If more than one input file is specified, they will be merged so that later files override earlier files on the command line. The input craff files in this example come from several checkpoints.</p>
<pre><code>&gt; craff -o merged.craff chkpt1.craff chkpt2.craff chkpt3.craff
</code></pre>
</li>
<li>
<p><span class="term" id="managedisks.html:dt:add-a-craff-file-to-a-raw-dump-producing-a-new-dump"><a href="#managedisks.html:dt:add-a-craff-file-to-a-raw-dump-producing-a-new-dump">Add a <code>craff</code> file to a raw dump, producing a new dump</a></span></p>
<pre><code>&gt; craff --decompress -o new.img mydisk.img diff.craff
</code></pre>
<p>The input files can be any combination of raw and <code>craff</code> files.</p>
</li>
<li>
<p><span class="term" id="managedisks.html:dt:make-a-file-of-the-differences-of-two-dumps"><a href="#managedisks.html:dt:make-a-file-of-the-differences-of-two-dumps">Make a file of the differences of two dumps</a></span></p>
<pre><code>&gt; craff --diff -o diff.craff dump1.img dump2.img
</code></pre>
<p>The resulting file, <code>diff.craff</code>, will contain only what is needed to add to <code>dump1.img</code> in order to get <code>dump2.img</code>. This is useful to save space if little has been changed.</p>
</li>
</ul>
</div>
<p>See also the <a href="../rm-base/craff.html">craff</a> in the <a href="../rm-base/index.html">Simics Reference Manual</a>
for a full description of the <code>craff</code> utility and its parameters.</p>
<h3 id="managedisks.html:craff-fs"><a href="#managedisks.html:craff-fs">2.5.2.9 craff-fs</a></h3>
<p>Most large data files in Simics, such as disk images, are stored in the compressed random access file format (CRAFF). In order to manipulate the raw data in these files it is necessary to decompress the file using the <code>craff</code> tool. For disk images these files can be very large, so decompressing them is not always feasible. Therefore, we provide an alternative in the experimental craff-fs tool. With craff-fs you can "mount" the craff file and access it through the file system as if it is a normal raw file. The craff-fs tool is only available on Linux and is provided AS IS.</p>
<p>craff-fs requires <code>libfuse</code> version 2.x.x (tested with 2.9.9) and <code>libvtutils</code>.</p>
<p>The synopsis of craff-fs is as follows:</p>
<pre><code># ./bin/craff-fs 
craff-fs file mountpt [fuse-opts]
</code></pre>
<h4 id="managedisks.html:example"><a href="#managedisks.html:example">2.5.2.9.1 Example</a></h4>
<p>This examples shows how to "mount" a craff image of a disk image in order to expose it as raw data without decompressing it and then mount the resulting file via loop back in order to access the disk's file system. Mounting craff files as raw files does not require root privileges, but mounting loop back mounting the result usually does. In this example, we use the UEFI agent craff image from Simics package 2096.</p>
<p>The first step is to mount the craff file with craff-fs to be able to access the raw data. Note that the mount point directory must always be created first. As explained further below, there are permission issues that one has to get right, and one way is to use administrator privileges everywhere, so in this example we will do that.</p>
<pre><code>$ mkdir -p craff-mnt
$ sudo ./bin/craff-fs targets/common/images/efi_agent_and_grub_only.craff craff-mnt
</code></pre>
<p>The mount point will now be populated with two files: <code>data</code> and <code>info</code>.</p>
<p>Other users (including root or users with administrator privileges) cannot access the information mounted under craff-mnt mount point:</p>
<pre><code>$ ls craff-mnt
ls: cannot access 'craff-mnt': Permission denied
</code></pre>
<p>Details about the user, group and file permission cannot be accessed by other users (including root).</p>
<pre><code>$ ls -l
d????????? ? ?           ?               ?            ? craff-mnt/
</code></pre>
<p>If other users should access the mount point, "allow_others" should be uncommented from <code>/etc/fuse.conf</code> file. This will enable all users (including root) to list/view the contents.</p>
<p>The <code>data</code> file contains the raw data that makes up the craff file, the <code>info</code> file contains additional information about the craff file in text format:</p>
<pre><code>$ sudo cat craff-mnt/info 
Craff mount: 0.1.0

Craff version: 1
Compression: gzip
Size: 107374182400
Block bits: 13
Sub bits: 4
Directory bits: 9
</code></pre>
<h5 id="managedisks.html:use-of-parted-to-display-the-file-type-and-partitions"><a href="#managedisks.html:use-of-parted-to-display-the-file-type-and-partitions">2.5.2.9.1.1 Use of parted to display the file type and partitions</a></h5>
<p>Since a disk image will have different partitions at different offsets it is not possible to mount the "disk image". It is necessary to mount the individual partitions. There is a tool called <code>parted</code> that can display this information.</p>
<pre><code>$ sudo parted craff-mnt/data
GNU Parted 3.5
Using /disk1/simics-6/craff-mnt/data
Welcome to GNU Parted! Type 'help' to view a list of commands.
(parted) unit
Unit?  [compact]? b
(parted) print
Model:  (file)
Disk /disk1/jhbaarnh/simics/merge-6/simics-base/craff-mnt/data: 107374182400B
Sector size (logical/physical): 512B/512B
Partition Table: loop
Disk Flags: 

Number  Start  End            Size           File system  Flags
 1      0B     107374182399B  107374182400B  fat32
(parted) q
</code></pre>
<p>CraffFS allows mounting as read-write and read-only. File systems successfully tested: ext2, ext3, ext4, NTFS, FAT32.</p>
<p>It can be seen from the example above that the first partition has a fat32 file system and it starts at offset 0. This information will be required to mount that partition via the loop back device.</p>
<h5 id="managedisks.html:mounting-the-partitions"><a href="#managedisks.html:mounting-the-partitions">2.5.2.9.1.2 Mounting the partitions</a></h5>
<p>Mount as read-only:</p>
<pre><code>$ mkdir -p mnt-loop
$ sudo mount -o ro,loop,offset=0 craff-mnt/data mnt-loop
$ ls mnt-loop
EFI  SimicsAgent.efi
$ 
</code></pre>
<p>Mount as read-write:</p>
<pre><code>$ mkdir -p mnt-loop
$ sudo mount -o rw,loop,offset=1048576 craff-mnt/data mnt-loop
$ ls mnt-loop
EFI  SimicsAgent.efi
$ 
</code></pre>
<p>Mount command used with options (-o) requires administrator privileges. If the craff-fs command is run without administrator privileges, even if mount command is run as root, mounting will fail. There are two options:</p>
<ol>
<li>Run both craff-fs and mount commands as root.</li>
<li>Run craff-fs as normal user but edit <code>/etc/fuse.conf</code> and uncomment "allow_others". Root (and other users) can mount and access mounted files.</li>
</ol>
<h5 id="managedisks.html:unmounting-the-partitions"><a href="#managedisks.html:unmounting-the-partitions">2.5.2.9.1.3 Unmounting the partitions</a></h5>
<pre><code>$ sudo fusermount -u mnt-loop
$ sudo fusermount -u craff-mnt
</code></pre>
<h4 id="managedisks.html:use-craff-tool-to-reduce-the-size-of-craff-files-if-needed"><a href="#managedisks.html:use-craff-tool-to-reduce-the-size-of-craff-files-if-needed">2.5.2.9.2 Use CRAFF tool to reduce the size of CRAFF files if needed</a></h4>
<p>Craff files will increase in size as files and information is written, but the file will not automatically decrease if same files or others are removed/deleted. To shrink the craff file size after delete, create an zero file (full of zeros) until the end of the partition and use the <code>craff</code> tool. This tool will ignore all zero blocks and will shrink the craff file.</p>
<h2 id="managedisks.html:cd-roms-and-floppies"><a href="#managedisks.html:cd-roms-and-floppies">2.5.3 CD-ROMs and Floppies</a></h2>
<h3 id="managedisks.html:accessing-a-host-cd-rom-drive"><a href="#managedisks.html:accessing-a-host-cd-rom-drive">2.5.3.1 Accessing a Host CD-ROM Drive</a></h3>
<p>This is a Linux specific chapter. Accessing the CD-ROM of the host machine from inside the simulation is supported on Linux hosts. This is done by creating a <code>cdrom-image</code> object using the <code>new-cdrom-image</code> command. First, you should insert the CD in the host machine and figure out which device name it uses.</p>
<p>On a Linux host, this is typically <code>/dev/cdrom</code>, which is a symbolic link to the actual CD-ROM device, e.g., <code>/dev/hdc</code>. Note that you need read/write access to the CD-ROM device for this to work.</p>
<p>When you have the correct device file name, you create a <code>cdrom-image</code> object and insert it into the simulated CD-ROM drive:</p>
<pre><code class="language-simics">simics&gt; <strong>new-cdrom-image /dev/cdrom file_cd0</strong>
CDROM 'file_cd0' created
simics&gt; <strong>cd0.insert file_cd0</strong>
Inserting media 'file_cd0' into CDROM drive
</code></pre>
<p>Note that you must replace <code>/dev/cdrom</code> with the correct host device name as mentioned above, and <code>cd0</code> with the correct Simics object name. Use the <code>list-objects</code> command to find the correct object of class <code>ide-cdrom</code>.</p>
<p>The <code>cd0.insert</code> command simulates inserting a new disk into the CD-ROM drive, and there is also a corresponding <code>cd0.eject</code> command that simulates ejecting the disk.</p>
<h3 id="managedisks.html:accessing-a-cd-rom-image-file"><a href="#managedisks.html:accessing-a-cd-rom-image-file">2.5.3.2 Accessing a CD-ROM Image File</a></h3>
<p>A file containing an ISO-9660 image can be used as medium in the simulated CD-ROM. This image file can be created from real CD-ROM disks, or from collections of files on any disk.</p>
<p>On Linux, an image can be created from a set of files with the <code>mkisofs</code> program. For example:</p>
<pre><code>mkisofs -l -L -o image -r dir
</code></pre>
<p>On Windows, you can use a third-party product to create ISO-9660 images from files or from CD-ROMs, and a non-exhaustive list is given in figure <a class="reference" href="#managedisks.html:listofwindowsisoprograms">1</a>. Note that many programs can read CD-ROMs in either "file" or "raw" mode ("raw" mode is often called "aspi"). If CD-ROMs are read using file mode, the resulting image will not be bootable.</p>
<figure id="managedisks.html:listofwindowsisoprograms">
<table><thead><tr><th style="text-align: left">Product</th><th style="text-align: left">Site</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">WinImage</td><td style="text-align: left"><a href="http://www.winimage.com" rel="noopener noreferrer" target="_top">http://www.winimage.com</a></td><td style="text-align: left">Shareware, only copies images from real CD-ROM</td></tr>
<tr><td style="text-align: left">WinISO</td><td style="text-align: left"><a href="http://www.winiso.com" rel="noopener noreferrer" target="_top">http://www.winiso.com</a></td><td style="text-align: left">Shareware</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">UltraISO</td><td style="text-align: left"><a href="http://www.ezbsystems.com/" rel="noopener noreferrer" target="_top">http://www.ezbsystems.com/</a></td><td style="text-align: left">Shareware</td></tr>
<tr><td style="text-align: left">MagicISO</td><td style="text-align: left"><a href="http://www.magiciso.com" rel="noopener noreferrer" target="_top">http://www.magiciso.com</a></td><td style="text-align: left">Shareware, can make images from files, CD-ROMs, and DVD-ROMs, and edit ISO images.</td></tr>
<tr><td style="text-align: left">mkisofs</td><td style="text-align: left"><a href="http://wiki.osdev.org/Mkisofs" rel="noopener noreferrer" target="_top">http://wiki.osdev.org/Mkisofs</a></td><td style="text-align: left">Part of the cdrtools package, free, need Cygwin</td></tr>
</tbody></table>
 <figcaption>Figure 1. Windows Programs to Create ISO-9660 Images</figcaption> 
</figure>
<p>Once you have an image file, a <code>cdrom-image</code> object can be created, and then inserted into a simulated CD-ROM device in the same way as above:</p>
<pre><code class="language-simics">simics&gt; <strong>new-cdrom-image myimage.iso</strong>
CDROM 'myimage' created
simics&gt; <strong>cd0.insert myimage</strong>
Inserting media 'myimage' into CDROM drive
</code></pre>
<p>Note that <code>cd0</code> above refers to the Simics object name of the CD-ROM drive. This may or may not be called <code>cd0</code>. To see which object name to use, try the <code>list-objects</code> command and look for an object of class <code>ide-cdrom</code>.</p>
<h3 id="managedisks.html:accessing-a-host-floppy-drive"><a href="#managedisks.html:accessing-a-host-floppy-drive">2.5.3.3 Accessing a Host Floppy Drive</a></h3>
<p>This is a Linux specific chapter. It is possible to access a floppy on the host machine from within Simics if the host is running Linux. For example (assuming the floppy device object is called <code>flp0</code>):</p>
<pre><code class="language-simics">simics&gt; <strong>flp0.insert-floppy A /dev/fd0</strong>
</code></pre>
<div class="note">
<p>To boot directly from the floppy on a simulated x86 architecture you need to select the "A" drive to be the boot device:</p>
<pre><code class="language-simics">simics&gt; <strong>&lt;motherboard_x58_ich10&gt;.cmos-boot-dev A</strong>
</code></pre>
</div>
<h3 id="managedisks.html:accessing-a-floppy-image-file"><a href="#managedisks.html:accessing-a-floppy-image-file">2.5.3.4 Accessing a Floppy Image File</a></h3>
<p>Sometimes it can be convenient to have copies of boot floppies as image files. On Windows, to create an image of a floppy you can use, for example, WinImage (see section <a class="reference" href="#managedisks.html:accessing-a-cd-rom-image-file">2.5.3.2</a> above).</p>
<p>On Linux, you can use the <code>dd</code> command:</p>
<pre><code>dd if=/dev/fd0 of=floppy.img
</code></pre>
<p>It is then possible to use this image file in Simics:</p>
<pre><code class="language-simics">simics&gt; <strong>flp0.insert-floppy A floppy.img</strong>
</code></pre>
<div class="note">
<p>To boot directly from the floppy on a simulated x86 architecture you need to select the "A" drive to be the boot device:</p>
<pre><code class="language-simics">simics&gt; <strong>&lt;motherboard_x58_ich10&gt;.cmos-boot-dev A</strong>
</code></pre>
</div>
<p>Floppies are also a convenient way to move small amounts of data out of the simulated machine. Write the data to the simulated floppy inside the simulated machine, and then extract it from the image.</p>
<p>If it is formatted as a FAT file system, a floppy image can be manipulated with, for example, Mtools (Linux only, see section <a class="reference" href="#managedisks.html:editing-fat-images-using-mtools">2.5.2.5</a> for more information).</p>
<h2 id="managedisks.html:usb-disks"><a href="#managedisks.html:usb-disks">2.5.4 USB disks</a></h2>
<p>Virtual USB disks can be used to transfer files to and from virtual machines.</p>
<p>A virtual USB disk is created with the <code>new-usb-disk-comp</code> command. The command accepts a file with disk image and creates a USB disk component:</p>
<pre><code class="language-simics">simics&gt; <strong>load-module usb-comp</strong>
simics&gt; <strong>$usb_disk=(new-usb-disk-comp file = /tmp/stick.img name = usb_disk)</strong>
</code></pre>
<p>Next, you can insert the virtual USB disk into the machine. Exactly how that is done depends on the system that is being simulated. A virtual USB disk should be connected to an empty USB-port connector:</p>
<pre><code class="language-simics">simics&gt; <strong>$usb_disk.connect-to $system</strong>
Connecting usb_disk.usb_host to board.mb.sb.usb_port[10]
</code></pre>
<p>Writes to a virtual USB disk are normally not written directly to an image file, but cached in memory. The <code>&lt;image&gt;.save</code> command can be used to save changes to a new image file. One can find the objects that support the command with the help of the <code>list-objects</code> command:</p>
<pre><code class="language-simics">simics&gt; <strong>list-objects -all iface = image</strong>
+-------+----------------------------+
| Class |           Object           |
+-------+----------------------------+
...
|&lt;image&gt;|usb_disk.usb_scsi_disk_image|
...
simics&gt; <strong>usb_disk.usb_scsi_disk_image.save new_image</strong>
</code></pre>
<h2 id="managedisks.html:using-simicsfs-with-fuse"><a href="#managedisks.html:using-simicsfs-with-fuse">2.5.5 Using SimicsFS with FUSE</a></h2>
<p>SimicsFS with FUSE is a new implementation based on FUSE, Filesystem in Userspace, which is supported by most Linux systems[1]. This is a client-server solution, which is more feature complete and with better performance than the old SimicsFS kernel module and device solution.</p>
<p>The Simics extension, SimicsFS with FUSE, will grant a simulated Linux system access to the file system of the host computer from inside the simulation. This allows more storage space for the target system and may make copying files to and from the target system unnecessary as they can be accessed directly from the host file system.</p>
<p>The SimicsFS client, used for SimicsFS with FUSE, is a regular Linux user-space application that allows non-privileged users to mount and unmount file systems. The FUSE kernel module needs to be included in the Linux kernel and the libfuse userspace library[2] in the Linux distribution.</p>
<p>All accesses to the host filesystem will be made with the privileges of the user starting the Simics session.</p>
<div class="note">
[1] FUSE is compatible with all Linux kernels since version 2.4.
</div>
<div class="note">
[2] SimicsFS client is compatible with FUSE 2.6 or later. 
</div>
<p>Some characteristics/limitations for SimicsFS with FUSE:</p>
<ul>
<li>The user can only mount on a mountpoint, for which the user has write permission.</li>
<li>The mountpoint is owned by the user.</li>
<li>No other user (including root) can access the contents of the mounted file system (although this can be relaxed by using the allow_other and allow_root mount options).</li>
<li>All file system operations on the host are performed by the user running Simics, indifferent to which user requested the operations in the target system. Therefore even a super user on the target is constrained by the file system permissions of the user running Simics.</li>
<li>SimicsFS does not perform any character set transformation of characters in the file paths, so if different character sets are used on the simulated target and on the host, the characters may be interpreted differently.</li>
<li>SimicsFS is currently not using wide characters on Windows, and valid file path names are therefore limited to ASCII characters.</li>
<li>Read-only files on the target system may not be copied to the mounted file system. See workaround in section <a class="reference" href="#managedisks.html:using-simicsfs-client">2.5.5.2</a>.</li>
<li>On Windows, the SimicsFS client only has partial access to the actual permissions of files and directories. Some permissions are not correctly reported, nor configurable by the client. See table below.</li>
</ul>
<p>Limitations for Windows hosts:</p>
<table><thead><tr><th><strong>Operation</strong></th><th><strong>Restriction</strong></th></tr></thead><tbody>
<tr><td>Read</td><td>Read accesses cannot be denied, any attempts are silently ignored.</td></tr>
<tr><td>Read</td><td>Unreadable files may still appear readable, but reading will fail.</td></tr>
<tr><td>Soft-link</td><td>Windows filesystems do not support it.</td></tr>
<tr><td>Add/Remove</td><td>Write permission on the directory is ignored.</td></tr>
</tbody></table>
<h3 id="managedisks.html:installing-simicsfs-client"><a href="#managedisks.html:installing-simicsfs-client">2.5.5.1 Installing SimicsFS client</a></h3>
<p>The SimicsFS client is installed on some disk images distributed with Simics. Where there is also a <code>/host</code> directory and definitions in <code>/etc/fstab</code> for mounting SimicsFS with the command <code>mount /host</code> by root. Then the host files become accessible by root alone.</p>
<p>If you run your own Linux distribution you have to compile SimicsFS client yourself. The source code is located in the <code>src/misc/simicsfs-client/</code> directory and in the <code>src/misc/libmagicpipe/</code> directory of the Base package (pkg 1000). The Linux kernel must be compiled with FUSE support and the file system must include libfuse.</p>
<p>Example definition in the <code>/etc/fstab</code> for mounting SimicsFS with the command <code>mount /host</code> by root:</p>
<pre><code>simicsfs-client /host fuse defaults,noauto 0 0
</code></pre>
<p>Replace <code>/host</code> with your mount point. The simicsfs-client executable must be located in a directory included in the PATH environment variable, either by placing it there or adding its directory.</p>
<p>With the user option it is also possible to define entries in <code>/etc/fstab</code> for normal users to mount and unmount SimicsFS. Example showing mount of host user home directory on directory <code>&lt;dir&gt;</code>:</p>
<pre><code>simicsfs-client &lt;dir&gt; fuse defaults,noauto,user,modules=subdir,subdir=/home/&lt;user&gt; 0 0
</code></pre>
<p>The <code>&lt;dir&gt;</code> directory must be empty and have write permission for the user. The user mounts with the command <code>mount &lt;dir&gt;</code> and unmounts with the command <code>fusermount -u &lt;dir&gt;</code>.</p>
<p>See the fstab and fuse documentation ("man fstab", "man fuse") for more information about the available mount options.</p>
<h3 id="managedisks.html:using-simicsfs-client"><a href="#managedisks.html:using-simicsfs-client">2.5.5.2 Using SimicsFS client</a></h3>
<p>The SimicsFS client requires the SimicsFS server to be started:</p>
<pre><code class="language-simics">simics&gt; <strong>start-simicsfs-server</strong>
</code></pre>
<p>Example commands showing how to mount SimicsFS with the command <code>simicsfs-client</code>:</p>
<ul>
<li>
<p>Mount host root directory on directory <code>&lt;dir&gt;</code>:</p>
<pre><code>~:$ simicsfs-client &lt;dir&gt;
</code></pre>
</li>
<li>
<p>Mount host user home directory on directory <code>&lt;dir&gt;</code>:</p>
<pre><code>~:$ simicsfs-client &lt;dir&gt; -omodules=subdir,subdir=/home/&lt;user&gt;
</code></pre>
</li>
</ul>
<p>Example command showing how to unmount SimicsFS:</p>
<ul>
<li>Unmount SimicsFS on directory <code>&lt;dir&gt;</code>:
<pre><code>~:$ fusermount -u &lt;dir&gt;
</code></pre>
</li>
</ul>
<p>Example commands showing how to mount SimicsFS on <code>/host</code> directory by root with definition in <code>/etc/fstab</code>, see section <a class="reference" href="#managedisks.html:installing-simicsfs-client">2.5.5.1</a>:</p>
<ul>
<li>
<p>Mount host root directory on <code>/host</code>:</p>
<pre><code>~:$ mount /host
</code></pre>
</li>
<li>
<p>Mount host user home directory on <code>/host</code>:</p>
<pre><code>~:$ mount /host -omodules=subdir,subdir=/home/&lt;user&gt;
</code></pre>
</li>
</ul>
<p>Example command showing how to mount SimicsFS on <code>&lt;dir&gt;</code> directory by a normal user:</p>
<ul>
<li>
<p>Mount host user home directory on <code>&lt;dir&gt;</code>. A user can not add options to the mount command so the options are added in <code>/etc/fstab</code>, see section <a class="reference" href="#managedisks.html:installing-simicsfs-client">2.5.5.1</a>.</p>
<pre><code>~:$ mount &lt;dir&gt;
</code></pre>
</li>
</ul>
<div class="note">
<p>Read-only files on the target system may not be copied to the mounted file system. A workaround is to first touch the file in the mounted file system, which creates the file with write permission, and then copy the file from the target system to the mounted file system. Finally change permission of the destination file to read-only.</p>
</div>
<div class="note">
<p>When running Simics on Windows host, replace all '\' in the mount path with '/' to prevent interpretation of escape character by the simulated target software. Example:</p>
<pre><code>~:$ simicsfs-client dir -omodules=subdir,subdir=D:/home/&lt;user&gt;
</code></pre>
</div>
<h3 id="managedisks.html:simicsfs-path-substitution"><a href="#managedisks.html:simicsfs-path-substitution">2.5.5.3 SimicsFS Path Substitution</a></h3>
<p>The host directory mounted from a target system is the root directory by default, but that is configurable from the target system. Although, it may not be feasible or desirable to modify the target system configuration when the host system path changes. The path may also be part of a checkpoint and may not be applicable when the checkpoint is restored again. For these cases the host path can be substituted with a replacement path on the host.</p>
<p>To perform a substitution a path rule must be created. These are applied to every operation, with immediate effect. A rule can be general to all clients or specific to just a group of clients. The rule will look for a substring in the requested path and replace that substring with the new destination path. The substring matching is performed from the beginning of the path, but need not match the whole requested path in the mount command on the target.</p>
<p>A client may thus request an existing or non-existing path on the host. This path will be matched against the defined path rules to see if there is a match. Specific rules are checked first, then the general rules. Therefore a specific rule will always override a general one. Otherwise the rules are matched in the order they were added and only the first matching rule will be applied.</p>
<p><strong>EXAMPLES:</strong></p>
<p>One of the main use-cases for this feature is to allow access to a user defined path which is configured at run-time without the need to modify the target configuration. For instance the users may want to access their own home directories, without modifying the generic target image. For this purpose they define a mount-point <code>/mnt/home</code> which is configured to mount <code>/home/user</code> on the host. The host path <code>/home/user</code> may not exist on the host and requires the user to configure a path rule to substitute it for the real home directory of the current user.</p>
<pre><code class="language-simics">simics&gt; <strong>$userhome = (env HOME)</strong>
simics&gt; <strong>&lt;simicsfs-server&gt;.add-path-rule /home/user $userhome</strong>
~:$ mount -t simicsfs-client /mnt/home -osubdir,subdir=/home/user
</code></pre>
<p>Another major use-case for this feature is to solve the checkpoint problem, where a user has mounted some path on the local machine. This checkpoint is then shared with a colleague, who has similar files stored in another path. The colleague will then need to replace the requested host path with the actual path to the equivalent folder local to this other machine.</p>
<pre><code class="language-simics">simics&gt; <strong>&lt;simicsfs-server&gt;.add-path-rule /work/simics/proj /my/path/to/proj</strong>
</code></pre>
<p>Sometimes you may need to differentiate between different clients. When a client registers itself with the simicsfs server, it provides a bit of details on the target that it runs on. Each of these details can be used to select clients for different groups. These groups can then be given as an extra argument to the path rule, which will then only apply to the clients of that group. Once a client is registered, it is assigned a unique magic number.</p>
<pre><code class="language-simics">simics&gt; <strong>&lt;simicsfs-server&gt;.add-client-group a_team magic 0x0103a1245edb31da</strong>
simics&gt; <strong>&lt;simicsfs-server&gt;.add-path-rule "/" /proj/area_a a_team</strong>
</code></pre>
<p>The first line will create a group called <code>a_team</code> which will consist of the client with magic number <code>0x0103a1245edb31da</code>. Since the magic numbers are unique there can only be one client in this group. The second line will add a path rule that replaces the root directory with <code>/proj/area_a</code>, but only for clients that belong to group <code>a_team</code>.</p>
<div class="note">
<p>The simicsfs-client is not aware of any changes to the path rules, which means that recently accessed files may appear to still be present even though the path rule has changed to point to another destination. Operations on that file, however, will fail.</p>
</div>
<h2 id="managedisks.html:using-virtiofs"><a href="#managedisks.html:using-virtiofs">2.5.6 Using VirtioFS</a></h2>
<p>The Virtio File System Device is specified in the <a href="https://github.com/oasis-tcs/virtio-spec" rel="noopener noreferrer" target="_top">Virtio
specification</a>. The device is used to
share files between the host and the guest. There are drivers available for the
VirtioFS device for Linux (<code>CONFIG_VIRTIO_FS</code>) ,
<a href="https://github.com/tianocore/edk2/tree/master/OvmfPkg/VirtioFsDxe" rel="noopener noreferrer" target="_top">UEFI</a> and
<a href="https://github.com/virtio-win/kvm-guest-drivers-windows/tree/master/viofs" rel="noopener noreferrer" target="_top">Windows</a>.</p>
<h3 id="managedisks.html:requirements"><a href="#managedisks.html:requirements">2.5.6.1 Requirements</a></h3>
<ul>
<li>Target software with VirtioFS device driver</li>
<li>Target platform with a free PCIe slot that supports devices implemented using
the new PCIe library</li>
<li>The simulator must be running on a Linux host</li>
</ul>
<h3 id="managedisks.html:example-using-virtiofs-with-a-linux-target"><a href="#managedisks.html:example-using-virtiofs-with-a-linux-target">2.5.6.2 Example Using VirtioFS with a Linux Target</a></h3>
<p>This section describes how to use VirtioFS with a Linux target. Setting up
target software on different target types (UEFI or Windows) is out of scope of
this documentation. However, setup of the target platform would be similar.</p>
<h4 id="managedisks.html:linux-kernel"><a href="#managedisks.html:linux-kernel">2.5.6.2.1 Linux Kernel</a></h4>
<p>A Linux target would need to have <code>CONFIG_VIRTIO_FS</code>, <code>CONFIG_VIRTIO_PCI</code>,
<code>CONFIG_PCI</code>, <code>CONFIG_PCI_MSI</code> and <code>CONFIG_FUSE_FS</code> enabled in the kernel
configuration either as modules or built-in. For modern Linux distributions,
these options are usually enabled by default.</p>
<h4 id="managedisks.html:platform-setup"><a href="#managedisks.html:platform-setup">2.5.6.2.2 Platform Setup</a></h4>
<p>The following example shows how to use VirtioFS on board that has a free PCIe
slot that supports devices implemented using the new PCIe library.</p>
<pre><code class="language-simics">simics&gt; <strong>load-module virtio-comp</strong>
virtio-comp module loaded
simics&gt; <strong>new-virtio-pcie-fs-comp fs0 share = &lt;a-directory-in-the-host&gt; tag_name = fs0</strong>
Created instantiated 'virtio_pcie_fs_comp' component 'fs0'
simics&gt; <strong>fs0.connect-to board</strong>
Connecting fs0.upstream_target to board.mb.nb.pcie_slot[0]
</code></pre>
<h4 id="managedisks.html:interacting-with-the-virtiofs-device"><a href="#managedisks.html:interacting-with-the-virtiofs-device">2.5.6.2.3 Interacting with the VirtioFS Device</a></h4>
<p>The following example will show commands executed on the target prepended with
<strong>[root@board]#</strong> and commands executed on the host prepended with <strong>[host]#</strong>.
Comments are prepended with <strong>#</strong>.</p>
<pre><code class="language-shell"># Mount the VirtioFS device in the target, note that when we created the
# VirtioFS device above, we set the tag_name to fs0.
[root@board]# mount -t virtiofs fs0 /mnt
[root@board]# echo "hello from target" &gt; /mnt/channel.txt
[host]# cat &lt;shared-directory-in-the-host&gt;/channel.txt
hello from target
[host]# echo "hello from host" &gt; &lt;shared-directory-in-the-host&gt;/channel.txt
[root@board]# cat /mnt/channel.txt
hello from host
[root@board]# umount /mnt
</code></pre>
<h4 id="managedisks.html:using-the-virtiofs-device-as-a-root-file-system"><a href="#managedisks.html:using-the-virtiofs-device-as-a-root-file-system">2.5.6.2.4 Using the VirtioFS Device as a Root File System</a></h4>
<p>Since the VirtioFS device is recognized by linux as a file system device, it can
also be mounted by Linux as a root file system during boot. This can for example
be useful to quickly test changes in the root file system without needing to
rebuild or relaunch the target.</p>
<p>For this to work, the kernel command line must be modified to include
<code>rootfstype=virtiofs root=&lt;tag&gt;</code> where <code>&lt;tag&gt;</code> would be <code>fs0</code> in the case of the
created VirtioFS device above. Additionally, the files in the shared root file
system directory on the host must have appropriate permissions. An example of
having this set up is having buildroot creating a root file system with correct
permissions by using for instance the <code>BR2_TARGET_ROOTFS_TAR</code> config. One would
have to extract the content of the outputted tar file. Finally, since The
virtioFS daemon does not do any uid/gid translation, the uid/gid of the user
running the daemon is what the target will see. Therefore, running the simulator
under <code>fakeroot</code> is suggested to get proper uid/gid translation.</p>
<h5 id="managedisks.html:the-user-provided-linux-qsp-target"><a href="#managedisks.html:the-user-provided-linux-qsp-target">2.5.6.2.4.1 The User Provided Linux QSP Target</a></h5>
<p>The user provided Linux target for QSP has some flexibility which makes
integration of VirtioFS as a root file system device straight forward. An
example of launching the user provided Linux target with VirtioFS as root file
system is shown below.</p>
<pre><code class="language-simics">simics&gt; <strong>load-target qsp-x86/user-provided-linux machine:software:linux:kernel=&lt;path-to-kernel-image&gt; machine:software:linux:virtio_rootfs=&lt;path-to-root-file-system-directory&gt; machine:software:linux:cmdline="console=ttyS0,115200n8 earlyprintk rootfstype=virtiofs root=myfs rw"</strong>
</code></pre>
<h2 id="managedisks.html:using-tftp"><a href="#managedisks.html:using-tftp">2.5.7 Using TFTP</a></h2>
<p>It is possible to transfer files from the host environment to the target (simulated) machine by using the TFTP feature provided by the <code>service-node</code>. Since TFTP executes in lockstep, with only one packet acknowledged at a time, it is slower than for example FTP, but it reliably transports files between the host and target machines.</p>
<p>It is assumed that a service node has been created and connected to the Ethernet device through an Ethernet link. The following example presents how TFTP is used on a target machine which is running Linux and has the <code>tftp</code> program installed. Furthermore, the target machine in this example is using the IP address 10.10.0.10 and the service node uses 10.10.0.1.</p>
<p>Creating a service node and connecting it to the target machine can be done with the <code>connect-real-network</code> command. This will also set up port forwarding to the real network, even though this is not a requirement for using TFTP:</p>
<pre><code class="language-simics">simics&gt; <strong>connect-real-network 10.10.0.10</strong>
</code></pre>
<p>After booting the target machine into Linux the first step is to bring up the network interface that is connected to the service node. At the target prompt, issue:</p>
<pre><code>joe@computer: ~# ifconfig eth0 10.10.0.10 up
</code></pre>
<p>To transfer the file <code>myfile.txt</code> from the host machine, issue:</p>
<pre><code>joe@computer: ~# tftp -l myfile.txt -g 10.10.0.1
</code></pre>
<p>The directory that the service node uses to find files downloaded by the target can be changed with the <code>&lt;service-node&gt;.set-tftp-directory</code> command. This also controls where uploaded files are saved. The default is to search the Simics path, starting with the current working directory of the Simics process. The search path can be changed with the <code>add-directory</code> command and can be viewed with the <code>list-directories</code> command.</p>
<h2 id="managedisks.html:using-ftp-service"><a href="#managedisks.html:using-ftp-service">2.5.8 Using FTP service</a></h2>
<p>The <code>service-node</code> provides a FTP service to support file transfers with the host using FTP clients on a target machine.</p>
<p>Assuming a <code>service-node</code> has been created, and that it is named <code>default_service_node0</code>, the FTP-service will be named <code>default_service_node0.ftp</code>. The service node must be configured with an IP address and connected to a link before the FTP service can be enabled and configured. The FTP root directory, the location on the host system for transferred files, can be set by the <code>set-ftp-directory</code> command. The default root directory is the current directory for the Simics session, usually your project directory.</p>
<p>On a target that runs Clear Linux there is usually a <code>curl</code> command for transferring data using various protocols, it can put a file to the server and retrieve a file from the server.</p>
<p>Here is an example on using the FTP service on a target running <code>Firststeps</code> with a network. Start Simics and run the following commands:</p>
<pre><code class="language-simics">simics&gt; <strong>run-script "targets/qsp-x86/firststeps.simics"</strong>
simics&gt; <strong>default_service_node0.set-ftp-directory dir = "/tmp/"</strong>
</code></pre>
<p>A <code>Firststeps</code> target was created. The target machine's IP address is 10.10.0.1 and it contains a <code>default_service_node0</code> with the FTP service. The root directory was set to the <code>/tmp/</code> directory on the host file system.</p>
<p>Continue the simulation until a prompt is reached.</p>
<pre><code class="language-simics">simics&gt; <strong>c</strong>
</code></pre>
<p>When prompt has been reached, the <code>curl</code> command can be run in the text console.</p>
<pre><code>~ # curl -T /etc/hostname ftp://10.10.0.1/targetfile.txt
</code></pre>
<p>The contents of the target file <code>/etc/hostname</code> has now been sent to the host file <code>targetfile.txt</code> in the path set from the <code>set-ftp-directory</code> command. In similar way:</p>
<pre><code>~ # curl ftp://10.10.0.1/targetfile.txt -o hostfile.txt
</code></pre>
<p>will retrieve a file, <code>targetfile.txt</code>, from the host and save it as <code>hostfile.txt</code> on the target.</p>
<p>Using other kind of distributions of Linux than Clear Linux there will most likely exist a <code>ftp</code> command in the shell for running a ftp client. An example on how to put a file to the host:</p>
<pre><code>#&gt; ftp 10.10.0.1
Connected to 10.10.0.1.
220 Welcome to the Simics FTP server
Name (10.10.0.1:simics): &lt;enter&gt;
230 User logged in
ftp&gt; put /proc/cpuinfo targetfile.txt
local: /proc/cpuinfo remote: targetfile.txt
200 OK
150 transfer about to start
226 file transfer done
6520 bytes sent in 0.00 secs (12734.4 kB/s)
</code></pre>
<p>If running Microsoft Windows as target then Windows Internet Explorer can be used as client to connect to the FTP service by entering <a href="ftp://10.10.0.1">ftp://10.10.0.1</a> as address. This will allow transfer from host to target. To be able to transfer files back to the host you will need to select <strong>Page → Open FTP Site in Windows Explorer</strong>.</p>
<h2 id="managedisks.html:importing-a-real-disk-into-simics"><a href="#managedisks.html:importing-a-real-disk-into-simics">2.5.9 Importing a Real Disk into Simics</a></h2>
<p>It is possible to create an image by copying data from a real disk. If the disk to be copied contains an operating system, you must have at least two operating systems on the machine, since the partition that should be copied should <strong>not</strong> be in use or mounted.</p>
<p>Before making a copy of a disk, some information about the disk should be gathered:</p>
<ul>
<li>The number of disk cylinders</li>
<li>The number of sectors per track</li>
<li>The number of disk heads</li>
<li>The offset where the specific partition starts (optional)</li>
<li>The size of a specific partition (optional)</li>
</ul>
<p>On Linux, these numbers can be obtained using the <code>fdisk</code> utility. You can choose to make a copy of the whole disk or just a partition of the disk using the <code>dd</code> utility. Example:</p>
<pre><code>dd if=/dev/hdb of=hdb_disk.img
</code></pre>
<p>On Windows, you can use the System Information application to find the information under <code>Components/Storage/Disks</code>. You have to select the <code>Advanced</code> setting from the <code>View</code> menu. If you have Cygwin (<a href="http://www.cygwin.com" rel="noopener noreferrer" target="_top">http://www.cygwin.com</a>) installed, you can use the <code>dd</code> utility to create the image, provided that the correct entries in the <code>/dev</code> file system are created. To access the first hard drive (<code>/dev/hda</code>):</p>
<pre><code>mkdir -p /dev/hda
mount -s -b '\\.\PHYSICALDRIVE0' /dev/hda
</code></pre>
<p>You can also mount a specific drive letter:</p>
<pre><code>mkdir -p /dev/fd0
mount -s -b '\\.\A:' /dev/fd0
</code></pre>
<p>or</p>
<pre><code>mkdir -p /dev/hda1
mount -s -b '\\.\C:' /dev/hda1
</code></pre>
<p>Cygwin's <code>mount</code> program creates persistent mounts (they are stored in the registry), so you will only need to set these things up once. The <em>-b</em> option to <code>mount</code> ensures that no CR/LF conversions are made. See the Cygwin documentation for further details on how to use the <code>mount</code> command.</p>
<p>On Windows hosts without Cygwin, a third-party program can be used to create the disk images. See figure <a class="reference" href="#managedisks.html:listofwindowsisoprograms">1</a> for more details.</p>
<div class="note">
<p>To save space, you may want to compress the disk image using the <code>craff</code> utility. See section <a class="reference" href="#managedisks.html:the-craff-utility">2.5.2.8</a>.</p>
</div>
<p>The next step is to prepare the target configuration so it can use the new disk. For x86 targets, the <code>dredd</code> machine has a <code>$disk_files</code> parameter that can be set to a list of files to use in the image object of the boot disk, and also <code>$disk_size</code> that specifies the size of that disk.</p>
<pre><code>$disk_size = 1056964608
$disk_files = [["hdb_disk.img", "ro", 0, 1056964608, 0]]
</code></pre>
<p>For other machines, that do not have these parameters, attributes in the disk object and its corresponding image objects have to be set instead.</p>
<p>Make sure to set the <code>$disk_size</code> correctly to reflect the size of the disk that has been copied. If only a partition has been copied, the offset where the partition starts, and the size of the partition, should be set in the file list. If the whole disk has been copied, the offset is zero and the size should be the size of the whole disk. Several partitions can be combined to form the complete disk, as described in section <a class="reference" href="#managedisks.html:constructing-a-disk-from-multiple-files">2.5.2.7</a>.</p>
<p>For an x86 machine, the system component will automatically set the BIOS geometry for the <code>C:</code> disk. It can also be set manually:</p>
<pre><code class="language-simics">simics&gt; <strong>system_cmp0.cmos-hd C 1023 16 63</strong>
</code></pre>
<h2 id="managedisks.html:foreign-image-formats-including-qemu-and-vmware"><a href="#managedisks.html:foreign-image-formats-including-qemu-and-vmware">2.5.10 Foreign Image Formats Including QEMU and VMware</a></h2>
<p>Similar to using a disk image copied from a real disk as in section <a class="reference" href="#managedisks.html:importing-a-real-disk-into-simics">2.5.9</a>, images from other simulators or virtual machines can also be imported into Simics.</p>
<p>As when importing real disks, care has to be taken to map parameters outside of the disk itself to suitable parameters in the Simics virtual machine. Such parameters include disk geometry, type of disk, and simulated hardware. For example, importing a SCSI disk image to an IDE disk image in Simics may cause issues as the disk may lack drivers for IDE, or the software configuration may simply expect the disk to show up with a name that corresponds to the type of disk, leading to failure in locating critical data.</p>
<p>Many simulator and virtual machine file formats can be converted for Simics use through the <code>qemu-img</code> tool included with <code>QEMU</code>. Notably, any <code>QEMU</code> format and several <code>VMware</code> formats can be converted to the raw image format with <code>qemu-img</code>. The <code>qemu-img</code> tool is not included with Simics, but can be downloaded from <a href="http://www.qemu.org" rel="noopener noreferrer" target="_top">http://www.qemu.org</a>. See the <code>QEMU</code> documentation for more information about <code>qemu-img</code>.</p>
<p>The resulting raw image file can be used directly in Simics, or converted to <code>craff</code>. See <a class="reference" href="#managedisks.html:image-file-formats">2.5.2.1</a> for a description of Simics image file formats.</p>
<h2 id="managedisks.html:serial-links"><a href="#managedisks.html:serial-links">2.5.11 Serial Links</a></h2>
<h3 id="managedisks.html:serial-link-component"><a href="#managedisks.html:serial-link-component">2.5.11.1 Serial Link Component</a></h3>
<p>Connecting simulated machines over a simulated serial connection is done by creating a <code>ser-link</code> component that connects to the serial devices in the machines. The link object can be thought of as modeling a serial cable that is plugged into the connectors on the devices—and just like a real cable, it is a point-to-point connection that connects exactly two devices.</p>
<p>The link object models serial communication at the character level in a simplified way. The bandwidth for the connection is configured in the link object, which means that the serial devices do not need to be explicitly configured by software.</p>
<p>New <code>ser-link</code> components can be added with the <code>new-ser-link</code> command:</p>
<pre><code class="language-simics">simics&gt; <strong>load-module ser-link</strong>
simics&gt; <strong>new-ser-link</strong>
Created instantiated 'ser_link' component 'serial_link0'
</code></pre>
<p>Serial connectors of other components can then connect to that link. The serial link has two connectors, <code>device0</code> and <code>device1</code>, representing the two endpoints of the cable. For an <code>QSP-x86</code> machine, the second UART can be connected to the link the following way:</p>
<pre><code class="language-simics">simics&gt; <strong>connect serial_link0.device0 board.mb.sb.serial[2]</strong>
</code></pre>
<h4 id="managedisks.html:text-and-telnet-consoles"><a href="#managedisks.html:text-and-telnet-consoles">2.5.11.1.1 Text and Telnet Consoles</a></h4>
<p>In addition to simulated serial devices, either endpoint of a serial link can be hooked up to a text console. (And just as with serial devices, you have the option of connecting the two endpoints directly without having a link in between—though this is generally much more useful with consoles.)</p>
<p>A text console can open GUI windows on the host computer, and let the user talk to the connected serial device. The text console also has the ability to start a telnet server; the user can then use any telnet program to connect to this server, and talk to the connected serial device.</p>
<p>You create text consoles by instantiating <code>txt_console_comp</code> components, and connecting them to the link or device you want them to talk to, as in the following example:</p>
<pre><code class="language-simics">simics&gt; <strong>new-txt-console-comp con visible=TRUE</strong>
simics&gt; <strong>connect con.serial board.mb.sb.serial[2]</strong>
</code></pre>
<h3 id="managedisks.html:host-serial-console"><a href="#managedisks.html:host-serial-console">2.5.11.2 Host Serial Console</a></h3>
<p>The text consoles also have the ability to open host serial connections. This is a way of connecting a terminal application through a serial port on the host machine to a serial device object in Simics. The procedure is almost identical in both Linux and Windows. The following examples show how to open host serial connections on a <code>QSP-x86</code> machine, first in Linux:</p>
<pre><code class="language-simics">simics&gt; <strong>board.serconsole.con.host-serial-setup pty = /dev/pts/1</strong>
[board.serconsole.con info] Device opened: /dev/pts/1
</code></pre>
<p>And the same procedure in Windows:</p>
<pre><code class="language-simics">simics&gt; <strong>board.serconsole.con.host-serial-setup pty = COM1</strong>
[board.serconsole.con info] Opened: COM1
</code></pre>
<p>The host serial connection will operate at the baud rate and other attributes that are set for the physical serial port of the host. In Linux these host settings are edited with <code>stty</code>. In Windows these settings must be edited from a <strong>Command Prompt</strong>, this is an example:</p>
<pre><code>C:\&gt; mode com1: baud=4800 parity=n data=8 stop=1
</code></pre>
<p>It is also possible to open a host serial connection to a virtual serial port. In Linux this is called pseudo-terminal or pseudo-device. If there is no parameter specified to <code>host-serial-setup</code>, any free <code>pts</code> is opened.</p>
<p>However, in Windows a virtual serial port must have been created in advance. There exist several Windows third-party utilities which create virtual serial port pairs for various purposes. In the following example, first such a pair has been created with the port names COM98 and COM99, then a host serial connection can be opened to port 98, and finally the terminal application can connect to port 99 and the two can communicate over the pair:</p>
<pre><code class="language-simics">simics&gt; <strong>board.serconsole.con.host-serial-setup pty = COM98</strong>
[board.serconsole.con info] Opened: COM98
</code></pre>
<h4 id="managedisks.html:using-host-serial-connections-with-windows-hyperterminal"><a href="#managedisks.html:using-host-serial-connections-with-windows-hyperterminal">2.5.11.2.1 Using host serial connections with Windows HyperTerminal</a></h4>
<p>Once the host serial connection has been configured within Simics it is possible to connect to it using a standard terminal program running on your host system. In this section we will use the HyperTerminal application, which comes bundled with some Windows versions, to connect to the simulated system.</p>
<p>First launch HyperTerminal from <strong>Start Menu → All Programs → Accessories → Communications → HyperTerminal</strong>. The dialog <em>Connection Description</em> will appear, as shown in Figure <a class="reference" href="#managedisks.html:host-serial-hyperterminal-setup">2</a>. Name the Connection "Simics" and press <em>OK</em>. In the next dialog, select the COM-port that Simics has opened in the field <em>Connect using</em>. In the next dialog, just accept the default settings and press <em>OK</em>.</p>
<figure id="managedisks.html:host-serial-hyperterminal-setup">
<p><img alt="" src="hyperterm-1-new-connection.png"> </p><figcaption>Figure 2. Connecting to Simics using the Windows HyperTerminal</figcaption><p></p>
</figure>
<p>Now, resume the simulation in Simics. The output from the simulated serial console will appear in the HyperTerminal window. See figure <a class="reference" href="#managedisks.html:host-serial-hyperterminal-running">3</a>.</p>
<figure id="managedisks.html:host-serial-hyperterminal-running">
<p><img alt="" src="hyperterm-2-running.png"> </p><figcaption>Figure 3. HyperTerminal connected to a simulation</figcaption><p></p>
</figure>
</section><section class="page" id="instrumentation.html"><h1 id="instrumentation.html:instrumentation"><a href="#instrumentation.html:instrumentation">2.6 Instrumentation</a></h1>
<p>This section describes the <em>Instrumentation Framework</em> in Simics.</p>
<p>Simics' instrumentation framework provides a mechanism for inspecting various parts of the running simulated system and features a flexible way to dynamically add/remove inspections. The framework is designed with performance in mind, allowing fast and parallel execution with low latency communication.</p>
<p>Unlike most profiling tools, which instrument the target source code or object code, Simics can profile a workload non-intrusively. This allows you to profile without disturbing the execution. Simics will profile arbitrary code, including device drivers, dynamically generated code, and code for which you do not have the source. Also, unlike most profiling tools, Simics collects profiling data exactly, not by sampling the execution and relying on statistics.</p>
<p>What information that can be obtained through the instrumentation framework depends on how well the devices and other objects have been adapted to this new framework. Since the framework is new, only some models support instrumentation through various interfaces:</p>
<ul>
<li>The processor models provide inspection capabilities to monitor instruction execution, memory accesses, exceptions, register changes etc. Only ARC, ARM, MIPS, PPC, X86 and Xtensa processor targets currently support this kind of instrumentation.</li>
<li>The SystemC Library awareness support tracing, breaking and custom tools for acting on the basic signals, sockets, event and processes that exists in a typical SystemC configuration. Please refer to <a href="../systemc-library/index.html">Simics SystemC Library</a>  documentation for more details.</li>
<li>DML device models will automatically support bank-instrumentation allowing register bank accesses to be monitored and controlled.</li>
</ul>
<p>Conceptually, Simics instrumentation framework consists of four elements:</p>
<ul>
<li><em><strong>Instrumentation providers</strong></em> are models of devices, processors, etc., that have been adapted for the instrumentation framework. Providers supply information on various things happening in the model, such as instructions being executed, exceptions triggered, or a device register written, etc.</li>
<li><em><strong>Instrumentation tools</strong></em> are objects which can connect to the providers and request information to be sent to them. The tool collects the information and provides user-commands for presenting the result.</li>
<li><em><strong>Instrumentation connections</strong></em> are the communication channels used when a tool and a provider are connected to each other.</li>
<li><em><strong>Instrumentation filters</strong></em> are optional objects which can be used by one or several tools. The filters make sure the tool only gets parts of the information from the provider by enabling or disabling the instrumentation according to the filter algorithm.</li>
</ul>
<p>Figure <a class="reference" href="#instrumentation.html:instrumentation-ex1">4</a> shows an abstract view of a possible setup. The instrumentation provider sends information through an instrumentation connection to the tool. The instrumentation filter can decide to disable the gathering of information from the provider. At any point within the simulation the tool can produce output for the user on what it has collected.</p>
<figure id="instrumentation.html:instrumentation-ex1">
<p><img alt="" src="instrumentation-ex1.png"> </p><figcaption>Figure 4. Abstract view of instrumentation elements</figcaption><p></p>
</figure>
<p>To concretize the abstract example in a more realistic setup, figure <a class="reference" href="#instrumentation.html:instrumentation-ex2">5</a> shows an "instruction-histogram" tool which counts the instructions being executed and their frequency, producing a histogram of the most commonly used instructions that were executed on this processor (system-wide, that is, both instructions in the operating system, kernel threads, and all user-level processes are counted).</p>
<figure id="instrumentation.html:instrumentation-ex2">
<p><img alt="" src="instrumentation-ex2.png"> </p><figcaption>Figure 5. Simple example</figcaption><p></p>
</figure>
<p>If only a specific application's instruction mix is of interest, we can add a filter to this setup. In figure <a class="reference" href="#instrumentation.html:instrumentation-ex3">6</a>, a process-filter has been setup to monitor the 'perl' application only. The process-filter uses the OS-Awareness feature in Simics to get information when any perl process is created, scheduled on a certain cpu, or die. With this knowledge, the process-filter enables and disables the instruction-histogram collection. The output from the instruction-histogram is now only the instruction mix for the perl application(s) that has executed.</p>
<figure id="instrumentation.html:instrumentation-ex3">
<p><img alt="" src="instrumentation-ex3.png"></p>
 <figcaption>Figure 6. Simple example with a filter</figcaption> 
</figure>
<p>Filters are orthogonal to the tools, and the tools are themselves unaware of any existing filters controlling them. From the tool perspective, it is simply someone requesting their connections to be disabled or enabled.</p>
<p>It is possible to have multiple filters controlling one tool as shown in figure <a class="reference" href="#instrumentation.html:instrumentation-ex4">7</a>. This allows sophisticated setups for zooming in a specific details of the instrumentation gathered.</p>
<p>In principle, all tools always have one filter: the user, which can use Simics commands to enable or disable the communication manually, in a script or in a script-branch. By using enable/disable commands in a script branch, the user have the possibility to control when the instrumentation should be active based on virtual-time, breakpoints triggered etc.</p>
<p>As long as all filters enables the tool's connection, it will be active.</p>
<figure id="instrumentation.html:instrumentation-ex4">
<p><img alt="" src="instrumentation-ex4.png"></p>
 <figcaption>Figure 7. Multiple filters, all enables</figcaption> 
</figure>
<p>But as shown in figure <a class="reference" href="#instrumentation.html:instrumentation-ex5">8</a> when any filter decides to disable the connection it will become disabled and remain so until all filters have enabled it again.</p>
<figure id="instrumentation.html:instrumentation-ex5">
<p><img alt="" src="instrumentation-ex5.png"></p>
 <figcaption>Figure 8. Multiple filters, one disables</figcaption> 
</figure>
<p>How providers and tools are allowed to be connected depends on the tool's requirements of the providers interfaces. That is, some tools can only connect to certain providers.</p>
<p>It is possible to connect:</p>
<ul>
<li>Multiple tools to the same provider. Each tool might extract the same or different information from the provider and produce various valuable output for the user.</li>
<li>One tool to multiple providers. Collecting system-wide statistics. For example, one tool can be connected to all processors in an SMP setup.</li>
<li>The same tool to the same provider, multiple times. Where each established connection might be configured to extract different information</li>
</ul>
<p>An even more advanced example is illustrated the in figure <a class="reference" href="#instrumentation.html:advanced-example">9</a>. In this setup, there are two tools working simultaneously, both are connected to the same SMP cluster of processors and both are using the same filter which tracks the 'perl' application.</p>
<figure id="instrumentation.html:advanced-example">
<p><img alt="" src="instrumentation-ex6.png"> </p><figcaption>Figure 9. Advanced example</figcaption><p></p>
</figure>
<h2 id="instrumentation.html:command-set"><a href="#instrumentation.html:command-set">2.6.1 Command Set</a></h2>
<p>This chapter describes an overview of the Simics commands that can be used in relation to instrumentation support.</p>
<p>When Simics has loaded a system configuration, providers normally already exist, as part of the device models. Which tools that are available depends on the Simics packages installed. To get an overview of the available instrumentation commands in Simics, use the command: <code>help Instrumentation</code>.</p>
<p>It is also possible to use the <code>list-instrumentation-tools</code> command to see the tools available.</p>
<p>Available tools must first be created with a <code>new-&lt;tool&gt;</code> command, for example <code>new-instruction-histogram</code>.</p>
<p>Once a tool has been created it will have a number of generic instrumentation commands associated with it, as well as tool specific commands. Tools typically supports the following generic commands:</p>
<ul>
<li><code>&lt;tool&gt;..add-instrumentation</code> — connect the tool to provider(s).</li>
<li><code>&lt;tool&gt;..remove-instrumentation</code> — disconnect the tool from provider(s).</li>
<li><code>&lt;tool&gt;..disable-instrumentation</code> — temporary disable information gathering.</li>
<li><code>&lt;tool&gt;..enable-instrumentation</code> — re-enable information gathering.</li>
<li><code>&lt;tool&gt;..add-filter</code> — adds a filter to the tool.</li>
<li><code>&lt;tool&gt;..remove-filter</code> — remove a filter from the tool.</li>
</ul>
<p>By connecting an <em>Instrumentation tool</em> object to an <em>Instrumentation provider</em> object, information can be extracted from the running system. Connecting can be done either directly when the tool is created with the <code>new-&lt;tool&gt;</code> command, or done afterwards with the <code>&lt;tool&gt;.add-instrumentation</code> command.</p>
<p>The established connections between providers and tools can be listed with the <code>list-instrumentation</code> command.</p>
<p>Figure <a class="reference" href="#instrumentation.html:command-example">10</a> shows a simple example of commands for creating two different instruction histograms and their output after running some instructions.</p>
<figure id="instrumentation.html:command-example">
<pre><code class="language-simics">simics&gt; <strong>new-instruction-histogram -connect-all view = size</strong>
[board.mb.cpu0.core[0][0] info] VMP not engaged. Reason: instrumentation enabled.
Created ihist0 (connected to 1 processor)
simics&gt; <strong>new-instruction-histogram -connect-all view = mnemonic</strong>
Created ihist1 (connected to 1 processor)
simics&gt; <strong>list-instrumentation</strong>
  1 ihist0 - connected to board.mb.cpu0.core[0][0]:0 view = "size"
  2 ihist1 - connected to board.mb.cpu0.core[0][0]:1 view = "mnemonic"
simics&gt; <strong>c 10000</strong>
simics&gt; <strong>ihist0.histogram</strong>
┌─────┬───────┬─────┬───────┬───────────┐
│Row #│  Size │Count│ Count%│Accumulated│
│     │(bytes)│     │       │   Count%  │
├─────┼───────┼─────┼───────┼───────────┤
│    1│      2│ 4480│ 44.80%│     44.80%│
│    2│      1│ 1661│ 16.61%│     61.41%│
│    3│      3│ 1596│ 15.96%│     77.37%│
│    4│      5│ 1074│ 10.74%│     88.11%│
│    5│      4│  560│  5.60%│     93.71%│
│    6│      6│  408│  4.08%│     97.79%│
│    7│      7│  212│  2.12%│     99.91%│
│    8│      8│    8│  0.08%│     99.99%│
│    9│     10│    1│  0.01%│    100.00%│
├─────┼───────┼─────┼───────┼───────────┤
│Sum  │       │10000│100.00%│           │
└─────┴───────┴─────┴───────┴───────────┘
Average size of executed instruction: 2.702500 (21 bits)

simics&gt; <strong>ihist1.histogram max = 10</strong>
┌─────────┬────────┬─────┬───────┬───────────┐
│  Row #  │mnemonic│Count│ Count%│Accumulated│
│         │        │     │       │   Count%  │
├─────────┼────────┼─────┼───────┼───────────┤
│        1│mov     │ 3025│ 30.25%│     30.25%│
│        2│jmp     │  901│  9.01%│     39.26%│
│        3│add     │  864│  8.64%│     47.90%│
│        4│cmp     │  854│  8.54%│     56.44%│
│        5│out     │  731│  7.31%│     63.75%│
│        6│movsx   │  413│  4.13%│     67.88%│
│        7│jne     │  386│  3.86%│     71.74%│
│        8│inc     │  377│  3.77%│     75.51%│
│        9│je      │  345│  3.45%│     78.96%│
│       10│jae     │  267│  2.67%│     81.63%│
├─────────┼────────┼─────┼───────┼───────────┤
│# 10/42  │        │     │       │           │
│Sum (all)│        │10000│100.00%│           │
│Sum shown│        │ 8163│ 81.63%│           │
└─────────┴────────┴─────┴───────┴───────────┘
</code></pre>
 <figcaption>Figure 10. Command Example</figcaption> 
</figure>
<p>The framework also supports creating named groups, which can be used in the above commands to, for example, disable a number of connections with a single command. Such groups can be created with the <code>create-instrumentation-group</code> command. The group name can then be used when the connection is established with the <code>new-&lt;tool&gt;</code> and <code>&lt;tool&gt;.add-instrumentation</code> commands.</p>
<p>Each established connection between a provider and tool gets a connection specific sub-object associated with the tool. When multiple tools are connected to a provider, by default, the provider will give instrumentation information to each tool in the order they where connected. That is, each new connection automatically comes last.</p>
<p>Some providers, however, supports re-arranging the order of how the tools are called. This can be useful if one tool makes any kind of change to the simulation that the other tools should see the effect of. For providers which support re-arranging the dispatch order, the <code>instrumentation-order</code> command can be used to see the order and the <code>instrumentation-move</code> command can be used to move a tool connection to an earlier or later stage.</p>
<p>The instrumentation setup is session specific, thus it will not be saved in checkpoints. To re-establish the instrumentation capabilities after loading a checkpoint, objects must be re-created and communication setup again using the same commands that was used before the checkpoint was saved. This can for example be done in a script executed after the checkpoint has been loaded.</p>
<h2 id="instrumentation.html:instrumentation-tools"><a href="#instrumentation.html:instrumentation-tools">2.6.2 Instrumentation Tools</a></h2>
<p>Below are some instrumentation tools listed, that are currently distributed (including source code), together with a short description of the tools purposes.</p>
<div class="dl">
<ul>
<li><span class="term" id="instrumentation.html:dt:bank-patch-tool"><a href="#instrumentation.html:dt:bank-patch-tool"><strong>bank-patch-tool</strong></a></span><br>
Allows the user to override certain device bank offsets (registers) by returning a different value when they are read.</li>
<li><span class="term" id="instrumentation.html:dt:bank-coverage-tool"><a href="#instrumentation.html:dt:bank-coverage-tool"><strong>bank-coverage-tool</strong></a></span><br>
Provides statistics concerning the number of register accesses to the devices of connected banks, including the proportion ('coverage') of accessed registers.</li>
<li><span class="term" id="instrumentation.html:dt:exception-histogram"><a href="#instrumentation.html:dt:exception-histogram"><strong>exception-histogram</strong></a></span><br>
Provides a histogram of the observed exception/interrupts on the connected processors.</li>
<li><span class="term" id="instrumentation.html:dt:instruction-count"><a href="#instrumentation.html:dt:instruction-count"><strong>instruction-count</strong></a></span><br>
Simple tool that just counts how many instructions that have executed one or several connected processors. This information is available from Simics too, but with the help of the process-filters it is for example possible to see the amount of instructions executed by a specific process. Note that Simics measures "steps" which are either instructions or interrupts/exceptions, so there can be small differences in Simics steps compared to the instruction count reported by this tool.</li>
<li><span class="term" id="instrumentation.html:dt:instruction-histogram"><a href="#instrumentation.html:dt:instruction-histogram"><strong>instruction-histogram</strong></a></span><br>
Provides a histogram of the executed instruction-types on the connected processors. Instruction-types can be grouped in various ways such as by mnemonic or instruction sizes.</li>
<li><span class="term" id="instrumentation.html:dt:memory-profiler"><a href="#instrumentation.html:dt:memory-profiler"><strong>memory-profiler</strong></a></span><br>
Counts the memory accesses (both instruction and data) from the connected processors and their memory addresses.</li>
<li><span class="term" id="instrumentation.html:dt:process-histogram"><a href="#instrumentation.html:dt:process-histogram"><strong>process-histogram</strong></a></span><br>
Histogram of the executed processes (using OS-Awareness). Details includes steps executed, number of times a process have been created, how often it has been scheduled on a processor.</li>
<li><span class="term" id="instrumentation.html:dt:tracer-tool"><a href="#instrumentation.html:dt:tracer-tool"><strong>tracer-tool</strong></a></span><br>
An instruction and data tracer for connected processors.</li>
<li><span class="term" id="instrumentation.html:dt:ram-tracer-tool"><a href="#instrumentation.html:dt:ram-tracer-tool"><strong>ram-tracer-tool</strong></a></span><br>
A data tracer for connected RAM/ROM objects.</li>
<li><span class="term" id="instrumentation.html:dt:x86-branch-profiler"><a href="#instrumentation.html:dt:x86-branch-profiler"><strong>x86-branch-profiler</strong></a></span><br>
Histogram of the used branch instruction on connected x86 processors, with statistics on whether the branches where taken or falls through.</li>
</ul>
</div>
<h2 id="instrumentation.html:instrumentation-filters"><a href="#instrumentation.html:instrumentation-filters">2.6.3 Instrumentation Filters</a></h2>
<p>The following instrumentation filters are available, including source code:</p>
<div class="dl">
<ul>
<li><span class="term" id="instrumentation.html:dt:process-filter"><a href="#instrumentation.html:dt:process-filter"><strong>process-filter</strong></a></span><br>
Filters on one or several processes, only activating the instrumentation when these processes are being executed. Requires that OS-Awareness is properly configured.</li>
<li><span class="term" id="instrumentation.html:dt:mode-filter"><a href="#instrumentation.html:dt:mode-filter"><strong>mode-filter</strong></a></span><br>
CPU filter for hypervisor, supervisor or user mode.</li>
<li><span class="term" id="instrumentation.html:dt:x86-mode-filter"><a href="#instrumentation.html:dt:x86-mode-filter"><strong>x86-mode-filter</strong></a></span><br>
Filter for x86 specific execution modes; RealMode16, RealMode32, Virtual86, ProtectedMode16, ProtectedMode32, ProtectedMode64, CompatibilityMode16 and CompatibilityMode32.</li>
</ul>
</div>
<h2 id="instrumentation.html:exporting-instrumentation-data"><a href="#instrumentation.html:exporting-instrumentation-data">2.6.4 Exporting Instrumentation Data</a></h2>
<p>Some instrumentation tools supports printing out the gathered data to a comma separated value (<code>.csv</code>) file. This makes it easy to import the raw data with an external spreadsheet program, for further analyses, calculations and visualizing the data as graphs.</p>
<p>Any Simics object that implements the <code>table</code> interface will automatically get the <code>export-table-csv</code> command and it exist on either the tool for the total, the individual connection objects, or both. See figure <a class="reference" href="#instrumentation.html:export-csv-example">11</a> for an example.</p>
<figure id="instrumentation.html:export-csv-example">
<pre><code class="language-simics">$&gt; ./simics targets/qsp-x86/firststeps.simics num_cores=8
simics&gt; <strong>new-instruction-histogram -connect-all</strong>
[board.mb.cpu0.core[0][0] info] VMP not engaged. Reason: instrumentation enabled.
Created ihist0 (connected to 8 processors)
simics&gt; <strong>run 10 s</strong>
simics&gt; <strong>ihist0.export-table-csv file = all-cpus-10seconds.csv</strong>
simics&gt; <strong>ihist0.con0.export-table-csv file = first-cpu-10seconds.csv</strong>
simics&gt; <strong>quit</strong>
</code></pre>
<pre><code>$&gt; head all-cpus-10seconds.csv
mnemonic,Count
mov,919169650
add,302311251
cmp,206492934
test,160303832
adc,150848000
jne,144637182
je,133354184
lea,120721026
push,97795399

$&gt; head first-cpu-10seconds.csv
mnemonic,Count
mov,414052451
add,165503526
cmp,100845317
adc,88820557
test,71309728
jne,70008313
lea,56315642
movzx,54618965
je,52189244
</code></pre>
 <figcaption>Figure 11. Exporting to CSV files</figcaption> 
</figure>
<h2 id="instrumentation.html:profiling-example"><a href="#instrumentation.html:profiling-example">2.6.5 Profiling Example</a></h2>
<p>This chapter describes a sample session when using some of the instrumentation tools. Refer to the command descriptions for details on each individual command.</p>
<p>As a basis for this example, the Coremark <a href="https://www.eembc.org/coremark/" rel="noopener noreferrer" target="_top">www.eembc.org/coremark/</a> benchmark will be run and analyzed in Simics. The source code is downloadable with an Apache license and very easy to compile and run. In this example Coremark will be run on a x86 QSP system running Linux.</p>
<h3 id="instrumentation.html:profiling-setup"><a href="#instrumentation.html:profiling-setup">2.6.5.1 Profiling Setup</a></h3>
<p>The Coremark binary was compiled on standard x86 Linux host system and in this example we are using the simics-agent to transfer the binary to the target system. The script in figure <a class="reference" href="#instrumentation.html:setup-instrumentation">12</a> shows how the binary is uploaded to the target, enabling instrumentation only for the coremark executable and starting coremark and waiting for it to be finished.</p>
<figure id="instrumentation.html:setup-instrumentation">
<pre><code class="language-simics">simics&gt; <strong>run-script "targets/qsp-x86/firststeps.simics"</strong>
simics&gt; <strong>script-branch {</strong>
    local $con = board.serconsole.con
    local $bin = coremark.exe
    local $params = " 0x0 0x0 0x66 10000 7 1 2000"    # run1 parameters (10000 iterations)
    local $prompt = "# "

    # Wait for a linux prompt to appear and then upload our binary
    # to the target system using simics-agent
    bp.console_string.wait-then-write console = $con $prompt "simics-agent &amp;\n"
    $am = (start-agent-manager)
    $m  = ($am.connect-to-agent)
    $m.change-directory "/root"
    $j = ($m.upload -executable $bin)
    $m.wait-for-job $j

    # Create and connect instrumentation tools
    $ihn = (new-instruction-histogram -connect-all view = x86-normalized)
    $ihs = (new-instruction-histogram -connect-all view = size)
    $bp = (new-x86-branch-profiler -connect-all)
    $mp = (new-memory-profiler -connect-all -read-logical -write-logical -execute-logical)

    # Only let the instrumentation tools monitor our process
    $pattern ="name='" + $bin + "'"
    $pf = (new-process-filter software-component = board.software pattern = $pattern)
    $ihn.add-filter filter = $pf
    $ihs.add-filter filter = $pf
    $bp.add-filter filter = $pf
    $mp.add-filter filter = $pf

    # Start the process, wait for it to finish, and then stop simulation
    $con.input "\n"
    bp.console_string.wait-then-write console = $con $prompt ("./" + $bin + $params + "\n")
    $con.bp-wait-for-console-string $prompt
    stop
}
simics&gt; <strong>run</strong>
</code></pre>
 <figcaption>Figure 12. Setup Script</figcaption> 
</figure>
<p>In this setup four instrumentation tools are enabled:</p>
<ul>
<li>An instruction histogram which takes a look at each instruction being executed and analyzes the x86 disassembly string. Registers such as EAX, EDX are replaced with "r32" indicating they operating on a normal 32 bit registers. Similarly immediate values are replaced with an "imm" marker.</li>
<li>Another instruction histogram which instead groups the instructions by their instruction sizes in bytes.</li>
<li>An x86 branch-profiler tool which monitors common branch instructions and checks if conditional branches take the jumps of falls-through.</li>
<li>A memory profiler which monitors all instruction and data accesses from the processor and keeps track of how many reads/writes and executes there are on each logical memory location being accessed.</li>
</ul>
<p>The instrumentation data gathered by these tools will be analyzed a bit in the next chapters. To get a bit more readable big numbers, the following commands splits the numbers with underscores on logical units; <code>digit-grouping 10 3</code> for decimal values and <code>digit-grouping 16 4</code> for hexadecimal values.</p>
<h3 id="instrumentation.html:instruction-profiling"><a href="#instrumentation.html:instruction-profiling">2.6.5.2 Instruction Profiling</a></h3>
<p>First lets take a look of which instructions that are most commonly executed shown in figure <a class="reference" href="#instrumentation.html:instruction-mix">13</a>.</p>
<figure id="instrumentation.html:instruction-mix">
<pre><code class="language-simics">simics&gt; <strong>ihist0.histogram max = 10</strong>
┌─────────┬────────────────────────────────┬─────────────┬───────┬───────────┐
│  Row #  │         x86 normalized         │    Count    │ Count%│Accumulated│
│         │                                │             │       │   Count%  │
├─────────┼────────────────────────────────┼─────────────┼───────┼───────────┤
│        1│mov r32,r32                     │  330_467_974│  9.60%│      9.60%│
│        2│jne imm                         │  308_597_223│  8.96%│     18.56%│
│        3│mov r64,r64                     │  204_178_395│  5.93%│     24.49%│
│        4│je imm                          │  190_302_166│  5.53%│     30.01%│
│        5│add r32,r32                     │  142_190_315│  4.13%│     34.14%│
│        6│test r64,r64                    │  140_221_077│  4.07%│     38.21%│
│        7│mov r64,qword ptr [r64]         │  139_282_002│  4.04%│     42.26%│
│        8│and r32,imm                     │  130_455_258│  3.79%│     46.05%│
│        9│cmp r8,imm                      │  123_723_347│  3.59%│     49.64%│
│       10│movsx r32,word ptr [r64+r64*imm]│  123_120_000│  3.58%│     53.22%│
├─────────┼────────────────────────────────┼─────────────┼───────┼───────────┤
│# 10/425 │                                │             │       │           │
│Sum (all)│                                │3_443_579_955│100.00%│           │
│Sum shown│                                │1_832_537_757│ 53.22%│           │
└─────────┴────────────────────────────────┴─────────────┴───────┴───────────┘
</code></pre>
 <figcaption>Figure 13. Instruction mix</figcaption> 
</figure>
<p>Here the 10 most commonly executed instruction combination is listed. A total of 425 different instruction variants was identified when running the coremark benchmark. With 10,000 iterations in coremark, roughly 3 billion instructions was executed in total. SSE registers are marked as x128 in the disassembly, lets see if any of these where executed in figure <a class="reference" href="#instrumentation.html:sse-instructions">14</a>.</p>
<figure id="instrumentation.html:sse-instructions">
<pre><code class="language-simics">simics&gt; <strong>ihist0.histogram sort-on-column = "x86 normalized" instruction-regexp = ".*x128"</strong>
 Table reduced from 425 to 29 rows
┌─────┬──────────────────────────────────┬─────┐
│Row #│          x86 normalized          │Count│
├─────┼──────────────────────────────────┼─────┤
│    1│cvtsi2sd(64) x128,r64             │    5│
│    2│divsd x128,[rip+imm]              │    4│
│    3│divsd x128,x128                   │    1│
│    4│movapd x128,x128                  │    1│
│    5│movaps xmmword ptr [r64+imm],x128 │   16│
│    6│movd r64,x128                     │   10│
│    7│movd x128,r32                     │   42│
│    8│movd x128,r64                     │    6│
│    9│movdqa x128,x128                  │   71│
│   10│movdqa x128,xmmword ptr [r64+imm] │    1│
│   11│movdqu x128,xmmword ptr [r64+imm] │   45│
│   12│movdqu x128,xmmword ptr [r64]     │   48│
│   13│movsd [r64+imm],x128              │    1│
│   14│movsd [r64-imm],x128              │    2│
│   15│movsd x128,[r64+imm]              │    1│
│   16│movsd x128,[r64]                  │    2│
│   17│movsd x128,[rip+imm]              │    1│
│   18│pcmpeqb x128,x128                 │  178│
│   19│pcmpeqb x128,xmmword ptr [r64+imm]│    9│
│   20│pcmpeqb x128,xmmword ptr [r64]    │    1│
│   21│pminub x128,[r64+imm]             │    3│
│   22│pmovmskb r32,x128                 │  103│
│   23│por x128,x128                     │   85│
│   24│pshufd x128,x128,imm              │   41│
│   25│punpcklbw x128,x128               │   41│
│   26│punpcklwd x128,x128               │   41│
│   27│pxor x128,x128                    │   68│
│   28│ucomisd x128,[rip+imm]            │    1│
│   29│ucomisd x128,x128                 │    1│
├─────┼──────────────────────────────────┼─────┤
│Sum  │                                  │  829│
└─────┴──────────────────────────────────┴─────┘
</code></pre>
 <figcaption>Figure 14. SSE instructions</figcaption> 
</figure>
<p>So a few instructions, but they are not used in the body of the benchmark at all, since they are executed so few times. Now lets investigate the instruction sizes of the executed instructions, which is gathered by the other instruction-histogram shown in figure <a class="reference" href="#instrumentation.html:instruction-sizes">15</a>.</p>
<figure id="instrumentation.html:instruction-sizes">
<pre><code class="language-simics">simics&gt; <strong>ihist1.histogram</strong>
┌─────┬───────┬─────────────┬───────┬───────────┐
│Row #│  Size │    Count    │ Count%│Accumulated│
│     │(bytes)│             │       │   Count%  │
├─────┼───────┼─────────────┼───────┼───────────┤
│    1│      3│1_552_922_442│ 45.10%│     45.10%│
│    2│      2│  867_469_439│ 25.19%│     70.29%│
│    3│      4│  575_089_349│ 16.70%│     86.99%│
│    4│      5│  253_701_408│  7.37%│     94.35%│
│    5│      6│  145_314_324│  4.22%│     98.57%│
│    6│      1│   34_766_864│  1.01%│     99.58%│
│    7│      7│    9_451_053│  0.27%│     99.86%│
│    8│      8│    4_273_215│  0.12%│     99.98%│
│    9│      9│      550_962│  0.02%│    100.00%│
│   10│     10│       40_428│  0.00%│    100.00%│
│   11│     11│          456│  0.00%│    100.00%│
│   12│     12│           14│  0.00%│    100.00%│
├─────┼───────┼─────────────┼───────┼───────────┤
│Sum  │       │3_443_579_954│100.00%│           │
└─────┴───────┴─────────────┴───────┴───────────┘
Average size of executed instruction: 3.187071 (25 bits)
</code></pre>
 <figcaption>Figure 15. Instruction sizes</figcaption> 
</figure>
<p>Three byte instructions are by far the most common instruction size when executing this benchmark.</p>
<p>The branch-profiler will report more details on the branch instructions shown in figure <a class="reference" href="#instrumentation.html:branch-instructions">16</a>.</p>
<figure id="instrumentation.html:branch-instructions">
<pre><code class="language-simics">simics&gt; <strong>bprof0.histogram max = 15</strong>
┌─────────┬───────────┬───────────┬───────────┬───────────┬───────┬───────────┐
│  Row #  │   Branch  │   Taken   │  Non-taken│   Total   │ Total%│Accumulated│
│         │Instruction│           │           │           │       │   Total%  │
├─────────┼───────────┼───────────┼───────────┼───────────┼───────┼───────────┤
│        1│jne        │273_402_780│ 35_194_443│308_597_223│ 47.44%│     47.44%│
│        2│je         │ 10_877_292│179_424_874│190_302_166│ 29.25%│     76.69%│
│        3│jmp        │ 34_532_902│          -│ 34_532_902│  5.31%│     82.00%│
│        4│ja         │  6_862_422│ 15_880_527│ 22_742_949│  3.50%│     85.50%│
│        5│call       │ 20_884_324│          -│ 20_884_324│  3.21%│     88.71%│
│        6│ret        │ 20_884_320│          -│ 20_884_320│  3.21%│     91.92%│
│        7│jbe        │ 14_880_208│  2_120_535│ 17_000_743│  2.61%│     94.53%│
│        8│jg         │  6_640_020│  6_320_100│ 12_960_120│  1.99%│     96.52%│
│        9│jb         │  7_021_647│    880_696│  7_902_343│  1.21%│     97.74%│
│       10│js         │  3_991_228│  2_330_079│  6_321_307│  0.97%│     98.71%│
│       11│jle        │  2_665_772│  2_280_227│  4_945_999│  0.76%│     99.47%│
│       12│jae        │    360_746│  3_080_521│  3_441_267│  0.53%│    100.00%│
│       13│jns        │         29│         10│         39│  0.00%│    100.00%│
│       14│jl         │         14│          4│         18│  0.00%│    100.00%│
│       15│jcxz       │          0│          0│          0│  0.00%│    100.00%│
├─────────┼───────────┼───────────┼───────────┼───────────┼───────┼───────────┤
│# 15/22  │           │           │           │           │       │           │
│Sum (all)│           │403_003_704│247_512_016│650_515_720│100.00%│           │
│Sum shown│           │403_003_704│247_512_016│650_515_720│100.00%│           │
└─────────┴───────────┴───────────┴───────────┴───────────┴───────┴───────────┘
</code></pre>
 <figcaption>Figure 16. Branch instructions</figcaption> 
</figure>
<p>Here we see the most commonly used branch instruction with information if the branches were taken or not. Unconditional jumps, of course, always jumps. Finally, we can get instruction information from the memory-profiler shown in figure <a class="reference" href="#instrumentation.html:instruction-profile-4k">17</a>.</p>
<figure id="instrumentation.html:instruction-profile-4k">
<pre><code class="language-simics">simics&gt; <strong>mprof0.profile view = execute-logical max = 10</strong>
┌─────────┬────────────────┬────────────────┬─────────────┬───────┬───────────┐
│  Row #  │     Start      │      Stop      │    Count    │ Count%│Accumulated│
│         │                │                │             │       │   Count%  │
├─────────┼────────────────┼────────────────┼─────────────┼───────┼───────────┤
│        1│     0x0040_1000│     0x0040_1fff│2_454_100_308│ 71.27%│     71.27%│
│        2│     0x0040_2000│     0x0040_2fff│  909_181_060│ 26.40%│     97.67%│
│        3│     0x0040_0000│     0x0040_0fff│   80_070_862│  2.33%│     99.99%│
│        4│0x7ff1_b614_4000│0x7ff1_b614_4fff│       56_044│  0.00%│    100.00%│
│        5│0x7ff1_b65d_c000│0x7ff1_b65d_cfff│       48_656│  0.00%│    100.00%│
│        6│0x7ff1_b65d_e000│0x7ff1_b65d_efff│       29_808│  0.00%│    100.00%│
│        7│0x7ff1_b65e_b000│0x7ff1_b65e_bfff│       22_112│  0.00%│    100.00%│
│        8│0x7ff1_b65d_b000│0x7ff1_b65d_bfff│       15_855│  0.00%│    100.00%│
│        9│0x7ff1_b65e_3000│0x7ff1_b65e_3fff│        8_683│  0.00%│    100.00%│
│       10│0x7ff1_b609_b000│0x7ff1_b609_bfff│        7_780│  0.00%│    100.00%│
├─────────┼────────────────┼────────────────┼─────────────┼───────┼───────────┤
│# 10/90  │                │                │             │       │           │
│Sum (all)│                │                │3_443_579_954│100.00%│           │
│Sum shown│                │                │3_443_541_168│100.00%│           │
└─────────┴────────────────┴────────────────┴─────────────┴───────┴───────────┘
</code></pre>
 <figcaption>Figure 17. Instruction executed in memory (4K granularity)</figcaption> 
</figure>
<p>Here we can see where we have executed most, using the logical addresses. By default, the range between start and stop is set to 4K, but this can be controlled through a command argument. So the coremark binary executed on a total of 90 4K pages, but 99.9% of its execution was only in three pages. The memory-profiler will count the first byte of an instruction as executed. So if we decrease the granularity to just one byte shown in figure <a class="reference" href="#instrumentation.html:instruction-profile-1b">18</a>.</p>
<figure id="instrumentation.html:instruction-profile-1b">
<pre><code class="language-simics">simics&gt; <strong>mprof0.profile view = execute-logical granularity = 1 max = 10</strong>
┌──────────┬───────────┬───────────┬─────────────┬───────┬───────────┐
│  Row #   │   Start   │    Stop   │    Count    │ Count%│Accumulated│
│          │           │           │             │       │   Count%  │
├──────────┼───────────┼───────────┼─────────────┼───────┼───────────┤
│         1│0x0040_1333│0x0040_1333│   61_200_000│  1.78%│      1.78%│
│         2│0x0040_1336│0x0040_1336│   61_200_000│  1.78%│      3.55%│
│         3│0x0040_1339│0x0040_1339│   61_200_000│  1.78%│      5.33%│
│         4│0x0040_133c│0x0040_133c│   61_200_000│  1.78%│      7.11%│
│         5│0x0040_133f│0x0040_133f│   61_200_000│  1.78%│      8.89%│
│         6│0x0040_1330│0x0040_1330│   59_160_000│  1.72%│     10.60%│
│         7│0x0040_112a│0x0040_112a│   29_160_000│  0.85%│     11.45%│
│         8│0x0040_112d│0x0040_112d│   29_160_000│  0.85%│     12.30%│
│         9│0x0040_1950│0x0040_1950│   29_160_000│  0.85%│     13.14%│
│        10│0x0040_1953│0x0040_1953│   29_160_000│  0.85%│     13.99%│
├──────────┼───────────┼───────────┼─────────────┼───────┼───────────┤
│# 10/12542│           │           │             │       │           │
│Sum (all) │           │           │3_443_579_954│100.00%│           │
│Sum shown │           │           │  481_800_000│ 13.99%│           │
└──────────┴───────────┴───────────┴─────────────┴───────┴───────────┘
</code></pre>
 <figcaption>Figure 18. Instruction executed in memory (1 byte granularity)</figcaption> 
</figure>
<p>This produces the top-list of the most executed instruction of the benchmark. A total of 12542 unique instructions (in memory) have been executed.</p>
<h3 id="instrumentation.html:data-profiling"><a href="#instrumentation.html:data-profiling">2.6.5.3 Data Profiling</a></h3>
<p>For the same coremark run, now examine a bit on how many data accesses that happened, using the memory-profile tool again shown in figure <a class="reference" href="#instrumentation.html:read-profile-4k">19</a>.</p>
<figure id="instrumentation.html:read-profile-4k">
<pre><code class="language-simics">simics&gt; <strong>mprof0.profile view = read-logical max = 10</strong>
┌─────────┬────────────────┬────────────────┬─────────────┬───────┬───────────┐
│  Row #  │     Start      │      Stop      │    Count    │ Count%│Accumulated│
│         │                │                │             │       │   Count%  │
├─────────┼────────────────┼────────────────┼─────────────┼───────┼───────────┤
│        1│     0x0060_5000│     0x0060_5fff│2_064_749_345│ 76.15%│     76.15%│
│        2│0x7fff_15e5_e000│0x7fff_15e5_efff│  646_513_938│ 23.84%│     99.99%│
│        3│          0x0000│          0x0fff│       79_652│  0.00%│     99.99%│
│        4│0x7ff1_b67f_3000│0x7ff1_b67f_3fff│       48_740│  0.00%│     99.99%│
│        5│0x7fff_15e5_d000│0x7fff_15e5_dfff│       24_501│  0.00%│     99.99%│
│        6│0x7ff1_b67f_6000│0x7ff1_b67f_6fff│       12_934│  0.00%│     99.99%│
│        7│0x7ff1_b67f_0000│0x7ff1_b67f_0fff│       12_375│  0.00%│    100.00%│
│        8│0x7ff1_b63c_6000│0x7ff1_b63c_6fff│       10_768│  0.00%│    100.00%│
│        9│0x7ff1_b67f_5000│0x7ff1_b67f_5fff│        5_678│  0.00%│    100.00%│
│       10│0x7ff1_b63c_4000│0x7ff1_b63c_4fff│        4_988│  0.00%│    100.00%│
├─────────┼────────────────┼────────────────┼─────────────┼───────┼───────────┤
│# 10/88  │                │                │             │       │           │
│Sum (all)│                │                │2_711_569_260│100.00%│           │
│Sum shown│                │                │2_711_462_919│100.00%│           │
└─────────┴────────────────┴────────────────┴─────────────┴───────┴───────────┘
</code></pre>
 <figcaption>Figure 19. Read profile (4K granularity)</figcaption> 
</figure>
<p>Here we can see that the reads to memory is pretty much only associated to one heap-page, and one stack-page. The memory-profiler here annotates each byte as being read. So if the software performs a 32 bit read, the four bytes will all have an increased counter. The similar for command for write-accesses is shown in figure <a class="reference" href="#instrumentation.html:write-profile-4k">20</a>.</p>
<figure id="instrumentation.html:write-profile-4k">
<pre><code class="language-simics">simics&gt; <strong>mprof0.profile view = write-logical max = 10</strong>
┌─────────┬─────────────────────┬─────────────────────┬─────────────┬───────┬───────────┐
│  Row #  │        Start        │         Stop        │    Count    │ Count%│Accumulated│
│         │                     │                     │             │       │   Count%  │
├─────────┼─────────────────────┼─────────────────────┼─────────────┼───────┼───────────┤
│        1│          0x0060_5000│          0x0060_5fff│  595_005_622│ 53.23%│     53.23%│
│        2│     0x7fff_15e5_e000│     0x7fff_15e5_efff│  522_602_567│ 46.75%│     99.99%│
│        3│0xffff_8801_f35a_f000│0xffff_8801_f35a_ffff│       81_720│  0.01%│     99.99%│
│        4│     0x7fff_15e5_d000│     0x7fff_15e5_dfff│       22_052│  0.00%│    100.00%│
│        5│     0x7ff1_b63c_6000│     0x7ff1_b63c_6fff│        5_924│  0.00%│    100.00%│
│        6│     0x7ff1_b602_3000│     0x7ff1_b602_3fff│        4_093│  0.00%│    100.00%│
│        7│     0x7ff1_b67f_3000│     0x7ff1_b67f_3fff│        3_690│  0.00%│    100.00%│
│        8│     0x7ff1_b65d_2000│     0x7ff1_b65d_2fff│        2_893│  0.00%│    100.00%│
│        9│     0x7ff1_b63c_4000│     0x7ff1_b63c_4fff│        2_712│  0.00%│    100.00%│
│       10│     0x7ff1_b67e_e000│     0x7ff1_b67e_efff│        2_512│  0.00%│    100.00%│
├─────────┼─────────────────────┼─────────────────────┼─────────────┼───────┼───────────┤
│# 10/31  │                     │                     │             │       │           │
│Sum (all)│                     │                     │1_117_752_782│100.00%│           │
│Sum shown│                     │                     │1_117_733_785│100.00%│           │
└─────────┴─────────────────────┴─────────────────────┴─────────────┴───────┴───────────┘
</code></pre>
 <figcaption>Figure 20. Write profile (4K granularity)</figcaption> 
</figure>
<p>Not very surprisingly, the writes goes to the same two pages, but writes are less frequent than reads. And finally say that we are interested in the distribution of the writes on the most commonly read stack-page, this is shown in figure <a class="reference" href="#instrumentation.html:read-stack">21</a>.</p>
<figure id="instrumentation.html:read-stack">
<pre><code class="language-simics">simics&gt; <strong>mprof0.profile view = read-logical start = 0x7fff_15e5_e000 stop = 0x7fff_15e5_efff granularity = 128 sort-on-column = Start</strong>
┌─────┬────────────────┬────────────────┬───────────┐
│Row #│     Start      │      Stop      │   Count   │
├─────┼────────────────┼────────────────┼───────────┤
│    1│0x7fff_15e5_e000│0x7fff_15e5_e07f│        700│
│    2│0x7fff_15e5_e080│0x7fff_15e5_e0ff│      9_029│
│    3│0x7fff_15e5_e100│0x7fff_15e5_e17f│     14_585│
│    4│0x7fff_15e5_e180│0x7fff_15e5_e1ff│     17_138│
│    5│0x7fff_15e5_e200│0x7fff_15e5_e27f│     10_315│
│    6│0x7fff_15e5_e280│0x7fff_15e5_e2ff│414_573_166│
│    7│0x7fff_15e5_e300│0x7fff_15e5_e37f│171_369_107│
│    8│0x7fff_15e5_e380│0x7fff_15e5_e3ff│ 56_832_627│
│    9│0x7fff_15e5_e400│0x7fff_15e5_e47f│  1_004_298│
│   10│0x7fff_15e5_e480│0x7fff_15e5_e4ff│  2_681_185│
│   11│0x7fff_15e5_e500│0x7fff_15e5_e57f│        746│
│   12│0x7fff_15e5_e580│0x7fff_15e5_e5ff│        408│
│   13│0x7fff_15e5_e600│0x7fff_15e5_e67f│        240│
│   14│0x7fff_15e5_e680│0x7fff_15e5_e6ff│        220│
│   15│0x7fff_15e5_e700│0x7fff_15e5_e77f│         76│
│   16│0x7fff_15e5_e780│0x7fff_15e5_e7ff│         98│
├─────┼────────────────┼────────────────┼───────────┤
│Sum  │                │                │646_513_938│
└─────┴────────────────┴────────────────┴───────────┘
</code></pre>
 <figcaption>Figure 21. Distribution of stack reads on a 4K page</figcaption> 
</figure>
<p>In this case we listed the addresses in address-order using the granularity of 128 bytes.</p>
<h2 id="instrumentation.html:device-register-coverage"><a href="#instrumentation.html:device-register-coverage">2.6.6 Device Register Coverage</a></h2>
<p>The bank-coverage-tool provides register coverage for DML devices.</p>
<p>Device register coverage can be thought of as code coverage for modeled registers. The tool can aggregate register accesses over several Simics runs by saving intermediate results to a file and summarize the total coverage figures for each device through the command line interface. The tool can also export results to CSV.</p>
<p>The tool makes use of the bank instrumentation framework to collect register accesses and uses the general instrumentation framework and its familiar interfaces, documented in this section, to connect to register banks. Please see the <a href="../reference-manual-api/index.html">API Reference Manual</a> for more details about the bank instrumentation framework, which the tool also relies on, and how to develop your own tools using this framework.</p>
<p>By connecting the tool to banks of interest, or using the -connect-all flag when instantiating the tool, the tool will track all accesses to connected banks and summarize the number of accessed registers in a device as a percentage to the number of its registers in total. We call this the 'coverage' of a device. For further inquiry, the tool may also present the accrued number of accesses to individual registers in a connected bank. However the register accesses are presented, they may be filtered on read accesses, write accesses, or both. Both commands may be interacted with in this way and the output may be sorted and mutated in a variety of ways.</p>
<p>In order to instantiate the tool, use the <code>new-bank-coverage-tool</code> command and provide any banks you want to connect to the tool. Alternatively, you can use the -connect-all flag to connect it to any supporting banks in the system. Additional banks can be connected using the <code>add-instrumentation</code> command on the tool.</p>
<h3 id="instrumentation.html:example"><a href="#instrumentation.html:example">2.6.6.1 Example</a></h3>
<p>When the configuration is loaded, instantiate and connect the bank coverage tool to all banks in the system like so:</p>
<pre><code class="language-simics">simics&gt; <strong>new-bank-coverage-tool -connect-all</strong>
Created coverage_tool0 (connected to 75 banks)
</code></pre>
<p>Once the tool is instantiated we may run the workload, which in this case is booting Linux. At any time we may stop the simulation and use the <code>coverage</code> command to present the coverage so far, which is ordered by the coverage percentage by default:</p>
<pre><code class="language-simics">simics&gt; <strong>coverage_tool0.coverage -write max = 10</strong>
┌─────────┬─────────────────────────┬──────────────────────┬─────────────┬─────────┐
│  Row #  │          Device         │No. accessed registers│No. registers│Coverage%│
├─────────┼─────────────────────────┼──────────────────────┼─────────────┼─────────┤
│        1│board.mb.sb.spi_flash_obj│                     0│            0│  100.00%│
│        2│board.mb.sb.com[0]       │                     5│            8│   62.50%│
│        3│board.mb.sb.com[2]       │                     5│            8│   62.50%│
│        4│board.mb.sb.com[1]       │                     5│            8│   62.50%│
│        5│board.mb.sb.com[3]       │                     5│            8│   62.50%│
│        6│board.mb.sb.hpet         │                    15│           28│   53.57%│
│        7│board.mb.sb.bridge       │                    17│           38│   44.74%│
│        8│board.mb.sb.uhci[4]      │                    19│           50│   38.00%│
│        9│board.mb.sb.uhci[2]      │                    19│           50│   38.00%│
│       10│board.mb.sb.uhci[0]      │                    19│           50│   38.00%│
├─────────┼─────────────────────────┼──────────────────────┼─────────────┼─────────┤
│# 10/44  │                         │                      │             │         │
│Sum (all)│                         │                   830│         3391│         │
│Sum shown│                         │                   109│          248│         │
└─────────┴─────────────────────────┴──────────────────────┴─────────────┴─────────┘
</code></pre>
<p>Note that we're limiting the output by using the max parameter. The output of the bank coverage tool commands may be morphed like this in many ways. It's left as an exercise to the user to explore these possibilities further.</p>
<p>A user may also export the attained coverage to CSV by using the to-file parameter:</p>
<pre><code class="language-simics">simics&gt; <strong>coverage_tool0.coverage -write max = 10 to-file = ~/coverage.csv</strong>
</code></pre>
<p>This will output a CSV file like so:</p>
<pre><code>Device,No. accessed registers,No. registers,Coverage%
board.mb.sb.spi_flash_obj,0,0,1.0
board.mb.sb.com[0],5,8,0.625
board.mb.sb.com[2],5,8,0.625
board.mb.sb.com[1],5,8,0.625
board.mb.sb.com[3],5,8,0.625
board.mb.sb.hpet,15,28,0.5357142857142857
board.mb.sb.bridge,17,38,0.4473684210526316
board.mb.sb.uhci[4],19,50,0.38
board.mb.sb.uhci[2],19,50,0.38
board.mb.sb.uhci[0],19,50,0.38
...
</code></pre>
<p>Furthermore, we may inspect the register accesses, of any connected bank, of every device presented in the coverage output by using the <code>access-count</code> command:</p>
<pre><code class="language-simics">simics&gt; <strong>coverage_tool0.access-count board.mb.sb.hpet.bank.regs -write sort-on-column = "Count" max = 10</strong>
┌─────────┬───────────────┬──────┬────┬──────┐
│  Row #  │      Name     │Offset│Size│Count │
├─────────┼───────────────┼──────┼────┼──────┤
│        1│tim_comp[2]    │ 0x148│   8│529647│
│        2│tim_comp[3]    │ 0x168│   8│ 19140│
│        3│gen_conf       │  0x10│   8│     6│
│        4│fsb_int_rout[2]│ 0x150│   8│     6│
│        5│tim_conf[1]    │ 0x120│   8│     5│
│        6│tim_conf[0]    │ 0x100│   8│     5│
│        7│tim_conf[2]    │ 0x140│   8│     5│
│        8│tim_comp[0]    │ 0x108│   8│     2│
│        9│tim_comp[1]    │ 0x128│   8│     2│
│       10│main_cnt       │  0xf0│   8│     2│
├─────────┼───────────────┼──────┼────┼──────┤
│# 10/15  │               │      │    │      │
│Sum (all)│               │      │    │548825│
│Sum shown│               │      │    │548820│
└─────────┴───────────────┴──────┴────┴──────┘
</code></pre>
<p>Note that we're sorting the table based on the number of accesses rather than offset, which is the default.</p>
<p>If the tool were to be used to compile the total coverage figures over a set of runs, such as over several tests, a user may utilize the <code>save</code> command to temporarily save the results to disk:</p>
<pre><code class="language-simics">simics&gt; <strong>coverage_tool0.save ~/coverage_0.bin</strong>
</code></pre>
<p>...and subsequently use the <code>load</code> command to aggregate the results:</p>
<pre><code class="language-simics">simics&gt; <strong>coverage_tool0.load ~/coverage_0.bin</strong>
simics&gt; <strong>coverage_tool0.load ~/coverage_1.bin</strong>
simics&gt; <strong>coverage_tool0.load ~/coverage_2.bin</strong>
...
</code></pre>
<p>Once loaded, the <code>coverage</code> and <code>access-count</code> commands will act as if all the accesses had happened during the same run and present the combined results accordingly. In this way, a user may compile the aggregated results of an entire test suite, which should prove useful.</p>
</section><section class="page" id="probes.html"><h1 id="probes.html:probes"><a href="#probes.html:probes">2.7 Probes</a></h1>
<p>This section describes the <em>Probes Framework</em> in Simics.</p>
<p>Simics' Probes framework provides a generic mechanism for measuring counters and other statistics in Simics. The probe measurement points are distributed across the entire simulated system.</p>
<p>Probes can be related to target processors, device models, the host system (where Simics runs), instrumentation tools etc. There are also probes which present sums of other probes in the system on cell or global level.</p>
<p>Currently, most probes have been added for the purpose of measuring and understanding the performance of Simics. Additional probes could focus more on the target hardware and software aspects.</p>
<p>A probe offers a simple way to extract the value, and also contains type information and formatting hints on the probe itself to present the value of the probe, in an uniform and user-readable format.</p>
<p>A probe is identified by a probe-kind, which is a string with a hierarchical namespaces separated with dots (<code>.</code>). For example, <code>cpu.cycles</code> would be found in each processor model in the system and represents how many cycles that has elapsed on the specific processor. The <code>cell.cycles</code> probes are related to the cell objects and this returns the sum of executed cycles of processors which are located under the specific cell. Finally, <code>sim.cycles</code> is not related to any object but form a singleton sum of all the processor's cycles elapsed.</p>
<p>Probes can also be derived from other probes, offering some calculated metric. For example <code>sim.slowdown</code> is calculated as the fraction between <code>sim.time.wallclock</code> and <code>sim.time.virtual</code>, providing an indication how fast the virtual time elapsed compared to the real wallclock time on the system which Simics runs on.</p>
<p>Simics itself is aware of all probes that currently exist in the system, allowing commands to list the probes or read out their values from Simics command line interface.</p>
<p>Probes may either be explicitly implemented in the various Simics objects, or can be implicitly created by the probes framework itself. For example, Simics may detect that a new object is created that implements the <code>cycle</code> interface and then automatically create probes for accessing the new object's cycle information.</p>
<h2 id="probes.html:probes-command-set"><a href="#probes.html:probes-command-set">2.7.1 Probes Command Set</a></h2>
<p>To look at the available probes, the probe-feature must first be enabled, which can be done with the <code>enable-probes</code> command. When the feature is enabled all probes in the system are detected and/or implicitly created. Also, any further creation or deletion of Simics objects is monitored, keeping the list of known probes in sync with the simulated system.</p>
<p>When the probes framework is enabled, a singleton object called <code>probes</code> is created, which holds all commands to examine probes. For example the <code>probes.list-kinds</code> command gives an overview of the probes that is available in the system, and the amount of objects for each probe-kind. See figure <a class="reference" href="#probes.html:probe-example1">22</a> for some examples.</p>
<figure id="probes.html:probe-example1">
<pre><code>./simics qsp-x86/firststeps machine:hardware:processor:num_cores=2
</code></pre>
<pre><code class="language-simics">simics&gt; <strong>enable-probes</strong>
simics&gt; <strong>probes.list-kinds</strong>
┌─────────┬───────────────────────────────────┬──────────────────────────┬───┬────────────────────────────────────────┐
│  Row #  │            Probe Kind             │       Display Name       │Num│              Description               │
├─────────┼───────────────────────────────────┼──────────────────────────┼───┼────────────────────────────────────────┤
│        1│cell.cycles                        │Cycles                    │  1│Total number of expired cycles in all   │
│         │                                   │                          │   │processors in a specific cell           │
├─────────┼───────────────────────────────────┼──────────────────────────┼───┼────────────────────────────────────────┤
│        2│cell.esteps                        │Esteps                    │  1│Total number of executed steps          │
│         │                                   │                          │   │(~instructions) on all processors in a  │
│         │                                   │                          │   │specific cell, ignoring any halt steps  │
├─────────┼───────────────────────────────────┼──────────────────────────┼───┼────────────────────────────────────────┤
│        3│cell.event.cycle.histogram         │Cycle Event Histogram     │  1│Histogram of all cycle events triggered │
│         │                                   │                          │   │in a cell.                              │
├─────────┼───────────────────────────────────┼──────────────────────────┼───┼────────────────────────────────────────┤
│        4│cell.event.cycle.intensity         │Cycle Event Intensity     │  1│Number of cycles per event in a cell.   │
├─────────┼───────────────────────────────────┼──────────────────────────┼───┼────────────────────────────────────────┤
...
simics&gt; <strong>probes.list-kinds probe-kind = cpu.  categories = instructions -active -probe-type</strong>
┌─────┬────────────────┬────────────┬───┬────────┬────────────────────────────────────────────────────────────────────┐
│Row #│   Probe Kind   │Display Name│Num│  Type  │                            Description                             │
├─────┼────────────────┼────────────┼───┼────────┼────────────────────────────────────────────────────────────────────┤
│    1│cpu.esteps      │Esteps      │  2│int     │Number of executed steps (~instructions) on this processor, ignoring│
│     │                │            │   │        │any halt steps                                                      │
├─────┼────────────────┼────────────┼───┼────────┼────────────────────────────────────────────────────────────────────┤
│    2│cpu.load_percent│Sim Load%   │  2│fraction│Calculated load of a processor, that is, instruction per cycles,    │
│     │                │            │   │        │shown as percent: esteps / cycles. 0% is reported if the processor  │
│     │                │            │   │        │is entirely idle and 100% when the processor executes instructions  │
│     │                │            │   │        │for all cycles. The value is also adjusted with the current step-   │
│     │                │            │   │        │rate of a processor, if this exists. Note that if the step-rate is  │
│     │                │            │   │        │dynamically changed during execution, the result will be incorrect  │
│     │                │            │   │        │and 0 / 0 is returned.                                              │
├─────┼────────────────┼────────────┼───┼────────┼────────────────────────────────────────────────────────────────────┤
│    3│cpu.steps       │Steps       │  2│int     │Number of steps (~instructions) consumed by this processor,         │
│     │                │            │   │        │including any halt steps                                            │
├─────┼────────────────┼────────────┼───┼────────┼────────────────────────────────────────────────────────────────────┤
│Sum  │                │            │  6│        │                                                                    │
└─────┴────────────────┴────────────┴───┴────────┴────────────────────────────────────────────────────────────────────┘
simics&gt; <strong>probes.list-kinds -objects probe-kind = cpu.steps</strong>
┌─────┬──────────┬────────────┬───┬────────────────────────────────────────┬─────────────────────────────────────────┐
│Row #│Probe Kind│Display Name│Num│                Objects                 │               Description               │
├─────┼──────────┼────────────┼───┼────────────────────────────────────────┼─────────────────────────────────────────┤
│    1│cpu.steps │Steps       │  2│board.mb.cpu0.core[0][0], board.mb.cpu0.│Number of steps (~instructions) consumed │
│     │          │            │   │core[1][0]                              │by this processor, including any halt    │
│     │          │            │   │                                        │steps                                    │
├─────┼──────────┼────────────┼───┼────────────────────────────────────────┼─────────────────────────────────────────┤
│Sum  │          │            │  2│                                        │                                         │
└─────┴──────────┴────────────┴───┴────────────────────────────────────────┴─────────────────────────────────────────┘
</code></pre>
 <figcaption>Figure 22. Example of probe.list-kinds commands</figcaption> 
</figure>
<p>The <code>probes.read</code> allows one or several probes values to be read out and displayed. The command can also be used in in Simics scripts to assign cli-variables. If a single <code>probe</code> is read, its value will be returned, while using <code>probe-kind</code> will return a list of tuples <code>[(probe, value)*]</code> that was read out.</p>
<p>See figure <a class="reference" href="#probes.html:probe-example2">23</a> for some examples.</p>
<figure id="probes.html:probe-example2">
<pre><code class="language-simics">simics&gt; <strong>disable-vmp</strong>
simics&gt; <strong>run-seconds 1</strong>
simics&gt; <strong>probes.read probe-kind = cpu. -active</strong>
┌─────┬────────────────────────────────────────────────────────────┬─────────────┐
│Row #│                           Probe                            │        Value│
├─────┼────────────────────────────────────────────────────────────┼─────────────┤
│    1│board.mb.cpu0.core[0][0]:cpu.counter.x86.exception          │            0│
│    2│board.mb.cpu0.core[0][0]:cpu.counter.x86.exception_intensity│            -│
│    3│board.mb.cpu0.core[0][0]:cpu.counter.x86.interrupt          │           78│
│    4│board.mb.cpu0.core[0][0]:cpu.counter.x86.interrupt_intensity│   6444230.13│
│    5│board.mb.cpu0.core[0][0]:cpu.cycles                         │   2000000000│
│    6│board.mb.cpu0.core[0][0]:cpu.disabled_reason                │             │
│    7│board.mb.cpu0.core[0][0]:cpu.esteps                         │    502649950│
│    8│board.mb.cpu0.core[0][0]:cpu.exec_mode.hypersim_steps       │            0│
│    9│board.mb.cpu0.core[0][0]:cpu.load_percent                   │          25%│
│   10│board.mb.cpu0.core[0][0]:cpu.steps                          │    502649950│
│   11│board.mb.cpu0.core[0][0]:cpu.time.virtual                   │  00:00:01.00│
│   12│board.mb.cpu0.core[0][0]:cpu.time.virtual_ps                │1000000000000│
│   13│board.mb.cpu0.core[0][0]:cpu.vmp.vmexits.histogram          │             │
│   14│board.mb.cpu0.core[0][0]:cpu.vmp.vmexits.total              │            0│
│   15│board.mb.cpu0.core[0][0]:cpu.vmp.vmrets.total               │            0│
│   16│board.mb.cpu0.core[1][0]:cpu.counter.x86.exception          │            0│
│   17│board.mb.cpu0.core[1][0]:cpu.counter.x86.exception_intensity│            -│
│   18│board.mb.cpu0.core[1][0]:cpu.counter.x86.interrupt          │            0│
│   19│board.mb.cpu0.core[1][0]:cpu.counter.x86.interrupt_intensity│            -│
│   20│board.mb.cpu0.core[1][0]:cpu.cycles                         │   2000000000│
│   21│board.mb.cpu0.core[1][0]:cpu.disabled_reason                │          HLT│
│   22│board.mb.cpu0.core[1][0]:cpu.esteps                         │       108585│
│   23│board.mb.cpu0.core[1][0]:cpu.exec_mode.hypersim_steps       │            0│
│   24│board.mb.cpu0.core[1][0]:cpu.load_percent                   │           0%│
│   25│board.mb.cpu0.core[1][0]:cpu.steps                          │       108585│
│   26│board.mb.cpu0.core[1][0]:cpu.time.virtual                   │  00:00:01.00│
│   27│board.mb.cpu0.core[1][0]:cpu.time.virtual_ps                │1000000000000│
│   28│board.mb.cpu0.core[1][0]:cpu.vmp.vmexits.histogram          │             │
│   29│board.mb.cpu0.core[1][0]:cpu.vmp.vmexits.total              │            0│
│   30│board.mb.cpu0.core[1][0]:cpu.vmp.vmrets.total               │            0│
└─────┴────────────────────────────────────────────────────────────┴─────────────┘
simics&gt; <strong>probes.read probe-kind = cpu.load_percent</strong>

┌─────┬─────────────────────────────────────────┬─────┐
│Row #│                  Probe                  │Value│
├─────┼─────────────────────────────────────────┼─────┤
│    1│board.mb.cpu0.core[0][0]:cpu.load_percent│  25%│
│    2│board.mb.cpu0.core[1][0]:cpu.load_percent│   0%│
└─────┴─────────────────────────────────────────┴─────┘
simics&gt; <strong>echo (probes.read probe-kind = cpu.load_percent)</strong>
[["board.mb.cpu0.core[0][0]:cpu.load_percent", "25%"], ["board.mb.cpu0.core[1][0]:cpu.load_percent", "0%"]]
simics&gt; <strong>echo (probes.read probe-kind = cpu.load_percent -values)</strong>

[["board.mb.cpu0.core[0][0]:cpu.load_percent", 0.251324975], ["board.mb.cpu0.core[1][0]:cpu.load_percent", 5.42925e-05]]
simics&gt; <strong>echo (probes.read probe = board.mb.cpu0.core[0][0]:cpu.load_percent -values)</strong>

0.251324975
</code></pre>
 <figcaption>Figure 23. Examples of probes.list-details</figcaption> 
</figure>
<p>Some probes are not active by default, typically because there could be overhead in maintaining their values. To activate a probe the <code>probes.subscribe</code> can be used. As long as there are at least one subscriber on a probe, it will be active, and when the number of subscribers goes down to zero, the probe becomes deactivated again.</p>
<p>Figure <a class="reference" href="#probes.html:probe-example3">24</a> shows some examples where probes first need to be subscribed in order to be read later.</p>
<figure id="probes.html:probe-example3">
<pre><code class="language-simics">
simics&gt; <strong>probes.subscribe probe-kind = sim.mips</strong>
simics&gt; <strong>probes.subscribe probe-kind = sim.module_profile</strong>
simics&gt; <strong>run-seconds 10</strong>
simics&gt; <strong>probes.read  probe = sim:sim.module_profile</strong>

x86-intel64.so                          94   45%
x86-p4e JIT                             32   15%
libsimics-common.so                     19    9%
libc.so.6                               16    8%
ICH10.so                                 8    4%
libwx_gtk2u_core-3.0.so.0.4.0            8    4%
libX11.so.6.4.0                          6    3%
libpython3.7m.so.1.0                     5    2%
x86_tlb.so                               4    2%
libvtutils.so                            4    2%
X58-devices.so                           3    1%
_core.cpython-37m-x86_64-linux-gnu.so    3    1%
pcie-downstream-port.so                  2    1%
siplib.cpython-37m-x86_64-linux-gnu.so   1    0%
libgdk-x11-2.0.so.0.2400.33              1    0%
libwx_baseu-3.0.so.0.4.0                 1    0%
simics&gt; <strong>probes.read probe-kind = sim.mips</strong>
┌─────┬────────────┬────────┐
│Row #│   Probe    │   Value│
├─────┼────────────┼────────┤
│    1│sim:sim.mips│608.72 M│
└─────┴────────────┴────────┘
simics&gt; <strong>probes.read probe-kind = sim.mips -values</strong>
┌─────┬────────────┬────────────┐
│Row #│   Probe    │       Value│
├─────┼────────────┼────────────┤
│    1│sim:sim.mips│608721207.89│
└─────┴────────────┴────────────┘
simics&gt; <strong>probes.read probe-kind = sim.mips -raw-values</strong>
┌─────┬────────────┬─────────────────────────┐
│Row #│   Probe    │                    Value│
├─────┼────────────┼─────────────────────────┤
│    1│sim:sim.mips│      7.35e+08 / 1.21e+00│
│     │            │= 6.09e+08 (608721207.89)│
└─────┴────────────┴─────────────────────────┘
</code></pre>
 <figcaption>Figure 24. Examples of probes.read</figcaption> 
</figure>
<p>Default the <code>read</code> command returns a string formatted in a user-readable format, according to the probe's properties. To get the actual value of the probe the <code>-values</code> switch can be used,</p>
<p>The <code>-raw-value</code> flag returns internal representation of advanced types. This can be useful for understanding the source-values for a calculated value.</p>
<h2 id="probes.html:probe-samplers"><a href="#probes.html:probe-samplers">2.7.2 Probe Samplers</a></h2>
<p>Probe samplers are a group of tools which use sampling during the simulation, to read user-configurable probes and displays their values. This captures deviations of the probes during the simulation, compared to just looking at the end result when the simulation is finished.</p>
<p>Probe samplers are a group of tools which read user-configurable probes during simulation, through sampling. This captures deviations of the probes during the simulation, compared to just looking at the end result when the simulation is finished.</p>
<p>By default, added probes are all sampled and printed out during run-time with one row representing each sample, each column representing a particular probe.</p>
<p>With many probes sampled, the table can become very wide, and hard to read. To avoid this, a probe can be added with special flags:</p>
<ul>
<li><strong>-no-sampling</strong> Do not sample the probe, but present the end value in the summary. This can be handy for probes where it is not interesting to know what happened during the simulation but the final value is of interest.</li>
<li><strong>-hidden</strong> Do not display the probe in each sample on screen during simulation. The data is still recorded and can be viewed or saved later.</li>
</ul>
<p>The result of the measurements can be saved to <code>csv</code> or <code>json</code> formats. There are also plot capabilities built in the tools when connected to Simics-client.</p>
<p>There are three different samplers, with very similar command sets. To create one of these samplers, the <code>new-probe-monitor</code>, <code>new-probe-streamer</code> or <code>new-system-perfmeter</code> is used. Since the command interface for these tools are largely identical, the probe-monitor chapter explains details which are generally applicable.</p>
<h3 id="probes.html:probe-monitor"><a href="#probes.html:probe-monitor">2.7.2.1 Probe Monitor</a></h3>
<p>The <code>probe-monitor</code> tool offers a way to read out and present the probe values in continuous samples, while the simulation is running.</p>
<p>All probes being monitored will be presented in a table row for each sample taken, allowing detection of abnormal values during the simulation.</p>
<p>It is possible to add lots of probes to the same probe-monitor, but as the number of probes increase, so does the width of the produced table. Therefore, it can be useful to create several probe-monitors, each showing some group of related feature.</p>
<p>To create a probe-monitor use the <code>new-probe-monitor</code> command. This will create a new object such as <code>pm0</code> which has some additional commands. See figure <a class="reference" href="#probes.html:pm-example">25</a> for an example.</p>
<figure id="probes.html:pm-example">
<pre><code class="language-simics">$&gt; ./simics qsp-x86/firststeps machine:hardware:processor:num_cores=2
simics&gt; <strong>new-probe-monitor sampling-mode = realtime interval = 1 -summary</strong>
simics&gt; <strong>pm0.add-probe probe-kind = sim.time.wallclock sim.time.virtual mode = session</strong>
simics&gt; <strong>pm0.add-probe probe-kind = sim.time.schedule sim.slowdown sim.esteps sim.mips cpu.esteps cpu.time.schedule cpu.schedule_percent cpu.mips</strong>
simics&gt; <strong>run-seconds 60</strong>

┌──────────────────────────────────────────────────────────────┬──────────────────────────────────────┬──────────────────────────────────────┐
│                                                              │       board.mb.cpu0.core[0][0]       │       board.mb.cpu0.core[1][0]       │
├──────────┬──────────┬─────────┬────────┬────────────┬────────┼────────────┬─────────┬──────┬────────┼────────────┬─────────┬──────┬────────┤
│ Session  │ Session  │Sched (s)│Slowdown│   Esteps   │  IPS   │   Esteps   │Sched (s)│Sched%│  IPS   │   Esteps   │Sched (s)│Sched%│  IPS   │
│Wallclock │ Virtual- │         │        │            │        │            │         │      │        │            │         │      │        │
│(hh:mm:ss)│   Time   │         │        │            │        │            │         │      │        │            │         │      │        │
│          │(hh:mm:ss)│         │        │            │        │            │         │      │        │            │         │      │        │
├──────────┼──────────┼─────────┼────────┼────────────┼────────┼────────────┼─────────┼──────┼────────┼────────────┼─────────┼──────┼────────┤
│  00:00:01│  00:00:01│311.92 ms│    0.59│   462112845│872.65 M│   462021371│297.54 ms│   95%│  1.55 G│       91474│ 14.38 ms│    5%│  6.36 M│
│  00:00:02│  00:00:04│445.62 ms│    0.29│   252202461│251.80 M│   252171406│432.12 ms│   97%│583.56 M│       31055│ 13.50 ms│    3%│  2.30 M│
│  00:00:03│  00:00:22│999.63 ms│    0.06│    54925316│ 54.86 M│    54925316│959.26 ms│   96%│ 57.26 M│           0│ 40.37 ms│    4%│  0.00  │
│  00:00:04│  00:00:40│995.50 ms│    0.06│    55920137│ 55.86 M│    55920137│955.12 ms│   96%│ 58.55 M│           0│ 40.38 ms│    4%│  0.00  │
│  00:00:05│  00:00:54│997.73 ms│    0.07│   798812869│798.45 M│   798792570│964.31 ms│   97%│828.36 M│       20299│ 33.42 ms│    3%│607.45 k│
│  00:00:06│  00:00:55│998.69 ms│    0.61│  3001496016│  3.00 G│  2927954125│941.13 ms│   94%│  3.11 G│    73541891│ 57.56 ms│    6%│  1.28 G│
│  00:00:07│  00:00:59│966.83 ms│    0.33│   548000049│547.45 M│   184324157│491.32 ms│   51%│375.16 M│   363675892│475.51 ms│   49%│764.82 M│
│  00:00:08│  00:00:59│994.97 ms│    2.38│  1178737071│  1.18 G│   643116292│395.46 ms│   40%│  1.63 G│   535620779│599.52 ms│   60%│893.42 M│
│  00:00:09│  00:01:00│998.21 ms│    1.30│  2418507935│  2.42 G│  1159903342│565.55 ms│   57%│  2.05 G│  1258604593│432.66 ms│   43%│  2.91 G│
</code></pre>
 <figcaption>Figure 25. Sample probe-monitor session</figcaption> 
</figure>
<p>Here, first a probe-monitor is created, that gets the name <code>pm0</code> by default. The probe-monitor samples the probes each wallclock seconds, which is controlled by the <code>mode</code> and <code>interval</code> arguments.</p>
<p>The <code>-summary</code> flag means all probe values will be displayed when the simulation stops, providing the session or current value for the probes subscribed to, described later.</p>
<p>Next, the <code>pm0.add-probe</code> is issued with two probe-kinds using the mode <code>session</code>. If mode is not specified, it defaults to <code>delta</code> meaning the value presented for the probe is the difference from the previous sample. That is, it shows the value for the sample only. With the <code>session</code> mode, it instead shows the total value since the probe was added to the monitor. In this case, the accumulated times, both in host wall-clock and the virtual time of the simulated system is displayed.</p>
<p>Apart from <code>session</code> and <code>delta</code> there is also the <code>current</code> mode which can be selected, which displays the plain probe value, without any adjustments. The <code>current</code> mode is interesting for some probes, which are not monotonically increasing, such as a temperature. It can also be interesting to be used for probes derived from checkpointed state, for example the global virtual time, when the user wants to see the absolute time.</p>
<p>Finally, before the execution is started we add more probes, now using the default <code>delta</code> mode. Here we are mixing some singleton probes <code>sim.*</code> and some processor specific probes <code>cpu.*</code>. Since there are two processors in the simulated system used in this example, the number of all monitored probes is 14.</p>
<p>When the simulation is started, the probe-monitor starts to print out table rows for the probes being measured, one second between each sample. Probes which have an object associated will be sorted under that object, so here probes for the two processors have an additional heading showing where the probes belong to.</p>
<p>Some more detailed information on each column or probe, that was monitored in this example.</p>
<div class="dl">
<ul>
<li>
<p><span class="term" id="probes.html:dt:session-wallclock-hh-mm-ss-sim-time-wallclock"><a href="#probes.html:dt:session-wallclock-hh-mm-ss-sim-time-wallclock">Session Wallclock (hh:mm:ss) - <em>sim.time.wallclock</em></a></span><br>
This is basically the host time that has elapsed during the simulation. Note that this time stands still if Simics is not executing. If the true wallclock is desired (which increments even when Simics is not simulating), the probe <code>host.time.wallclock</code> can be used instead. The time here is presented as hours, minutes and second format.</p>
</li>
<li>
<p><span class="term" id="probes.html:dt:session-virtual-time-hh-mm-ss-sim-time-virtual"><a href="#probes.html:dt:session-virtual-time-hh-mm-ss-sim-time-virtual">Session Virtual-Time (hh:mm:ss) - <em>sim.time.virtual</em></a></span><br>
This probe returns the virtual time of the simulation. The virtual time for all processors are pretty much in sync, but there can be small differences. The probe simply selects the first processor that it finds and presents that. Similar to wall clock, and all <code>session</code> or <code>current</code> times are presented in hours, minutes and second format.</p>
</li>
<li>
<p><span class="term" id="probes.html:dt:sched-s-sim-time-schedule"><a href="#probes.html:dt:sched-s-sim-time-schedule">Sched (s) - <em>sim.time.schedule</em></a></span><br>
This is another aspect of time in Simics, namely how much time that Simics scheduler have requested the different processor to be scheduled in total. In a multi-threaded simulation this time can be much greater than the wallclock time, since each execution thread can run in parallel. The monitor presents any delta times with a second metric-prefix, giving much higher resolution.</p>
</li>
<li>
<p><span class="term" id="probes.html:dt:slowdown-sim-slowdown"><a href="#probes.html:dt:slowdown-sim-slowdown">Slowdown - <em>sim.slowdown</em></a></span><br>
The slowdown probes gives an measurement on how fast virtual time elapses compared to wallclock time. Any value below one means that the virtual time goes faster then the host wallclock. This provides a hint on how fast the simulation is.</p>
<p>A value of 0.5 means Simics simulation goes twice as fast as the simulated virtual system, while a figure of 2.0 means the simulation goes in half the speed compared to the simulated system.</p>
  <div class="note">
<p>Don't take this figure for any kind of exactness to the real system, sim.time.virtual depends on:</p>
<ul>
<li>The frequency of the simulated processors.</li>
<li>A simplistic timing models where typically one instruction always takes one cycle to execute.</li>
<li>Device models are also typically simplistic on how fast transfers and interrupts occur.</li>
<li>Idle processor can typically consume cycles almost infinitely fast, which does not happen in real hardware.</li>
</ul>
<p>How fast Simics executes also depends on how many processors it schedules, the processor models, the type of workload, threading settings, internal caches and much more. Thus, one needs to take the slowdown figure with a grain of salt, before comparing with other sessions, or even with just with different workloads.</p>
  </div>
</li>
<li>
<p><span class="term" id="probes.html:dt:esteps-sim-esteps"><a href="#probes.html:dt:esteps-sim-esteps">Esteps - <em>sim.esteps</em></a></span><br>
Steps in Simics are roughly equivalent to instructions. Some processor models however can consume steps while they are stalled. Therefore, the esteps (executed steps) metric is better suited for counting instructions, where the halt-steps have been subtracted from the steps counter. The simulator global <code>sim.esteps</code> is the total of all <code>cpu.esteps</code> in the system.</p>
</li>
<li>
<p><span class="term" id="probes.html:dt:ips-sim-mips"><a href="#probes.html:dt:ips-sim-mips">IPS - <em>sim.mips</em></a></span><br>
(M)IPS is an acronym of (Million) Instructions Per Second. This is a common measurement for looking at the how fast the simulation is. It is calculated as <code>sim.esteps /     sim.time.wallclock</code>. Note that, depending on the simulation speed, other prefixes then <code>M</code> is used each sample, for example <code>G</code> for GIPS, or <code>k</code> for kIPS.</p>
</li>
<li>
<p><span class="term" id="probes.html:dt:esteps-cpu-esteps"><a href="#probes.html:dt:esteps-cpu-esteps">Esteps - <em>cpu.esteps</em></a></span><br>
The processor specific number of executed steps.</p>
</li>
<li>
<p><span class="term" id="probes.html:dt:sched-s-cpu-time-schedule"><a href="#probes.html:dt:sched-s-cpu-time-schedule">Sched (s) - <em>cpu.time.schedule</em></a></span><br>
The amount of time Simics scheduler has scheduled this processor.</p>
</li>
<li>
<p><span class="term" id="probes.html:dt:sched-cpu-schedule_percent"><a href="#probes.html:dt:sched-cpu-schedule_percent">Sched% - <em>cpu.schedule_percent</em></a></span><br>
This probe gives a percent value of how much of the time this processor has been scheduled <code>cpu.time.schedule / sim.time.schedule</code> This can be used to detect bottle-necks in the simulation, if one processor stands for the majority of the time.</p>
</li>
<li>
<p><span class="term" id="probes.html:dt:ips-cpu-mips"><a href="#probes.html:dt:ips-cpu-mips">IPS - <em>cpu.mips</em></a></span><br>
This probe might look like <code>sim.mips</code> but is actually a bit different. The processor specific MIPS number is calculated as: <code>cpu.esteps / cpu.time.schedule</code>. This means that the MIPS numbers here cannot be added together. Instead this gives an indication of how fast this particular processor executes, given the amount of time it got. This can be used to detect sub-optimal processor simulation even if the processor runs at a much lower frequency, and consequently is not scheduled as much.</p>
</li>
</ul>
</div>
<p>When the simulation is finished, the probe-monitor shows a table of all the probes that are monitored. The table provides the current value for all probes, see figure <a class="reference" href="#probes.html:pm-summary-example">26</a> for the example output.</p>
<figure id="probes.html:pm-summary-example">
<pre><code>┌─────┬────────────┬────────────────────┬────────────────────────┬───────────────────────┐
│Row #│Display Name│     Probe-kind     │         Object         │Session Formatted Value│
├─────┼────────────┼────────────────────┼────────────────────────┼───────────────────────┤
│    1│Wallclock   │sim.time.wallclock  │sim                     │            00:00:09.09│
│    2│Virtual-Time│sim.time.virtual    │sim                     │            00:01:00.00│
│    3│Sched       │sim.time.schedule   │sim                     │            00:00:08.27│
│    4│Slowdown    │sim.slowdown        │sim                     │                   0.15│
│    5│Esteps      │sim.esteps          │sim                     │             9512224930│
│    6│IPS         │sim.mips            │sim                     │                 1.05 G│
│    7│Esteps      │cpu.esteps          │board.mb.cpu0.core[0][0]│             6853454540│
│    8│Sched       │cpu.time.schedule   │board.mb.cpu0.core[0][0]│            00:00:06.43│
│    9│Sched%      │cpu.schedule_percent│board.mb.cpu0.core[0][0]│                    78%│
│   10│IPS         │cpu.mips            │board.mb.cpu0.core[0][0]│                 1.07 G│
│   11│Esteps      │cpu.esteps          │board.mb.cpu0.core[1][0]│             2658770390│
│   12│Sched       │cpu.time.schedule   │board.mb.cpu0.core[1][0]│            00:00:01.84│
│   13│Sched%      │cpu.schedule_percent│board.mb.cpu0.core[1][0]│                    22%│
│   14│IPS         │cpu.mips            │board.mb.cpu0.core[1][0]│                 1.45 G│
└─────┴────────────┴────────────────────┴────────────────────────┴───────────────────────┘
</code></pre>
 <figcaption>Figure 26. Probe-Monitor Summary Printout</figcaption> 
</figure>
<p>The <em>Session Formatted Value</em> represents the probe value formatted accordingly to the probe properties. If probes have been added with the <code>current</code> mode then an additional <em>Current Formatted Value</em> column is also displayed.</p>
<p>It is also possible to get the same results printed out with the <code>pm0.summary</code> command, where it is possible to request more floating point decimals to be presented with the <code>float-decimals</code> argument.</p>
<p>The <code>pm0.status</code> shows the settings of the probe-monitor, including which probes that are currently monitored. Probes can be removed with the <code>pm0.remove-probe</code> command and it is possible to change the sampling settings of the probe-monitor itself with the <code>pm0.sampling-settings</code> command.</p>
<p>While the probe-monitor prints out the table data while the simulation is running, all data is also saved internally. To show the entire history of all samples, the <code>pm0.print-table</code> can be used and the data can also be saved into a <code>.csv</code> with the <code>pm0.export-table-csv</code> command. Any data in the csv file will be unformatted, allowing easily import in a spreadsheet for further analyses.</p>
<h3 id="probes.html:probe-streamer"><a href="#probes.html:probe-streamer">2.7.2.2 Probe Streamer</a></h3>
<p>The <code>probe-streamer</code> tool offers a way to read out probe values and dump the samples in a <code>.csv</code>, while the simulation is running.</p>
<p>To create a probe-streamer use the <code>new-probe-streamer</code> command. This will create a new object such as <code>ps0</code> which has some additional commands. Most of these commands are common to the <code>probe-monitor</code>. See figure <a class="reference" href="#probes.html:ps-example">27</a> for an example.</p>
<figure id="probes.html:ps-example">
<pre><code class="language-simics">$&gt; ./simics qsp-x86/firststeps machine:hardware:processor:num_cores=2
simics&gt; <strong>new-probe-streamer mode = realtime interval = 1 csv-file-output=stream.csv</strong>
</code></pre>
</figure>
<h3 id="probes.html:probe-based-system-perfmeter"><a href="#probes.html:probe-based-system-perfmeter">2.7.2.3 Probe Based system-perfmeter</a></h3>
<p>This tool replaces the old <code>system-perfmeter</code> tool, which had similar capabilities but more monolithic, with all measurement, calculations and output formatting part of the tool itself. Another difference is that the old <code>system-perfmeter</code> was a singleton object, you could not have multiple tools measuring different things.</p>
<p>The <code>new-system-perfmeter</code> extends the <code>new-probe-monitor</code>, with some added features making it easier to use when measuring Simics performance:</p>
<ul>
<li>Some default probes are automatically monitored.</li>
<li>The <code>new-system-perfmeter</code> has some handy command line switches for easily adding additional performance related probes.</li>
</ul>
<p>See figure <a class="reference" href="#probes.html:perfmeter-example">28</a> for an example.</p>
<figure id="probes.html:perfmeter-example">
<pre><code class="language-simics">$&gt; ./simics qsp-x86/firststeps machine:hardware:processor:num_cores=2
simics&gt; <strong>new-system-perfmeter -summary</strong>

Using board.mb.cpu0.core[0][0] as clock
Enabling probes
[probes info] Enabling probes (could take a while)
[probes info] Found 330 probes using 141 different probe-kinds
[probes info] Additional probe-related command now exists under the 'probes' singleton object
[sp0 info] Added: sim:sim.time.virtual with mode session
[sp0 info] Added: sim:sim.time.wallclock with mode session
[sp0 info] Added: sim:sim.time.virtual with mode delta
[sp0 info] Added: sim:sim.time.wallclock with mode delta
[sp0 info] Added: sim:sim.slowdown with mode delta
[sp0 info] Added: sim:sim.process.cpu_percent with mode delta
[sp0 info] Added: sim:sim.load_percent with mode delta
Created sp0
simics&gt; <strong>run-seconds 20</strong>
┌──────────┬──────────┬─────────┬─────────┬────────┬────┬────┐
│ Session  │ Session  │Virtual- │Wallclock│Slowdown│Host│Sim │
│ Virtual- │Wallclock │Time (s) │   (s)   │        │CPU%│Load│
│   Time   │(hh:mm:ss)│         │         │        │    │ %  │
│(hh:mm:ss)│          │         │         │        │    │    │
├──────────┼──────────┼─────────┼─────────┼────────┼────┼────┤
│  00:00:00│  00:00:00│479.60 ms│215.28 ms│    0.45│118%│ 22%│
│  00:00:02│  00:00:01│  1.91 s │  1.00 s │    0.52│ 57%│  3%│
│  00:00:19│  00:00:02│ 16.47 s │999.54 ms│    0.06│114%│  0%│
┌─────┬────────────┬───────────────────────┬──────┬───────────────────────┐
│Row #│Display Name│      Probe-kind       │Object│Session Formatted Value│
├─────┼────────────┼───────────────────────┼──────┼───────────────────────┤
│    1│Virtual-Time│sim.time.virtual       │sim   │            00:00:30.00│
│    2│Wallclock   │sim.time.wallclock     │sim   │            00:00:02.83│
│    3│Slowdown    │sim.slowdown           │sim   │                   0.09│
│    4│Host CPU%   │sim.process.cpu_percent│sim   │                    93%│
│    5│Sim Load%   │sim.load_percent       │sim   │                     1%│
└─────┴────────────┴───────────────────────┴──────┴───────────────────────┘
simics&gt; <strong>quit</strong>

$&gt; ./simics qsp-x86/firststeps machine:hardware:processor:num_cores=2
simics&gt; <strong>new-system-perfmeter -summary -cpu-exec-modes</strong>

Using board.mb.cpu0.core[0][0] as clock
Enabling probes
[probes info] Enabling probes (could take a while)
[probes info] Found 330 probes using 141 different probe-kinds
[probes info] Additional probe-related command now exists under the 'probes' singleton object
[sp0 info] Added: sim:sim.time.virtual with mode session
[sp0 info] Added: sim:sim.time.wallclock with mode session
[sp0 info] Added: sim:sim.time.virtual with mode delta
[sp0 info] Added: sim:sim.time.wallclock with mode delta
[sp0 info] Added: sim:sim.slowdown with mode delta
[sp0 info] Added: sim:sim.process.cpu_percent with mode delta
[sp0 info] Added: sim:sim.load_percent with mode delta
[sp0 info] Added: board.mb.cpu0.core[0][0]:cpu.exec_mode.hypersim_percent with mode delta
[sp0 info] Added: board.mb.cpu0.core[1][0]:cpu.exec_mode.hypersim_percent with mode delta
[sp0 info] Added: board.mb.cpu0.core[0][0]:cpu.exec_mode.vmp_percent with mode delta
[sp0 info] Added: board.mb.cpu0.core[1][0]:cpu.exec_mode.vmp_percent with mode delta
[sp0 info] Added: board.mb.cpu0.core[0][0]:cpu.exec_mode.jit_percent with mode delta
[sp0 info] Added: board.mb.cpu0.core[1][0]:cpu.exec_mode.jit_percent with mode delta
[sp0 info] Added: board.mb.cpu0.core[0][0]:cpu.exec_mode.interpreter_percent with mode delta
[sp0 info] Added: board.mb.cpu0.core[1][0]:cpu.exec_mode.interpreter_percent with mode delta
Created sp0
simics&gt; <strong>run-seconds 30</strong>
┌────────────────────────────────────────────────────────────┬───────────────────┬───────────────────┐
│                                                            │  board.mb.cpu0.   │  board.mb.cpu0.   │
│                                                            │    core[0][0]     │    core[1][0]     │
├──────────┬──────────┬─────────┬─────────┬────────┬────┬────┼────┬────┬────┬────┼────┬────┬────┬────┤
│ Session  │ Session  │Virtual- │Wallclock│Slowdown│Host│Sim │HYP%│VMP%│JIT%│INT%│HYP%│VMP%│JIT%│INT%│
│ Virtual- │Wallclock │Time (s) │   (s)   │        │CPU%│Load│    │    │    │    │    │    │    │    │
│   Time   │(hh:mm:ss)│         │         │        │    │ %  │    │    │    │    │    │    │    │    │
│(hh:mm:ss)│          │         │         │        │    │    │    │    │    │    │    │    │    │    │
├──────────┼──────────┼─────────┼─────────┼────────┼────┼────┼────┼────┼────┼────┼────┼────┼────┼────┤
│  00:00:01│  00:00:00│508.60 ms│390.61 ms│    0.77│ 71%│ 21%│  0%│100%│  0%│  0%│  0%│ 63%│  4%│ 33%│
│  00:00:03│  00:00:01│  2.36 s │  1.00 s │    0.42│ 71%│  3%│  0%│ 99%│  1%│  0%│  0%│ 40%│ 25%│ 35%│
│  00:00:21│  00:00:02│ 17.71 s │  1.00 s │    0.06│113%│  0%│  0%│ 98%│  1%│  1%│-   │-   │-   │-   │
┌─────┬────────────┬─────────────────────────────────┬────────────────────────┬───────────────────────┐
│Row #│Display Name│           Probe-kind            │         Object         │Session Formatted Value│
├─────┼────────────┼─────────────────────────────────┼────────────────────────┼───────────────────────┤
│    1│Virtual-Time│sim.time.virtual                 │sim                     │            00:00:30.00│
│    2│Wallclock   │sim.time.wallclock               │sim                     │            00:00:02.92│
│    3│Slowdown    │sim.slowdown                     │sim                     │                   0.10│
│    4│Host CPU%   │sim.process.cpu_percent          │sim                     │                    92%│
│    5│Sim Load%   │sim.load_percent                 │sim                     │                     1%│
│    6│HYP%        │cpu.exec_mode.hypersim_percent   │board.mb.cpu0.core[0][0]│                     0%│
│    7│VMP%        │cpu.exec_mode.vmp_percent        │board.mb.cpu0.core[0][0]│                    99%│
│    8│JIT%        │cpu.exec_mode.jit_percent        │board.mb.cpu0.core[0][0]│                     0%│
│    9│INT%        │cpu.exec_mode.interpreter_percent│board.mb.cpu0.core[0][0]│                     0%│
│   10│HYP%        │cpu.exec_mode.hypersim_percent   │board.mb.cpu0.core[1][0]│                     0%│
│   11│VMP%        │cpu.exec_mode.vmp_percent        │board.mb.cpu0.core[1][0]│                    52%│
│   12│JIT%        │cpu.exec_mode.jit_percent        │board.mb.cpu0.core[1][0]│                    14%│
│   13│INT%        │cpu.exec_mode.interpreter_percent│board.mb.cpu0.core[1][0]│                    34%│
└─────┴────────────┴─────────────────────────────────┴────────────────────────┴───────────────────────┘
</code></pre>
</figure>
<p>In the first run, only the default probes are used. The <code>-summary</code> switch automatically prints the value of the collected probes when Simics stops. In the second run, the <code>-cpu-exec-modes</code> is added, causing 8 additional probes to be monitored.</p>
</section><section class="page" id="low-level-debugging.html"><h1 id="low-level-debugging.html:low-level-debugging"><a href="#low-level-debugging.html:low-level-debugging">3 Low-Level Debugging</a></h1>
</section><section class="page" id="introduction-2.html"><h1 id="introduction-2.html:introduction"><a href="#introduction-2.html:introduction">3.1 Introduction</a></h1>
<p>This part of the document explains how to use Simics as a tool in low-level software development. In this setting, Simics plays two roles:</p>
<div class="dl">
<ul>
<li><span class="term" id="introduction-2.html:dt:execution-platform"><a href="#introduction-2.html:dt:execution-platform">execution platform</a></span><br>
The software is run on a simulated target machine inside Simics.</li>
<li><span class="term" id="introduction-2.html:dt:debugger"><a href="#introduction-2.html:dt:debugger">debugger</a></span><br>
Simics can either function as a stand-alone debugger, or as a debugger backend for an external debugger. The main Simics debugger is provided in Simics Analyzer.</li>
</ul>
</div>
<p>Simics Analyzer provides a full symbolic debugger for C and C++. This is described in the <a href="../analyzer-user-guide/index.html">Simics Analyzer User's Guide</a>. The debugger in Simics Analyzer is also capable of tracking software running on target machines, to give you the ability to debug individual processes, threads and tasks. Also, Simics provides some debugging capabilities.</p>
<p>Using Simics as a debugger has some major benefits compared to debugging on real hardware:</p>
<ul>
<li>Debugging is completely non-intrusive.</li>
<li>You can inspect and modify the state of the entire target system, at any level. This is especially convenient when debugging low-level code such as firmware and hardware drivers.</li>
<li>The simulation is completely deterministic. Once you manage to trigger a bug, you can repeat it as often as you like.</li>
<li>You have complete control over time. For example, you can freeze time while inspecting the target, save the simulated state in a checkpoint and restore it at a later time, and even run the whole simulation backward.</li>
</ul>
<div class="note">
<p>It is recommended that you have read <a href="../getting-started/index.html">Getting Started</a>  before tackling this document.</p>
</div>
</section><section class="page" id="debug.html"><h1 id="debug.html:low-level-debugging-with-simics"><a href="#debug.html:low-level-debugging-with-simics">3.2 Low-level Debugging with Simics</a></h1>
<div class="note">
<p>Simics Analyzer provides a full symbolic C/C++ debugger with a command line interface. You can read all about it in <a href="../analyzer-user-guide/index.html">Simics Analyzer User's Guide</a> . This can be used in parallel with the low-level features described in this chapter.</p>
</div>
<p>This chapter explains Simics's powerful, but low-level, breakpoint support.</p>
<h2 id="debug.html:breakpoints"><a href="#debug.html:breakpoints">3.2.1 Breakpoints</a></h2>
<p>Simics can set breakpoints on code and data. Unlike most debuggers, Simics breakpoints are not limited by what the hardware can support; for example, there is no restriction on the number of read/write breakpoints (also known as watchpoints).</p>
<p>In Simics you can set breakpoints on, for instance:</p>
<ul>
<li>memory accesses: any range and combination of read/write/execute</li>
<li>time (number of cycles or instructions executed)</li>
<li>instruction types, such as control register accesses</li>
<li>device accesses</li>
<li>output in the console</li>
<li>log output</li>
</ul>
<p>Simics is fully deterministic, and breakpoints in Simics are fully non-intrusive. This makes it possible to narrow down the location of difficult bugs by re-running the <em>exact</em> same run as many times as you need.</p>
<h3 id="debug.html:the-breakpoint-manager"><a href="#debug.html:the-breakpoint-manager">3.2.1.1 The Breakpoint Manager</a></h3>
<p>Simics has a <em>breakpoint manager</em> which stores information about all breakpoints, of all types. It has commands for listing breakpoints, enabling, deleting and other common operations. Breakpoint creation is specific to the different types, and is described in the following chapters. The breakpoint manager is the object <code>bp</code>.</p>
<p>In general, breakpoint creation commands return an ID, which can be used to later delete the breakpoint, or obtain information about it. The most important generic commands are</p>
<ul>
<li><code>bp.list</code>, which lists all breakpoints.</li>
<li><code>bp.delete</code>, which removes a particular breakpoint.</li>
<li><code>bp.show</code>, which shows more information about a particular breakpoint.</li>
</ul>
<h3 id="debug.html:memory-breakpoints"><a href="#debug.html:memory-breakpoints">3.2.1.2 Memory Breakpoints</a></h3>
<p>A memory breakpoint stops the simulation whenever a memory location in a specified address interval is accessed. The address interval can be of arbitrary length and the type of memory access can be specified as any combination of <em>read</em>, <em>write</em>, and <em>execute</em>.</p>
<p>The easiest way to set memory breakpoints is to use the <code>bp.memory.break</code> command:</p>
<pre><code class="language-simics">simics&gt; <strong>output-radix 16</strong>
simics&gt; <strong>bp.memory.break p:0x10000</strong>
Breakpoint 1 set on address 0x10000 in 'board.mb.cpu0.mem[0][0]' with access mode 'x'
</code></pre>
<p>Prefix the address with <code>p:</code> or <code>v:</code> to get a physical or virtual address, respectively. As you can see in the following example, Simics defaults to interpreting a breakpoint address as virtual if you do not specify otherwise:</p>
<pre><code class="language-simics">simics&gt; <strong>board.mb.cpu0.core[0][0]-&gt;current_virtual_context = "board.cell_context"</strong>
simics&gt; <strong>bp.memory.break v:0x4711</strong>
[board.mb.cpu0.core[0][0] info] VMP not engaged. Reason: virtual breakpoint.
Breakpoint 2 set on address 0x4711 in 'board.cell_context' with access mode 'x'
simics&gt; <strong>bp.memory.break p:0x4711</strong>
Breakpoint 3 set on address 0x4711 in 'board.mb.cpu0.mem[0][0]' with access mode 'x'
simics&gt; <strong>bp.memory.break 0x4711</strong>
Breakpoint 4 set on address 0x4711 in 'board.cell_context' with access mode 'x'
Note: overlaps with breakpoint 2
</code></pre>
<p>This way of setting breakpoints will attach them to the memory space (physical address) or context (virtual address) connected to the <em>current processor</em>. If the current processor is not the processor you are interested in, it can be changed using the <code>pselect</code> command:</p>
<pre><code class="language-simics">simics&gt; <strong>pselect board.mb.cpu0.core[0][0]</strong>
</code></pre>
<p>Without an argument, <code>pselect</code> prints the current processor:</p>
<pre><code class="language-simics">simics&gt; <strong>pselect</strong>
"board.mb.cpu0.core[0][0]"
</code></pre>
<p>Also useful is the <code>cpu</code> object alias, which returns the current processor and can be used to expand child objects, commands and aliases on the current processor.</p>
<pre><code class="language-simics">simics&gt; <strong>cpu # type cpu&lt;tab&gt;</strong>
cpu-&gt;  cpu-pages-dump  cpu-switch-time  cpu.  cpu.vtime.
</code></pre>
<p>Physical memory breakpoints are handled by memory space objects. A memory space represents a physical address space; they sit between the processor and the actual hardware devices, for example RAM, that can be accessed with read and write instructions. Breakpoints are created with the memory space's <code>break</code> command:</p>
<pre><code class="language-simics">simics&gt; <strong>board.mb.cpu0.core[0][0]-&gt;physical_memory</strong>
"board.mb.cpu0.mem[0][0]"
simics&gt; <strong>board.mb.cpu0.mem[0][0].bp-break-memory address = 0x10000 length = 16 -w</strong>
Breakpoint 1 set on address 0x10000 in 'board.mb.cpu0.mem[0][0]', length 16 with access mode 'w'
</code></pre>
<p>Virtual memory breakpoints are handled by context objects. A context represents a virtual address space; you can learn more about them in chapter <a class="reference" href="#debug.html:symbolic-debugging">3.2.2</a>. Essentially, they provide a level of indirection between processors and virtual memory breakpoints; a processor has a current context, which in turn has virtual breakpoints:</p>
<pre><code class="language-simics">simics&gt; <strong>board.mb.cpu0.core[0][0]-&gt;current_context</strong>
"board.cell_context"
simics&gt; <strong>board.cell_context.bp-break-memory 0x1ff00</strong>
Breakpoint 2 set on address 0x1ff00 in 'board.cell_context' with access mode 'x'
</code></pre>
<p>Note that by default, all simulated processors in a cell share one context (<code>celln_context</code>). If you want a virtual breakpoint to apply only to a subset of the processors, create a new context just for them:</p>
<pre><code class="language-simics">simics&gt; <strong>new-context foo</strong>
simics&gt; <strong>board.mb.cpu0.core[0][0].set-context foo</strong>
simics&gt; <strong>foo.bp-break-memory 0xffffffffbfc008b8</strong>
</code></pre>
<p>When creating execution breakpoints, it is possible to specify filter rules to only trigger when instructions match certain syntactical criteria. This feature is mainly useful with breakpoints covering large areas of memory. The available parameters to the break command are <em>prefix</em> (to match the start of an instruction), <em>substr</em> (to match a particular substring), and <em>pattern</em> (to match the bit pattern of the instruction).</p>
<p>For example, to stop when an instruction with the name <code>add</code> is executed in a memory range from 0x10000 to 0x12000, use the following commands:</p>
<pre><code class="language-simics">simics&gt; <strong>bp.memory.break 0x10000 0x2000 -x prefix = "add"</strong>
Breakpoint 1 set on address 0x10000 in 'board.cell_context', length 8192 with access mode 'x'
</code></pre>
<p>Simics will now break on the first add instruction encountered. For more information, see the
<a href="../rm-base/rm-cmd-categories.html#breakpoints">breakpoints section</a> in the <a href="../rm-base/index.html">Simics Reference Manual</a>
or use the <code>help bp.memory.break</code> command.</p>
<h3 id="debug.html:temporal-breakpoints"><a href="#debug.html:temporal-breakpoints">3.2.1.3 Temporal Breakpoints</a></h3>
<p>Unlike an ordinary debugger, Simics can handle temporal breakpoints, i.e., breakpoints in time. Since the concept of time is based on steps and cycles, to be precise a temporal breakpoint refers to a specific step or a cycle count as measured by a given processor, but one can also specify breakpoints in seconds of virtual time:</p>
<pre><code class="language-simics">simics&gt; <strong>bp.cycle.break cpu0 100</strong>
simics&gt; <strong>bp.step.break cpu0 100</strong>
simics&gt; <strong>bp.time.break cpu0 1</strong>
</code></pre>
<p>In the example above, the breakpoints are specified relative to the current time. It is also possible to give temporal breakpoints in absolute time (where 0 refers to the time when the original configuration was set up in Simics).</p>
<pre><code class="language-simics">simics&gt; <strong>board.mb.cpu0.core[0][0].bp-break-cycle -absolute 100</strong>
simics&gt; <strong>board.mb.cpu0.core[0][0].bp-break-step -absolute 100</strong>
simics&gt; <strong>board.mb.cpu0.core[0][0].bp-break-time -absolute 1</strong>
</code></pre>
<p>The commands <code>bp.cycle.break</code>, <code>bp.step.break</code> and <code>bp.time.break</code>, can be given without providing the CPU ad argument. This will set a breakpoint for the current processor.</p>
<h3 id="debug.html:control-register-breakpoints"><a href="#debug.html:control-register-breakpoints">3.2.1.4 Control Register Breakpoints</a></h3>
<p>A control register breakpoint triggers when the selected control register is accessed. The access type is determined by the break command parameters used.</p>
<p>To break on a control register <em>write</em>, use <code>bp.control_register.break</code>. For example, to break when the register <code>cr0</code> is written to:</p>
<pre><code class="language-simics">simics&gt; <strong>bp.control_register.break name = cr0</strong>
</code></pre>
<p>To break on a control register <em>read</em>, use <code>bp.control_register.break -r</code>. For example, to break when the register <code>cr0</code> is read:</p>
<pre><code class="language-simics">simics&gt; <strong>bp.control_register.break name = cr0 -r</strong>
</code></pre>
<p>A list of available control registers can be obtained by tab-completing the <em>name</em> argument. See the documentation for <a href="../rm-base/rm-cmd-bp-manager.cr.break.html">bp.control_register.break</a> in the
<a href="../rm-base/index.html">Simics Reference Manual</a> for more information.</p>
<h3 id="debug.html:i-o-breakpoints"><a href="#debug.html:i-o-breakpoints">3.2.1.5 I/O Breakpoints</a></h3>
<p>An I/O breakpoint is always connected to a specific device object. The breakpoint is triggered when that device is accessed. The breakpoint is set using the <code>break-io</code> command, which take the device name as a parameter. For example, to break on accesses to a device called <code>dma</code>, we would use the following syntax:</p>
<pre><code class="language-simics">simics&gt; <strong>break-io device = board.mb.sb.dma</strong>
</code></pre>
<p>A list of devices can be obtained by tab-completing the <em>device</em> argument.</p>
<h3 id="debug.html:text-output-breakpoints"><a href="#debug.html:text-output-breakpoints">3.2.1.6 Text Output Breakpoints</a></h3>
<p>Many simulated machines have a <em>text console</em>—a terminal window hooked up to a serial port on the target machine, so that you can type commands to the target and get replies. In particular x86 systems also often have a <em>graphics console</em>—a window acting as a monitor to the machine, hooked up to a graphics device on the target machine, and usually also to keyboard and mouse devices.</p>
<p>A text console can halt the simulation on the occurrence of a given character sequence in the output; this is called a <em>text output breakpoint</em>. This is also possible on a graphics console when it is running in text mode graphics, assuming that the graphics device implements this.</p>
<p>To set a breakpoint, use the command <code>bp.console_string.break console string</code>, which returns a breakpoint id. Simics will stop when <em>string</em> appears in the output.</p>
<div class="note">
<p>To find out if a specific simulated machine uses these consoles, look for objects of class <code>textcon</code> or <code>graphcon</code> in the list provided by <code>list-objects</code> once the configuration is loaded.</p>
</div>
<h3 id="debug.html:graphics-breakpoints"><a href="#debug.html:graphics-breakpoints">3.2.1.7 Graphics Breakpoints</a></h3>
<p>If your target machine has a graphical display (as opposed to just a text console), you can set graphical breakpoints on it. A graphical breakpoint is a (small or large) bitmap image and a pair of coordinates; when the pixels at those coordinates on the simulated display exactly match the breakpoint image, the simulation will halt.</p>
<p>Graphics breakpoints can be created from the console GUI window, but the following commands can also be used to save and set breakpoints for a graphics console:</p>
<div class="dl">
<ul>
<li><span class="term" id="debug.html:dt:gfx-console-save-break-xy-filename-left-top-right-bottom"><a href="#debug.html:dt:gfx-console-save-break-xy-filename-left-top-right-bottom"><code>gfx-console.save-break-xy filename left top right bottom</code></a></span><br>
Let the user specify a rectangular area inside the graphics console using the top left and bottom right corners coordinates. The selected area will be saved as a binary graphical breakpoint file.</li>
<li><span class="term" id="debug.html:dt:gfx-console-bp-break-gfx-filename"><a href="#debug.html:dt:gfx-console-bp-break-gfx-filename"><code>gfx-console.bp-break-gfx filename</code></a></span><br>
Activate a previously saved breakpoint and return a breakpoint id. When a graphical breakpoint is reached, Simics halts execution and returns to the command prompt.</li>
<li><span class="term" id="debug.html:dt:bp-delete-id"><a href="#debug.html:dt:bp-delete-id"><code>bp.delete id</code></a></span><br>
Delete the breakpoint associated with <em>id</em>.</li>
</ul>
</div>
<h3 id="debug.html:magic-instructions-and-magic-breakpoints"><a href="#debug.html:magic-instructions-and-magic-breakpoints">3.2.1.8 Magic Instructions and Magic Breakpoints</a></h3>
<p>For each simulated processor architecture, a special nop (no-operation) instruction has been chosen to be a <strong>magic instruction</strong> for the simulator. When the simulator executes such an instruction, it triggers a <code>Core_Magic_Instruction</code> hap and calls all the callbacks functions registered on this hap.</p>
<p>Since magic instructions are just no-operation instructions on hardware, you can run code containing magic instructions on hardware as well as in the simulator, but you will not get any of the extra behavior Simics implements for the magic instruction.</p>
<p>If the architecture makes it possible, a magic instruction parameter is encoded as an immediate value in the magic instruction. When the hap is triggered, this value is passed as an argument to the hap handlers. This provides the user with a rudimentary way of passing information from the simulated system to the hap handler.</p>
<p>Magic instructions have to be compiled into the binary files that are executed on the target. The file <code>magic-instruction.h</code> in <code>[simics]/src/include/simics/</code> defines a <code>MAGIC(n)</code> macro that can be used to place magic instructions in your program, where <code>n</code> is the magic instruction parameter value to encode. Some parameter values are reserved for internal use; see figure <a class="reference" href="#debug.html:magic_instruction_figure">29</a> and figure <a class="reference" href="#debug.html:reserved_magic_numbers_figure">30</a>.</p>
<p>A complete list of magic instructions and the range of the parameter <code>n</code> is provided in figure <a class="reference" href="#debug.html:magic_instruction_figure">29</a>.</p>
<div class="note">
<p>The declaration of the macros are heavily dependent on the compiler used, so you may get an error message telling you that your compiler is not supported. In that case, you will have to write the inline assembly corresponding to the magic instruction you want to use. The GCC compiler should always be supported.</p>
</div>
<div class="note">
<p>The magic instruction macro is directly usable only from C and C++; if your program is written in another language, you will have to call a C function that uses the macro, or an assembly function that includes the magic instruction. (If the language supports inline assembly, that can of course be used as well.) For example, in Java it would be necessary to use the JNI interface. Check your compiler and language documentation for details.</p>
</div>
<div class="note">
<p>(x86 specific) The magic instruction parameter is passed through the <code>eax</code> register on x86. The <code>eax</code> register contents is preserved when the magic instruction is emulated by Simics. Thus the <code>eax</code> register value can be used just after the magic instruction to extract the magic parameter value from it. The values of the <code>ebx</code>, <code>ecx</code> and <code>edx</code> registers are undefined after the magic instruction. Earlier Simics versions had different definitions of magic instructions for x86. The old magic instruction can still be used on x86 if the processor is not running in VMP mode.</p>
</div>
<div class="note">
<p>(PowerPC specific) There are two different encodings of the <code>rlwimi</code>-based magic instruction on PowerPC. On 64-bit models, the new encoding is always used; it is also the one generated by the <code>MAGIC()</code> and <code>MAGIC_BREAKPOINT()</code> macros in <code>magic-instruction.h</code> when compiling 64-bit PowerPC code. The old encoding is used on 32-bit models when the <code>old_rlwimi_magic</code> attribute is set. When compiling 32-bit PowerPC code, the macros will use the old encoding unless the preprocessor symbol <code>SIM_NEW_RLWIMI_MAGIC</code> has been defined.</p>
<p>It is recommended that the new encoding is used with 32-bit PowerPC models and code by setting the appropriate attribute and preprocessor symbol.</p>
</div>
<figure id="debug.html:magic_instruction_figure">
<center>
<table border="cross">
  <tbody><tr>
     <td><b>Target</b></td>
     <td><b>Magic instruction</b></td>
     <td><b>Conditions on <arg>n</arg></b></td>
     <td>
  </td></tr>
  <tr>
     <td>ARC</td><td><tt>mov 0, n</tt></td>
                 <td>1 ≤ n &lt; 64</td>
                 <td>
  </td></tr>
  <tr>
     <td>ARM</td><td><tt>orr rn, rn, rn</tt></td>
                 <td>0 ≤ n ≤ 14</td>
                 <td>
  </td></tr>
  <tr>
     <td>ARMv8</td><td><tt>orr xn, xn, xn</tt></td>
                 <td>0 ≤ n ≤ 31</td>
                 <td>
  </td></tr>
  <tr>
     <td>ARM Thumb-2</td><td><tt>orr.w rn, rn, rn</tt></td>
                         <td>0 ≤ n ≤ 12</td>
                         <td>
  </td></tr>
  <tr>
     <td>H8300</td><td><tt>brn n</tt></td>
                   <td>-128 ≤ n ≤ 127</td>
                   <td>
  </td></tr>
  <tr>
     <td>M680x0</td><td><tt>dbt dx,y</tt></td>
                  <td>0 ≤ n &lt; 0x3ffff</td>
                  <td>
  </td></tr>
  <tr>
    <td>
    </td><td>x=n[17:15], y=n[14:0] * 2</td>
    <td>
    </td><td>
  </td></tr>
  <tr>
     <td>MIPS</td><td><tt>li %zero, n</tt></td>
                  <td>0 ≤ n &lt; 0x10000</td>
                  <td>
  </td></tr>
  <tr>
     <td>Nios II</td><td><tt>or rN, rN, rN,</tt></td>
                  <td>0 ≤ N &lt; 32</td>
                  <td>
  </td></tr>
  <tr>
    <td>PowerPC</td><td><tt>rlwimi x,x,0,y,z</tt></td>
    <td>0 ≤ n &lt; 8192</td>
    <td>new encoding</td>
  </tr>
  <tr>
    <td>
    </td><td>x=n[12:8], y=n[7:4], z=n[3:0]|16</td>
    <td>
    </td><td>
  </td></tr>
  <tr>
    <td>PowerPC</td><td><tt>rlwimi x,x,0,y,z</tt></td>
    <td>0 ≤ n &lt; 32768</td>
    <td>old encoding</td>
  </tr>
  <tr>
    <td>
    </td><td>x=n[14:10], y=n[9:5], z=n[4:0]</td>
    <td>
    </td><td>
  </td></tr>
  <tr>
     <td>RISC-V</td><td><tt>srai zero, zero, n</tt></td>
                 <td>0 ≤ n ≤ 31</td>
                 <td>
  </td></tr>
  <tr>
     <td>SH</td><td><tt>mov rn, rn</tt></td>
                      <td>0 ≤ n &lt; 16</td>
                      <td>
  </td></tr>
  <tr>
     <td>SPARC</td><td><tt>sethi n, %g0</tt></td>
             <td>1 ≤ n &lt; 0x400000</td>
             <td>
  </td></tr>
  <tr>
    <td>x86</td>
    <td><tt>cpuid</tt></td>
    <td>0 ≤ n &lt; 0x10000</td>
    <td>
  </td></tr>
  <tr>
    <td>
    </td><td>with <tt>eax</tt> = 0x4711 + n * 2<sup>16</sup></td>
    <td>
    </td><td>
  </td></tr>
</tbody></table>
</center>
 <figcaption>Figure 29. Magic instructions for different Simics Targets</figcaption> 
</figure>
<figure id="debug.html:reserved_magic_numbers_figure">
<center>
<table border="cross">
  <tbody><tr><td><b>Reserved Magic Numbers</b></td></tr>
  <tr><td><tt>&nbsp;0</tt></td></tr>
  <tr><td><tt>12</tt></td></tr>
</tbody></table>
</center>
 <figcaption>Figure 30. Reserved magic numbers, for internal use only.</figcaption> 
</figure>
<p>Here is a simple example of how to use magic instructions:</p>
<pre><code class="language-C">#include "magic-instruction.h"

int main(int argc, char **argv)
{
        initialize();
        MAGIC(1);                     // tell the simulator to start
                                      // the cache simulation
        do_something_important();
        MAGIC(2);                     // tell the simulator to stop
                                      // the cache simulation
        clean_up();
}
</code></pre>
<p>This code needs to be coupled with a callback registered on the magic instruction hap to handle what happens when the simulator encounters a magic instruction with the arguments 1 or 2 (in this example, to start and stop the cache simulation).</p>
<p>Simics implements a special handling of magic instructions called <strong>magic breakpoints</strong>. A magic breakpoint occurs if magic breakpoints are enabled and if the parameter <code>n</code> of a magic instruction matches a special condition. When a magic breakpoint is triggered, the simulation stops and returns to the prompt.</p>
<p>Magic breakpoints can be enabled with the command <code>bp.magic.break</code> . The condition on <code>n</code> for a magic instruction to be recognized as a magic breakpoint is the following:</p>
<pre><code>n == 0 || (n &amp; 0x3f0000) == 0x40000
</code></pre>
<p>Note that the value 0 is included for architectures where no immediate can be specified. The file <code>magic-instruction.h</code> defines a macro called MAGIC_BREAKPOINT that places a magic instruction with a correct parameter value in your program.</p>
<h2 id="debug.html:symbolic-debugging"><a href="#debug.html:symbolic-debugging">3.2.2 Symbolic Debugging</a></h2>
<p>A vital part of a debugger's task is to understand the system being debugged at a higher level than just machine instructions and memory contents. The user thinks in terms of processes, functions, and named variables, so the debugger presents a view of the software that matches these concepts. This view is even more important in Simics, where the user has access to the whole system and not only user processes. To handle this, Simics Analyzer provides a full symbolic debugger, which you can read about in <a href="../analyzer-user-guide/index.html">Simics Analyzer User's Guide</a>.</p>
<p>Simics provides only some primitive building blocks for basic debugging like <em>context objects</em>.</p>
<h3 id="debug.html:contexts"><a href="#debug.html:contexts">3.2.2.1 Contexts</a></h3>
<p>A <code>context</code> object represents a virtual address space. Each processor in the simulated system has a <em>current context</em>, which represents the virtual address space currently visible to code running on the processor. Virtual-address breakpoints are properties of contexts; different context objects have separate sets of virtual breakpoints, and by changing a processor's current context, you change its set of virtual breakpoints.</p>
<p>The correctness of the simulation does not depend on contexts in any way; the concept of multiple virtual address spaces is useful for <em>understanding</em> the simulated software, but not necessary for running it. What contexts to create and how to use them is entirely your business; Simics does not care.</p>
<p>By default, every processor in a simulation cell use the same default context. You may create new contexts and switch between them at any time. This allows you, for example, to maintain separate debugging symbols and breakpoints for different processes in your target machine. When a context is used in this manner (active when and only when a certain simulated process is active), the context is said to <em>follow</em> the process.</p>
<p><em>Simics Analyzer</em> will help you coordinate contexts for processes running on the target system.</p>
</section><section class="page" id="lowlevel-software.html"><h1 id="lowlevel-software.html:using-simics-for-hardware-bring-up-and-firmware"><a href="#lowlevel-software.html:using-simics-for-hardware-bring-up-and-firmware">3.3 Using Simics for Hardware Bring-Up and Firmware</a></h1>
<p>Development</p>
<p>Simics makes hardware bring-up, firmware development, and other low-level programming tasks easier in a number of ways:</p>
<div class="dl">
<ul>
<li><span class="term" id="lowlevel-software.html:dt:hardware-replacement"><a href="#lowlevel-software.html:dt:hardware-replacement">Hardware replacement</a></span><br>
A simulator replaces hardware. This has two key benefits during hardware bring-up: you can start working on the software before the hardware is available, and you can have as many copies of the simulated hardware as you like. Both of these translate directly to reduced total development time for the combined hardware+software product.</li>
<li><span class="term" id="lowlevel-software.html:dt:inspection-and-modification"><a href="#lowlevel-software.html:dt:inspection-and-modification">Inspection and modification</a></span><br>
You can inspect the state of the entire simulation—memory, processor registers, device registers, anything—all entirely non-intrusively. And time is simply paused while you do so. You can restore a snapshot taken earlier, modify memory or register contents, and then run forward again and see the effects of this change.</li>
<li><span class="term" id="lowlevel-software.html:dt:full-debug-support"><a href="#lowlevel-software.html:dt:full-debug-support">Full debug support</a></span><br>
The full power of Simics debugging (see chapter <a class="reference" href="#debug.html">3.2</a>), with breakpoints, symbolic debugging, scripting, and so on, is available everywhere, even at the very lowest levels.</li>
</ul>
</div>
<h2 id="lowlevel-software.html:a-simple-example"><a href="#lowlevel-software.html:a-simple-example">3.3.1 A Simple Example</a></h2>
<p>It is easy to write a handful of instructions directly to memory, fill the registers with any necessary values, and manually single-step through this little program:</p>
<pre><code class="language-simics">simics&gt; <strong>board.mb.cpu0.core[0][0]-&gt;cs[7] = 0</strong>
simics&gt; <strong>board.mb.cpu0.core[0][0]-&gt;cs[8] = 0xffffffff</strong>
simics&gt; <strong>load-file test.bin 0xf000</strong>
simics&gt; <strong>set-pc 0x10001</strong>
simics&gt; <strong>%dx = 4711</strong>
simics&gt; <strong>si</strong>
[board.mb.cpu0.core[0][0]] cs:0x0000000000010001 p:0x000010001  mov ax,0x1
simics&gt; <strong>si</strong>
[board.mb.cpu0.core[0][0]] cs:0x0000000000010004 p:0x000010004  xor ebx,ebx
</code></pre>
<p>As always in Simics, this can be scripted if you expect to run it more than once:</p>
<div class="dl">
<ul>
<li><span class="term" id="lowlevel-software.html:dt:test-simics"><a href="#lowlevel-software.html:dt:test-simics"><code>test.simics</code>:</a></span></li>
</ul>
<pre><code>run-script targets/qsp-x86/firststeps.simics
board.mb.cpu0.core[0][0]-&gt;cs[7] = 0
board.mb.cpu0.core[0][0]-&gt;cs[8] = 0xffffffff
load-file test.bin 0xf000
set-pc 0x10001
%dx = 4711
continue 12
expect %dx 4713
expect %pc 0x1001c
quit
</code></pre>
</div>
<pre><code>$ ./simics test.simics
*** Values differ in expect command: 4711 4713
$
</code></pre>
<p>Here, we first call another simics script to set up the machine for us, then run our test case. The <code>expect</code>s will cause Simics to exit with an error code (as shown) if the conditions are not met; otherwise, the <code>quit</code> will cause Simics to quit successfully.</p>
<h2 id="lowlevel-software.html:going-further"><a href="#lowlevel-software.html:going-further">3.3.2 Going Further</a></h2>
<p>The simple script in the last section can be extended in several directions:</p>
<ul>
<li>
<p><code>load-file</code> simply writes the contents of a file directly to memory. There are at least two other options:</p>
<ul>
<li>Using <code>set</code> to write values directly to memory. This is useful if the test program is only a few instructions long.</li>
<li>Using <code>load-binary</code> to load an executable in one of the formats Simics recognizes, such as ELF. Unlike <code>load-file</code>, this command automatically loads the executable at the right address, and returns the entry point address.</li>
</ul>
</li>
<li>
<p>You can have more complicated stop conditions than simply "run twelve instructions"; for example, you can use execution or data breakpoints (section <a class="reference" href="#debug.html:memory-breakpoints">3.2.1.2</a>), control register breakpoints (section <a class="reference" href="#debug.html:control-register-breakpoints">3.2.1.4</a>), device I/O breakpoints (section <a class="reference" href="#debug.html:i-o-breakpoints">3.2.1.5</a>), or magic instruction breakpoints (section <a class="reference" href="#debug.html:magic-instructions-and-magic-breakpoints">3.2.1.8</a>).</p>
</li>
<li>
<p>Various conditions cause Simics to trigger <em>haps</em>; for example breakpoints, privilege level changes, magic instructions, and traps. You can easily write a small hap callback function that is called whenever this happens; such a callback could terminate the simulation (indicating success or failure), or simply log or change some value.</p>
</li>
</ul>
</section><section class="page" id="gdb.html"><h1 id="gdb.html:using-simics-with-gdb"><a href="#gdb.html:using-simics-with-gdb">3.4 Using Simics with GDB</a></h1>
<p>This chapter describes how to use <code>gdb-remote</code>, a Simics module that lets you connect a GDB session running on your host machine to the simulated machine using GDB's remote debugging protocol, and use GDB to debug software running on the target machine.</p>
<p>If you load the <code>gdb-remote</code> module in Simics, you can use the remote debugging feature of GDB, the GNU debugger, to connect one or more GDB processes to Simics over TCP/IP. In order to do this, you need a GDB compiled to support the simulation's target architecture on whichever host you're running. The <code>gdb-remote</code> module has been tested with several different versions of GDB 6 and 7.</p>
<p>A prebuilt GDB is distributed in the Simics GDB (#1031) package. In a Simics project, the <code>bin/gdb</code> command (<code>bin\gdb.bat</code> on Windows) can be used to launch GDB.</p>
<div class="note">
<p>The <code>bin/gdb</code> or <code>bin\gdb.bat</code> commands will only work if Simics GDB (#1031) is installed and available as addon package in the Simics project.</p>
</div>
<p>To connect a GDB session to Simics, start your Simics session and run the <code>new-gdb-remote</code> command, optionally followed by a TCP/IP port number, which defaults to 9123 otherwise. This will automatically load the <code>gdb-remote</code> module. You can also specify which processor or context the remote debugger should be attached to with the <em>cpu</em> and <em>context</em> arguments.</p>
<p>When a configuration is loaded, Simics will start listening to incoming TCP/IP connections on the specified port. Run the simulated machine up to the point where you want to connect GDB. To inspect a user process or dynamically loaded parts of the kernel, the easiest solution might be to insert magic instructions at carefully chosen points. For static kernel debugging, a simple breakpoint on a suitable address will solve the problem.</p>
<div class="note">
<p>When debugging the start-up phase of an operating system, it might happen that gdb gets confused by the machine state and disconnects when you try to connect. In this case, execute a few instructions and try again.</p>
</div>
<p>Once Simics is in the desired state, start your GDB session, load any debugging information into it, and then connect it to Simics using the <code>target remote host:port</code> command, where <em>host</em> is the host Simics is running on, and <em>port</em> is the TCP/IP port number as described above. Here is a short sample session using <code>firststeps</code>:</p>
<pre><code>
(gdb) symbol-file targets/qsp-x86/images/yocto_linux/yocto-1.8-vmlinux
Reading symbols from targets/qsp-x86/images/yocto_linux/yocto-1.8-vmlinux...done.
(gdb) set endian little
The target is assumed to be little endian
(gdb) target remote localhost:9123
Remote debugging using localhost:9123
0x000000000000fff0 in unicast_sock ()
(gdb) 
</code></pre>
<p>Note that yocto-1.8-vmlinux is internal file and not distributed in the package, so the reader cannot run the example in simics.</p>
<div class="note">
<p>The GDB supplied with Simics has builtin support for several target architectures. The architecture will be set automatically when GDB connects, but for little-endian architectures (such as x86 and x86_64), the following GDB command has to be issued: <code>set endian little</code>.</p>
</div>
<p>From this point, you can use GDB to control the target machine by entering normal GDB commands such as <code>continue</code>, <code>step</code>, <code>stepi</code>, <code>info regs</code>, <code>breakpoint</code>, etc.</p>
<div class="note">
<p>GDB does not expect the target state to change while it is in control and has asked for the simulation to be stopped. If the simulation is started from another frontend (e.g., by the <code>continue</code> command from the Simics command line) then GDB will not be notified and will still use cached information about the program location and register values. To recover from such a situation, issue a GDB command that makes the simulation run.</p>
</div>
<p>To force Simics to close a connection, use the <code>gdb0.disconnect</code> command.</p>
<p>The <code>gdb-remote</code> module does not have any high-level information about the OS being run inside Simics. This means that in order to examine memory or disassemble code, the data or code you want to look at has to be in the active TLB.</p>
<div class="note">
<p>When using <code>gdb-remote</code> with targets supporting multiple address sizes (such as x86-64 and SPARC), you must have a GDB compiled for the larger address size. For SPARC, run GDB's configure script with the <code>--target=sparc64-sun-solaris2.8</code> option.</p>
</div>
<h2 id="gdb.html:remote-gdb-and-shared-libraries"><a href="#gdb.html:remote-gdb-and-shared-libraries">3.4.1 Remote GDB and Shared Libraries</a></h2>
<p>It takes some work to figure out how to load symbol tables at the correct offsets for relocatable object modules in GDB. This is done automatically for normal (non-remote) targets, but for the remote target, you have to do it yourself. You need to find out the actual address at which the shared module is mapped in the current context on the simulated machine, and then calculate the offset to use for GDB's <code>add-symbol-file</code> command.</p>
<p>Under Linux, the list of memory mappings can be found in the file <code>/proc/pid/maps</code> (plain text format). The <code>VMA</code> column of the <code>.text</code> line of the output from <code>objdump -h file</code> contains the start address of the text segment.</p>
<p>Using these two values, <em>map address</em> and <em>text address</em>, you should use <em>map address</em> + <em>text address</em> as the offset to <code>add-symbol-file</code> (it has to be done this way to compensate for how GDB handles symbol loading).</p>
<p>To show you how it works, we will work through a simple example. The example uses a simple program with a simple shared library. The program can be found in <code>[qsp-x86]/targets/qsp-x86/images/hello</code> and the shared library is the <code>libgreeter.so</code> file in the same directory. Here and in the rest of this section <em>[qsp-x86]</em> refers to the location where the QSP-x86 package is installed.</p>
<p>Start by booting the firststeps machine. Then mount the host file system and copy the program and shared library onto the machine. This should be done on the target:</p>
<pre><code>
~ # mount /host
~ # cp /host/[qsp-x86]/targets/qsp-x86/images/hello .
~ # cp /host/[qsp-x86]/targets/qsp-x86/images/libgreeter.so .
</code></pre>
<p>Then run the program in the background. The program will enter the infinite loop in the shared library.</p>
<p>Now we need the <em>map address</em> and the <em>text address</em> of the shared library. To get the map address, look in the process file system to see where it has mapped the shared library:</p>
<pre><code>
~ # ./hello &amp;
[1] 13104
~ # cat /proc/13104/maps
00400000-00401000 r-xp 00000000 08:02 9442              /home/root/hello
00600000-00601000 r--p 00000000 08:02 9442              /home/root/hello
00601000-00602000 rw-p 00001000 08:02 9442              /home/root/hello
7f686c5ed000-7f686c786000 r-xp 00000000 08:02 10049     /lib/libc-2.21.so
7f686c786000-7f686c986000 ---p 00199000 08:02 10049     /lib/libc-2.21.so
7f686c986000-7f686c98a000 r--p 00199000 08:02 10049     /lib/libc-2.21.so
7f686c98a000-7f686c98c000 rw-p 0019d000 08:02 10049     /lib/libc-2.21.so
7f686c98c000-7f686c990000 rw-p 00000000 00:00 0 
7f686c990000-7f686c991000 r-xp 00000000 08:02 10247     /home/root/libgreeter.so
7f686c991000-7f686cb90000 ---p 00001000 08:02 10247     /home/root/libgreeter.so
7f686cb90000-7f686cb91000 r--p 00000000 08:02 10247     /home/root/libgreeter.so
7f686cb91000-7f686cb92000 rw-p 00001000 08:02 10247     /home/root/libgreeter.so
7f686cb92000-7f686cbb4000 r-xp 00000000 08:02 9919      /lib/ld-2.21.so
7f686cdad000-7f686cdb0000 rw-p 00000000 00:00 0 
7f686cdb2000-7f686cdb3000 rw-p 00000000 00:00 0 
7f686cdb3000-7f686cdb4000 r--p 00021000 08:02 9919      /lib/ld-2.21.so
7f686cdb4000-7f686cdb5000 rw-p 00022000 08:02 9919      /lib/ld-2.21.so
7f686cdb5000-7f686cdb6000 rw-p 00000000 00:00 0 
7fffde6a7000-7fffde6c8000 rw-p 00000000 00:00 0         [stack]
7fffde7ff000-7fffde800000 r-xp 00000000 00:00 0         [vdso]
ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0 [vsyscall]
</code></pre>
<p>From this output you can see that the program is running with PID 13104 and that the map address is 0x7f686c990000. The exact PID may differ, adapt the commands accordingly.</p>
<p>To get the <em>text address</em> we use objdump. This should be run on a host computer with objdump installed:</p>
<pre><code>
&gt; objdump -h [qsp-x86]/targets/qsp-x86/images/libgreeter.so
libgreeter.so:     file format elf64-x86-64

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
    :
 10 .text         00000134  00000000000005e0  00000000000005e0  000005e0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
    :
</code></pre>
<p>The <code>.text</code> symbols starts at address <code>0x5e0</code> and this is what we call the <em>text address</em>, so if we connect GDB to Simics we have to add the symbols with an offset of <code>0x7f686c990000 + 0x5e0 = 0x7f686c9905e0</code>.</p>
<p>Now we can set up GDB, connect it to Simics, and debug the program:</p>
<pre><code>
(gdb) dir [qsp-x86]/targets/qsp-x86/
Source directories searched: [qsp-x86]/targets/qsp-x86:$cdir:$cwd
(gdb) add-symbol-file [qsp-x86]/targets/qsp-x86/images/libgreeter.so 0x7f686c9905e0
add symbol table from file "[qsp-x86]/targets/qsp-x86/images/libgreeter.so" at
	.text_addr = 0x6c9905e0
(y or n) y
Reading symbols from [qsp-x86]/targets/qsp-x86/images/libgreeter.so...done.
(gdb) set endian little
The target is assumed to be little endian
(gdb) target remote localhost:9123
Remote debugging using localhost:9123
greet (name=0x4008eb "World") at ../greeter.c:12
14	        while (loop); /* Loop until the loop variable is reset by gdb */
(gdb)
</code></pre>
<p>This is just a toy program written to make it possible to debug it without any OS awareness. Normally you would use the OS awareness functionality described in <a href="../analyzer-user-guide/index.html">Simics Analyzer User's Guide</a> to debug user space programs.</p>
</section><section class="page" id="others.html"><h1 id="others.html:using-simics-with-other-ides"><a href="#others.html:using-simics-with-other-ides">3.5 Using Simics with Other IDEs</a></h1>
<p>Simics does not explicitly support IDEs other than those listed in this manual. If you would like to use Simics with such an IDE, there are a few options you could try:</p>
<ul>
<li>Use Simics's own user interface to control the debugging process (see chapter <a class="reference" href="#debug.html">3.2</a>).</li>
<li>If your IDE speaks the GDB serial protocol, try connecting it directly to Simics with the help of a <code>gdb-remote</code> object (see chapter <a class="reference" href="#gdb.html">3.4</a>).</li>
<li>If your IDE uses GDB as a debugger backend, try to make this GDB instance connect to Simics with <code>gdb-remote</code>.</li>
</ul>
</section><section class="page" id="performance.html"><h1 id="performance.html:performance"><a href="#performance.html:performance">4 Performance</a></h1>
</section><section class="page" id="simulation-performance.html"><h1 id="simulation-performance.html:simulation-performance"><a href="#simulation-performance.html:simulation-performance">4.1 Simulation Performance</a></h1>
<p>This chapter covers various topics related to Simics performance and what can be done to measure and improve it. It discusses the general performance features provided by Simics. For ways to scale the simulation even further see chapter <a class="reference" href="#scaling-simics.html">4.2</a>.</p>
<p>Simics is a fast simulator utilizing various techniques such as run-time code generation to optimize performance. In some cases Simics can execute code faster than the target system being simulated, while it can also be considerably slower in other cases.</p>
<p>There are four major execution modes Simics uses to execute target instructions: hypersimulation, VMP, JIT and interpreted mode.</p>
<p>Hypersimulation means that Simics detects repetitive work performed by the target code and performs the effects of the code without actually having to run the code. In the most simple case this is a simple idle loop, but it can also be applied to more complex examples such as spin-locks and device polling. This is the fastest execution mode.</p>
<p>VMP, which is a part of Simics's x86 models, utilizes the virtualization capabilities of modern processors to run target instructions directly. This typically results in high simulation performance, but the host and target needs have the same instruction set, and you have to do special set up to enable it. VMP is currently only supported on x86 hosts.</p>
<p>JIT mode uses run-time code generation to translate blocks of the target instructions into blocks of host instructions. JIT mode is when Simics runs such translated blocks. This mode is supported by most target processor models in Simics.</p>
<p>Interpreted mode interprets the target instructions one by one. This mode is the slowest, but it is always available.</p>
<p>There are basically two ways to measure Simics performance:</p>
<ul>
<li>How fast the instructions are being simulated, typically measured in million target instructions per host second (MIPS).</li>
<li>How fast the virtual times elapses.</li>
</ul>
<p>In most cases the user is mostly interested in the first. Simics should execute instructions as fast as possible to finish the workload in shortest possible time. However, since Simics is a full system simulator, it is also important that the virtual time on the simulated machine advances quickly. That is important in cases where a program or operating system is waiting on a timer to expire or an interrupt from a device in order to proceed with the workload.</p>
<p>If we divide the wall-clock time on the host that Simics executes on, with the elapsed virtual time on the target machine, we get a slowdown number.</p>
<p>slowdown = Time<sub>host</sub>/Time<sub>virtual</sub></p>
<p>A slowdown number of 2.3 means that Simics performance is 2.3 times slower than the system it simulates. A slowdown value of less than 1.0 means that Simics manages to execute the corresponding code faster than the system it simulates. The slowdown depends on various factors:</p>
<ul>
<li>The performance of the host which Simics runs on.</li>
<li>The application which runs in Simics.</li>
<li>The frequency of the target being simulated.</li>
<li>The simulator time model.</li>
</ul>
<p>The default time model in Simics is that each target instruction takes one target cycle to execute. That is the default, <em>Instructions Per Cycle</em> (IPC) is 1.0. This is a simplification (but in many cases an adequate approximation) compared to the actual time it takes on the real hardware to execute instructions. It is possible to change the IPC number using the <code>&lt;cpu&gt;.set-step-rate</code> command. For example:</p>
<pre><code class="language-simics">simics&gt; <strong>board.mb.cpu0.core[0][0].set-step-rate ipc = 1.5</strong>
Setting step rate to 3/2 steps/cycle
simics&gt; <strong>board.mb.cpu0.core[0][0].set-step-rate ipc = 0.5</strong>
Setting step rate to 1/2 steps/cycle
</code></pre>
<p>In the first example, IPC of 1.5 means that Simics needs to execute 3 instructions for 2 cycles to elapse. In the second example, for each instruction executed two cycles elapse. Thus, with a lower IPC value, virtual time will progress faster and simulation slowdown will decrease.</p>
<p>Note that there is nothing wrong in changing the default IPC when it comes to the accuracy of the simulation. In many cases, the IPC observed for a given benchmark is much lower than the 1.0 that Simics assumes, and matching it will both make the simulation closer to the real hardware and improve the simulation speed, at least in virtual time. Simulations that profits most from this change are simulations involving devices and long memory latencies.</p>
<h2 id="simulation-performance.html:measuring-performance"><a href="#simulation-performance.html:measuring-performance">4.1.1 Measuring Performance</a></h2>
<p>The <code>system-perfmeter</code> extension can be used to understand the performance you get out of Simics. The system-perfmeter is sample based, which means that you can see the performance during the workload execution, and how it varies, not only the end result when a workload is finished.</p>
<p>The easiest way to try it out is simply to issue the <code>system-perfmeter</code> command without any additional arguments:</p>
<pre><code class="language-simics">simics&gt; <strong>system-perfmeter</strong>
</code></pre>
<p>This will cause a sample to be taken every 1.0 virtual seconds. For each sample the system-perfmeter extracts various counters from Simics and displays the delta since last time. The output can look like this:</p>
<pre><code class="language-simics">simics&gt; <strong>c</strong>
SystemPerf: Total-vt Total-rt Sample-vt Sample-rt Slowdown  CPU Idle
SystemPerf: -------- -------- --------- --------- -------- ---- ----
SystemPerf:     1.0s     6.0s     1.00s     5.99s     5.99  97%   0%
SystemPerf:     2.0s     6.7s     1.00s     0.69s     0.69  97%   0%
SystemPerf:     3.0s     8.0s     1.00s     1.34s     1.34  92%   0%
SystemPerf:     4.0s     8.4s     1.00s     0.42s     0.42 100%   0%
SystemPerf:     5.0s     9.2s     1.00s     0.78s     0.78  98%  14%
SystemPerf:     6.0s    10.5s     1.00s     1.31s     1.31  96%  55%
SystemPerf:     7.0s    10.7s     1.00s     0.12s     0.12  92%  93%
SystemPerf:     8.0s    10.7s     1.00s     0.00s     0.00 100% 100%
</code></pre>
<p>Here we can see the execution for the first 8 virtual seconds and the corresponding performance measured in each second sample. To simulate these 8 virtual seconds, it took Simics 10.7 host seconds, thus the average slowdown is 1.34.</p>
<p>The <code>CPU</code> column shows how much of the host CPU that Simics has used, allowing you to notice if there is another process consuming the host CPU resources. Another reason for CPU utilization to be low can be that Simics itself is running in real-time mode where Simics sleeps so that virtual time does not race ahead of host time.</p>
<p>When an 'idle' condition has been detected (see chapter <a class="reference" href="#simulation-performance.html:idle-loops-and-performance">4.1.4.1</a>), the total idleness of the system is reported in the <code>Idle</code> column. If the simulated system consists of multiple processors and you wish to see how much each processor is idling you can use the <em>-cpu-idle</em> switch to <code>system-perfmeter</code>. Note that idling is defined by the simulator, not by the target architecture (see chapter <a class="reference" href="#simulation-performance.html:idle-loops-and-performance">4.1.4.1</a>). With the <em>-cpu-exec-mode</em>, information is also gathered and printed on how simulation steps are executed in the CPU model. The fastest mode to be executing in is idle, followed by VMP, JIT, and interpreter.</p>
<p>The <code>system-perfmeter</code> can also be used to get an understanding of which processor that takes the longest time to simulate. The <em>-cpu-host-ticks</em> switch adds extra columns per CPU for this. For example:</p>
<pre><code>SystemPerf: Total-vt Total-rt Sample-vt Sample-rt Slowdown  CPU Idle [   0   1   2   3 ]
SystemPerf: -------- -------- --------- --------- -------- ---- ----   --- --- --- ---
SystemPerf:     1.0s    15.6s     1.00s    15.63s     15.6  99%  74% [  71  11  11   8 ]
SystemPerf:     2.0s    32.6s     1.00s    16.97s     17.0  98%  72% [  70  11  10   9 ]
</code></pre>
<p>Here we have a 4 CPU system which is idle roughly 70% and the last columns show that CPU0 takes 70% of the time to simulate, while the other three about 10% each. Hence CPU0 is working while the other CPUs are idling.</p>
<p>The <em>-module-profile</em> flag enables live profiling of the main Simics thread. The profiling is sample based, and any sample hitting in code produced dynamically by a JIT engine will be reported as <code>"classname JIT"</code>. The <em>-module-profile</em> data is not printed in the standard line print mode, so you must use either <em>-top</em> or <em>-summary</em> to get profiling information.</p>
<figure id="simulation-performance.html:perfmeter-fig">
<p><img alt="" src="perfmeter_description.png"> </p><figcaption>Figure 31. Annotated output from <code>system-perfmeter -top -module-profile -cpu-exec-mode</code> </figcaption><p></p>
</figure>
<p>Figure <a class="reference" href="#simulation-performance.html:perfmeter-fig">31</a> explains the output of <code>system-perfmeter</code>. There are many other options to the system-perfmeter command, please read the associated help text for details.</p>
<pre><code class="language-simics">simics&gt; <strong>help system-perfmeter</strong>
</code></pre>
<h2 id="simulation-performance.html:multithreaded-simulation-profiling-and-tuning"><a href="#simulation-performance.html:multithreaded-simulation-profiling-and-tuning">4.1.2 Multithreaded Simulation Profiling and Tuning</a></h2>
<p>With Simics Accelerator, simulation performance can be increased by utilizing host system parallelism. Simics exploits available target system parallelism and spreads the load over available host cores, in order to increase performance.</p>
<p>Simics Accelerator has two different mechanisms that can operate alone or work together to improve performance. The first is Simics® <em>Multimachine Accelerator</em> which is based upon the cell concept. The other mechanism is <em>Multicore Accelerator</em> which can parallelize simulation even within cells.</p>
<p>A cell ideally contains tightly coupled parts of the target system (typically one or more CPUs and associated devices). Different cells can be simulated in parallel with <em>Multimachine Accelerator</em> (which is default on), but unless <em>Multicore Accelerator</em> is enabled (default off), a single cell will be simulated in a single-threaded fashion (see chapter <a class="reference" href="#scaling-simics.html">4.2</a> for more details).</p>
<h3 id="simulation-performance.html:simics-multimachine-accelerator"><a href="#simulation-performance.html:simics-multimachine-accelerator">4.1.2.1 Simics® Multimachine Accelerator</a></h3>
<p>The Multithreaded Simulation Profiler tool (<strong>mtprof</strong>) can be used to analyze some performance aspects of multithreaded simulation. Mtprof is primarily useful to</p>
<ul>
<li>detect parallelism bottlenecks</li>
<li>predict how fast the simulation would run on a more parallel host machine</li>
<li>provide some insights into the performance impact of various latency setting.</li>
</ul>
<p>The Multithreaded Simulation Profiler helps in understanding threading behavior at the Multimachine Accelerator level. There is no explicit tool support for optimizing specific Multicore Accelerator issues.</p>
<p>The Multithreaded Simulation Profiler is started with the following command:</p>
<pre><code class="language-simics">simics&gt; <strong>enable-mtprof</strong>
</code></pre>
<p>When mtprof is enabled, Simics keeps track of how much CPU time is spent simulating each cell in the system. Once Simics has been running for a while, it is possible to ask mtprof for an overview:</p>
<pre><code class="language-simics">simics&gt; <strong>mtprof.cellstat</strong>
============================================================
  cellname                    rt   %elapsed  %cputime
------------------------------------------------------------
  ebony3.cell3             77.0s     93.6%    80.0% 
  ebony1.cell1              8.9s     10.9%     9.3% 
  ebony2.cell2              8.2s     10.0%     8.5% 
  ebony0.cell0              2.1s      2.5%     2.1% 
------------------------------------------------------------
  elapsed_realtime         82.2s    100.0%    85.5%
============================================================
</code></pre>
<p>From the above output, we can conclude that cell3 is a limiting factor: the other cells frequently have to wait upon this cell in order to keep the virtual time in sync. Investigating why cell3 is so expensive to simulate is the next natural step: there might be an expensive poll loop or the idle optimization might not function properly, for instance. Other potential ways to address the load imbalance include</p>
<ul>
<li>enabling <em>Multicore Accelerator</em> for the cell if applicable</li>
<li>splitting cell3 into multiple cells (if it contains multiple CPUs and Multicore Accelerator is not applicable)</li>
<li>changing the step rate of CPUs belonging to cell3.</li>
</ul>
<p>The mtprof tool can also be used to estimate how fast the simulation would run on a machine with enough host cores to allow Simics to assign a dedicated host core to each cell:</p>
<pre><code class="language-simics">simics&gt; <strong>mtprof.modelstat</strong>
============================================================
  latency      rt_model  realtime/rt_model
------------------------------------------------------------
    10 ms        81.9s       100.4%
    40 ms        81.2s       101.2%
   160 ms        80.3s       102.4%
   640 ms        78.6s       104.6%
============================================================
</code></pre>
<p>The latency column corresponds to various values for <code>set-min-latency</code>. In this case, the simulation was executed with a 10 ms latency, which means that the model predicts that the simulation would take 81.9 s to run (which is pretty close to the measured value of 82.2 s above).</p>
<p>It is important to note that the performance model does not take modified target behavior, due to different latency settings, into account (which can be a huge factor if the cells interact). With substantial inter-cell interaction, only the row corresponding to the current latency setting should be trusted.</p>
<p>Below is an example from a more evenly loaded system run with a min-latency of 1 ms:</p>
<pre><code class="language-simics">simics&gt; <strong>mtprof.modelstat</strong>
============================================================
  latency      rt_model  realtime/rt_model
------------------------------------------------------------
     1 ms        35.3s       107.4%
     4 ms        29.5s       128.8%
    16 ms        25.9s       146.3%
    64 ms        24.2s       156.5%
============================================================
</code></pre>
<p>In this case, we see that increasing the latency setting to about 16 ms would improve simulation performance substantially (once again, without taking changed target behavior into account).</p>
<p>Quite often, the target behavior is not static but varies with simulated time. In that case, it is often useful to export the collected data and plot it using an external tool:</p>
<pre><code class="language-simics">simics&gt; <strong>mtprof.save-data output.txt</strong>
</code></pre>
<p>The exported data is essentially the information provided by <code>mtprof.cellstat</code> and/or <code>mtprof.modelstat</code>, but expressed as a function of virtual time (exported in a plot friendly way). The <code>mtprof.save-data</code> command takes multiple flags which can be used to customize the output. One useful flag is <em>-oplot</em>:</p>
<pre><code class="language-simics">simics&gt; <strong>mtprof.save-data mtprof-plot.m -oplot</strong>
</code></pre>
<p>which outputs the data in the form of an Octave file together with commands which plots the data.</p>
<p>The mtprof tool currently does not support Multicore Accelerator.</p>
<h3 id="simulation-performance.html:multicore-accelerator"><a href="#simulation-performance.html:multicore-accelerator">4.1.2.2 Multicore Accelerator</a></h3>
<p>Whether to use Multicore Accelerator or not depends heavily on the workload of the system that is being modeled. Multicore Accelerator performs best for systems with CPU intensive tasks, with little communication, and a low I/O rate. The <code>print-device-access-stats</code> and <code>system-perfmeter</code> commands can be use measure the frequency of I/O operations in the system. (I/O operations are expensive in Multicore Accelerator mode.)</p>
<p>Note that some systems perform well even if the number of target instructions per I/O operation is as low as 300 while others perform bad even though this number is considerably higher. Different target systems behave differently, and in the end, one have to benchmark each system by itself to get highest possible performance. As a guideline, if a target system executes less than 10,000 instructions per I/O operation on average, one might have to consider switching off Multicore Accelerator, or tune the system software in order to achieve good performance.</p>
<p>The <code>enable-multicore-accelerator</code> command provides some tuning and settings for Multicore Accelerator. For more information, see the documentation for the <code>enable-multicore-accelerator</code> command.</p>
<p>It is probably best practice to try to optimize the cell partitioning as described in section <a class="reference" href="#simulation-performance.html:simics-multimachine-accelerator">4.1.2.1</a> to find the most resource demanding cells first, and then switching on Multicore Accelerator for those cells (if available host cores still exists). Currently, it is not possible to restrict a number of host cores for particular target CPUs. Simics will instead automatically balance the system as efficient as possible.</p>
<h2 id="simulation-performance.html:platform-effects"><a href="#simulation-performance.html:platform-effects">4.1.3 Platform Effects</a></h2>
<p>Starting with the most important, consider these factors when choosing a platform to run Simics on:</p>
<div class="dl">
<ul>
<li>
<p><span class="term" id="simulation-performance.html:dt:cpu-speed"><a href="#simulation-performance.html:dt:cpu-speed">CPU Speed</a></span><br>
Simulation is a very compute intensive application. As a general rule, a machine with higher compute performance will outperform a lower compute performance machine unless the simulation is starved for memory. The SPECint2006 benchmark suite (<code>www.spec.org</code>) is a good indicator of compute performance and can be used to compare systems with different processors. Both processor architecture and clock frequency affects the performance. Within an architecture performance scales almost linearly with clock frequency.</p>
<p>Other CPU features such as the size of the caches does affect performance, but less so than the architecture and the clock frequency.</p>
</li>
<li>
<p><span class="term" id="simulation-performance.html:dt:memory-size"><a href="#simulation-performance.html:dt:memory-size">Memory Size</a></span><br>
The simulator can operate with less memory than the simulated memory size. It does that by allocating pages only when used and swapping out pages to disk when running low on memory. The memory size needs to be large enough so that the paging of memory to disk does not hurt performance too much.</p>
</li>
<li>
<p><span class="term" id="simulation-performance.html:dt:number-of-cores"><a href="#simulation-performance.html:dt:number-of-cores">Number of Cores</a></span><br>
Simics Accelerator will utilize multiple host threads to simulate in parallel. If all simulated processors require equal amounts of time to simulate, then the simulator can theoretically utilize as many host cores as there are simulated processors. In practice, the workload is always skewed, meaning that fewer host cores can be effectively utilized. It is more efficient to use multiple cores or processors on a single machine compared to distributing the simulation across multiple host machines.</p>
</li>
<li>
<p><span class="term" id="simulation-performance.html:dt:file-system"><a href="#simulation-performance.html:dt:file-system">File System</a></span><br>
Running from local disk is faster than running over a network file system. When running low on memory, make sure that the swap directory used by the memory limit feature is located on local disk. Also, solid state disks (SSDs) are highly preferred over traditional rotating disks.</p>
</li>
</ul>
</div>
<h2 id="simulation-performance.html:workload-characteristics"><a href="#simulation-performance.html:workload-characteristics">4.1.4 Workload Characteristics</a></h2>
<p>The performance of Simics sometimes depends on the kind of software that runs inside the target machine being simulated. Thus, the slowdown can vary a lot depending on what the target software is currently executing. Here are some general tips for understanding what decreases simulation speed.</p>
<div class="dl">
<ul>
<li><span class="term" id="simulation-performance.html:dt:floating-point-intense-workloads"><a href="#simulation-performance.html:dt:floating-point-intense-workloads">Floating-point intense workloads</a></span><br>
If the target software runs floating-point arithmetic instructions frequently, the performance is likely lower compared to running integer based workloads. The same is usually true for workloads with frequent use of SIMD-style media instructions.</li>
<li><span class="term" id="simulation-performance.html:dt:supervisor-code"><a href="#simulation-performance.html:dt:supervisor-code">Supervisor code</a></span><br>
If a workload runs much of the code in supervisor mode such as frequently causing exceptions, this type of code normally runs slower than regular user-level code.</li>
<li><span class="term" id="simulation-performance.html:dt:i-o-workloads"><a href="#simulation-performance.html:dt:i-o-workloads">I/O workloads</a></span><br>
If the code does frequent accesses to devices, compared to accessing RAM, Simics needs to do more work to simulate this, which slows down simulation. Note that this type of workload is an excellent candidate for a lower IPC setting.</li>
<li><span class="term" id="simulation-performance.html:dt:memory-usage"><a href="#simulation-performance.html:dt:memory-usage">Memory usage</a></span><br>
If the target software is using more memory than available on the host. This is typically a problem when the simulated machine has equal or more memory than the host it executes on <strong>and</strong> the software also uses it. This will cause Simics to swap out pages on disk, which decreases performance.</li>
<li><span class="term" id="simulation-performance.html:dt:event-usage"><a href="#simulation-performance.html:dt:event-usage">Event usage</a></span><br>
Simics modules which frequently post events with short time quanta. For example, if a device posts an event every 10th cycle, to keep a counter register updated, this will severely affect performance.</li>
</ul>
</div>
<p>Typically, target code which runs with low performance on real hardware due to bad cache behavior, bad memory locality etc. will also cause Simics to run with poor performance.</p>
<h3 id="simulation-performance.html:idle-loops-and-performance"><a href="#simulation-performance.html:idle-loops-and-performance">4.1.4.1 Idle Loops and Performance</a></h3>
<p>When an operating system does not have any processes to schedule, it typically runs some tight loop waiting for an interrupt to occur. This is referred to as the <em>idle loop</em>. The way the idle loop is implemented varies between operating systems and the capabilities in the underlying hardware.</p>
<p>For example, the most simple idle loop would be a "branch to itself" instruction. When the processor reaches this instruction, nothing but an interrupt will cause the execution to proceed somewhere else. Another example is when the operating system uses some kind of power-down mode on the processor, causing the processor to stop executing any more instructions (and consequently consume less power). Some processors also have dedicated instructions causing the processor to stop until something interesting happens, such as the x86 <code>HLT</code> instruction. Processor idling in Simics is defined by what the simulator can detect and usually includes architectural states such as halt or power-down, but can also be loops normally executed by the processor.</p>
<p>A fast simulation of the idle loop, is very important in some cases. For example, when simulating multiple processors, we want to use as much of the host CPU cycles as possible for simulating the processor that actually performs useful tasks. Rather than wasting cycles on the idle loop.</p>
<p>Even when simulating a single CPU, fast idle loops can be important, since all of the active processes might be stalling on disk or some other peripheral. Execution of the processes will not continue unless, for example, a disk issues an interrupt.</p>
<p>Simics processor models can sometimes detect idle conditions. When the processor model detects a branch to itself, there is no point in simulating the instruction, if it branches to itself repeatedly.</p>
<p>Instead, Simics is capable of fast-forwarding time until an event that can generate an interrupt is about to be executed. Hence, this model is equivalent to running the branch millions of times, but is much faster.</p>
<p>In some cases, the idle loop in the operating system is more than a single instruction, e.g., it might be a loop checking a variable in memory for the next process to schedule. These more difficult cases can be handled with hypersimulation (see chapter <a class="reference" href="#simulation-performance.html:hypersimulation">4.1.5</a>).</p>
<h2 id="simulation-performance.html:hypersimulation"><a href="#simulation-performance.html:hypersimulation">4.1.5 Hypersimulation</a></h2>
<p>The term <em>hypersimulation</em> refers to a simulator feature which can detect, analyze and understand, frequently executed target instructions and fast-forward the simulation of these, thus providing the corresponding results more rapidly.</p>
<p>Being able to detect the idle loop (see chapter <a class="reference" href="#simulation-performance.html:idle-loops-and-performance">4.1.4.1</a>) is one example of when this technique is applicable. A much more extreme hypersimulation task would be to understand a complete program and simply provide the corresponding result without actually starting the program. Naturally, this is hardly ever applicable, and impossible in general. Busy-wait loops and spin-locks are more realistic examples of cases where it is easy to optimize away the execution with hypersimulation.</p>
<p>Hypersimulation can be achieved in several ways:</p>
<ul>
<li>
<p><strong>CPU handled instruction hypersimulation</strong>: The processor model can detect certain instructions which will either stop the execution or jump to itself. This behavior is always enabled, thus <code>disable-hypersim</code> does not change the behavior. Only an exception/interrupt will stop this execution.</p>
</li>
<li>
<p><strong>Automatic hypersimulation</strong>: Automatic detection of certain small loops that only wait for a future event to occur. This feature is only available for some processor models. The <code>-no-auto</code> switch for the <code>enable-hypersim</code> command disables automatic hypersimulation.</p>
</li>
<li>
<p><strong>Hypersim-pattern-matcher</strong>: User-written specifications, hypersim patterns, are used by the simulator to detect waiting loops that match. The hypersim pattern describes the binary layout of the instructions in the loop and the conditions for leaving it. The hypersim-pattern-matcher module contains the framework for writing hypersim patterns.</p>
</li>
</ul>
<p>The following instructions are handled with <em>CPU handled instruction hypersimulation</em>:</p>
<table><thead><tr><th><strong>Target</strong></th><th><strong>Instruction</strong></th><th><strong>Comment</strong></th></tr></thead><tbody>
<tr><td>ARM</td><td><code>mcr</code></td><td>Enabling "Wait for Interrupt"</td></tr>
<tr><td>m68k</td><td><code>stop</code></td><td></td></tr>
<tr><td>MIPS</td><td><code>wait</code></td><td></td></tr>
<tr><td>PowerPC</td><td><code>mtmsr</code></td><td>Setting <code>MSR[POW]</code>.</td></tr>
<tr><td>PowerPC</td><td><code>b 0</code></td><td>Branch to itself</td></tr>
<tr><td>PowerPC</td><td><code>wait</code></td><td></td></tr>
<tr><td>x86</td><td><code>hlt</code></td><td></td></tr>
<tr><td>x86</td><td><code>mwait</code></td><td></td></tr>
</tbody></table>
<p>Hypersimulation should be as non-intrusive as possible, the only difference that should be noticeable as a Simics user is the increased performance. Registers, timing, memory contents, exceptions, interrupts etc. should be identical.</p>
<p>Hypersimulation using the hypersim-pattern-matcher may have some intrusions regarding Simics features:</p>
<ul>
<li>Device and memory access count will be too low if accesses are optimized away.</li>
<li>Breakpoints inside a hypersim detected code segment will not trigger every time.</li>
<li>Breakpoints on accesses to memory or devices will not hit every time since many of these accesses can have been optimized away.</li>
</ul>
<p>Hypersimulation using the hypersim-pattern-matcher is activated by default, and can be activated/deactivated with <code>enable-hypersim</code>/<code>disable-hypersim</code>.</p>
<p>The <code>hypersim-status</code> command gives some details on what hypersim features that are currently active.</p>
<p>Hypersim patterns are typically fragile, since they depend on an exact instruction pattern. Simply changing the compiler revision or an optimizing flag to the compiler can break the pattern from being recognized.</p>
<p>The <code>QSP-x86</code> machine does not use hypersim patterns, but with an old PPC-based machine we run the following example:</p>
<pre><code class="language-simics">simics&gt; <strong>disable-hypersim</strong>
simics&gt; <strong>system-perfmeter -realtime -mips</strong>
Using real time sample slice of 1.000000s
simics&gt; <strong>c</strong>
SystemPerf: Total-vt Total-rt Sample-vt Sample-rt Slowdown  CPU Idle  MIPS
SystemPerf: -------- -------- --------- --------- -------- ---- ---- -----
SystemPerf:     0.1s     0.3s     0.09s     0.33s      3.4 100%   0%    29
SystemPerf:     0.7s     1.3s     0.56s     1.00s      1.8  97%   0%    55
SystemPerf:     0.8s     2.3s     0.13s     1.00s      7.6  99%   0%    13
SystemPerf:     2.0s     3.3s     1.22s     1.00s      0.8  95%   0%   122
SystemPerf:     4.2s     4.3s     2.24s     1.00s      0.4  78%   0%   223
SystemPerf:     5.8s     5.3s     1.54s     1.00s      0.6  97%   0%   153
SystemPerf:    11.3s     6.3s     5.46s     1.00s      0.2  99%   0%   543
SystemPerf:    15.9s     7.3s     4.65s     1.00s      0.2  98%   0%   462
SystemPerf:    21.7s     8.3s     5.82s     1.00s      0.2  99%   0%   579
SystemPerf:    27.5s     9.3s     5.82s     1.00s      0.2 100%   0%   579
SystemPerf:    33.3s    10.3s     5.80s     1.00s      0.2  99%   0%   579

simics&gt; <strong>enable-hypersim</strong>
simics&gt; <strong>c</strong>
SystemPerf:    65.6s    11.2s    32.23s     0.88s      0.0  98%  85%  3673
SystemPerf:   491.1s    12.2s   425.52s     1.00s      0.0 100% 100% 42382
SystemPerf:   908.4s    13.2s   417.36s     1.00s      0.0  99% 100% 41550
SystemPerf:  1305.9s    14.2s   397.44s     1.00s      0.0 100% 100% 39745
SystemPerf:  1746.3s    15.2s   440.44s     1.00s      0.0  99% 100% 44039
SystemPerf:  2200.9s    16.2s   454.59s     1.00s      0.0  99% 100% 45457
</code></pre>
<p>This configuration has a Linux idle loop optimizer by default. We disable hypersim and execute the code "normally" during boot. After 6 seconds (host) or 12 seconds (virtual) the boot is finished and the operating system starts executing the idle loop. The idle loop itself is executed quickly in Simics, running at 579 MIPS. When idling, almost 6 virtual seconds is executed for each host second. That is, Simics executes 6 times faster than the hardware (the processor is configured to be running at 100 MHz).</p>
<p>Next, we stop the execution, enable hypersim, and continue the simulation. Now we can see the idle loop optimizer kicking in and 400 virtual seconds is executed each host second, that is about 70 times faster than without hypersim enabled.</p>
<h2 id="simulation-performance.html:vmp"><a href="#simulation-performance.html:vmp">4.1.6 VMP</a></h2>
<p>The VMP add-on for Simics makes use of hardware virtualization support to provide vastly improved performance when simulating x86-based systems. It is an optional part of the x86-based models.</p>
<p>The VMP feature requires that the host machine running Simics has the Intel® Virtualization Technology (Intel® VT) for IA-32, Intel® 64 and Intel® Architecture (Intel® VT-x) enabled in the host machine firmware (the BIOS).</p>
<p>Almost all Intel® processors since the original Core™ architecture, including Xeon® server processors, support the Intel® VT-x feature set. See the Intel® ARK at ark.intel.com for information on specific products.</p>
<p>The Intel® VT-x virtualization feature and the NX execute protection feature must also be enabled in the host machine firmware to run VMP. Look for options under either <em>Security</em> or <em>Virtualization</em> to find where to enable Intel® VT and NX in your firmware. If Intel® Trusted Execution Technology (TXT) is enabled in the firmware, it can also happen that the Intel® VT-x virtualization feature is restricted to trusted applications only; there is usually a special firmware setting controlling this behavior. VMP requires Intel® VT-x to be generally available.</p>
<p>All major features of Simics, including full inspectability of simulated state, and ability to model heterogeneous systems, are fully supported when running with VMP.</p>
<h3 id="simulation-performance.html:installing-the-vmp-kernel-module"><a href="#simulation-performance.html:installing-the-vmp-kernel-module">4.1.6.1 Installing the VMP Kernel Module</a></h3>
<h4 id="simulation-performance.html:linux"><a href="#simulation-performance.html:linux">4.1.6.1.1 Linux</a></h4>
<p>Installing and managing VMP kernel modules requires sudo privileges. Installing will compile the kernel module and therefore also requires an environment to build kernel modules. Which packages you need for building kernel modules depend on the distribution of Linux that you are using, but at least for certain Red Hat based distributions you would need <code>gcc-c++</code>, <code>kernel-headers</code>, and <code>kernel-devel</code>. Change directory to the user project and run:</p>
<pre><code>[project]$ bin/vmp-kernel-install
</code></pre>
<p>The script will build and then load the VMP kernel module. It will not install it permanently however, but it will tell you how to do that.</p>
<p>Disable VMP temporarily by running the <code>bin/vmp-kernel-unload</code> script, and enable VMP with the <code>bin/vmp-kernel-load</code> script. Permanently uninstall VMP from your host by running the <code>bin/vmp-kernel-uninstall</code> script.</p>
<p>If the installation is read-only, or if you for some other reason want to have the built VMP artifacts outside of the installation, you can give a directory to the relevant VMP scripts, for example:</p>
<pre><code>[project]$ bin/vmp-kernel-install /somewhere/directory
</code></pre>
<h4 id="simulation-performance.html:windows"><a href="#simulation-performance.html:windows">4.1.6.1.2 Windows</a></h4>
<p>The kernel module can be loaded and unloaded by running the <code>bin\vmp-kernel-load.bat</code> respective <code>bin\vmp-kernel-unload.bat</code> scripts as administrator. To do that, open a command shell as administrator and run:</p>
<pre><code>[project]&gt; bin\vmp-kernel-load.bat
</code></pre>
<p>Another way to perform the same action would be to right-click on <code>vmp-kernel-load.bat</code> and select run as administrator.</p>
<p>The <code>/AUTO</code> and <code>/DEMAND</code> options select the start option for the VMP service. With <code>/AUTO</code> (default), the service will be available after restart whereas with <code>/DEMAND</code> makes the service available just until shutdown or reboot, and then VMP has to be loaded again when needed.</p>
<p>If the script fails, see the Windows event log for more information. The most common reason is that Intel® VT-x technology or the NX feature is not enabled in the UEFI/BIOS. The kernel module will also fail to load if the Hyper-V feature is enabled.</p>
<h4 id="simulation-performance.html:hyper-v-interaction"><a href="#simulation-performance.html:hyper-v-interaction">4.1.6.1.3 Hyper-V Interaction</a></h4>
<p>Windows 8 and later can be run with Hyper-V enabled. Hyper-V is a feature where the operating system is run as a guest under the control of a hypervisor. VMP cannot be used in conjunction with Hyper-V: loading the VMP kernel module will fail.</p>
<p>There are various ways to disable the Hyper-V feature. Below are instructions for adding an additional boot configuration database entry to make it easy to boot with Hyper-V disabled:</p>
<ul>
<li>
<p>Open cmd prompt as <strong>administrator</strong>. In the admin prompt, run the following command to duplicate the current boot configuration entry:</p>
<pre><code>bcdedit /copy {current} /d "Win 8.1 with Hyper-V disabled"
</code></pre>
<p>This will print the id of the newly created entry, e.g.</p>
<pre><code>The entry was successfully copied to {41f7b750-485b-4f02-9d0e-4c8e3d02c31d}.
</code></pre>
</li>
<li>
<p>Run the following command (replace the id below with the id just printed):</p>
<pre><code>bcdedit /set {41f7b750-485b-4f02-9d0e-4c8e3d02c31d} hypervisorlaunchtype off
</code></pre>
</li>
<li>
<p>Restart the computer with boot option selection (click on Restart while holding down the shift key). Windows will present a blue screen where you can select the newly created boot entry.</p>
</li>
</ul>
<h3 id="simulation-performance.html:running-with-the-vmp-add-on"><a href="#simulation-performance.html:running-with-the-vmp-add-on">4.1.6.2 Running with the VMP Add-on</a></h3>
<p>With the VMP kernel modules installed, VMP will be enabled by default for each processor. You can disable VMP by running the <code>disable-vmp</code> command.</p>
<p>Due to details about how the Intel® VT feature that VMP is based on works, the acceleration may not kick in. Use the system-perfmeter to find out if a processor actually uses the VMP execution mode. To find out why VMP is not used, either raise the log level of the CPU in question or use the <code>info</code> command on the CPU.</p>
<h3 id="simulation-performance.html:current-limitations-of-the-vmp-add-on"><a href="#simulation-performance.html:current-limitations-of-the-vmp-add-on">4.1.6.3 Current Limitations of the VMP Add-on</a></h3>
<p>The VMP packages are currently available and supported for Linux and Windows.</p>
<div class="note">
<p>Due to bugs in the performance counters on many Intel CPU types, precise instruction counting cannot be achieved with VMP. The only CPU types that we are aware of that do not have this bug is Intel® Core™ Duo/Solo, and Pentium® 4 processors. This results in that slight differences in timing between runs will appear and cannot be avoided due to the bug in the underlying hardware.</p>
</div>
<div class="note">
<p>Software using hardware virtualization frequently have problems co-existing on a machine. If you are running other software using hardware virtualization such as VMware, VirtualBox, KVM, or Intel® Hardware Accelerated Execution Manager (Intel® HAXM), you may need to unload the driver corresponding to that software before using VMP.</p>
</div>
<p>Note that virtualizers such as VMware or Xen in most versions do not expose the Intel® VT feature. Even virtualizers that do expose the Intel® VT feature are likely to either lack support for the performance counters needed to run with VMP, or will have very different performance characteristics compared to native solutions. To summarize, it is highly recommended that VMP is run in a non-virtualized environment.</p>
<h3 id="simulation-performance.html:differences-between-vmp-and-non-vmp"><a href="#simulation-performance.html:differences-between-vmp-and-non-vmp">4.1.6.4 Differences Between VMP and non-VMP</a></h3>
<p>VMP is designed to be a transparent performance enhancement. The implementation with Intel® VT-x makes that impossible in some areas, and in some other areas we have taken the chance to utilize the VMP mode to tweak performance further. Enabling features that cannot be emulated using Intel® VT-x will automatically disable VMP.</p>
<p>VMP is optimized for software development, and the default timing parameters used in VMP reflect that. The timing settings can be viewed with the <code>info</code> command on the CPU object. As default, VMP timing will stall the PAUSE instruction, the RDTSC instruction, and each port-mapped I/O access for 10 milliseconds. These stalls are added to allow loops containing these operations to consume more virtual time per iteration and therefore speed up simulation if the loop is terminated after a set virtual time. This is controlled by attributes in the CPU object and can be changed if somewhat more realistic timing is more important than maximum simulation speed.</p>
<p>The hardware performance counters are used to figure out the number of executed instructions when running in VMP mode. Since those counters count string instructions as one regardless of the number of iterations, this is the instruction count model that must be used to enable VMP. This is controlled by the one_step_per_string_instruction attribute, and setting that to classic counting will disable VMP.</p>
<p>The TLB model is bypassed in VMP mode. To simulate a particular configuration of the TLB, or listen to the haps that the TLB model generates, VMP has to be manually disabled.</p>
<h2 id="simulation-performance.html:performance-tweaks"><a href="#simulation-performance.html:performance-tweaks">4.1.7 Performance Tweaks</a></h2>
<p>There are a number of parameters in Simics which can be tweaked which might lead to increased performance.</p>
<ul>
<li><em>Multicore Accelerator</em> can be enabled.</li>
<li>The instruction per cycle (IPC) parameter can be decreased, see command <code>&lt;cpu&gt;.set-step-rate</code>. Similar to reducing the CPU frequency, this will cause virtual time to progress more rapidly with the same amount of instructions executed.</li>
<li>Devices sometimes have a timing model that can be changed by attributes.</li>
<li>When real-time performance is required, the <code>real-time</code> module provides some means to achieve this. See command <code>enable-real-time-mode</code>.</li>
<li>For distributed simulation, multithreading, and Multicore Accelerator, you might want to tweak the default latency or allowed virtual time window. Increasing the latency/time window will diminish the cost of synchronizing the simulation. More information is available in chapter <a class="reference" href="#scaling-simics.html">4.2</a>.</li>
<li>In a similar way, you may want to check the time quantum used to schedule the simulated processors within a Simics process or a simulation cell. Processors unrelated to each other (they do not share memory, for example) do not need to be simulated with a small time quantum.</li>
<li>The frequencies of the processors can be lowered (<code>cpu_freq_mhz</code>). This will cause virtual time to progress more rapidly with the same amount of instructions executed.</li>
<li>If page/swap activities can be monitored on the host running Simics you might want to decrease the memory-limit. See the <code>set-image-memory-limit</code> command. See chapter <a class="reference" href="#managedisks.html:reducing-memory-usage-due-to-images">2.5.2.3</a>.</li>
<li>For large configuration using many cells and/or processors, Simics will create as many execution threads as there are available host processors and schedule the execution on these. However, sometimes it is not beneficial to use the SMT threads on the host but instead reduce the amount of created threads, using only 1 SMT thread per core. In that case, use the <code>set-thread-limit</code> command to limit the thread count to the available number of host cores.</li>
<li>The <code>sim-&gt;max_worker_threads</code> attribute controls the number of threads that can be used for JIT compilation. The default number of JIT threads is automatically set conservatively low, to avoid interfering with the execution threads. This attribute can be adjusted at any time. To disable parallel JIT compilation, the <code>sim-&gt;use_jit_threads</code> attribute can be set to <code>false</code>. Then the execution threads themselves run the compilation.</li>
</ul>
</section><section class="page" id="scaling-simics.html"><h1 id="scaling-simics.html:scaling-simics"><a href="#scaling-simics.html:scaling-simics">4.2 Scaling Simics</a></h1>
<p>This chapter describes performance scaling features provided by Simics. To get the best performance out of Simics you should also read the <a href="#performance.html">Performance</a> chapter for general information about better Simics performance.</p>
<p>This chapter talks about two major features: parallel simulation and page sharing. Parallel simulation allows you to use multithreading to speed up simulation on multiprocessor hosts. Parallel simulation works both at the machine (cell) level, called Simics® <em>Multimachine Accelerator</em> and at the processor level, called <em>Multicore Accelerator</em>. Multicore Accelerator is new in Simics 5. Multimachine Accelerator was known simply as <em>multithreading</em> in earlier Simics versions, but has been renamed to reflect that we have multiple types of multithreading in Simics 5.</p>
<p>You can also split the simulation and run it distributed across more than one host machine.</p>
<p>Page sharing finds identical memory pages and shares them to decrease memory consumption and increase execution performance. This is particularly useful when you have several machines running the same software.</p>
<h2 id="scaling-simics.html:intel-simics-multimachine-accelerator"><a href="#scaling-simics.html:intel-simics-multimachine-accelerator">4.2.1 Intel® Simics® Multimachine Accelerator</a></h2>
<p>The easiest way to parallelize a simulation is to use the Simics® Multimachine Accelerator feature. It requires that the models used in the simulation are marked as <em>thread-safe</em>. The rest of this section describes how to use Multimachine Accelerator.</p>
<p>With Multimachine Accelerator the simulation runs in a single Simics process: you control the entire simulation from a single point, and the entire simulation state gets saved in one checkpoint, just as when you run a single threaded simulation.</p>
<p>To use Multimachine Accelerator the configuration must be partitioned into <em>simulation cells</em>. Each cell contains a subset of the configuration objects in the simulation. The only communication allowed between cells is over <em>links</em>. A link transmits messages between objects with a <em>latency</em> measured in simulated time, for example an Ethernet cable.</p>
<p>Dividing the system into cells can be done automatically via the Simics's component system. This makes it easy to parallelize an existing model.</p>
<h3 id="scaling-simics.html:multithread-ready-models"><a href="#scaling-simics.html:multithread-ready-models">4.2.1.1 Multithread-Ready Models</a></h3>
<p>Most models provided with Simics can run with Multimachine Accelerator enabled and are thus marked <em>thread-safe</em>. Loading modules that are not marked <em>thread-safe</em> will result in a warning message and Multimachine Accelerator will be disabled. Please contact your Simics provider if you are running a model that is not multithread-ready and you want to utilize Multimachine Accelerator.</p>
<p>If you developed your own models of devices, you should refer to the <a href="../model-builder-user-guide/index.html">Model Builder User's Guide</a> to learn how to make them multithread-compatible.</p>
<p>Whenever possible, all default components provided with Simics create <em>simulation cells</em> for use with Multimachine Accelerator. For example, instantiating two <code>MPC8641-Simple</code> boards in the same Simics session will create two <em>cells</em>, which can be scheduled on two simulation threads. The maximum possible parallelism is limited by the number of cells in a session (as well as the number of processor cores on your host, of course). You can list the cells instantiated in a configuration with the following command:</p>
<pre><code class="language-simics">simics&gt; <strong>list-objects -all class = cell</strong>
</code></pre>
<h3 id="scaling-simics.html:enabling-and-disabling-multimachine-accelerator"><a href="#scaling-simics.html:enabling-and-disabling-multimachine-accelerator">4.2.1.2 Enabling and Disabling Multimachine Accelerator</a></h3>
<p>Simics® Multimachine Accelerator is enabled by default. It can be turned off using the command</p>
<pre><code class="language-simics">simics&gt; <strong>disable-multithreading</strong>
</code></pre>
<p>and on again with</p>
<pre><code class="language-simics">simics&gt; <strong>enable-multithreading</strong>
</code></pre>
<p>This command will also check that the configuration looks reasonable before switching on Multimachine Accelerator, and warn you if something is incorrect.</p>
<h3 id="scaling-simics.html:controlling-cell-synchronization"><a href="#scaling-simics.html:controlling-cell-synchronization">4.2.1.3 Controlling Cell Synchronization</a></h3>
<p>To allow multi-cell simulation to perform well, Simics lets each thread run for a certain amount of virtual time on its own before it needs to resynchronize with the other cells. This time span is the synchronization latency. Because of the synchronization latency, Simics does not allow communication between objects of different cells. Even if all accesses were properly locked and performed in a thread-safe way, the objects would have no way to control at what time their access would be done in the other cell, and the simulation would stop being deterministic.</p>
<p>The solution is to communicate via <em>link objects</em>. Link objects ensure that messages send from one cell are delivered at the expected virtual time in the other cell, at the cost of a virtual time delay in the transmission. For links to send messages deterministically, the delay in transmission must be greater or equal to the synchronization latency. For this reason, the synchronization latency is often called the minimum latency for link communication.</p>
<p>The next two sections explain how to control the synchronization latency—and the link latencies—in multi-cell simulations.</p>
<h4 id="scaling-simics.html:the-simple-way"><a href="#scaling-simics.html:the-simple-way">4.2.1.3.1 The Simple Way</a></h4>
<p>By default, Simics creates a single synchronization domain called <code>default_sync_domain</code>. Cells created later in the simulation will be attached to this synchronization domain, unless specified otherwise. Thus the synchronization latency in the simulation will be controlled by the <code>min_latency</code> attribute set in <code>default_sync_domain</code>.</p>
<p>The simplest way to control the synchronization latency is to use the <code>set-min-latency</code> command, which will immediately create a default synchronization domain if it does not exist, and set its <code>min_latency</code> attribute with the given valid latency. An error message will be printed out if the given latency value failed the validity check.</p>
<pre><code class="language-simics">simics&gt; <strong>set-min-latency 0.01</strong>
simics&gt; <strong>list-objects class = sync_domain</strong>
┌───────────────────┬─────────────┐
│      Object       │    Class    │
├───────────────────┼─────────────┤
│default_sync_domain│&lt;sync_domain&gt;│
└───────────────────┴─────────────┘

simics&gt; <strong>default_sync_domain-&gt;min_latency</strong>
0.01
</code></pre>
<p>One important thing to remember is that the time quantum in each multiprocessor cell must be less than half the minimum latency. In other words: sync_latency &gt; 2 × time_quantum for every multiprocessor cell in the system. Simics will print an error if this condition is not respected.</p>
<h4 id="scaling-simics.html:understanding-synchronization-domains"><a href="#scaling-simics.html:understanding-synchronization-domains">4.2.1.3.2 Understanding Synchronization Domains</a></h4>
<p>Synchronization latencies can be controlled in a much finer way. Synchronization domains can be organized in a hierarchy that allows different cells to be synchronized with different latencies. This organization is the foundation of the domain-based distribution system, described in chapter <a class="reference" href="#scaling-simics.html:distributed-simulation">4.2.3</a>.</p>
<p>Let us build a networked system with two-tightly coupled machines communicating on a very fast network, associated with a control server that sends a command from time to time. The two machines require a low communication latency, while the communication latency between them and the server does not matter. Using a hierarchy of two domains allows all latency requirements to be fulfilled without sacrificing performance:</p>
<pre><code>Top-domain (latency 1.0s)
 -&gt; Server cell
 -&gt; Sub-domain (latency 1e-6s)
     -&gt; Machine0 cell
     -&gt; Machine1 cell
</code></pre>
<p>In that configuration, the two machines can communicate with a latency of 1e-6 s while the communication latency between the machines and the server is 1 s. In practice, this allows Simics to give the server a 1 s synchronization window with the two machines, hence much less synchronization overhead and a better usage of parallel simulation.</p>
<p>More concretely, in Simics, the domains are setup in the following way (in Python):</p>
<pre><code class="language-simics">simics&gt; <strong>@top_domain = pre_conf_object("top_domain", "sync_domain")</strong>
simics&gt; <strong>@top_domain.min_latency = 1.0</strong>
simics&gt; <strong>@sub_domain = pre_conf_object("sub_domain", "sync_domain")</strong>
simics&gt; <strong>@sub_domain.min_latency = 1e-6</strong>
simics&gt; <strong>@sub_domain.sync_domain = top_domain</strong>
simics&gt; <strong>@SIM_add_configuration([top_domain, sub_domain], None)</strong>
</code></pre>
<p>Cells created automatically can be assigned to a domain by using the <code>domain</code> attribute of the corresponding top-component. It is also possible to set a cell's <code>sync_domain</code> attribute when creating it manually.</p>
<h4 id="scaling-simics.html:setting-latencies-the-complete-rules"><a href="#scaling-simics.html:setting-latencies-the-complete-rules">4.2.1.3.3 Setting Latencies: the Complete Rules</a></h4>
<p>Latencies must obey certain rules for the domain hierarchy to work properly:</p>
<ul>
<li>The time quantum of a multiprocessor cell must be less than half the latency of the domain that contains the cell. The reason for this restriction is that the synchronization system considers a cell as a single unit and does not cope with the fact that the processors inside the cell are scheduled in a round-robin fashion. Simics checks this requirement and prints an error message if a domain latency is incompatible with a cell time quantum.</li>
<li>The latency of a child domain must be less than half the latency of its parent domain. This restriction is once again related to how synchronization events are scheduled. Simics checks for this requirement and adjusts the latency of the child domain automatically while printing a warning.</li>
<li>The latency of a domain must be greater than the length of two cycles of the slowest processor it contains. Simics uses cycles as lowest time unit for posting events, so synchronization can not be ensured if the latency resolution is too small. Simics checks this requirement and prints an error message if a domain latency is incompatible with one of the processor.</li>
<li>A link may not have a latency smaller than the one of the lowest domain in the hierarchy that contains the cells the link is connected in. In other words: the link must obey the highest latency between the systems it is connected to. Simics checks this requirement and adjust the link latency automatically upward if necessary while printing a warning.</li>
<li>Once set, latencies may not be changed. This is a limitation in Simics that we hope to remove in future versions.</li>
</ul>
<h3 id="scaling-simics.html:multimachine-accelerator-and-scripting"><a href="#scaling-simics.html:multimachine-accelerator-and-scripting">4.2.1.4 Multimachine Accelerator and Scripting</a></h3>
<p>Commands and script branches are never run multithreaded, thus parallelism can be safely ignored most of the time when scripting Simics. However, using Simics® Multimachine Accelerator has side-effects that may cause scripts to behave in a correct but indeterministic way. If we consider the following script, in a configuration consisting of two cells, <code>cell0</code> and <code>cell1</code>:</p>
<pre><code class="language-simics">simics&gt; <strong>cell0_console.break "foo"</strong>
simics&gt; <strong>c</strong>
simics&gt; <strong>cell1_console.input "bar"</strong>
</code></pre>
<p>Even with <code>cell0</code> and <code>cell1</code> running in parallel, the simulation will stop properly when the text breakpoint in <code>cell0</code> is triggered. However, <code>cell1</code> is not at a deterministic point in time: the only thing known about it is that it is within a certain window of virtual time in which it is allowed to drift without needing to re-synchronize with <code>cell0</code>, as explained in the previous section. So running this script twice in a row may not produce exactly the same results.</p>
<p>In many cases, it does not matter and the scripts will work fine. If perfect determinism is required, it is possible to save a checkpoint and run the sensitive part of the simulation single-threaded.</p>
<p>One aspect of Multimachine Accelerator that affects scripting directly is Python scripting. Hap handlers are run in the thread where they are triggered, which means that the same handler can run in parallel on different host processors. If the handler uses global state, it must use proper locks to access it. In general, this is not a problem since most haps are triggered for a specific object, so their handlers will only run in the thread where this object is scheduled. Some haps are triggered globally, however, and care must be taken when responding to them.</p>
<p>Python scripts are run with the global Python lock taken, so Python scripts never <em>really</em> run in parallel. However, the Python interpreter will schedule Python threads as it sees fit, so Python code that may run in several threads (device or extension code, hap handlers) should not assume that it has full control of the execution. The Python lock is also released every time a Simics API functions is called (including implicit calls like reading an attribute value).</p>
<p>When running Python scripts in a simulation thread, the script should not access state that is in a different cell, since this cell might be running on another host processor. When in need to access the whole simulation state, a callback function can be scheduled with <code>SIM_run_alone()</code> (this is currently how script branches and commands are handled).</p>
<p>Finally, running commands in the simulation thread is <em>not</em> allowed, as the CLI parser is not thread-safe and might cause unexpected problems. Commands must be scheduled with <code>SIM_run_alone()</code>. It is also possible to rewrite scripts to access directly objects and attributes instead of using the commands directly.</p>
<h3 id="scaling-simics.html:dynamic-load-balancing"><a href="#scaling-simics.html:dynamic-load-balancing">4.2.1.5 Dynamic Load Balancing</a></h3>
<p>Simics uses dynamic load balancing to distribute the simulation workload across the available hardware resources (host threads). The dynamic load balancer optimizes the mapping of simulation threads onto available host resources.</p>
<p>When Simics is running with Simics® Multimachine Accelerator, CPUs belonging to the same cell can not be simulated concurrently by separate host threads. The available concurrency in this mode of operation is between CPUs belonging to different cells. Using as many cells as possible can potentially improve performance since this increases the parallelism of the simulation. Having many cells also makes it easier for the dynamic load balancer to keep all host threads fully loaded.</p>
<p>When Simics is running with Multicore Accelerator, CPUs belonging to the same cell can be simulated concurrently. Note that Multimachine Accelerator is implied by Multicore Accelerator.</p>
<p>Simics uses a non hierarchical scheduling algorithm based on simulated time and available work. By default, Simics spawns at most as many threads as there are host threads, but it is possible to limit this number using the <code>set-thread-limit</code> command. Setting a thread limit may be useful if the physical machine is shared by multiple users.</p>
<p>Simics does not interact with the host operating system with regards to scheduling. The details of the scheduling are internal and there exists no API for controlling it.</p>
<h2 id="scaling-simics.html:multicore-accelerator"><a href="#scaling-simics.html:multicore-accelerator">4.2.2 Multicore Accelerator</a></h2>
<p>With <em>Multicore Accelerator</em>, multiple host threads can be used to simulate multiple processors and clocks within each cell concurrently. This requires that all the processors and clocks supports this execution model. Multicore Accelerator is compatible with Multimachine Accelerator meaning that both can be enabled at the same time, utilizing the dynamic load balancing (see <a class="reference" href="#scaling-simics.html:dynamic-load-balancing">4.2.1.5</a>).</p>
<p>When developing models to be used in the Multicore Accelerator execution mode there are a couple of considerations to take into account. See the section <a href="../reference-manual-api/rmapi-threading-model.html">Threading Model</a> in <a href="../reference-manual-api/index.html">API Reference Manual</a> for more information.</p>
<h3 id="scaling-simics.html:enabling-and-disabling-multicore-accelerator"><a href="#scaling-simics.html:enabling-and-disabling-multicore-accelerator">4.2.2.1 Enabling and Disabling Multicore Accelerator</a></h3>
<p>Unlike Simics® Multimachine Accelerator, Multicore Accelerator is disabled by default. The reason for Multicore Accelerator being disabled is that it changes the timing model of simulation, notably no longer supporting deterministic simulation. In the Multicore Accelerator mode the modeled CPUs are run concurrently by host threads, which means that the interleaving of memory accesses to a shared memory is not guaranteed to occur in the same order between simulation sessions. This implementation was chosen to be able to leverage maximum simulation performance.</p>
<p>Multicore Accelerator is enabled with</p>
<pre><code class="language-simics">simics&gt; <strong>enable-multicore-accelerator</strong>
</code></pre>
<p>and can be disabled with</p>
<pre><code class="language-simics">simics&gt; <strong>disable-multicore-accelerator</strong>
</code></pre>
<p>The optional argument <em>max-time-span</em> to <code>enable-multicore-accelerator</code> controls how far the time is allowed to drift apart between CPUs/clocks in each cell where Multicore Accelerator is enabled (cf. <em>min latency</em> for cells, <a class="reference" href="#scaling-simics.html:controlling-cell-synchronization">4.2.1.3</a>). For more information, consult the documentation for the <code>enable-multicore-accelerator</code> command.</p>
<h3 id="scaling-simics.html:when-is-multicore-accelerator-beneficial"><a href="#scaling-simics.html:when-is-multicore-accelerator-beneficial">4.2.2.2 When is Multicore Accelerator beneficial</a></h3>
<p>Multicore Accelerator works best for parallel compute intensive applications with little interaction between the CPUs. On the other hand, a system with a large amount of I/O operations will not be a good candidate. Such workloads, for example Operating System boot, can perform worse when Multicore Accelerator is enabled.</p>
<p>Remember that although there are parallel workloads occupying all CPUs in the system, the amount of actual parallelism that Multicore Accelerator can extract may be much lower. This is mainly because of serial sections, communication, synchronization, and poor load balancing in the target system.</p>
<p>For more information about performance of Multicore Accelerator and how to measure how much parallelism there is in the modeled system, see the <a href="#performance.html">Performance</a> chapter.</p>
<h2 id="scaling-simics.html:distributed-simulation"><a href="#scaling-simics.html:distributed-simulation">4.2.3 Distributed Simulation</a></h2>
<p>Distributed simulation is used for connecting multiple Simics processes, possibly running on different host machines, to run synchronously and exchange data in a reliable and deterministic way.</p>
<h3 id="scaling-simics.html:configuration"><a href="#scaling-simics.html:configuration">4.2.3.1 Configuration</a></h3>
<p>The Simics processes taking part in the combined simulation, here called <em>nodes</em>, are configured and managed individually. Each node will set up and run its own configuration and have its own name space. It will be controlled by its own command line or graphical interface.</p>
<p>Nodes are strung together by letting the local top-level synchronization domain in one node have a domain in another node as parent. Typically, there will be one global top-level domain in one node controlling the domains in all other nodes:</p>
<pre><code>       D0                         global top-level domain
        |
        +---------+---------+
        |         |         |
       D1        D2        D3     local domains
        |         |         |
        +-+-+     +-+-+     +-+-+
        |   |     |   |     |   |
        C11 C12   C21 C22   C31 C32  cells
        |--------|---------|--------|
        node 1    node 2   node 3
</code></pre>
<p>In the above diagram, <code>D0</code>-<code>D3</code> are synchronization domains and <code>C11</code>-<code>C32</code> cells. <code>D1</code>, <code>C11</code> and <code>C12</code> are all in node 1, and so on. The top-level domain <code>D0</code> could be placed either in a node of its own, without any cells, or in one of the other nodes. We will here assume it is located in node 1, the <em>server node</em>; the other nodes are then <em>clients</em>.</p>
<p>Domains in different nodes connect by proxies, which themselves connect over the network. The relation between D0 and D3 above is set up like follows:</p>
<pre><code>           /     D0           sync_domain
   node 1 |      |
           \     D3_proxy     remote_sync_node
                 :
              (network connection)
                 :
           /     D0_proxy     remote_sync_domain
   node 3 |      |
           \     D3           sync_domain
</code></pre>
<p>The <code>remote_sync_domain</code> in the client node, <code>D0_proxy</code>, is created explicitly in the configuration for that node. The <code>remote_sync_node</code> in the server node is created automatically by a special server object when <code>D0_proxy</code> connects to the server node.</p>
<p>When a node has finished its configuration, it must inform the server to allow other clients to connect. This is done by setting to <code>None</code> the <code>finished</code> attribute of the <code>remote_sync_domain</code> object, or the <code>remote_sync_server</code> in the server. As a result, node configuration is done in sequence.</p>
<p>The default domain used by cells is <code>default_sync_domain</code>, so by using this as the local domain name, existing non-distributed configurations can be re-used. It is also a good idea to use the same name for the <code>remote_sync_domain</code> as for the actual top-level domain it is a proxy for. That way, it will matter less in what node the top-level domain is placed.</p>
<p>The configuration script for a single node could look like the following Python fragment:</p>
<pre><code>srv_host = "serverhost"  # machine the server node runs on
srv_port = 4567          # TCP port the server listens on

# Start by creating the global and/or local domain objects:

if this_is_the_server_node:
    topdom = SIM_create_object("sync_domain", "top_domain",
                               [["min_latency", 0.04]])
    rss = SIM_create_object("remote_sync_server", "rss",
                            [["domain", topdom], ["port", srv_port]])
else:
    # Client nodes: create a proxy for the top-level domain.
    # This will initiate a connection to the server.
    topdom = SIM_create_object("remote_sync_domain", "top_domain",
                               [["server",
                                 "%s:%d" % (srv_host, srv_port)]])
# create a local domain to be a parent for the cells in this node
SIM_create_object("sync_domain", "default_sync_domain",
                  [["sync_domain", topdom], ["min_latency", 0.01]])

# --- Here the rest of the node should be configured. ---

if this_is_the_server_node:
    rss.finished = None     # let clients connect to the server
else:
    topdom.finished = None  # let other clients connect to the server
</code></pre>
<p>At the end of this script, the configuration is finished for that node. Note that other nodes may not have finished theirs yet—the simulation cannot start until the entire system has been set up. The user can just wait for this to happen, or write a mechanism to block until the system is ready; see the section about global messages below.</p>
<h3 id="scaling-simics.html:links"><a href="#scaling-simics.html:links">4.2.3.2 Links</a></h3>
<p>Links work across nodes in the same way as in a single process simulation. Using the same global ID for links in two different nodes ensures that they are considered as the same link in the distributed simulation. The global ID for a link is set using the <code>global_id</code> attribute when the link is created.</p>
<p>There is one important aspect of link distribution that should be taken into account when creating distributed configuration.</p>
<p>When creating single-session configuration, Simics provides only one object namespace, which means that all objects have a unique name in that session. This property is used to keep link message delivery deterministic when no other way of comparing the messages is available. To be more precise, messages arriving from different senders to the same receiver at the same cycle are sorted according to the pair (sender name, sender port).</p>
<p>In distributed sessions however, Simics does not impose a single object namespace. This allows several objects with the same name to be connected to the same distributed link. As a consequence, the delivery of messages as described in the previous paragraph may become indeterministic again, since different sender may report the same (sender name, sender port) pair. Distributed links report an error if such a configuration is found.</p>
<p>The solution is to name differently the various boards or machines that compose the complete distribution configuration.</p>
<div class="note">
<p>Deleting a distributed link is not supported.</p>
</div>
<h3 id="scaling-simics.html:global-messages"><a href="#scaling-simics.html:global-messages">4.2.3.3 Global Messages</a></h3>
<p>There is a supporting mechanism for sending simple messages to all nodes in the combined system: <code>SIM_trigger_global_message(msg)</code> will trigger the global notifier <code>Sim_Global_Notify_Message</code>, whose callbacks can use <code>SIM_get_global_message</code> to obtain the message. A notifier listener could look like:</p>
<pre><code>def global_message_callback(_, ref):
    print("got message {0}".format(SIM_get_global_message(ref)))
SIM_add_global_notifier(Sim_Global_Notify_Message, None,
                        global_message_callback, my_ref)
</code></pre>
<p>Global messages will arrive and be processed during a call to <code>SIM_process_work()</code>. This is useful for blocking further execution of a script until a certain message has arrived.</p>
<p>Global messages can be used to assist in configuration and running a distributed system. Possible uses include:</p>
<ul>
<li>waiting for all nodes to finish their configuration</li>
<li>starting and stopping the simulation on all nodes as the same time</li>
<li>broadcasting commands to all nodes</li>
<li>sending data to a single requesting node</li>
<li>saving the configuration of all nodes</li>
</ul>
<p>This facility is <em>not intended for simulation use</em>; message delivery is reliable but not deterministic in timing. It should be regarded as a low-level mechanism to be used as a building block for higher-level communication.</p>
<h3 id="scaling-simics.html:running-the-simulation"><a href="#scaling-simics.html:running-the-simulation">4.2.3.4 Running the simulation</a></h3>
<p>Each node will have to start the simulation for the combined system to make progress. If one node stops the simulation—by user intervention or because of a coded breakpoint—the remaining nodes will be unable to continue, because the top-level synchronization domain keeps cells in different nodes from diverging.</p>
<p>Each node can only access the objects it has defined locally. This means that inspection and interaction with the system must be done separately for each node. A combined front-end interface is not available for Simics at this time.</p>
<p>When one Simics process terminates, the other nodes will automatically exit as well.</p>
<h3 id="scaling-simics.html:saving-and-restoring-checkpoints"><a href="#scaling-simics.html:saving-and-restoring-checkpoints">4.2.3.5 Saving and restoring checkpoints</a></h3>
<p>The state of a distributed simulation can be saved by issuing <code>write-configuration</code> in each node separately. To restore such a checkpoint, start an equal number of (empty) Simics processes and read the saved configuration for each node.</p>
<p>Note that the server host name and port number are saved in the configuration files. These have to be edited if the checkpoint is restored with a different server host, or if the port number needs to be changed. Similarly, if SimicsFS is mounted to a file system, it will be saved in the checkpoint. Not all connections to real network or file systems can be restored at a later time.</p>
<p>Note as well that the configurations must be read in sequence again, using the <code>finished</code> attribute to control which session is allowed to connect. However, the order of read-configuration sequence does not matter, as long as the server is started first.</p>
<h3 id="scaling-simics.html:security"><a href="#scaling-simics.html:security">4.2.3.6 Security</a></h3>
<p>The distributed simulation facility has no authentication mechanism and is not security-hardened. It should therefore only be used in a trusted network environment.</p>
<h2 id="scaling-simics.html:page-sharing"><a href="#scaling-simics.html:page-sharing">4.2.4 Page-Sharing</a></h2>
<p>When running multiple instances of the same target system, in a virtual network or similar, it is likely that many of the RAM, ROM, flash, or disk pages in each system are identical to the others. Simics Accelerator adds a new <em>page-sharing</em> feature which takes advantage of this fact to reduce host memory consumption and increase execution performance.</p>
<p>When the page-sharing feature is activated, at certain trigger points Simics will examine the contents of a page, comparing it with other pages examined earlier. If an identical match is found, the page is removed and instead set to share data with the other page(s).</p>
<p>When many pages are shared the host memory that Simics uses will be reduced and consequently it will take longer until the memory-limit is reached. If the frequency of reaching Simics memory-limit is a factor limiting performance, execution performance will also increase. Simics can also take advantage of the fact that the page is shared by sharing the generated JIT code corresponding to a shared page. This can lead to improved performance since the JIT code only needs to be created once, but also thanks to better instruction caching when many target processors use the same JIT code.</p>
<p>Shared pages are always read-only, if a shared page is written to, it will automatically be un-shared and the writer will be given a private copy of the page. Consequently, page-sharing works best for pages containing only instructions or data pages which are never or rarely modified.</p>
<p>To activate page-sharing, use the command <code>enable-page-sharing</code>. This command also has a <em>-now</em> command argument which causes all pages to be analyzed and possibly shared directly.</p>
<p>To monitor how much memory that is saved due to the page-sharing feature, the <code>system-perfmeter</code> has a <em>-shared</em> switch which shows how much memory in total that has been saved, in each measurement sample (see the <a href="#performance.html">Performance</a> chapter).</p>
<p>Use <code>disable-page-sharing</code> to deactivate the page-sharing feature. This will not cause already shared pages to be un-shared but no more pages will be shared.</p>
</section><section class="page" id="appendix.html"><h1 id="appendix.html:appendix"><a href="#appendix.html:appendix">5 Appendix</a></h1>
</section><section class="page" id="script-decls.html"><h1 id="script-decls.html:old-script-parameters"><a href="#script-decls.html:old-script-parameters">5.1 Old Script Parameters</a></h1>
<p>This describes the old script parameter system, which is deprecated. See section <a class="reference" href="#script-support-in-simics.html:targets-and-parameters">2.3.3</a> for the target parameter framework.</p>
<p>A Simics target script may declare its parameters and resulting values.</p>
<h2 id="script-decls.html:declarations-and-parameters"><a href="#script-decls.html:declarations-and-parameters">5.1.1 Declarations and Parameters</a></h2>
<p>Script declaration blocks are optional, and have the form</p>
<pre><code>  decl {
    declarations
  }
</code></pre>
<p>Such a block must come before any commands in the script file. Possible declarations are:</p>
<ul>
<li>Parameters</li>
<li>Results</li>
<li>Script documentation</li>
<li>Imported parameters</li>
<li>Parameter groups</li>
</ul>
<p>Whitespace (spaces, tabs, line breaks) are in general not significant unless specifically noted. Comments are allowed, starting with '#' and running to the end of the line.</p>
<p>A parameter declaration takes the form</p>
<pre><code>  param NAME : TYPE [= DEFAULT-VALUE]
</code></pre>
<p>where the default value is optional. Example:</p>
<pre><code>  param ram_size : int = 8
</code></pre>
<p>This means that the variable <code>$ram_size</code> will be set when the script is executed, that it must be an integer, and that it will be 8 if not specified in any other way.</p>
<p>If there is no default value, then the parameter must be specified; otherwise, it is optional.</p>
<p>A script with a declaration block will only see the variables that have been declared as parameters. Other variables are hidden during the script's execution and will re-appear when the script terminates.</p>
<h2 id="script-decls.html:results"><a href="#script-decls.html:results">5.1.2 Results</a></h2>
<p>A script can return variables that it has set by declaring <em>results</em>:</p>
<pre><code>  result NAME : TYPE
</code></pre>
<p>Example:</p>
<pre><code>  result mac_address : string
</code></pre>
<p>It means that the script must set <code>$mac_address</code> before terminating, that it must be a string value, and that this variable is available to the caller. All other variables assigned to by the script are lost.</p>
<p>The same name can be used for both a parameter and a result.</p>
<h2 id="script-decls.html:running-scripts"><a href="#script-decls.html:running-scripts">5.1.3 Running Scripts</a></h2>
<p>Parameters are given on the command line when running Simics:</p>
<pre><code>$ ./simics myscript.simics ram_size=64
</code></pre>
<p>or as arguments to the <code>run-script</code> command:</p>
<pre><code class="language-simics">simics&gt; <strong>run-script myscript.simics ram_size = 64</strong>
</code></pre>
<p>or by setting the CLI variables before invoking the script:</p>
<pre><code class="language-simics">simics&gt; <strong>$ram_size = 64</strong>
simics&gt; <strong>run-script myscript.simics</strong>
</code></pre>
<p>The <code>-help</code> command-line option will show all parameters of a script:</p>
<pre><code>$ ./simics myscript.simics -help
</code></pre>
<p>From the Simics command line, the arguments for a file can be listed by using the <code>help</code> command:</p>
<pre><code class="language-simics">simics&gt; <strong>help myscript.simics</strong>
The original IBM PC XT from 1983, complete with
a full-height 10 MB fixed disk and a 5 1/4' floppy drive.

networking:
  mac_addr  -  string or NIL
...
</code></pre>
<p>It is also possible to use tab completion with the <code>run-script</code> command:</p>
<pre><code class="language-simics">simics&gt; <strong>run-script myscript.simics&lt;tab&gt;</strong>
  -local  -main-branch  ram_size =  cpu_freq =
</code></pre>
<h2 id="script-decls.html:types"><a href="#script-decls.html:types">5.1.4 Types</a></h2>
<p>The following type specifications are allowed in the declarations of parameters and results. Each item in the list below describes the values permitted by the type.</p>
<div class="dl">
<ul>
<li>
<p><span class="term" id="script-decls.html:dt:int"><a href="#script-decls.html:dt:int">int</a></span><br>
An integer. Integers can be written in decimal, hex (<code>0x1e3</code>) or binary (<code>0b1011</code>).</p>
</li>
<li>
<p><span class="term" id="script-decls.html:dt:float"><a href="#script-decls.html:dt:float">float</a></span><br>
A floating-point number or integer.</p>
</li>
<li>
<p><span class="term" id="script-decls.html:dt:string"><a href="#script-decls.html:dt:string">string</a></span><br>
Any string, like "Miss Piggy". Quotes can be omitted for word-like strings, like <code>x86_64</code>.</p>
</li>
<li>
<p><span class="term" id="script-decls.html:dt:bool"><a href="#script-decls.html:dt:bool">bool</a></span><br>
Either <code>TRUE</code> or <code>FALSE</code>.</p>
</li>
<li>
<p><span class="term" id="script-decls.html:dt:file-pattern"><a href="#script-decls.html:dt:file-pattern">file(PATTERN)</a></span><br>
A string that names an existing file. PATTERN is a (double-quoted) string with a pattern that suggests what file names are acceptable, such as <code>"*.exe"</code>. The pattern is just a hint for the user interface; any existing file will be accepted. Use <code>file("*")</code> to indicate no particular file name preference.</p>
<p>File names may start with <code>%simics%</code> to force a look-up relative the current project and Simics package path, or with <code>%script%</code> representing the script directory itself. (<code>%script%</code> is only allowed in default values.)</p>
</li>
<li>
<p><span class="term" id="script-decls.html:dt:value1-value2"><a href="#script-decls.html:dt:value1-value2">{VALUE1, VALUE2, ...}</a></span><br>
One of the enumerated values (which each can be of any type).</p>
<p>Example: <code>{1, "apple pie", 8.25}</code></p>
</li>
<li>
<p><span class="term" id="script-decls.html:dt:type-or-nil"><a href="#script-decls.html:dt:type-or-nil">TYPE or nil</a></span><br>
A value that matches TYPE or is the value NIL.</p>
<p>Example: <code>string or nil</code> will match <code>"abc"</code> or NIL, but not <code>1.3</code>.</p>
</li>
</ul>
</div>
<p>Complex or compound data types can often be packed into a string and unpacked and verified by the receiver in Simics. See documentation of the <code>split-string</code> command.</p>
<h2 id="script-decls.html:documentation"><a href="#script-decls.html:documentation">5.1.5 Documentation</a></h2>
<p>Parameters can have documentation strings that are shown in the command-line. These consist of one or more lines that begin with an exclamation mark, immediately following the parameter. Example:</p>
<pre><code>  param ram_size : int
  ! RAM size in megabytes.
  ! Note that Windows 95 needs at least 2 MiB to run.
</code></pre>
<p>The script itself can also be described in the same way, by putting a documentation string first in a declaration block:</p>
<pre><code>  decl {
    ! Atari 2600 Video Game Console System
    param cartridge : string = "COMBAT"
  }
</code></pre>
<p>Documentation strings are written in a subset of the Simics JDocu mark-up language, which is XML-based. Most plain text can be written directly, but the symbols '&lt;' and '&amp;' must be written '<code>&amp;lt;</code>' and '<code>&amp;amp;</code>', respectively. Use blank lines to break paragraphs.</p>
<p>The following typographic elements exist:</p>
<div class="dl">
<ul>
<li><span class="term" id="script-decls.html:dt:tt-text-tt"><a href="#script-decls.html:dt:tt-text-tt"><code>&lt;tt&gt;TEXT&lt;/tt&gt;</code></a></span><br>
set TEXT in a fixed-width font.</li>
<li><span class="term" id="script-decls.html:dt:em-text-em"><a href="#script-decls.html:dt:em-text-em"><code>&lt;em&gt;TEXT&lt;/em&gt;</code></a></span><br>
set TEXT for emphasis (italic).</li>
<li><span class="term" id="script-decls.html:dt:param-text-param"><a href="#script-decls.html:dt:param-text-param"><code>&lt;param&gt;TEXT&lt;/param&gt;</code></a></span><br>
set TEXT as the name of a parameter.</li>
</ul>
</div>
<h2 id="script-decls.html:parameters-from-other-scripts"><a href="#script-decls.html:parameters-from-other-scripts">5.1.6 Parameters from Other Scripts</a></h2>
<p>Parameter declarations can be taken (imported) from other script files by using the declaration</p>
<pre><code>  params from SCRIPT [except NAMES] [default NAME = VALUE ...]
</code></pre>
<p>All parameter (but not result) declarations from the given script will be used as if they had been declared in the importing script.</p>
<p>The optional <code>except</code> clause will exclude one or more comma-separated parameters.</p>
<p>Example: if the script a.simics contains:</p>
<pre><code>  decl {
    params from "b.simics" except y
    param x : int
    result r : string
  }
</code></pre>
<p>and b.simics contains:</p>
<pre><code>  decl {
    param y : int = 10
    param z : bool = TRUE
    result s : string
  }
</code></pre>
<p>then a.simics will behave as if it had been written:</p>
<pre><code>  decl {
    param z : bool = TRUE
    param x : int
    result r : string
  }
</code></pre>
<p>The default value of imported parameters can be overridden by adding <code>default</code> clauses. Example:</p>
<pre><code>  params from "hardware-setup.simics"
    default ram_size = 256
    default cpu_freq = 3.58e6
</code></pre>
<p>There is also a <code>substitute</code> declaration that is reserved for Simics internal use.</p>
<h2 id="script-decls.html:parameter-groups"><a href="#script-decls.html:parameter-groups">5.1.7 Parameter Groups</a></h2>
<p>Parameters can be arranged into groups, to make them easier to browse when they are numerous. The declaration</p>
<pre><code>  group "Networking"
</code></pre>
<p>will put all parameters that follow (in that file) into the group named "Networking". Groups do not affect how parameters actually work; they only serve to make the presentation better.</p>
<h2 id="script-decls.html:script-execution"><a href="#script-decls.html:script-execution">5.1.8 Script Execution</a></h2>
<p>When a script with a declaration block is run, interactively or from another script, this is what happens in detail:</p>
<ol>
<li>
<p>The script declaration is read and checked for errors. Imported parameters ("<code>params from</code>") are resolved recursively.</p>
</li>
<li>
<p>Actual parameter values are taken from, in order:</p>
<ol>
<li>The supplied arguments, if the script was started from a shell command, or from <code>run-script</code>.</li>
<li>CLI variables.</li>
<li>Default values from the script declaration.</li>
</ol>
<p>An error is signalled if a parameter value is missing or has the wrong type.</p>
</li>
<li>
<p>The current CLI variables, if any, are saved away and replaced with the script parameters having their initial values as described above.</p>
</li>
<li>
<p>The command part of the script (below the declaration) is executed. If the script runs another script, this entire algorithm is used again.</p>
</li>
<li>
<p>CLI variables corresponding to declared result names are retrieved. An error is signalled for missing results or ones with the wrong type.</p>
</li>
<li>
<p>The saved CLI variables are restored, throwing away all current variables except for the declared results, which retain their values from the executed script.</p>
</li>
</ol>
<h2 id="script-decls.html:example"><a href="#script-decls.html:example">5.1.9 Example</a></h2>
<p>Here is a slightly longer example of a script declaration block.</p>
<pre><code># A machine from the good old days (?)
decl {
  ! The original IBM PC XT from 1983, complete with
  ! a &lt;em&gt;full-height&lt;/em&gt; 10 MB fixed disk and a 5 1/4" floppy drive.

  # Note that comments (like this one) are distinct from doc strings.

  param ram_size : int = 256
  ! RAM size in KiB. Max is 640, which should be enough for anyone.

  param cpu_freq : float = 4.77
  ! CPU frequency in MHz.

  param video : {mda, cga, hercules} = cga
  ! Type of video card. mda &amp;amp; hercules look best.

  group "networking"
  param mac_addr : string or nil = NIL
  ! Ethernet MAC address, or NIL if no Ethernet adapter present.

  param rom_file : file("*.bin") = "%script%/pc_xt_rom.bin"
  ! File containing the ROM image. Must be exactly 40 KiB.

  param rtc_time : string = "2015-02-01 13:37:00"
  ! Initial time and date of the real-time clock, on the form
  ! &lt;tt&gt;"YYYY-MM-DD HH:MM:SS"&lt;/tt&gt;.

  # Include parameters declared in another file.
  params from "ms-dos.simics"

  # Override the default value of a parameter from that file
  default dos_ver = "2.11"

  result system : string
  ! Name of generated system component object.
}

# Here the actual script starts with commands to execute.
</code></pre>
</section>