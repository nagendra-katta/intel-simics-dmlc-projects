<!doctype html>
<meta charset=utf8>
<link rel=stylesheet href="../simics.css">
<title>Analyzer User's Guide</title>

<section class="page" id="index.html"><h1 id="index.html:analyzer-user-s-guide"><a href="#index.html:analyzer-user-s-guide">Analyzer User's Guide</a></h1>
</section><section class="page" id="analyzer-introduction.html"><h1 id="analyzer-introduction.html:introduction"><a href="#analyzer-introduction.html:introduction">1 Introduction</a></h1>
<p>Simics Analyzer provides features for completely non-intrusive analysis and debugging of software applications within Simics. It makes it possible to see what software processes are running, and to inspect, analyze and debug them individually. It includes tools for code coverage analysis and other profiling. This document describes how these features work, and shows how to use them.</p>
<p>Many of the features described in this documentation build on other features in Simics, and it is recommended that you read the <em>Simics User's Guide</em> to familiarize yourself with the Simics debugging tools.</p>
<p>Simics Analyzer includes a source code debugger for C and C++, that you can use from the Simics command line. You can read more about it in chapter <a class="reference" href="#debugging-target-code.html">3</a>.</p>
</section><section class="page" id="target-software-tracking.html"><h1 id="target-software-tracking.html:os-awareness"><a href="#target-software-tracking.html:os-awareness">2 OS Awareness</a></h1>
<p>The OS Awareness (OSA) feature provides commands (section <a class="reference" href="#osa-commands.html">2.3</a>) and interfaces (section <a class="reference" href="#software-tracker-scripting.html">2.5</a>) to assist in debugging or analyzing target software. Other Simics features, such as the Simics debugger, also make use of the OSA feature.</p>
<p>To be able to debug, analyze, or otherwise track tasks, processes, etc on the target software Simics employs specialized <em>tracker</em> modules. These trackers examine the state of the target system to determine when and where each task is running. This is usually achieved by monitoring changes to memory, registers or processor state. No modification or instrumentation of the target software is required.</p>
<p>This documentation covers the OS Awareness framework and trackers that are provided in the Simics base package. For other trackers, see their respective documentation. The <em>Simics Model Builder</em> product makes it possible to create custom trackers.</p>
<p>To be able to use the features described in this chapter, the configuration script for the target system needs to support the OS awareness functionality. For this to work the target script has to be set up with a <code>software</code> object and a <code>tracker</code> composition object for the specific operating system. Most provided target scripts will set up the software object directly under the main system top object, such as <code>board.software</code>. See section <a class="reference" href="#os-awareness-scripts.html">2.9</a> for details about adding OS Awareness to scripts.</p>
<p>To see which tracker is used, you can use the <code>info</code> command on the software slot:</p>
<pre><code class="language-simics">simics&gt; <strong>board.software.info</strong>
Information about board.software [class os_awareness]
=====================================================

Software:
          Tracker : board.software.tracker
    Tracker class : linux_tracker_comp
             CPUs : board.mb.cpu0.core[0][0]
</code></pre>
<p>In the example above, the software tracker is configured with the tracker composition of type <code>linux_tracker_comp</code> at the slot <code>board.software.tracker</code>. If there is no tracker object configured then <code>none</code> is shown both as class and object.</p>
<p>The <code>software</code> object provides commands for inspecting and monitoring the target software, an overview of available commands can be found in section <a class="reference" href="#osa-commands.html">2.3</a>.</p>
</section><section class="page" id="tracker-activation.html"><h1 id="tracker-activation.html:tracker-activation"><a href="#tracker-activation.html:tracker-activation">2.1 Tracker Activation</a></h1>
<p>Tracking software does not come for free. For this reason, the OSA framework is disabled by default and has to be enabled to make it track anything or get any information out of it.</p>
<p>There are different ways to enable and disable the OSA framework. First, it can be done via the command line using the <code>enable-tracker</code> command. To disable the tracker again use the <code>disable-tracker</code> command.</p>
<pre><code class="language-simics">simics&gt; <strong>board.software.enable-tracker</strong>
simics&gt; <strong>board.software.disable-tracker</strong>
</code></pre>
<p>Secondly, it can be enabled (disabled) using the <code>request</code> (<code>release</code>) function in the <code>osa_control_v2</code> interface. The <code>request</code> function generates a new OSA framework handle and the <code>release</code> function releases the corresponding handle. The OSA framework is enabled when there exist at least one active OSA framework handle and is disabled when there are no active OSA framework handles. The <code>enable-tracker</code> command uses the <code>osa_control_v2</code> interface internally to enable and disable the OSA framework. Hence, this way to enable and disable the OSA framework can be used from within scripts without affecting OSA framework operation started from other scripts.</p>
<pre><code class="language-simics">simics&gt; <strong>@admin = conf.board.software.iface.osa_component.get_admin()</strong>
simics&gt; <strong>@(ok, riq_or_msg) = admin.iface.osa_control_v2.request("My requester")</strong>
simics&gt; <strong>@admin.iface.osa_control_v2.release(riq_or_msg)</strong>
</code></pre>
<p>Each of the above methods for controlling the OSA framework are separate from each other. That means that the framework can only be disabled using the matching disable function and that the framework will stay active until there are no more users with an active request.</p>
<p>Some trackers are able to determine some information about the running software just by enabling it on an already running system, but in other cases there is additional—and sometimes important information— that can only be collected by having the tracker enabled while the software starts. For instance, the Linux software tracker can determine the name and process id of already running processes, but to determine the path to the running binary the tracker needs to be enabled when the process starts.</p>
</section><section class="page" id="nodes.html"><h1 id="nodes.html:the-node-tree"><a href="#nodes.html:the-node-tree">2.2 The Node Tree</a></h1>
<p>A tracker—when activated—monitors the machine state and the associated mapper represents it as a tree of nodes, in a hierarchical way. Other objects and scripts can query this tree, and register callbacks that trigger when it changes.</p>
<p>The node tree usually represents the state of the operating system. A node can map against a software entity such as a thread. Other nodes group child nodes based on a property they share, such as being part of the same process or running under the same access level. Another possibility is to group by guest OS for a Hypervisor, as the framework supports stacked node trees.</p>
<p>Each tree will consist of a single root node at the base. This root node usually provides the overall system details, such as the name of the operating system.</p>
<p>The node tree changes over time, and nodes will be created and destroyed as processes and threads are born and die.</p>
<p>The OSA framework provides a couple of interfaces in order to operate on the node tree. For getting the state of the node tree there is the <code>osa_node_tree_query</code> interface. For monitoring changes to the node tree the <code>osa_node_tree_notification</code> interface can be used. See the <em>API - Reference Manual</em> for details about these interfaces and section <a class="reference" href="#software-tracker-scripting.html">2.5</a> for scripting examples.</p>
<p>In the interfaces and commands used to interact with the node tree, every node is identified by a <em>node ID</em>, which is an integer that is unique. The IDs are never reused by the framework.</p>
<p>Each node has a set of named <em>properties</em> that contain information about what the node represents. Which properties exist depends on the type of node, but the properties listed below are the standard properties, which all nodes have (except where noted):</p>
<div class="dl">
<ul>
<li><span class="term" id="nodes.html:dt:name"><a href="#nodes.html:dt:name">name</a></span><br>
The name of this node. Unlike the ID, it does not need to be unique.</li>
<li><span class="term" id="nodes.html:dt:extra_id"><a href="#nodes.html:dt:extra_id">extra_id</a></span><br>
A list of properties that will uniquely identify nodes at the same level. All nodes that have the same parent node must have the same value for <code>extra_id</code>. If the list is empty, the property <code>name</code> should be used to identify the node. The <code>extra_id</code> property is useful for finding a unique node without having to know its node ID.</li>
</ul>
</div>
<p>Each tracker defines its own set of node properties. See documentation for each tracker for further details.</p>
<p>The <code>node-tree</code> command can be used to print the current node tree. See figure <a class="reference" href="#node-tree-patterns.html:np-fake-tree">1</a> for an illustration of a node tree.</p>
<p>A node can be active for a certain processor in which case all its ancestors will also be active. The exact meaning of this depends on the node type, but for a thread node this means that the thread is executing on the active processor. To see which processors a certain node is active on the <code>get_current_processors</code> function in the <code>osa_node_tree_query</code> interface can be used. To get a list of all active nodes the <code>get_current_nodes</code> function in the same interface can be used.</p>
<p>The following rules apply for active nodes:</p>
<ol>
<li><em>If a node is active on a processor, its parent is also active on that processor.</em> Therefore all its ancestors all the way to the root node will also be active on that processor. This is because a child node always represents a subset of its parent.</li>
<li><em>If two nodes are active for the same processor, then one must be a descendant of the other.</em> This is a consequence of processors being able to do just one thing at a time. For example, it is not possible for a processor to run more than one thread at a time.</li>
</ol>
</section><section class="page" id="osa-commands.html"><h1 id="osa-commands.html:commands"><a href="#osa-commands.html:commands">2.3 Commands</a></h1>
<p>This section gives an overview of all commands provided by the <code>software</code> object. Using the <code>help</code> command for a specific command will give more detailed help for that command.</p>
<h2 id="osa-commands.html:controlling"><a href="#osa-commands.html:controlling">2.3.1 Controlling</a></h2>
<div class="dl">
<ul>
<li>
<p><span class="term" id="osa-commands.html:dt:enable-tracker"><a href="#osa-commands.html:dt:enable-tracker">enable-tracker</a></span><br>
Enables the OS Awareness framework and associated trackers. This is necessary for most other commands to work.</p>
<pre><code class="language-simics">simics&gt; <strong>board.software.enable-tracker</strong>
OSA control enabled.
</code></pre>
</li>
<li>
<p><span class="term" id="osa-commands.html:dt:disable-tracker"><a href="#osa-commands.html:dt:disable-tracker">disable-tracker</a></span><br>
Disables the OS Awareness framework and enabled trackers. This will destroy all node trees.</p>
<pre><code class="language-simics">simics&gt; <strong>board.software.disable-tracker</strong>
OSA control disabled.
</code></pre>
</li>
</ul>
</div>
<h2 id="osa-commands.html:tracking-related"><a href="#osa-commands.html:tracking-related">2.3.2 Tracking Related</a></h2>
<p>These commands will require that the tracker is enabled in order to work.</p>
<div class="dl">
<ul>
<li>
<p><span class="term" id="osa-commands.html:dt:find"><a href="#osa-commands.html:dt:find">find</a></span><br>
Search for a node in the node tree. The output of the command is a list of node path patterns (see <a class="reference" href="#node-tree-patterns.html">2.4</a>) matching the search.</p>
<pre><code class="language-simics">simics&gt; <strong>board.software.find node="tid=1"</strong>
/Linux/Userspace/pid=1/tid=1
</code></pre>
</li>
<li>
<p><span class="term" id="osa-commands.html:dt:list"><a href="#osa-commands.html:dt:list">list</a></span><br>
Prints a list of all processes in the system.</p>
<pre><code class="language-simics">simics&gt; <strong>board.software.list</strong>
Process         Binary  PID  TID
systemd                    1    1
...
python3                  247  247
simics-agent             248  248
systemd                  253  253
(sd-pam)                 254  254
bash                     260  260
</code></pre>
</li>
<li>
<p><span class="term" id="osa-commands.html:dt:node-info"><a href="#osa-commands.html:dt:node-info">node-info</a></span><br>
Prints the name and value of all properties of the given node.</p>
<pre><code class="language-simics">simics&gt; <strong>board.software.node-info "tid=1"</strong>

              Name : systemd
              Path : /Linux/Userspace/pid=1/tid=1
                ID : 648
            Parent : 647
          Children : []
          extra_id : tid
      memory_space : 647
    multiprocessor : False
               pid : 1
               tid : 1
</code></pre>
</li>
<li>
<p><span class="term" id="osa-commands.html:dt:node-tree"><a href="#osa-commands.html:dt:node-tree">node-tree</a></span><br>
Lists the node trees for an active software trackers.</p>
<pre><code class="language-simics">simics&gt; <strong>board.software.node-tree</strong>
</code></pre>
</li>
<li>
<p><span class="term" id="osa-commands.html:dt:bp-break-active"><a href="#osa-commands.html:dt:bp-break-active">bp-break -active</a></span>
Break the simulation when a specific node becomes active.</p>
<pre><code class="language-simics">simics&gt; <strong>board.software.bp-break -active node-pattern = "tid=1"</strong>
Added breakpoint 1
</code></pre>
</li>
<li>
<p><span class="term" id="osa-commands.html:dt:bp-break-inactive"><a href="#osa-commands.html:dt:bp-break-inactive">bp-break -inactive</a></span><br>
Break the simulation when a specific node gets deactivated.</p>
<pre><code class="language-simics">simics&gt; <strong>board.software.bp-break -inactive node-pattern = "tid=1"</strong>
Added breakpoint 2
</code></pre>
</li>
<li>
<p><span class="term" id="osa-commands.html:dt:bp-delete"><a href="#osa-commands.html:dt:bp-delete">bp.delete</a></span>
Remove breakpoints that were created by <code>bp-break</code>.</p>
<pre><code class="language-simics">simics&gt; <strong>bp.delete -all</strong>
</code></pre>
</li>
<li>
<p><span class="term" id="osa-commands.html:dt:active-node"><a href="#osa-commands.html:dt:active-node">active-node</a></span><br>
List the node that is active on a certain processor.</p>
<pre><code class="language-simics">simics&gt; <strong>board.software.active-node</strong>
board.mb.cpu0.core[0][0] is active on /Linux/Userspace/pid=1/tid=1
</code></pre>
</li>
<li>
<p><span class="term" id="osa-commands.html:dt:bp-wait-for-active"><a href="#osa-commands.html:dt:bp-wait-for-active">bp-wait-for -active</a></span><br>
Similar to <code>bp-break -active</code>, but to be used in a script-branch.</p>
</li>
<li>
<p><span class="term" id="osa-commands.html:dt:bp-wait-for-inactive"><a href="#osa-commands.html:dt:bp-wait-for-inactive">bp-wait-for -inactive</a></span><br>
Similar to <code>bp-break -inactive</code>, but to be used in a script-branch.</p>
</li>
</ul>
</div>
<h2 id="osa-commands.html:parameter-related"><a href="#osa-commands.html:parameter-related">2.3.3 Parameter Related</a></h2>
<p>These commands do not require the tracker to be enabled.</p>
<div class="dl">
<ul>
<li><span class="term" id="osa-commands.html:dt:load-parameters"><a href="#osa-commands.html:dt:load-parameters">load-parameters</a></span><br>
Load configuration parameters for a software tracker from a file.</li>
<li><span class="term" id="osa-commands.html:dt:save-parameters"><a href="#osa-commands.html:dt:save-parameters">save-parameters</a></span><br>
Save the current configuration parameters to a file.</li>
<li><span class="term" id="osa-commands.html:dt:supports-parameters"><a href="#osa-commands.html:dt:supports-parameters">supports-parameters</a></span><br>
Tells whether or not a parameters file is supported by the current modules.</li>
</ul>
</div>
</section><section class="page" id="node-tree-patterns.html"><h1 id="node-tree-patterns.html:node-path-patterns"><a href="#node-tree-patterns.html:node-path-patterns">2.4 Node path patterns</a></h1>
<p>A node in the node tree may be identified with its node ID. This is often not good enough, since it is hard to know the given node ID in advance; this makes scripting hard to accomplish in a satisfying way. Using <strong>node path patterns</strong> makes it possible to find nodes based on their properties instead of their node ID. A node path pattern is a matching rule that selects nodes based on one or more property values, and optionally the property values of their ancestors.</p>
<h2 id="node-tree-patterns.html:introduction"><a href="#node-tree-patterns.html:introduction">2.4.1 Introduction</a></h2>
<p>This section will assume that the node tree looks like the one in figure <a class="reference" href="#node-tree-patterns.html:np-fake-tree">1</a>.</p>
<figure id="node-tree-patterns.html:np-fake-tree">
<p><img alt="" src="np-fake-tree.png"></p><figcaption>Figure 1. Example node tree</figcaption><p></p>
</figure>
<p>The simplest node path pattern is a single integer. This is treated as a node ID. Thus, "2" can be used to find the Userspace node:</p>
<pre><code class="language-simics">simics&gt; <strong>board.software.find 2</strong>
</code></pre>
<p>The name property will be used for matching if the given node specification only contains letters, digits, and underscore, and does not start with a digit. This gives an alternative way of locating the Userspace node in <a class="reference" href="#node-tree-patterns.html:np-fake-tree">1</a>:</p>
<pre><code class="language-simics">simics&gt; <strong>board.software.find Userspace</strong>
</code></pre>
<p>However, if the name contain any non-alphanumeric characters, such as space or punctuation, the name needs to be enclosed in single quotes, and the <code>name</code> property needs to be named explicitly:</p>
<pre><code class="language-simics">simics&gt; <strong>board.software.find "name='Linux'"</strong>
</code></pre>
<p>A node path pattern can specify properties other than just the name of a node. For example, this one will find all nodes that belong to the <code>simics</code> process (the process node and all thread nodes) by specifying the matching pid:</p>
<pre><code class="language-simics">simics&gt; <strong>board.software.find "pid=20"</strong>
</code></pre>
<p>If a match is to be made based on multiple properties, they should be comma-separated. Given the node tree in figure <a class="reference" href="#node-tree-patterns.html:np-fake-tree">1</a>, the following pattern would match just one node, the thread node with <code>tid=20</code>:</p>
<pre><code class="language-simics">simics&gt; <strong>board.software.find "pid=20,tid=20"</strong>
</code></pre>
<p>A slash (<code>/</code>) is used to separate rules for nodes at adjacent levels in the tree. For example, this pattern matches any node named <code>init</code> that lies directly under a node named <code>Userspace</code>:</p>
<pre><code class="language-simics">simics&gt; <strong>board.software.find "Userspace/init"</strong>
</code></pre>
<p>A slash at the beginning of the pattern anchors it to the root of the tree, so that the part after the first slash must match the root node, the part after the second slash must match any of its children, etc.</p>
<p>Node path patterns can contain three kinds of wildcards:</p>
<ul>
<li>One asterisk (<code>*</code>) will match any <em>single</em> node. For example, <code>/*/*/simics</code> will match any node named <code>simics</code> that is a grandchild of the root node.</li>
<li>Two asterisks (<code>**</code>) will match a path of zero or more nodes in the tree. For example, <code>/name=Linux/**/pid=20</code> matches nodes 13, 14, and 15 in the example tree.</li>
<li>An asterisk in the expected value of a property matches zero or more characters. For example, <code>*s*</code> will match the ls, sh, and Userspace nodes; and <code>pid=*</code> will match all nodes with a <code>pid</code> property.</li>
</ul>
<div class="note">
<p>Quoted wildcards will be treated literally. That means, <code>name="'ho*er'"</code> will only match a node named "ho*er", while <code>name="'ho'*'er'"</code> will match any nodes named "hover", "hoover", "hotter", etc.</p>
</div>
<h2 id="node-tree-patterns.html:summary"><a href="#node-tree-patterns.html:summary">2.4.2 Summary</a></h2>
<p>This is a short summary of the available operators when creating a node path pattern.</p>
<ul>
<li>Integer value: this is treated as a node id</li>
<li>String: if the string contains only alphanumeric characters or the _ sign and does not begin with a digit, <code>str</code> will be the same as <code>name='str'</code>.</li>
<li>Slash (<code>/</code>): separates rules for nodes at different levels. At the beginning of a pattern, it means that the root has to match the following rule.</li>
<li>Asterisk (<code>*</code>): matches exactly one node, ignoring all node properties on that level.</li>
<li>Double asterisk (<code>**</code>): Matches a path of zero or more nodes in the node tree.</li>
<li>Equals sign (<code>=</code>): Specifies the required value of a node property.</li>
<li>Comma (<code>,</code>): Separator when a rule restricts more than one node property.</li>
</ul>
<h2 id="node-tree-patterns.html:limitations"><a href="#node-tree-patterns.html:limitations">2.4.3 Limitations</a></h2>
<p>Node path patterns have some known limitations:</p>
<ul>
<li>Asterisk (<code>*</code>) is the only wildcard available for property matching. More advanced wildcards, such as <code>name=cat??</code> or <code>pid=5[0-1]</code>, are not supported.</li>
<li>A rule may not end with <code>/**/</code> or <code>/**</code>.</li>
<li>It is not possible to start a pattern with <code>**/</code>; use <code>/**/</code> instead. (However, note that all patterns that do not already start with a slash are implicitly prefixed with <code>/**/</code>.)</li>
<li>Just <code>**</code> is not a valid pattern. Use <code>*</code> in order to match all nodes.</li>
</ul>
</section><section class="page" id="software-tracker-scripting.html"><h1 id="software-tracker-scripting.html:scripting"><a href="#software-tracker-scripting.html:scripting">2.5 Scripting</a></h1>
<p>The OS Awareness framework supports scripting against the node tree. The <code>osa_node_tree_query</code> interface implemented by the <code>os_awareness</code> object can be used for retrieving the current state of the node tree. The <code>osa_node_tree_notification</code> interface, also implemented by the <code>os_awareness</code> object, can be used to register callbacks for notifications about changes to the node tree.</p>
<p>The administrator object can be retrieved by calling the <code>get_admin</code> function in the <code>osa_component</code> interface, implemented by the OSA object. This interface also provides the <code>get_root_node</code> function. This gives a known node ID which can be used to access the root node and its descendant nodes.</p>
<p>Details about the interfaces used for scripting can be found in the <em>API - Reference Manual</em>.</p>
<p>The following Python example script uses the OS Awareness framework and the Linux tracker to track a process and count all hardware exceptions that happen while that process is active. The basic idea is to activate the <code>Core_Exception</code> hap only when the given program is activate. It assumes that the target system is named <code>board</code>.</p>
<pre><code>import simics
import conf
class exception_counter:
    "This class counts hardware exceptions for a specific process."

    def __init__(self, software_comp, process_name):
        # Get the osa_admin object from the component, this will be used to
        # access the node tree interfaces.
        self.osa_admin = software_comp.iface.osa_component.get_admin()
        self.notifiers = set()
        self.exc_haps = {}

        self.exceptions = {}          # The result

        # Most OSA interface functions require a node ID. Retrieve the root_id
        # from the component. Using the root ID in combination with the
        # recursive flag makes it possible to get notifications for the entire
        # node tree.
        root_node = software_comp.iface.osa_component.get_root_node()
        if not root_node.valid:
            print ("No root node present")
            return
        self.root_id = root_node.id

        # The node names will be truncated to 15 characters, since
        # they use the Linux task 'comm' field. So we only match the
        # first 15 characters of the requested process name.
        process_name = process_name[:15]

        # Get interface used to register callback functions for node tree
        # updates.
        self.notification_ifc = self.osa_admin.iface.osa_node_tree_notification
        # Get interface used to query the current state in the node tree.
        self.query_ifc = self.osa_admin.iface.osa_node_tree_query

        # Install a callback on node creation.
        cid = self.notification_ifc.notify_create(self.root_id, True,
                                                  self.create_cb, process_name)
        self.notifiers.add(cid)

        # Install a callback on changes to the 'name' property in any node, in
        # case the program switches name after the node was created.
        self.notifiers.add(
            self.notification_ifc.notify_property_change(
                self.root_id, "name", True, self.name_cb,
                process_name))

        print(("Will count exceptions for the next process called %s"
               % process_name))

    def is_process(self, node_id):
        # This will only work for the Linux tracker. It uses the fact that a
        # process node contains the process id, but not the thread id.
        props = self.query_ifc.get_node(node_id)
        return 'pid' in props and not 'tid' in props

    def create_cb(self, process_name, osa_admin, curcpu, node_id):
        # There can be other nodes than the process node with a
        # matching name, for example thread nodes. Verify both name
        # and that it is a process.
        if (self.query_ifc.get_node(node_id)['name'] == process_name
            and self.is_process(node_id)):
            self.process_found(node_id)

    def name_cb(self, process_name, osa_admin, curcpu, node_id,
                key, old_val, new_val):
        # There can be other nodes than the process node with a
        # matching name, for example thread nodes. Verify both name
        # and that it is a process.
        if new_val == process_name and self.is_process(node_id):
            self.process_found(node_id)

    def process_found(self, node_id):
        # Remove the callbacks for node creation and name changes.
        while self.notifiers:
            self.notification_ifc.cancel_notify(self.notifiers.pop())

        # Install callbacks when processors enter and leave this
        # process node.
        self.notifiers.add(
            self.notification_ifc.notify_cpu_move_to(node_id, self.move_to_cb,
                                                     None))
        self.notifiers.add(
            self.notification_ifc.notify_cpu_move_from(node_id,
                                                       self.move_from_cb, None))

        # Install a callback when the process finishes.
        self.notifiers.add(
            self.notification_ifc.notify_destroy(node_id, False,
                                                 self.destroy_cb, None))

        # For each CPU already executing in this node, make sure
        # to enable counting.
        for cpu in self.query_ifc.get_current_processors(node_id):
            self.enable_counting(cpu)

    def enable_counting(self, cpu):
        # Install a hap callback for the exception hap.
        self.exc_haps[cpu] = simics.SIM_hap_add_callback_obj(
            "Core_Exception", cpu, 0, self.exception_cb, None)

    def disable_counting(self, cpu):
        simics.SIM_hap_delete_callback_id("Core_Exception", self.exc_haps[cpu])

    def move_to_cb(self, data, osa_admin, cpu, node_path):
        self.enable_counting(cpu)

    def move_from_cb(self, data, osa_admin, cpu, node_path):
        self.disable_counting(cpu)

    def destroy_cb(self, data, osa_admin, cpu, node_id):
        print("The process finished")
        for exc in sorted(self.exceptions.keys()):
            print("%5d %-30s: %8d" % (exc, cpu.iface.exception.get_name(exc),
                                      self.exceptions[exc]))
        while self.notifiers:
            self.notification_ifc.cancel_notify(self.notifiers.pop())

    def exception_cb(self, data, cpu, exception):
        if exception in self.exceptions:
            self.exceptions[exception] += 1
        else:
            self.exceptions[exception] = 1

counter = exception_counter(conf.board.software, "ls")
</code></pre>
<div class="note">
<p>Remember that this will only work if the tracker is enabled. It can be enabled with the <code>enable-tracker</code> command.</p>
</div>
</section><section class="page" id="event-system.html"><h1 id="event-system.html:event-system"><a href="#event-system.html:event-system">2.6 Event system</a></h1>
<p>The OS Awareness framework provides two different types of callbacks. The first type is notifications about changes to the node tree, as explained in section <a class="reference" href="#software-tracker-scripting.html">2.5</a>. These changes are persistent until they are updated by the tracker or the node is destroyed.</p>
<p>The second type of notifications are called events. These are used for notifying about changes that are not persistent and hence not part of the node tree. It is up to each tracker to define the list of supported events. For example, the Linux tracker supports system call notification via the event system, see section <a class="reference" href="#linux-tracker.html:system-calls">2.13.4</a> for more details.</p>
<p>It is possible to register an event notification callback by calling the <code>notify_event</code> function in the <code>osa_node_tree_notification</code> interface. See the <em>API – Reference Manual</em> for details.</p>
<p>Here follows a simple example of the event notification system. It registers a callback function for all events on all nodes generated by the tracker. When this callback is triggered the simulation will be stopped. This Python example assumes that the system is named <code>board</code>.</p>
<pre><code>import simics
import conf

def event_cb(cb_data, admin, cpu, node_id, event_name, event_data):
    simics.SIM_break_simulation(
        "Got event '%s' on the %s cpu with event data '%s'"
        % (event_name, cpu.name, event_data))

def break_on_event(software_comp):
    root_node = software_comp.iface.osa_component.get_root_node()
    if not root_node.valid:
        print ("No root node present")
        return
    root_id = root_node.id
    admin = software_comp.iface.osa_component.get_admin()
    notification_ifc = admin.iface.osa_node_tree_notification
    notification_ifc.notify_event(root_id, None, True, event_cb, None)

break_on_event(conf.board.software)
</code></pre>
<div class="note"> 
<p>Remember that this will only work if the tracker is enabled. It can be enabled with the <code>enable-tracker</code> command.</p>
</div>
</section><section class="page" id="tracker-parameters.html"><h1 id="tracker-parameters.html:tracker-parameters"><a href="#tracker-parameters.html:tracker-parameters">2.7 Tracker Parameters</a></h1>
<p>Most trackers will need parameters in order to be able to track software. The parameter file contains information about which tracker should be used, and additional information required by the tracker in order to track the target software. This can be anything from offsets into structs to the name of the system. Often the parameter files will be provided with the target system and they may be loaded in the target scripts. The <code>load-parameters</code> command is used to load parameters.</p>
<p>When parameters are loaded the <code>os-awareness</code> object will automatically create a tracker composition object based on the parameters if one does not already exist.</p>
<p>For many systems the parameters can only be detected when the operating system is booted on the target. For example, the Linux tracker object provides a <code>detect-parameters</code> command to be able to retrieve parameters for the current system. See section <a class="reference" href="#linux-tracker.html:system-configuration">2.13.6</a> for more information about configuring the Linux tracker.</p>
</section><section class="page" id="os-awareness-configuration.html"><h1 id="os-awareness-configuration.html:tracker-configuration"><a href="#os-awareness-configuration.html:tracker-configuration">2.8 Tracker Configuration</a></h1>
<p>In order to use the OS Awareness framework, a software object must be created. This object can be created by the <code>new-os-awareness</code> command. The object should be created under the top object for each machine and preferably be named <code>software</code>. Note that many scripts will set up a pre-configured software object.</p>
<p>The software object handles user interaction by providing a number of commands, see section <a class="reference" href="#osa-commands.html">2.3</a> for further details. It also contains interfaces for scripting, see section <a class="reference" href="#software-tracker-scripting.html">2.5</a> for further details.</p>
<p>A new tracker can be added by using the <code>load-parameters</code> command if there is a parameters file available. If there are no parameters available the <code>insert-tracker</code> command can be used followed by the <code>detect-parameters</code> command as described in section <a class="reference" href="#tracker-parameters.html">2.7</a>. The software object should now contain a tracker composition. Note that many scripts will set up a pre-configured tracker.</p>
<p>Most <code>tracker</code> composition objects will contain two sub-objects, one named <code>tracker_obj</code> which takes care of tracking the currently running software. The other object will be the <code>mapper_obj</code> object which takes care of mapping the information given by the tracker into a node tree (see section <a class="reference" href="#nodes.html">2.2</a>). One tracker could potentially have several different mappers to represent the trackers information in different node trees.</p>
</section><section class="page" id="os-awareness-scripts.html"><h1 id="os-awareness-scripts.html:adding-tracker-support-to-target-scripts"><a href="#os-awareness-scripts.html:adding-tracker-support-to-target-scripts">2.9 Adding Tracker Support to Target Scripts</a></h1>
<p>Every system configuration script that creates a system on which software can run, should add an <code>os_awareness</code> object to the <code>software</code> slot of each top-level object. For further details on how to configure the OSA framework see section <a class="reference" href="#os-awareness-configuration.html">2.8</a>. This is done by running the <code>new-os-awareness</code> command and naming the new object by appending <code>.software</code> to the system top object name. This is how it's done in the standard configuration files (usually called <code>something-system.include</code>).</p>
<pre><code class="language-simics">simics&gt; <strong>new-os-awareness name = $system.software</strong>
Created OS awareness framework 'test_board.software'
</code></pre>
<p>If a target script starts a specific kernel version, it is convenient to make it include pre-defined parameters for the tracker. For example, if we have linux-3.1.4.simics, we could also provide a linux-3.1.4.params file with parameters matching the target OS. This makes it possible to run the system without having to configure the tracker each time. However, not everyone may have access to a specific tracker module, so care needs to be taken in order to add support to the target script so it works even without a tracker. Below is an example on how a target script can be written so that the system can be brought up even if the user does not have access to the tracker. The tracker itself, will not work if the parameters are not supported.</p>
<pre><code>
if not defined tracker_params = {$tracker_params = "linux-3.1.4.params"}

$sw = $system.software

# First check if any parameters should be loaded at all.
if $tracker_params != "" {
  if $sw.supports-parameters $tracker_params {
    $sw.load-parameters file = $tracker_params
  } else {
      echo ("No tracker module found that supports parameters file: "
            + $tracker_params)
  }
}

</code></pre>
<p>The software object handles user interaction by providing a number of commands, see section <a class="reference" href="#osa-commands.html">2.3</a> for further details. The object will contain interfaces for scripting against node trees. The software object will also contain a sub-object named <code>tracker</code> which will be added once a tracker has been configured. Configuration of the tracker can be done in two ways. The first way is by loading parameters with the <code>load-parameters</code> command, which will add a tracker composition object matching the tracker specified in the parameters file loaded, if a matching tracker module exists.</p>
<p>The second way is by inserting a tracker composition object of a specific kind with the <code>insert-tracker</code> command. This way has to be used if no parameters exist. The tracker composition object can then provide ways to detect parameters for the target software. See section <a class="reference" href="#tracker-parameters.html">2.7</a> for more information about parameters.</p>
<p>Most <code>tracker</code> composition objects will contain two objects, one named <code>tracker_obj</code> which takes care of tracking the currently running software. The other object will be the <code>mapper</code> object which takes care of mapping the information given by the tracker into a node tree (see section <a class="reference" href="#nodes.html">2.2</a>) which can be used when scripting or debugging. One tracker could potentially have several different mappers to represent the trackers information in different node trees.</p>
</section><section class="page" id="os-awareness-domains.html"><h1 id="os-awareness-domains.html:multiple-software-domains"><a href="#os-awareness-domains.html:multiple-software-domains">2.10 Multiple Software Domains</a></h1>
<p>A software domain is a system or subsystem where target software runs. All software tracking mechanisms described in this chapter work individually in each software domain without affecting each other. If a configuration contains two hardware subsystems that run different software instances, there will be two separate software trackers, each one tracking the software in one of the two subsystems.</p>
<p>For most configurations, an <code>os_awareness</code> object that defines the software domain will be placed in each top-level system object, in its <code>software</code> slot. For some complex configurations it is possible to define software domains differently by placing the <code>os_awareness</code> object elsewhere in the object hierarchy, or by configuring it to use a subset of the available processors.</p>
<p>See the <em>Model Builder User's Guide</em> for more information about software domains.</p>
</section><section class="page" id="multiple-oss.html"><h1 id="multiple-oss.html:multiple-operating-systems-on-a-single-machine"><a href="#multiple-oss.html:multiple-operating-systems-on-a-single-machine">2.11 Multiple Operating Systems on a Single Machine</a></h1>
<p>It is possible to use several trackers on a single machine running multiple operating systems. In that case each operating system must have dedicated processors. Such a system requires some additional configuration steps, that has to be done after the processor objects have been instantiated. First create a software object for each operating system. This is done with the <code>new-os-awareness</code> command. Then set the <code>processors</code> attribute of each software object to match that of the operating system it is going to track. The trackers are now ready to be used.</p>
<pre><code class="language-simics">simics&gt; <strong>load-module os-awareness</strong>
os-awareness module loaded
simics&gt; <strong>new-os-awareness name = board.softwareA</strong>
Created OS awareness framework 'board.softwareA'
simics&gt; <strong>new-os-awareness name = board.softwareB</strong>
Created OS awareness framework 'board.softwareB'
simics&gt; <strong>@conf.board.softwareA.processors = [conf.board.mb.cpu0.core[0][0]]</strong>
&lt;
simics&gt; <strong>@conf.board.softwareB.processors = [conf.board.mb.cpu1.core[0][0]]</strong>
&lt;
</code></pre>
</section><section class="page" id="os-awareness-limitations.html"><h1 id="os-awareness-limitations.html:limitations"><a href="#os-awareness-limitations.html:limitations">2.12 Limitations</a></h1>
<p>Some common limitations for most trackers are that they rely on monitoring OS data structures, registers and processor state. If the behavior of any of these are changed, for example between kernel versions or due to different configuration options when compiling the kernel, the tracker may require an update in order to work with that specific kernel.</p>
<ul>
<li>The Simics debugger has special requirements on trackers in order to be compatible so all trackers may not work with it. The Linux tracker and UEFI Firmware tracker, for example, do work.</li>
<li>OS Awareness will impact the simulation performance. Commands such as <code>&lt;bp-manager.os-awareness&gt;.break</code> or <code>&lt;osa_component&gt;.bp-break</code> will also impact the performance negatively. Registering notification callbacks, especially from Python, can also have an impact on performance.</li>
<li>The gdb-remote extension has not been tested together with OS Awareness and may not work.</li>
<li>See respective tracker's documentation for a list of limitations for that tracker.</li>
</ul>
</section><section class="page" id="linux-tracker.html"><h1 id="linux-tracker.html:linux-tracker"><a href="#linux-tracker.html:linux-tracker">2.13 Linux Tracker</a></h1>
<p>The Linux tracker tracks processes and threads in Linux.</p>
<p>When a processor runs an address that is considered to be in kernel space, processor nodes will be created under the Other node (see <a class="reference" href="#linux-tracker.html:linux-tracker-tree">2</a>) and they will be set as active. Once the OS has come far enough in the boot process for the first processes to start, the tracker will consider the system booted and the Linux tracker will add nodes for processes and threads to form a tree like the one shown in figure <a class="reference" href="#linux-tracker.html:linux-tracker-tree">2</a>.</p>
<h2 id="linux-tracker.html:node-tree"><a href="#linux-tracker.html:node-tree">2.13.1 Node Tree</a></h2>
<p>This section describes how the Linux system is represented as a node tree. Figure <a class="reference" href="#linux-tracker.html:linux-tracker-tree">2</a> shows an example of the Linux node tree representation.</p>
<figure id="linux-tracker.html:linux-tracker-tree">
<p><img alt="" src="linux-tracker-tree.png"></p><figcaption>Figure 2. Node tree of a Linux tracker</figcaption><p></p>
</figure>
<p>There are ten different kinds of nodes:</p>
<div class="dl">
<ul>
<li>
<p><span class="term" id="linux-tracker.html:dt:kernel-node"><a href="#linux-tracker.html:dt:kernel-node">Kernel node</a></span><br>
(Node 1 in figure <a class="reference" href="#linux-tracker.html:linux-tracker-tree">2</a>.) This node represent the kernel half of Linux. Each processor currently executing in kernel space will be active on this node.</p>
</li>
<li>
<p><span class="term" id="linux-tracker.html:dt:other-node"><a href="#linux-tracker.html:dt:other-node">Other node</a></span><br>
(Node 3 in figure <a class="reference" href="#linux-tracker.html:linux-tracker-tree">2</a>.) This node is used to group activity that is not being represented by any of the other nodes. For example when a user space process does a system call.</p>
</li>
<li>
<p><span class="term" id="linux-tracker.html:dt:other-node-s-child-nodes"><a href="#linux-tracker.html:dt:other-node-s-child-nodes">Other node's child nodes</a></span><br>
(Nodes 6 and 7 in figure <a class="reference" href="#linux-tracker.html:linux-tracker-tree">2</a>.) For each processor that is available to the system a new node will be created here.</p>
</li>
<li>
<p><span class="term" id="linux-tracker.html:dt:threads-node"><a href="#linux-tracker.html:dt:threads-node">Threads node</a></span><br>
(Node 5 in figure <a class="reference" href="#linux-tracker.html:linux-tracker-tree">2</a>.) This node is used to group all kernel threads under one node. If a kernel thread is currently active, so will this node be.</p>
</li>
<li>
<p><span class="term" id="linux-tracker.html:dt:kernel-thread-nodes"><a href="#linux-tracker.html:dt:kernel-thread-nodes">Kernel thread nodes</a></span><br>
(Node 10 in figure <a class="reference" href="#linux-tracker.html:linux-tracker-tree">2</a>.) A new kernel thread node is created for each new kernel thread. When the task is terminated, the node is destroyed. When the kernel thread is executing, this node will be active. Thread nodes have the following extra properties in addition to the standard ones:</p>
  <div class="dl">
<ul>
<li><span class="term" id="linux-tracker.html:dt:tid"><a href="#linux-tracker.html:dt:tid">tid</a></span><br>
The integer tid ("thread ID") associated with the thread. This is unique in the whole OS instance.</li>
</ul>
  </div>
</li>
<li>
<p><span class="term" id="linux-tracker.html:dt:idle-node"><a href="#linux-tracker.html:dt:idle-node">Idle node</a></span><br>
(Node 4 in figure <a class="reference" href="#linux-tracker.html:linux-tracker-tree">2</a>.) This node is used to group activity that is identified as the system being idle. If a processor is idling then this node will be active.</p>
</li>
<li>
<p><span class="term" id="linux-tracker.html:dt:idle-node-s-child-nodes"><a href="#linux-tracker.html:dt:idle-node-s-child-nodes">Idle node's child nodes</a></span><br>
(Nodes 8 and 9 in figure <a class="reference" href="#linux-tracker.html:linux-tracker-tree">2</a>.) For each processor that is available to the system a new node will be created here. It will be active when the processor is identified as being idle. This is approximated by the time when a swapper task is running on the specific processor.</p>
</li>
<li>
<p><span class="term" id="linux-tracker.html:dt:userspace-node"><a href="#linux-tracker.html:dt:userspace-node">Userspace node</a></span><br>
(Node 2 in figure <a class="reference" href="#linux-tracker.html:linux-tracker-tree">2</a>.) All processors executing in user-space will be active on this node.</p>
</li>
<li>
<p><span class="term" id="linux-tracker.html:dt:process-nodes"><a href="#linux-tracker.html:dt:process-nodes">Process nodes</a></span><br>
(Nodes 11, 21, 23, and 25. in figure <a class="reference" href="#linux-tracker.html:linux-tracker-tree">2</a>.) Immediately below the user-space node, there is one process node for each process in the system. A new process node is created for each new process, and when a process is terminated, its node is destroyed. Process nodes have the following extra properties in addition to the standard ones:</p>
  <div class="dl">
<ul>
<li><span class="term" id="linux-tracker.html:dt:binary"><a href="#linux-tracker.html:dt:binary">binary</a></span><br>
A string containing the path to the binary that the process is running. This property will only exist if the binary is known.</li>
<li><span class="term" id="linux-tracker.html:dt:pid"><a href="#linux-tracker.html:dt:pid">pid</a></span><br>
A list containing the pid of this process. This is the same as the thread group ID.</li>
</ul>
  </div>
</li>
<li>
<p><span class="term" id="linux-tracker.html:dt:process-thread-nodes"><a href="#linux-tracker.html:dt:process-thread-nodes">Process thread nodes</a></span><br>
(Nodes 12, 22, 24, 26, and 27 in figure <a class="reference" href="#linux-tracker.html:linux-tracker-tree">2</a>.) Immediately below each process node is one or more thread nodes representing the threads in the process. Just like the process nodes, these are created and destroyed on demand. Thread nodes have the following extra properties in addition to the standard ones:</p>
  <div class="dl">
<ul>
<li><span class="term" id="linux-tracker.html:dt:pid-2"><a href="#linux-tracker.html:dt:pid-2">pid</a></span><br>
The integer pid ("process ID") associated with the thread. This is the same for all threads in a process and matches pid for the parent process node.</li>
<li><span class="term" id="linux-tracker.html:dt:tid-2"><a href="#linux-tracker.html:dt:tid-2">tid</a></span><br>
The integer tid ("thread ID") associated with the thread. This is unique in the whole OS instance.</li>
</ul>
  </div>
</li>
</ul>
</div>
<h2 id="linux-tracker.html:commands"><a href="#linux-tracker.html:commands">2.13.2 Commands</a></h2>
<p>The Linux tracker composition object includes some useful commands. Use the <code>help</code> command for a specific command to get more detailed information about that command.</p>
<div class="dl">
<ul>
<li>
<p><span class="term" id="linux-tracker.html:dt:detect-parameters"><a href="#linux-tracker.html:dt:detect-parameters">detect-parameters</a></span><br>
Detect parameters to be used by the Linux tracker. The system has to be booted for detection to succeed and for some systems kernel debug information must be provided in order for the tracker to be able to detect parameters. Use the <code>-load</code> flag to load the detected parameters directly and the <em>param-file</em> argument to save the parameters to disk.</p>
<pre><code class="language-simics">simics&gt; <strong>board.software.tracker.detect-parameters symbol-file=System.map -load param-file=detect.params</strong>
[board.software.tracker.tracker_obj info] Detecting settings using 1 processor(s)
[board.software.tracker.tracker_obj info] Failed to detect kernel module parameters
[board.software.tracker.tracker_obj info] Successfully detected parameters
Saved autodetected parameters to detect.params
</code></pre>
</li>
<li>
<p><span class="term" id="linux-tracker.html:dt:load-parameters"><a href="#linux-tracker.html:dt:load-parameters">load-parameters</a></span><br>
Load configuration parameters for the Linux tracker from a file.</p>
<pre><code class="language-simics">simics&gt; <strong>board.software.tracker.load-parameters detect.params</strong>
&lt;
</code></pre>
</li>
<li>
<p><span class="term" id="linux-tracker.html:dt:save-parameters"><a href="#linux-tracker.html:dt:save-parameters">save-parameters</a></span><br>
Save the current configuration parameters to a file.</p>
<pre><code class="language-simics">simics&gt; <strong>board.software.tracker.save-parameters saved.params</strong>
&lt;
</code></pre>
</li>
<li>
<p><span class="term" id="linux-tracker.html:dt:supports-parameters"><a href="#linux-tracker.html:dt:supports-parameters">supports-parameters</a></span><br>
Check if a parameters file is supported by the Linux tracker.</p>
<pre><code class="language-simics">simics&gt; <strong>board.software.tracker.supports-parameters saved.params</strong>
Parameters of kind linux_tracker are supported by board.software.tracker
</code></pre>
</li>
<li>
<p><span class="term" id="linux-tracker.html:dt:log-syscalls"><a href="#linux-tracker.html:dt:log-syscalls">log-syscalls</a></span><br>
Log system calls made by the Linux system.</p>
<pre><code class="language-simics">simics&gt; <strong>board.software.tracker.log-syscalls</strong>
&lt;
simics&gt; <strong>c</strong>
[board.software.tracker.mapper_obj info] Syscall: 'nanosleep' (35) on node 948 (board.mb.cpu0.core[0][0])
</code></pre>
</li>
</ul>
</div>    
<h2 id="linux-tracker.html:availability"><a href="#linux-tracker.html:availability">2.13.3 Availability</a></h2>
<p>This section gives an overview of systems that are known to work for the Linux tracker. It has been tested on many systems in order to verify that it works using the Linux kernel versions listed in the figure <a class="reference" href="#linux-tracker.html:linux-kernel-versions">3</a>. However, as it is dependent on specific kernel configuration it may not work for a given system even if the kernel version is the same. Even if a kernel version is not listed here as tested it might still work with the tracker.</p>
<p>The following keywords are used in figure <a class="reference" href="#linux-tracker.html:linux-kernel-versions">3</a> and figure <a class="reference" href="#linux-tracker.html:linux-system-versions">4</a>:</p>
<div class="dl">
<ul>
<li><span class="term" id="linux-tracker.html:dt:kernel-thread"><a href="#linux-tracker.html:dt:kernel-thread">Kernel thread</a></span><br>
Indicates if the tracker supports tracking individual kernel threads.</li>
</ul>
</div>
<div class="dl">
<ul>
<li><span class="term" id="linux-tracker.html:dt:arch"><a href="#linux-tracker.html:dt:arch">Arch</a></span><br>
The target architecture.</li>
</ul>
</div>
<div class="dl">
<ul>
<li><span class="term" id="linux-tracker.html:dt:version"><a href="#linux-tracker.html:dt:version">Version</a></span><br>
Indicates the operating system version, or distribution version known to work.</li>
</ul>
</div>
<figure id="linux-tracker.html:linux-kernel-versions">
<table><thead><tr><th>Arch</th><th>Version</th><th>Kernel threads</th></tr></thead><tbody>
<tr><td>arcv2</td><td>4.2</td><td>yes</td></tr>
<tr><td>arm32</td><td>2.6</td><td>no</td></tr>
<tr><td>arm32</td><td>3.3</td><td>no</td></tr>
<tr><td>arm64</td><td>5.0</td><td>no</td></tr>
<tr><td>mips64</td><td>2.6</td><td>yes</td></tr>
<tr><td>ppc32</td><td>2.6</td><td>yes</td></tr>
<tr><td>ppc32</td><td>3.8</td><td>yes</td></tr>
<tr><td>ppc64</td><td>2.6</td><td>no</td></tr>
<tr><td>x86</td><td>2.6</td><td>no</td></tr>
<tr><td>x86</td><td>3.7</td><td>no</td></tr>
<tr><td>x86_64</td><td>2.6</td><td>no</td></tr>
<tr><td>x86_64</td><td>4.18</td><td>no</td></tr>
</tbody></table>
<figcaption>Figure 3. Tested Linux Kernel Versions</figcaption>
</figure>
<figure id="linux-tracker.html:linux-system-versions">
<table><thead><tr><th>Arch</th><th>Version</th></tr></thead><tbody>
<tr><td>arm32</td><td>Wind River Linux 4.3</td></tr>
<tr><td>ppc32</td><td>Wind River Linux 3.0</td></tr>
<tr><td>ppc32</td><td>Wind River Linux 4.3</td></tr>
<tr><td>ppc32</td><td>Wind River Linux 5.0</td></tr>
<tr><td>ppc64</td><td>Wind River Linux 5.0</td></tr>
<tr><td>x86</td><td>Wind River Linux 4.3</td></tr>
<tr><td>x86_64</td><td>Wind River Linux 3.0</td></tr>
<tr><td>x86_64</td><td>Wind River Linux 4.0</td></tr>
<tr><td>x86_64</td><td>Wind River Linux 4.3</td></tr>
</tbody></table>
<figcaption>Figure 4. Supported Linux Systems</figcaption>
</figure>
<h2 id="linux-tracker.html:system-calls"><a href="#linux-tracker.html:system-calls">2.13.4 System Calls</a></h2>
<p>The Linux tracker will generate events (see section <a class="reference" href="#event-system.html">2.6</a>) when system calls are made in the target software. The name of the event will be <em>"syscall"</em>. A system call notification can be registered in the following way:</p>
<pre><code>
notify_event(node_id, "syscall", recursive, syscall_cb, data)
</code></pre>
<p>The <em>event_data</em> argument of the callback will be a dictionary containing the system call number and name:</p>
<pre><code>{'name': &lt;name&gt;, 'number': &lt;number&gt;}
</code></pre>
<p>The Linux tracker will try to translate the system call number into the system call name, such as <code>fork</code> or <code>write</code>, if no translation is available the name will be <code>unknown</code>.</p>
<h2 id="linux-tracker.html:kernel-modules"><a href="#linux-tracker.html:kernel-modules">2.13.5 Kernel Modules</a></h2>
<p>The Linux tracker can be used to track which kernel modules are loaded and at what addresses their sections are loaded at. This information will then be provided to the debugger. This feature is only supported for x86-64 and arm64 architectures, but could potentially work for other architectures as well.</p>
<p>There is a <code>&lt;linux_tracker&gt;.list-kernel-modules</code> command on the Linux tracker object and the tracker composition object. This can be used to display all known modules and their sections. Use <code>help</code> on that command for options.</p>
<p>In order for kernel modules to be tracked, parameter detection (see <a class="reference" href="#linux-tracker.html:system-configuration">2.13.6</a>) symbols have to be provided and must contain the 'modules' symbol. If plain symbols (usually <code>kallsyms</code> or <code>System.map</code>) are provided, then there must be at least one kernel modules inserted and live in order to be able to find kernel modules parameters. Also it is likely needed that at least one processor is running the kernel while performing the detection. If an ELF symbol file (usually <code>vmlinux</code>) with debug information is provided then kernel module parameters can be found without having to have any module currently loaded.</p>
<p>Kernel modules will be included by default in the parameters if found, but can be enforced to be found by using the <em>kernel-modules</em> argument to the <code>&lt;linux_tracker&gt;.detect-parameters</code> command and setting it to <code>TRUE</code>. Detection will then fail if kernel module parameters are not found. To leave out tracking kernel modules, instead set this argument to <code>FALSE</code>.</p>
<p>In order for the debugger to be able to find the kernel module binaries, the <code>&lt;linux_tracker&gt;.set-kernel-module-path</code> can be used. This should specify the base directory on the host where the kernel module binaries (with <code>.ko</code> extension) that should be debugged on the target system are located. That directory and it's sub-directories will be scanned for kernel modules and then they will be matched against modules found by the tracker. In order for modules to be matched with files under this path, the file must be named as the kernel module, with the exception that the file can have a hyphen (<code>-</code>) where the name has an underscore (<code>_</code>), and excluding the <code>.ko</code> suffix.</p>
<p>When the kernel module path is passed to the debugger it will apply any added path maps to the path, meaning that this can be re-mapped to another location using the debugger's <code>add-pathmap-entry</code> command.</p>
<p>Another way to debug one or a few kernel modules is to apply path maps for each kernel module name, to the matching kernel module <code>.ko</code> binary on disk. Something like:</p>
<pre><code> add-pathmap-entry foo_module /tmp/kernel-build/modules/foo-module.ko
</code></pre>
<p>Kernel modules can usually not be found if the tracker is enabled while all processors are running outside of the kernel. When that occurs, finding the initial kernel modules will be postponed until a processor has entered the kernel and proper page tables are loaded.</p>
<h2 id="linux-tracker.html:system-configuration"><a href="#linux-tracker.html:system-configuration">2.13.6 System Configuration</a></h2>
<p>The Linux tracker depends on its parameters file in order to know how to track the target software. If the target software is updated with a new or reconfigured kernel the parameters needs to be regenerated. This can be done with the <code>detect-parameters</code> command. In order for the parameters detection to work the Linux system must be booted. The <code>detect-parameters</code> command may also require some arguments in order to succeed with the detection, see the build-in help for further details. Use the <code>-load</code> flag to load the detected parameters directly.</p>
<p>If the system does not contain any OS Awareness software object at all, the system will have to be configured as described in section <a class="reference" href="#os-awareness-scripts.html">2.9</a>. After the OS Awareness object has been created, the Linux tracker composition objectcan be added with the <code>insert-tracker</code> command. The <em>tracker</em> argument should be the <code>linux_tracker_comp</code> module.</p>
<h2 id="linux-tracker.html:limitations"><a href="#linux-tracker.html:limitations">2.13.7 Limitations</a></h2>
<ul>
<li>The Linux <code>detect-parameters</code> command can in rare cases take up to ten minutes to complete.</li>
<li>Trackers that support kernel space information only provide a best effort view. The tracker will only show what the OS reports as active, it will not trace exceptions, interrupts, short lived work that is re-using another context, etc that does not cause a context switch. In addition to that, a userspace process executing in the kernel space will report its activity under the Other node.</li>
<li>The <a class="reference" href="#linux-tracker.html:availability">2.13.3</a> section list system configurations that the tracker is known to work on; it may very well work on other systems as well. However, even small configuration changes (especially kernel configuration options and shell) may cause the tracker to not work on the same kernel; this is usually not a problem.</li>
<li>Shutting down or rebooting an OS while having an active tracker is not supported.</li>
<li>Process relationship, such as a process' parent, children, or siblings, is not exposed in the node tree.</li>
<li>The MIPS64 Linux tracker can only find the current task when breaking at the <code>finish_task_switch</code> function. So no tasks will be found directly after a <code>enable-tracker</code> command, instead tasks will be found after that function has run.</li>
<li>The MIPS64 tracker requires a symbol file containing the <code>finish_task_switch</code> symbol when detecting parameters.</li>
<li>The ARCv2 tracker requires a symbol file containing the <code>_current_task</code> symbol when detecting parameters.</li>
<li>The ARM64 tracker can only track 64-bit tasks correctly. For 32-bit tasks syscalls and binary properties will be incorrect.</li>
<li>The tracker will not work for an ARM 32-bit Linux running on an ARM64 processor.</li>
<li>For x86-64 there is limited support for a Linux target that runs KVM guests. The tracker will ignore any haps or memory accesses that the guest performs, but no tracking of the guest is available. This support can be disabled by clearing the <code>enable_vm_support</code> attribute.</li>
<li>For other targets than x86-64 there is no support for Linux targets with KVM guests running.</li>
<li>Kernels with randomized base (<code>RANDOMIZE_BASE</code> kernel configuration option) are only supported for x86-64.</li>
<li>The Linux tracker does not work together with VMP. VMP will be disabled automatically when the tracker is enabled.</li>
</ul>
</section><section class="page" id="cpumode-tracker.html"><h1 id="cpumode-tracker.html:cpu-mode-tracker"><a href="#cpumode-tracker.html:cpu-mode-tracker">2.14 CPU Mode Tracker</a></h1>
<p>The CPU mode tracker, in module <code>cpumode-software-tracker</code>, tracks processor state for the processors of a system. It will keep track of which mode each processor is active in. This tracker can for example be useful to track when an operating system is active in kernel mode and when it is running a user program for an operating system for which there is no dedicated tracker available.</p>
<p>In order to use the CPU mode tracker use the <code>insert-tracker</code> command with the <code>cpumode_software_tracker_comp</code> class as <em>tracker</em>, see section <a class="reference" href="#os-awareness-configuration.html">2.8</a> for more information about tracker configuration.</p>
<h2 id="cpumode-tracker.html:node-tree"><a href="#cpumode-tracker.html:node-tree">2.14.1 Node Tree</a></h2>
<p>Figure <a class="reference" href="#cpumode-tracker.html:cpumode-tracker-tree">5</a> shows an example of the CPU mode node tree representation. One of the right-most nodes will be active on each processor depending on the mode that the processor is currently running in. In other words, one of the nodes 4, 5 or 6 will be active for <code>cpu0</code> and one of the nodes 7, 8 or 9 will be active for <code>cpu1</code>.</p>
<figure id="cpumode-tracker.html:cpumode-tracker-tree">
<p><img alt="" src="cpumode-tracker-tree.png"></p><figcaption>Figure 5. Node tree of a CPU mode tracker</figcaption><p></p>
</figure>
</section><section class="page" id="partition-tracker.html"><h1 id="partition-tracker.html:partition-tracker"><a href="#partition-tracker.html:partition-tracker">2.15 Partition tracker</a></h1>
<p>The Partition tracker is used to add separate trackers for different processors in the system. This can be useful if different operating systems are run on different processors.</p>
<p>The partition tracker is a stacked tracker where other trackers will be inserted as guests to the partition tracker.</p>
<h2 id="partition-tracker.html:node-tree"><a href="#partition-tracker.html:node-tree">2.15.1 Node tree</a></h2>
<p>This section describes how the partition tracker is represented in a node tree.</p>
<p>The partition tracker will be at the root of the node tree. Then each guest of the partition tracker will be represented with that guests representation of a node tree rooted at a child node of the partition tracker root node. A partition can also be empty, meaning that it does not contain any guest tracker.</p>
<p>Figure <a class="reference" href="#partition-tracker.html:partition-tracker-tree">6</a> shows an example of how a node tree, containing a partition tracker with two cpu mode trackers and an empty partition as guests, could look like.</p>
<figure id="partition-tracker.html:partition-tracker-tree">
<p><img alt="" src="partition-tracker-tree.png"></p><figcaption>Figure 6. Node tree of a Linux tracker</figcaption><p></p>
</figure>
<div class="dl">
<ul>
<li>
<p><span class="term" id="partition-tracker.html:dt:guest-node"><a href="#partition-tracker.html:dt:guest-node">Guest node</a></span><br>
(Nodes on level 1 in figure <a class="reference" href="#partition-tracker.html:partition-tracker-tree">6</a>.) This node will contain the root node of the guest inserted under the partition tracker. Two extra properties will be added to this node besides the guest tracker's original root properties.</p>
  <div class="dl">
<ul>
<li><span class="term" id="partition-tracker.html:dt:part_id"><a href="#partition-tracker.html:dt:part_id">part_id</a></span><br>
A unique identifier for each guest partition.</li>
<li><span class="term" id="partition-tracker.html:dt:cpus"><a href="#partition-tracker.html:dt:cpus">cpus</a></span><br>
A list of processors assigned to the partition.</li>
</ul>
  </div>
<p>By default the <code>name</code> property of the node will also be updated so that the name is prefixed with the partition name. This updating of the name can be removed by setting the <code>include_partition_name</code> attribute of the partition mapper to false.</p>
</li>
</ul>
</div>
<h2 id="partition-tracker.html:commands"><a href="#partition-tracker.html:commands">2.15.2 Commands</a></h2>
<p>The partition tracker includes some commands to manage guest partitions and parameters.</p>
<div class="dl">
<ul>
<li>
<p><span class="term" id="partition-tracker.html:dt:insert-empty-partition"><a href="#partition-tracker.html:dt:insert-empty-partition">insert-empty-partition</a></span><br>
Inserts a new partition that is not associated with any tracker. Some processors, <em>cpus</em>, have to be set for this partition and a partition name, <em>partition</em>, will also have to be specified. This partition will show up in the node tree when the OS Awareness framework is enabled, but that node will not have any children or be active at any point. A guest tracker can later be added to this node with the <code>insert-tracker</code> command.</p>
</li>
<li>
<p><span class="term" id="partition-tracker.html:dt:insert-tracker"><a href="#partition-tracker.html:dt:insert-tracker">insert-tracker</a></span><br>
Inserts a new partition associated with a tracker component either on an existing empty node or as a new guest partition.</p>
<p>The component of the guest tracker is specified through the <em>tracker</em> argument of this command.</p>
<p>If adding a new guest, some processors associated with the partition will have to be specified through the <em>cpus</em> argument and a partition name has to be specified through the <em>partition</em> argument.</p>
<p>If a new tracker is added to an empty guest, the <em>node</em> argument is used to specify which guest node to insert the tracker on.</p>
<p>Optionally parameters can be passed on to the guest component via the <em>parameters</em> argument.</p>
<p>The component of the guest will end up in the component hierarchy under the partition tracker component, named either as the specified <em>name</em> argument or as the partition name prefixed with <code>guest</code>.</p>
</li>
<li>
<p><span class="term" id="partition-tracker.html:dt:remove-partition"><a href="#partition-tracker.html:dt:remove-partition">remove-partition</a></span><br>
Remove an existing partition by selecting either a <em>partition</em> name, a partition <em>node</em> or a partition <em>id</em>.</p>
</li>
<li>
<p><span class="term" id="partition-tracker.html:dt:load-parameters"><a href="#partition-tracker.html:dt:load-parameters">load-parameters</a></span><br>
Load configuration parameters for the partition tracker from a file.</p>
</li>
<li>
<p><span class="term" id="partition-tracker.html:dt:save-parameters"><a href="#partition-tracker.html:dt:save-parameters">save-parameters</a></span><br>
Save the current configuration parameters to a file. If the <em>no-children</em> argument is given the parameters of the guest trackers will not be included in the saved file, it will then just include the partition tracker and which type of guests it has. By default the guest trackers parameters are also saved in the configuration file.</p>
</li>
<li>
<p><span class="term" id="partition-tracker.html:dt:supports-parameters"><a href="#partition-tracker.html:dt:supports-parameters">supports-parameters</a></span><br>
Check if parameters file is supported by the partition tracker.</p>
</li>
</ul>
</div>
<h2 id="partition-tracker.html:limitations"><a href="#partition-tracker.html:limitations">2.15.3 Limitations</a></h2>
<ul>
<li>Inserting a guest tracker and adding parameters to that guest at the same time might not work for all guest trackers as processors will not yet be available to the guest when the parameters are set. The Linux tracker for example requires to be able to get all processors from its parent when setting parameters and will fail if parameters are set directly when inserting it as a guest under a partition tracker. The workaround is to first add it as a guest tracker and then load parameters for that guest afterwards.</li>
<li>If enabling or adding processors fails for some guest the partition tracker will not take care of disabling or removing processors for already enabled guests.</li>
</ul>
</section><section class="page" id="uefi-fw-trk.html"><h1 id="uefi-fw-trk.html:uefi-firmware-tracker"><a href="#uefi-fw-trk.html:uefi-firmware-tracker">2.16 UEFI Firmware Tracker</a></h1>
<p>The <em>UEFI Firmware Tracker</em> tracks UEFI, Intel® Slim Bootloader (Intel® SBL) and Intel® Firmware Support Package (Intel® FSP) module loading and unloading to allow source code debugging of UEFI systems. The UEFI Firmware Tracker is implemented as an <em>OS Awareness</em> component. Read more about OS Awareness in chapter <a class="reference" href="#target-software-tracking.html">2</a>.</p>
<p>Supported target platforms for the tracker are X86 and ARM64.</p>
<p>While the tracker works on both Windows and Linux and can track UEFI, Intel® Slim Bootloader (Intel® SBL) and Intel® FSP, there are some details to consider when it comes to <em>source code debugging</em>, see section <a class="reference" href="#uefi-fw-trk.html:source-code-debugging">2.16.3</a>.</p>
<h2 id="uefi-fw-trk.html:tracking-techniques"><a href="#uefi-fw-trk.html:tracking-techniques">2.16.1 Tracking Techniques</a></h2>
<p>Knowing how the UEFI tracker works is optional, but understanding the basics may be useful during configuration. Tracking is handled with several techniques which handles modules loaded in the different UEFI phases.</p>
<p>The below tables lists the <em>tracking techniques</em> available on <em>X86</em> (figure <a class="reference" href="#uefi-fw-trk.html:uefi-fw-trk-tracking-techniques-x86">7</a>) and <em>ARM64</em> (figure <a class="reference" href="#uefi-fw-trk.html:uefi-fw-trk-tracking-techniques-arm64">8</a>) and for which phases, or modules the tracking techniques work. Note that some tracking techniques may find other module types as well. However, it may not support unload for example.</p>
<figure id="uefi-fw-trk.html:uefi-fw-trk-tracking-techniques-x86">
<table><thead><tr><th><strong>Tracking Technique</strong></th><th><strong>Default</strong></th><th><strong>SEC and PEI (static)</strong></th><th><strong>PEI (dynamic)</strong></th><th><strong>DXE</strong></th><th><strong>SMM</strong></th><th><strong>Intel® FSP</strong></th></tr></thead><tbody>
<tr><td>Map File</td><td>Disabled</td><td>Yes</td><td>—</td><td>—</td><td>—</td><td>—</td></tr>
<tr><td>Pre-DXE</td><td>Disabled</td><td>—</td><td>Yes</td><td>—</td><td>—</td><td>—</td></tr>
<tr><td>DXE</td><td>Enabled</td><td>—</td><td>—</td><td>Yes</td><td>—</td><td>—</td></tr>
<tr><td>SMM</td><td>Enabled</td><td>—</td><td>—</td><td>—</td><td>Yes</td><td>—</td></tr>
<tr><td>Execution <a href="#uefi-fw-trk.html:uefi-fw-trk-tracking-techniques-footnote-x86-1">(1)</a><a href="#uefi-fw-trk.html:uefi-fw-trk-tracking-techniques-footnote-x86-2">(2)</a></td><td>Enabled</td><td>Yes</td><td>Yes</td><td>—</td><td>—</td><td>Yes</td></tr>
<tr><td>Notification <a href="#uefi-fw-trk.html:uefi-fw-trk-tracking-techniques-footnote-x86-2">(2)</a></td><td>Enabled</td><td>Yes</td><td>Yes</td><td>Yes <a href="#uefi-fw-trk.html:uefi-fw-trk-tracking-techniques-footnote-x86-3">(3)</a></td><td>—</td><td>—</td></tr>
<tr><td>Reset <a href="#uefi-fw-trk.html:uefi-fw-trk-tracking-techniques-footnote-x86-2">(4)</a></td><td>Enabled</td><td>—</td><td>—</td><td>—</td><td>—</td><td>—</td></tr>
<tr><td>OS Hand-off <a href="#uefi-fw-trk.html:uefi-fw-trk-tracking-techniques-footnote-x86-4">(5)</a></td><td>Enabled</td><td>—</td><td>—</td><td>—</td><td>—</td><td>—</td></tr>
</tbody></table>
<table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td><span id="uefi-fw-trk.html:uefi-fw-trk-tracking-techniques-footnote-x86-1"><strong>(1)</strong></span></td><td>Detection of module unload is not supported.</td></tr>
<tr><td><span id="uefi-fw-trk.html:uefi-fw-trk-tracking-techniques-footnote-x86-2"><strong>(2)</strong></span></td><td>Will not remove SEC and PEI modules when UEFI enters DXE (which DXE tracking supports).</td></tr>
<tr><td><span id="uefi-fw-trk.html:uefi-fw-trk-tracking-techniques-footnote-x86-3"><strong>(3)</strong></span></td><td>Requires that UEFI has been updated with notification support, see appendix <a class="reference" href="#uefi-fw-trk-uefi-notification-update.html">B</a>.</td></tr>
<tr><td><span id="uefi-fw-trk.html:uefi-fw-trk-tracking-techniques-footnote-x86-4"><strong>(4)</strong></span></td><td><em>Reset tracking</em> does not track modules but will clear the module list when detecting a processor reset.</td></tr>
<tr><td><span id="uefi-fw-trk.html:uefi-fw-trk-tracking-techniques-footnote-x86-5"><strong>(5)</strong></span></td><td><em>OS Hand-off tracking</em> does not track modules, but improves simulation performance while executing the OS..</td></tr>
</tbody></table>
<figcaption>Figure 7.  Tracking techniques available on X86 targets. </figcaption>
</figure>
<figure id="uefi-fw-trk.html:uefi-fw-trk-tracking-techniques-arm64">
<table><thead><tr><th><strong>Tracking Technique</strong></th><th><strong>Default</strong></th><th><strong>SEC and PEI (static)</strong></th><th><strong>PEI (dynamic)</strong></th><th><strong>DXE</strong></th></tr></thead><tbody>
<tr><td>Map File</td><td>Disabled</td><td>Yes</td><td>—</td><td>—</td></tr>
<tr><td>DXE</td><td>Enabled</td><td>—</td><td>—</td><td>Yes</td></tr>
<tr><td>Execution <a href="#uefi-fw-trk.html:uefi-fw-trk-tracking-techniques-footnote-arm64-1">(1)</a><a href="#uefi-fw-trk.html:uefi-fw-trk-tracking-techniques-footnote-arm64-2">(2)</a></td><td>Enabled</td><td>Yes</td><td>Yes</td><td>—</td></tr>
</tbody></table>
<table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td><span id="uefi-fw-trk.html:uefi-fw-trk-tracking-techniques-footnote-arm64-1"><strong>(1)</strong></span></td><td>Detection of module unload is not supported.</td></tr>
<tr><td><span id="uefi-fw-trk.html:uefi-fw-trk-tracking-techniques-footnote-arm64-2"><strong>(2)</strong></span></td><td>Will not remove SEC and PEI modules when UEFI enters DXE (which DXE tracking supports).</td></tr>
</tbody></table>
<figcaption>Figure 8.  Tracking techniques available on ARM64 targets </figcaption>
</figure>
<h2 id="uefi-fw-trk.html:commands"><a href="#uefi-fw-trk.html:commands">2.16.2 Commands</a></h2>
<p>The UEFI firmware tracker commands are used to configure the tracker and also to provide information about the UEFI system. The commands are:</p>
<div class="dl">
<ul>
<li>
<p><span class="term" id="uefi-fw-trk.html:dt:uefi_fw_tracker-detect-parameters"><a href="#uefi-fw-trk.html:dt:uefi_fw_tracker-detect-parameters"><code>&lt;uefi_fw_tracker&gt;.detect-parameters</code></a></span><br>
Detect parameters and load them directly by using the <code>-load</code> flag. Example for the target <code>viper</code>:</p>
<pre><code>viper.software.tracker.detect-parameters -load
</code></pre>
<p>Parameters can also be saved to a parameter file which can then be loaded with <code>&lt;uefi_fw_tracker&gt;.load-parameters</code>. Use the <em>param-file</em> argument to specify a file to save.</p>
</li>
<li>
<p><span class="term" id="uefi-fw-trk.html:dt:uefi_fw_tracker-load-parameters"><a href="#uefi-fw-trk.html:dt:uefi_fw_tracker-load-parameters"><code>&lt;uefi_fw_tracker&gt;.load-parameters</code></a></span><br>
Load configuration parameters for the tracker from a configuration parameter file such a file created by <code>&lt;uefi_fw_tracker&gt;.detect-parameters</code>. Example for the target <code>viper</code>:</p>
<pre><code>viper.software.tracker.load-parameters
</code></pre>
</li>
<li>
<p><span class="term" id="uefi-fw-trk.html:dt:uefi_fw_tracker-info"><a href="#uefi-fw-trk.html:dt:uefi_fw_tracker-info"><code>&lt;uefi_fw_tracker&gt;.info</code></a></span><br>
Show information on how the tracker was configured. Example for the target <code>viper</code>:</p>
<pre><code>viper.software.tracker.info
</code></pre>
</li>
<li>
<p><span class="term" id="uefi-fw-trk.html:dt:uefi_fw_tracker-status"><a href="#uefi-fw-trk.html:dt:uefi_fw_tracker-status"><code>&lt;uefi_fw_tracker&gt;.status</code></a></span><br>
Show the tracker enabled state, list all UEFI modules currently loaded, and show various UEFI system information. Example for the target <code>viper</code>:</p>
<pre><code>viper.software.tracker.status
</code></pre>
</li>
<li>
<p><span class="term" id="uefi-fw-trk.html:dt:uefi_fw_tracker_comp-list-modules-or-uefi_fw_mapper-list-modules"><a href="#uefi-fw-trk.html:dt:uefi_fw_tracker_comp-list-modules-or-uefi_fw_mapper-list-modules"><code>&lt;uefi_fw_tracker_comp&gt;.list-modules</code> or <code>&lt;uefi_fw_mapper&gt;.list-modules</code></a></span><br>
List the UEFI modules that the tracker is aware of. To list all modules, specify <code>max=0</code>.</p>
</li>
</ul>
</div>
<p>For more information about the commands, see:</p>
<ul>
<li>section <a class="reference" href="#osa-commands.html:controlling">2.3.1</a> for an overview of the OS Awareness set of commands, and</li>
<li>command help information in <em>Simics CLI</em>:
<pre><code>
simics&gt; load-module uefi-fw-tracker
simics&gt; help uefi_fw_tracker
  
</code></pre>
</li>
</ul>
<h2 id="uefi-fw-trk.html:source-code-debugging"><a href="#uefi-fw-trk.html:source-code-debugging">2.16.3 Source Code Debugging</a></h2>
<p>In order for source code debugging to work, there are some requirements that must be met:</p>
<ol>
<li>The <em>host type</em> in combination with the <em>compiler tool chain</em> used to compile UEFI must be <em>supported</em> (see table in Figure <a class="reference" href="#uefi-fw-trk.html:uefi-fw-trk-debugging-host-compiler">9</a>).</li>
<li>The UEFI system must have been compiled with <em>debug information</em>.</li>
<li>The debug information and source files must be <em>available to TCF</em>.</li>
</ol>
<figure id="uefi-fw-trk.html:uefi-fw-trk-debugging-host-compiler">
<table><thead><tr><th><strong>Compiler Tool Chain</strong></th><th><strong>Microsoft Windows</strong></th><th><strong>Linux</strong></th></tr></thead><tbody>
<tr><td>Microsoft Visual Studio</td><td>Supported <a href="#uefi-fw-trk.html:uefi-fw-trk-debugging-dbghelp">(1)</a></td><td>—</td></tr>
<tr><td>ELF/DWARF compiler such as GCC</td><td>Supported</td><td>Supported</td></tr>
</tbody></table>
<table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td><span id="uefi-fw-trk.html:uefi-fw-trk-debugging-dbghelp"><strong>(1)</strong></span></td><td>Requires that DBGHELP.DLL is available to TCF.</td></tr>
</tbody></table>
<figcaption>Figure 9. Supported combinations of of *host type* and *compiler tool chain*</figcaption>
</figure>
<p>To get the best source code debugging experience when debugging UEFI (or any other binary), please compile with as <em>much debug information</em> as possible and as <em>little optimization</em>as possible.</p>
<p>If copying an already built UEFI system from another computer, it is important to <em>keep</em> files that are needed for debugging. There is usually a <code>DEBUG</code> folder for each UEFI module that contains the files needed for debugging, and it is important that at least the some of the files are kept. As an example, lets say that the module <code>SecCore</code> has a directory <code>Build/.../SecCore/DEBUG</code>. Then at least the following files <em>must be kept</em></p>
<table><thead><tr><th><strong>Microsoft Visual Studio</strong></th><th><strong>ELF/DWARF compiler such as GCC</strong></th></tr></thead><tbody>
<tr><td>SecMain.efi</td><td>SecMain.efi</td></tr>
<tr><td>SecMain.dll</td><td>SecMain.dll</td></tr>
<tr><td>SecMain.pdb</td><td>SecMain.debug</td></tr>
</tbody></table>
<h2 id="uefi-fw-trk.html:configuration"><a href="#uefi-fw-trk.html:configuration">2.16.4 Configuration</a></h2>
<p>Some platform start scripts come with UEFI Firmware Tracker support. If that is not the case, a tracker configuration must be added.</p>
<p>Here is an example of how to configure the <em>viper</em> system. For more in-depth information on OS Awareness configurations, read section <a class="reference" href="#os-awareness-scripts.html">2.9</a>.</p>
<pre><code>
# Specify the file that will contain the tracker parameters.
if not defined tracker_params { $tracker_params = "uefi.params" }

# Load uefi-fw-tracker and insert it into the tracker hierarchy.
load-module uefi-fw-tracker
viper.software.insert-tracker tracker = uefi_fw_tracker_comp

# Detect the parameters which will be written to the $tracker_params.
viper.software.tracker.detect-parameters -overwrite param-file = $tracker_params

# Load the parameters.
viper.software.tracker.load-parameters $tracker_params

# Enable the tracker.
viper.software.enable-tracker
  
</code></pre>
<p>If the target configuration scripts configures another OS-Awareness tracker, this should be deleted first with the command <code>&lt;os_awareness&gt;.delete-tracker</code>, for example:</p>
<pre><code>
# Delete the current tracker to allow configuration of the UEFI tracker.
viper.software.delete-tracker
  
</code></pre>
<p>After incorporating the tracker configuration and starting the simulation, you can debug the system with the debugger commands in <em>Simics CLI</em>. For more information about debugging with Simics in general, see chapter <a class="reference" href="#debugging-target-code.html">3</a>.</p>
<h2 id="uefi-fw-trk.html:troubleshooting"><a href="#uefi-fw-trk.html:troubleshooting">2.16.5 Troubleshooting</a></h2>
<p>This section describes common problems and how to fix them.</p>
<ul>
<li>
<p>If <strong>debugging of UEFI</strong> does not work correctly, please perform the following steps in order:</p>
<ul>
<li>Start by troubleshooting <strong>tracking problems</strong> in figure <a class="reference" href="#uefi-fw-trk.html:uefi-fw-trk-troubleshoot-tracker-configuration">10</a>, <a class="reference" href="#uefi-fw-trk.html:uefi-fw-trk-troubleshoot-by-running-forward">11</a>, and <a class="reference" href="#uefi-fw-trk.html:uefi-fw-trk-troubleshoot-uefi-advanced">12</a> These steps are needed to be sure that the tracker configuration is correct enough to allow <em>finding at least one UEFI module</em>.</li>
<li>When the tracker works well enough to at least find an UEFI module, but debugging problems remain, continue to <strong>troubleshoot debugging</strong> in figure <a class="reference" href="#uefi-fw-trk.html:uefi-fw-trk-troubleshoot-stack-trace">13</a>, <a class="reference" href="#uefi-fw-trk.html:uefi-fw-trk-troubleshoot-visual-studio-build">14</a> and <a class="reference" href="#uefi-fw-trk.html:uefi-fw-trk-troubleshoot-module-problems">15</a></li>
</ul>
</li>
<li>
<p>If the problem is that the UEFI tracker degrades <strong>simulation performance</strong>:</p>
<ul>
<li>
<p>If the code or situation that demands debugging can be reached by running simulation <em>a specific time</em> or by setting for example an address breakpoint (which does not require debug information and hence not a tracker either):</p>
<ol>
<li>Start the simulation without the tracker enabled.</li>
<li>Run until the time or address that requires debugging</li>
<li>Enable the tracker to allow source code debugging</li>
</ol>
<p>Unless rebuilding UEFI is needed and the same code needs to be debugged several times, saving a checkpoint (<code>write-configuration</code>) after reaching the situation that requires debugging, and for subsequent steps, load the checkpoint (<code>read-configuration</code>), <em>and then</em> enable the tracker may be an option.</p>
</li>
</ul>
<ol>
<li><em>Pre-DXE tracking</em> has a lot of performance penalty. If <em>Pre-DXE tracking</em> is used, consider if <em>Execution tracking</em> can be used instead.</li>
</ol>
</li>
</ul>
<figure id="uefi-fw-trk.html:uefi-fw-trk-troubleshoot-tracker-configuration">
<p><img alt="" src="uefi-fw-tracker-trshoot-tracker-configuration.png"></p>
<ul>
<li>(1) See section <a class="reference" href="#uefi-fw-trk.html:configuration">2.16.4</a>.</li>
<li>(2) See section <a class="reference" href="#tracker-activation.html">2.1</a>.</li>
</ul>
<figcaption>Figure 10. Troubleshoot the tracker configuration</figcaption>
</figure>
<figure id="uefi-fw-trk.html:uefi-fw-trk-troubleshoot-by-running-forward">
<p><img alt="" src="uefi-fw-tracker-trshoot-by-running-forward.png"></p><figcaption>Figure 11. Troubleshoot by running forward. Not every address (for example the reset vector) has debug information.</figcaption><p></p>
</figure>
<figure id="uefi-fw-trk.html:uefi-fw-trk-troubleshoot-uefi-advanced">
<p><img alt="" src="uefi-fw-tracker-trshoot-tracker-advanced.png"></p>
<ul>
<li>(1) See section <a class="reference" href="#uefi-fw-trk.html:tracking-techniques">2.16.1</a>.</li>
<li>(2) See section <a class="reference" href="#uefi-fw-trk.html:configuration">2.16.4</a>.</li>
</ul>
<figcaption>Figure 12. Troubleshoot tracking advanced</figcaption>
</figure>
<figure id="uefi-fw-trk.html:uefi-fw-trk-troubleshoot-stack-trace">
<p><img alt="" src="uefi-fw-tracker-trshoot-stack-trace.png"></p>
<ul>
<li>(1) See the end of section <a class="reference" href="#talos-debugging-cli.html:configuration">3.1.2</a>.</li>
</ul>
<figcaption>Figure 13. Troubleshoot stack trace</figcaption>
</figure>
<figure id="uefi-fw-trk.html:uefi-fw-trk-troubleshoot-visual-studio-build">
<p><img alt="" src="uefi-fw-tracker-trshoot-visual-studio-build.png"></p>
<ul>
<li>(1) See appendix <a class="reference" href="#uefidbg-dbghelp.html">A</a>.</li>
</ul>
<figcaption>Figure 14. Troubleshoot debugging UEFI built with Visual Studio</figcaption>
</figure>
<figure id="uefi-fw-trk.html:uefi-fw-trk-troubleshoot-module-problems">
<p><img alt="" src="uefi-fw-tracker-trshoot-module-problems.png"></p>
<ul>
<li>(1) See the end of section <a class="reference" href="#talos-debugging-cli.html:configuration">3.1.2</a>.</li>
<li>(2) See section <a class="reference" href="#uefi-fw-trk.html:source-code-debugging">2.16.3</a>.</li>
</ul>
<figcaption>Figure 15. Troubleshoot module problems</figcaption>
</figure>
<h2 id="uefi-fw-trk.html:limitations"><a href="#uefi-fw-trk.html:limitations">2.16.6 Limitations</a></h2>
<ul>
<li>
<p>Debugging UEFI systems compiled with Visual Studio only works on Windows hosts and require <code>DBGHELP.DLL</code>.</p>
</li>
<li>
<p>When debugging UEFI systems compiled with Visual Studio, the paths to the module binaries must be shorter than 256 characters. This is a limitation in <code>DBGHELP.DLL</code>.</p>
</li>
<li>
<p>Pre-DXE tracking does not support tracking of Terse Executable (TE) modules.</p>
</li>
<li>
<p>When tracking the DXE phase, breakpoints are added on each 4 MB interval in the area specified by <em>dxe-start</em> and <em>dxe-size</em>. Any address within this range that cannot be read when the tracker is enabled is ignored. If the EFI_SYSTEM_TABLE_POINTER is placed in memory that is not readable when the tracker is enabled, DXE will not be detected. As a workaround, either toggle the tracker when in DXE, or set <code>enable_dxe_phase_mem_map_changed_hap</code> to true.</p>
 <div class="note">
<p>Setting <code>enable_dxe_phase_mem_map_changed_hap</code> has a severe performance impact on some systems.</p>
 </div>
</li>
<li>
<p>Multi socket system has not been tested and are not officially supported, but may work.</p>
</li>
<li>
<p>Only modules that have a PDB pointer containing a PDB file path can be tracked.</p>
</li>
<li>
<p>Execution tracking does not track unloading of modules.</p>
</li>
<li>
<p>For full SMM tracking both SMM and execution tracking modes must be enabled.</p>
</li>
<li>
<p>Only modules that have a module path (IMAGE) in the map-file will be tracked by the map-file tracker. If these modules have a valid PDB pointer, and are executed, it is possible to track them using the execution tracker.</p>
</li>
<li>
<p>On ARM64, <em>Pre-DXE tracking</em> is not supported. To track dynamic PEI modules, <em>Execution tracking</em> should be used.</p>
</li>
<li>
<p>On ARM64, <em>Reset tracking</em> is not supported. The recommended workaround is to add a breakpoint on reset, and toggle (disable and then enable) the tracker if reset occurs.</p>
</li>
</ul>
</section><section class="page" id="debugging-target-code.html"><h1 id="debugging-target-code.html:debugging-target-code"><a href="#debugging-target-code.html:debugging-target-code">3 Debugging Target Code</a></h1>
<p>Simics includes a command-line debugger that allows you to perform source level, multi-core, multi-target debugging of your target code running in Simics.</p>
<p>An API for scripting against the debugger is available, see section <a class="reference" href="#debugger-api.html">3.3</a>.</p>
</section><section class="page" id="talos-debugging-cli.html"><h1 id="talos-debugging-cli.html:the-command-line-debugger"><a href="#talos-debugging-cli.html:the-command-line-debugger">3.1 The Command Line Debugger</a></h1>
<p>This section provides an overview of the Simics command-line debugger and describes how its pieces work together. The tutorial in <em>Getting Started With Simics</em> describes how to use these commands in a complete workflow. For details about the commands, see the <em>Simics Reference Manual</em>.</p>
<p>Simics is a full-system simulator; in addition to the thing you are trying to debug, it probably runs a complete operating system (or several, under a hypervisor). To limit the scope of your debugging to just one process (or task, or kernel thread, etc.), you use an appropriate debug context. Each debug context corresponds to some part of the target system. It can be a processor or the memory space of a processor, or a software abstraction like a process or thread. There are also debug contexts that group other contexts. Section <a class="reference" href="#talos-debugging-cli.html:debug-contexts">3.1.1</a> describes debug contexts in more detail.</p>
<p>The debugger will only create debug contexts for the software in the system if you have configured OS awareness and enabled it. How to set up OS awareness is described in chapter <a class="reference" href="#target-software-tracking.html">2</a>. If you do not use OS awareness you can debug directly on the processors instead, but then the debugger will not track when the operating system on the target switches between different processes or tasks.</p>
<p>To do source level debugging you need to tell the debugger about the binaries (executable files and shared libraries) that the part of the system you want to debug is using. This is described in section <a class="reference" href="#talos-debugging-cli.html:configuration">3.1.2</a>. That section also explains how to tell the debugger where to find the source code for your program, if needed.</p>
<p>Section <a class="reference" href="#talos-debugging-cli.html:breakpoints">3.1.3</a> describes how to manage break- and watch-points with the command line frontend.</p>
<div class="note">
<p>This section only describes the C/C++ debugger specific concepts. You can still use any other Simics commands to help you debug your code.</p>
</div>
<h2 id="talos-debugging-cli.html:debug-contexts"><a href="#talos-debugging-cli.html:debug-contexts">3.1.1 Debug Contexts</a></h2>
<p>The debugger presents the target system as a set of debug contexts. Each debug context represents one interesting part of the system. It can be a software concept, like a process, a thread or a task, or a processor core or the physical memory space of a processor. To provide context there are also debug contexts that provide grouping, like a machine, or a group of all user space programs on a Linux system.</p>
<p>When you interact with debug contexts directly you usually interact with a context running code, such as a thread or a processor core. In this text we call such a debug context a <em>thread</em>. A thread allows you to step through the code and to inspect variables scoped to the current location in the code.</p>
<p>By default Simics does not activate the debugger; global stepping commands, etc will be directed at the current processor in Simics, and not to a debug context. There are two ways to activate the debugger and get access to debug contexts. The first is to enable the debugger with the <code>enable-debugger</code> command. This will make Simics track debug contexts and automatically selects an initial debug context if possible. The second way is to explicitly select a debug context with the <code>debug-context</code> command. This will set a current debug context and will also activate the debugger.</p>
<p>You can disable the debugger with the <code>disable-debugger</code> command. This disable the debugger and Simics returns to the default behavior of the global stepping commands, etc.</p>
<p>Once Simics tracks debug contexts, Simics will update the current debug context to the currently running thread every time the simulation stops. The current debug context is the debug context that all global step and inspection commands will interact with. This means that when you have hit a breakpoint or completed a step you can use the global commands to investigate the state of your software and to continue stepping through the code.</p>
<p>Once you have a debug context you can use it to step through the code and inspect its state. When the debugger is enabled and you have a current debug context you can use the global versions of these commands. The commands are also implemented directly by the debug context, which means that you can use them on debug contexts that are not the current debug context. You can do this even if the debugger is disabled.</p>
<p>Here is a summary of the commands you can use:</p>
<div class="dl">
<ul>
<li><span class="term" id="talos-debugging-cli.html:dt:step-line"><a href="#talos-debugging-cli.html:dt:step-line">step-line</a></span><br>
Run until the debug context reaches another line in the program.</li>
<li><span class="term" id="talos-debugging-cli.html:dt:next-line"><a href="#talos-debugging-cli.html:dt:next-line">next-line</a></span><br>
Run until the debug context reaches another line, but skip over calls made by the current function.</li>
<li><span class="term" id="talos-debugging-cli.html:dt:finish-function"><a href="#talos-debugging-cli.html:dt:finish-function">finish-function</a></span><br>
Run until the current function returns.</li>
<li><span class="term" id="talos-debugging-cli.html:dt:step-instruction"><a href="#talos-debugging-cli.html:dt:step-instruction">step-instruction</a></span><br>
Run until the debug context reaches another instruction.</li>
<li><span class="term" id="talos-debugging-cli.html:dt:next-instruction"><a href="#talos-debugging-cli.html:dt:next-instruction">next-instruction</a></span><br>
Run until the debug context reaches another instruction, but skip over calls made by the current function.</li>
<li><span class="term" id="talos-debugging-cli.html:dt:sym-value"><a href="#talos-debugging-cli.html:dt:sym-value">sym-value</a></span><br>
Get the value of a symbol or a C expression.</li>
<li><span class="term" id="talos-debugging-cli.html:dt:sym-write"><a href="#talos-debugging-cli.html:dt:sym-write">sym-write</a></span><br>
Write a new value to a variable.</li>
<li><span class="term" id="talos-debugging-cli.html:dt:sym-type"><a href="#talos-debugging-cli.html:dt:sym-type">sym-type</a></span><br>
Get the type of a C expression.</li>
<li><span class="term" id="talos-debugging-cli.html:dt:sym-address"><a href="#talos-debugging-cli.html:dt:sym-address">sym-address</a></span><br>
Get the address of a C lvalue expression.</li>
<li><span class="term" id="talos-debugging-cli.html:dt:sym-string"><a href="#talos-debugging-cli.html:dt:sym-string">sym-string</a></span><br>
Get the contents of a C string identified by a C expression.</li>
<li><span class="term" id="talos-debugging-cli.html:dt:list"><a href="#talos-debugging-cli.html:dt:list">list</a></span><br>
List source code.</li>
<li><span class="term" id="talos-debugging-cli.html:dt:sym-source-sym-file"><a href="#talos-debugging-cli.html:dt:sym-source-sym-file">sym-source, sym-file</a></span><br>
Show where an address or function can be found in the source code.</li>
</ul>
</div>
<p>An active thread also has a stack of call frames, or just frames. Simics provides commands to show the stack and to select which frame other commands should use to find local variables. The stack goes from the innermost frame up towards the outermost frame. The current stack frame is reset to the innermost frame every time Simics stops executing.</p>
<div class="dl">
<ul>
<li><span class="term" id="talos-debugging-cli.html:dt:stack-trace"><a href="#talos-debugging-cli.html:dt:stack-trace">stack-trace</a></span><br>
Show the stack.</li>
<li><span class="term" id="talos-debugging-cli.html:dt:frame"><a href="#talos-debugging-cli.html:dt:frame">frame</a></span><br>
Select the frame with the given number. The currently executing function has frame 0, its caller has frame 1, and so on.</li>
<li><span class="term" id="talos-debugging-cli.html:dt:up"><a href="#talos-debugging-cli.html:dt:up">up</a></span><br>
Select the frame with the next higher number.</li>
<li><span class="term" id="talos-debugging-cli.html:dt:down"><a href="#talos-debugging-cli.html:dt:down">down</a></span><br>
Select the frame with the next lower number.</li>
</ul>
</div>
<h2 id="talos-debugging-cli.html:configuration"><a href="#talos-debugging-cli.html:configuration">3.1.2 Configuration</a></h2>
<p>To perform source level debugging you need to tell the debugger about the binaries that the debug contexts you want to debug are running. These binaries must be in ELF format and should contain debug information in Dwarf format. Once this is done you can set breakpoints, step through your program, and inspect the value of variables in it.</p>
<div class="note">
<p>If you try to debug optimized code you may not be able to view all variables, and the mapping between line information and addresses in memory may be confusing.</p>
</div>
<p>The debugger keeps a memory map to locate functions, variables, etc in memory and to find debug information for target code. You add entries to the memory map using the <code>add-symbol-file</code> command. The command uses <em>context queries</em> to limit which debug contexts the information applies to. You can read more about context queries in section <a class="reference" href="#talos-debugging-queries.html">3.2</a>. Here is a summary of the commands to manage the memory map:</p>
<div class="dl">
<ul>
<li><span class="term" id="talos-debugging-cli.html:dt:add-symbol-file"><a href="#talos-debugging-cli.html:dt:add-symbol-file">add-symbol-file</a></span><br>
Add a symbol file or a section or segment from a symbol file to the memory map.</li>
<li><span class="term" id="talos-debugging-cli.html:dt:clear-memorymap"><a href="#talos-debugging-cli.html:dt:clear-memorymap">clear-memorymap</a></span><br>
Clear all memory map entries set from the Simics command line.</li>
<li><span class="term" id="talos-debugging-cli.html:dt:show-memorymap"><a href="#talos-debugging-cli.html:dt:show-memorymap">show-memorymap</a></span><br>
Show all memory map entries set from the Simics command line.</li>
<li><span class="term" id="talos-debugging-cli.html:dt:list-segments-list-sections"><a href="#talos-debugging-cli.html:dt:list-segments-list-sections">list-segments, list-sections</a></span><br>
List segments or sections in an ELF file.</li>
</ul>
</div>
<p>For simple programs you just have to provide the main binary, but for more complex cases, with shared libraries or dynamically loaded modules, you may need to add several symbol files for your program.</p>
<p>If the source code paths in the debug information in the binaries do not match the location of the source code on your host system, you also need to tell the debugger how to find the source code if you want the debugger to be able to show you the actual source code.</p>
<p>Tell the debugger where to find the source code for your program using the <code>add-pathmap-entry</code> command. As with the <code>add-symbol-file</code> command, you can use context queries to limit which debug contexts the information applies to. Here are the commands you can use to manage the path translation:</p>
<div class="dl">
<ul>
<li><span class="term" id="talos-debugging-cli.html:dt:add-pathmap-entry"><a href="#talos-debugging-cli.html:dt:add-pathmap-entry">add-pathmap-entry</a></span><br>
Add a translation from a path in the debug information to a path on the host.</li>
<li><span class="term" id="talos-debugging-cli.html:dt:clear-pathmap"><a href="#talos-debugging-cli.html:dt:clear-pathmap">clear-pathmap</a></span><br>
Remove all translations of paths set from the command line.</li>
<li><span class="term" id="talos-debugging-cli.html:dt:show-pathmap"><a href="#talos-debugging-cli.html:dt:show-pathmap">show-pathmap</a></span><br>
Show all translations of paths set from the command line.</li>
</ul>
</div>
<h2 id="talos-debugging-cli.html:breakpoints"><a href="#talos-debugging-cli.html:breakpoints">3.1.3 Breakpoints</a></h2>
<p>The C/C++ Debugger allows you to set breakpoints on source code lines and on variables and expressions.</p>
<div class="note">
<p>Read and write breakpoints are commonly called "watchpoints", and "breakpoints" is often taken to refer exclusively to execution breakpoints. In Simics speak, however, we use "read breakpoint", "write breakpoint", and "execution breakpoint" for the specific types, and just "breakpoint" when we wish to leave the type unspecified.</p>
</div>
<p>Breakpoints are set with two simple commands:</p>
<div class="dl">
<ul>
<li><span class="term" id="talos-debugging-cli.html:dt:bp-source_line-break"><a href="#talos-debugging-cli.html:dt:bp-source_line-break">bp.source_line.break</a></span><br>
Add a breakpoint or watchpoint on a source line.</li>
<li><span class="term" id="talos-debugging-cli.html:dt:bp-source_location-break"><a href="#talos-debugging-cli.html:dt:bp-source_location-break">bp.source_location.break</a></span><br>
Add a breakpoint or watchpoint on a location given as an address or as a C expression.</li>
</ul>
</div>
<p>Both commands take flags to specify if they should trigger for <em>reads</em>, <em>writes</em>, and/or <em>execution</em>. A watchpoint is simply a breakpoint with the <em>read</em> or <em>write</em> flag set. In this section we use the term breakpoint to mean both watchpoints and breakpoints.</p>
<p>Breakpoints can be set on all contexts matching a context query. This allows you to set breakpoints that will trigger in threads or processes that do not exist yet. The default context query matches all debug contexts.</p>
<p>You can also set breakpoints for a specific debug context by using the <code>bp-break-source-location</code> and <code>bp-break-source-line</code> commands that are namespaced on debug contexts. This allows you to limit the breakpoint to a particular debug context, but this can only be done for debug contexts that already exist.</p>
<p>Breakpoints set with <code>bp-break-source-line</code> and <code>bp-break-source-location</code> are managed by commands namespaced on the <code>bp</code> object in Simics. Here are the commands you can use to manage such breakpoints:</p>
<div class="dl">
<ul>
<li><span class="term" id="talos-debugging-cli.html:dt:bp-list"><a href="#talos-debugging-cli.html:dt:bp-list">bp.list</a></span><br>
List breakpoints.</li>
<li><span class="term" id="talos-debugging-cli.html:dt:bp-show"><a href="#talos-debugging-cli.html:dt:bp-show">bp.show</a></span><br>
Show details about a breakpoint.</li>
<li><span class="term" id="talos-debugging-cli.html:dt:bp-enabled"><a href="#talos-debugging-cli.html:dt:bp-enabled">bp.enabled</a></span><br>
Set or get if the breakpoint should trigger.</li>
<li><span class="term" id="talos-debugging-cli.html:dt:bp-ignore-count"><a href="#talos-debugging-cli.html:dt:bp-ignore-count">bp.ignore-count</a></span><br>
Set or get the ignore count of a breakpoint.</li>
<li><span class="term" id="talos-debugging-cli.html:dt:bp-delete"><a href="#talos-debugging-cli.html:dt:bp-delete">bp.delete</a></span><br>
Delete a breakpoint.</li>
</ul>
</div>
</section><section class="page" id="talos-debugging-queries.html"><h1 id="talos-debugging-queries.html:using-context-queries"><a href="#talos-debugging-queries.html:using-context-queries">3.2 Using Context Queries</a></h1>
<p>Simics implements a query-based system to specify subsets of contexts. The queries specify context properties and what values they must have in order to match. In addition, a query can filter based on a context's ancestors in the context hierarchy.</p>
<h2 id="talos-debugging-queries.html:about-context-queries"><a href="#talos-debugging-queries.html:about-context-queries">3.2.1 About Context Queries</a></h2>
<p>A <em>query</em> consists of a sequence of parts separated by a slash character (<code>/</code>). This sequence specifies a path through the context tree.</p>
<p>A context matches the query if the last part of the query matches the properties of the context, and the parent of the context matches the query excluding the last part. The properties of a context match a part if each property specified in the part matches the property of the same name in the context, or if the name of the context matches the string specified in the part.</p>
<p>The contexts are assumed to be placed in a tree. Each context has zero or one parent. If it has zero parents it is a child of the root of the tree.</p>
<p>There are also two wild cards. The part <code>*</code> matches any context. The part <code>**</code> matches any sequence of contexts. If the query starts with a <code>/</code>, the first part of the query must match a child of the root of the context tree.</p>
<div class="note">
<p>The <code>*</code> wild card matches an entire node, not part of its name or attribute. Thus, a query such as <code>/foo/bar/baz*</code> is invalid, since <code>*</code> can only be used on its own, between <code>/</code> or at the end of the query after a <code>/</code>.</p>
</div>
<h2 id="talos-debugging-queries.html:context-query-syntax"><a href="#talos-debugging-queries.html:context-query-syntax">3.2.2 Context Query Syntax</a></h2>
<pre><code>query = [ "/" ], { part, "/" }, part ;
    part = string | "*" | "**" | properties ;
    properties = property, { ",", property } ;
    property = string, "=", value ;
    value = string | number | boolean ;
    string = quoted string | symbol ;
    quoted string = '"', {any-character - ('"' | '\')
                                 | ('\', ('"' | '\'))}, '"' ;
    symbol = letter, { letter | digit } ;
    number = digit, { digit } ;
    boolean = "true" | "false" ;
    letter = ? A-Z, a-z or _ ? ;
    digit = ? 0-9 ? ;
    any-character = ? any character ? ;
</code></pre>
<h2 id="talos-debugging-queries.html:examples"><a href="#talos-debugging-queries.html:examples">3.2.3 Examples</a></h2>
<p>This section illustrates the syntax with some examples, and what a user might mean when providing such a query:</p>
<ul>
<li><strong>httpd</strong>: matches all contexts named "httpd".</li>
<li><strong>pid=4711</strong>: matches any context with a property <strong>pid</strong>, which has the value 4711.</li>
<li><strong>/server/**</strong>: matches all contexts that are descendants of the top level context named "server".</li>
<li><strong>"Linux 2.6.14"/Kernel/*</strong>: matches all kernel processes in operating systems named "Linux 2.6.14".</li>
<li><strong>pid=4711/*</strong>: matches all threads in processes with the pid 4711.</li>
<li><strong>/client/**/"rule30.elf"</strong>: matches the context for program <em>rule30.elf</em> running on the machine called <code>client</code>.</li>
<li><strong>/server/**/HasState=true</strong>: matches all threads that are descendants of the context "server". Contexts with no state, typically container, do not match the query.</li>
</ul>
<h2 id="talos-debugging-queries.html:context-queries-in-the-command-line-interface"><a href="#talos-debugging-queries.html:context-queries-in-the-command-line-interface">3.2.4 Context Queries in the Command Line Interface</a></h2>
<p>The Simics debugger is built on top of the <em>target connection framework</em> (TCF) technology, which introduces the context query concept. The above text describes the standard TCF syntax for context queries. It is very similar in principle to the process trackers node path concept.</p>
<p>To make context queries work better with the CLI syntax, and look closer to node paths, the syntax of TCF context queries in the command line has been modified. The difference is minor, as it impacts only the double quote character (<code>"</code>) used to quote a string with non-alpha-numeric characters. In the command line you must either escape this character or use the single quote character (<code>'</code>) instead.</p>
<p>Originally the context query to match a context named <em>rule30.elf</em> is written <code>name="rule30.elf"</code>. The corresponding node path is <code>name='rule30.elf'</code>. So for instance in the command line you will use:</p>
<pre><code>
simics&gt; add-symbol-file context-query = "name='rule30.elf'"
or
simics&gt; add-symbol-file context-query = "name=\"rule30.elf\""
</code></pre>
<p>Another example for selecting a cpu context named <em>cpu[0]</em>, in Simics command line, the query is written:</p>
<pre><code>
simics&gt; bp.source_location.break 0xfff00000 context-query = "'cpu[0]'"
or
simics&gt; bp.source_location.break 0xfff00000 context-query = "\"cpu[0]\""
</code></pre>
</section><section class="page" id="debugger-api.html"><h1 id="debugger-api.html:the-debugger-api"><a href="#debugger-api.html:the-debugger-api">3.3 The Debugger API</a></h1>
<h2 id="debugger-api.html:introduction"><a href="#debugger-api.html:introduction">3.3.1 Introduction</a></h2>
<p>The Simics debugger comes with a series of interfaces to allow scripting against the debugger. This allows adding symbol files, looking up symbols, notifying on debugger events, stepping and more.</p>
<p>The API interfaces can be accessed from Python or C (also allowing C++ or DML).</p>
<p>The debugger API interfaces and their functions are documented in <em>API Reference Manual</em>. All interfaces start with <code>debug_</code>.</p>
<p>The debugger API is implemented by a Simics object, which you access through the <code>SIM_get_debugger</code> API function.</p>
<h2 id="debugger-api.html:interfaces"><a href="#debugger-api.html:interfaces">3.3.2 Interfaces</a></h2>
<p>Here is a short introduction to the debugger API interfaces available, more detailed documentation is available in the <em>API Reference Manual</em>.</p>
<ul>
<li><code>debug_setup</code> - Add symbol files and mappings to the debug configuration.</li>
<li><code>debug_notification</code> - Get notification on debugger events. An event can for example be when a certain source line runs or when a context becomes activate.</li>
<li><code>debug_query</code> - Used for finding contexts that match certain criteria or creating context queries.</li>
<li><code>debug_step</code> - Perform source or instruction stepping.</li>
<li><code>debug_symbol</code> - Look up symbol information and values. Can for example be translating between address and line, getting a symbol value, finding which functions exist or getting a stack trace.</li>
<li><code>debug_symbol_file</code> - Open symbol files and get information, such as section or segment information, for that symbol file. The open symbol file can also be used to look up symbols using the <code>debug_symbol</code> interface.</li>
</ul>
<h2 id="debugger-api.html:examples"><a href="#debugger-api.html:examples">3.3.3 Examples</a></h2>
<p>This section provides some examples on how the debugger API can be used. All these examples require an object <code>tcf</code> of the <code>tcf-agent</code> class to be present in Simics. The object can be created by running <code>new-tcf-agent</code> if it is not already present.</p>
<p>All examples are in Python, they can be run in Simics <code>python-mode</code> or can be written to a file that then can be run with the <code>run-script</code> command.</p>
<h3 id="debugger-api.html:symbol-file-information-example"><a href="#debugger-api.html:symbol-file-information-example">3.3.3.1 Symbol file information example</a></h3>
<p>Shows how symbol information, such as sections, source files and functions for
a symbol file can be obtained using the debugger API.</p>
<pre><code>import conf
import simics
import stest
import pprint

debugger = simics.SIM_get_debugger()

(err, file_id) = debugger.iface.debug_symbol_file.open_symbol_file(
    "%simics%/targets/qsp-x86/images/debug_example", 0, False)
stest.expect_equal(err, simics.Debugger_No_Error, file_id)
(err, info) = debugger.iface.debug_symbol_file.symbol_file_info(file_id)
stest.expect_equal(err, simics.Debugger_No_Error, info)

print("File info:")
pprint.pprint(info)

(err, sections_data) = debugger.iface.debug_symbol_file.sections_info(file_id)
stest.expect_equal(err, simics.Debugger_No_Error, sections_data)
stest.expect_equal(sections_data[0], "ELF", "Should be an ELF binary")

sections = sections_data[1]

print("\nExecutable sections:")
for section in sections:
    if section.get("executable"):
        print("  0x%08x-0x%08x: %s" % (section["address"],
                                       section["address"] + section["size"],
                                       section.get("name", "")))

(err, src_files) = debugger.iface.debug_symbol.list_source_files(file_id)
stest.expect_equal(err, simics.Debugger_No_Error, src_files)

print("\nSource files:")
for src in src_files:
    print("  '%s'" % src)

(err, functions) = debugger.iface.debug_symbol.list_functions(file_id)
stest.expect_equal(err, simics.Debugger_No_Error, functions)

print("\nFunctions:")
for function_data in functions:
    if function_data["size"] == 0:
        continue
    addr = function_data["address"]
    print("  0x%08x-0x%08x: %s" % (addr, addr + function_data["size"],
                                   function_data["symbol"]))

(err, err_str) = debugger.iface.debug_symbol_file.close_symbol_file(file_id)
stest.expect_equal(err, simics.Debugger_No_Error, err_str)
</code></pre>
<p>This example has showed how to:</p>
<ul>
<li>Open an symbol file as a context to be used with other debugger API
functions.</li>
<li>Get file information.</li>
<li>Get sections information.</li>
<li>List the source files in the debug information of a binary.</li>
</ul>
<h3 id="debugger-api.html:debug-example"><a href="#debugger-api.html:debug-example">3.3.3.2 Debug example</a></h3>
<p>This example uses the <code>debug_example</code> file to demonstrate how
debugger API usages. Various interfaces and functions
in the debugger API will be used in this example.</p>
<pre><code>import cli
import conf
import simics
import stest

# SIMICS-20853
conf.sim.deprecation_level = 0

simics.SIM_run_command_file_params(
    simics.SIM_lookup_file('%simics%/targets/qsp-x86/firststeps.simics'),
    False,
    # Parameters to make simulation more deterministic (NB: VMP is
    # on so we still get some uncertainty.):
    [["connect_real_network", "no"],
     ["rtc_time", "2019-11-12 11:47:01"]])
con = conf.board.serconsole.con
prompt = "$ "
con.iface.break_strings_v2.add_single(prompt, None, None)
simics.SIM_continue(0)

(am, _) = cli.quiet_run_command('start-agent-manager')
(matic, _) = cli.quiet_run_command(f'{am}.connect-to-agent')
cli.quiet_run_command(f'{matic}.upload -executable'
                      r' "%simics%/targets/qsp-x86/images/debug_example"'
                      ' "/home/simics"')
cli.quiet_run_command(f'{matic}.run-until-job')

cli.run_command('board.software.enable-tracker')

def expect_no_error(api_result):
    (err, res) = api_result
    stest.expect_equal(err, simics.Debugger_No_Error, res)
    return res

# Get the debugger object
debugger = simics.SIM_get_debugger()
symbol_iface = debugger.iface.debug_symbol
query_iface = debugger.iface.debug_query
notify_iface = debugger.iface.debug_notification
step_iface = debugger.iface.debug_step

# Add a symbol file
ctx_query = "debug_example"   # Match the target binary
add_id = expect_no_error(debugger.iface.debug_setup.add_symbol_file(
    ctx_query, "%simics%/targets/qsp-x86/images/debug_example", 0, False))

local_src = simics.SIM_lookup_file("%simics%/targets/qsp-x86/debug_example.c")
compiled_src = "/tmp/debug_example.c"  # nosec: /tmp is OK here

# Path map entry only needed for debugger to be able to find source file and
# display its contents. Not really needed for this example.
pm_id = expect_no_error(debugger.iface.debug_setup.add_path_map_entry(
    ctx_query, compiled_src, local_src))

with open(local_src, "r") as f:
    debug_example_contents = f.readlines()

def get_pc(cpu):
    return cpu.iface.processor_info_v2.get_program_counter()

def context_name(ctx_id):
    return expect_no_error(query_iface.context_name(ctx_id))

def print_current_line(ctx_id):
    cpu = expect_no_error(query_iface.get_active_processor(ctx_id))

    def addr_src_cb(src_lines, code_area):
        src_lines.append(code_area)

    src_lines = []
    expect_no_error(symbol_iface.address_source(ctx_id, get_pc(cpu), 1,
                                                addr_src_cb, src_lines))
    stest.expect_equal(len(src_lines), 1)
    curr_area = src_lines[0]
    filename = curr_area["filename"].split("/")[-1]
    print(f"Line '{filename}:{curr_area['start-line']}':")
    if filename == "debug_example.c":
        print(debug_example_contents[curr_area["start-line"] - 1])
    else:
        print("  &lt;unknown contents&gt;")

def ints_as_hex(value):
    if isinstance(value, int):
        return hex(value)
    elif isinstance(value, list):
        return f'[{", ".join(map(ints_as_hex, value))}]'
    return value

def print_local_variables(ctx_id):
    local_vars = expect_no_error(symbol_iface.local_variables(ctx_id, 0))
    print("Local variables:")
    for var in local_vars:
        value = expect_no_error(symbol_iface.expression_value(ctx_id, 0, 0,
                                                              var))
        print(f"  {var}: {ints_as_hex(value)}")

def get_active_cpu(ctx_id):
    (err, cpu) = query_iface.get_active_processor(ctx_id)
    if err == simics.Debugger_Context_Is_Not_Active:
        return None
    expect_no_error((err, cpu))
    return cpu

def run_to_known_source(ctx_id):
    while 1:
        stack = expect_no_error(symbol_iface.stack_frames(cbdata.ctx_id, 0, 0))
        if stack[0].get("source-line") is not None:
            return
        step_iface.instruction_into(ctx_id)

class CBData:
    ctx_id = None
    stop_reason = None

print("Installing context creation callback")

cbdata = CBData()
installed_callback_ids = []

def take_snapshot_cb(name):
    simics.SIM_take_snapshot(name)

def create_cb(cb_data, tcf_obj, ctx_id, updated):
    event_type = "updated" if updated else "created"
    print(f"Context '{context_name(ctx_id)}' {event_type}")
    cb_data.ctx_id = ctx_id
    simics.SIM_run_alone(take_snapshot_cb, 'creation')

cid = expect_no_error(notify_iface.notify_context_creation(
    ctx_query, create_cb, cbdata))
installed_callback_ids.append(cid)

print("Installing context destruction callback")

def destroy_cb(cb_data, tcf_obj, ctx_id):
    print(f"Context 'context_name(ctx_id)' destroyed")
    stest.expect_equal(ctx_id, cb_data.ctx_id,
                       "Not the same context that was created")
    simics.SIM_break_simulation("context destroyed")
    cb_data.stop_reason = "destroy"

cid = expect_no_error(notify_iface.notify_context_destruction(
    ctx_query, destroy_cb, cbdata))
installed_callback_ids.append(cid)

conf.board.serconsole.con.iface.con_input.input_str("./debug_example\n")

# Should run until the context is destroyed. Context ID, ctx_id, should have
# been updated at creation time.
simics.SIM_continue(0)
stest.expect_different(cbdata.ctx_id, None)
stest.expect_equal(cbdata.stop_reason, "destroy")

simics.SIM_restore_snapshot("creation")

def line_cb(cb_data, tcf, ctx_id, cpu, addr, *dont_care):
    cb_data.stop_reason = "line"
    cb_data.ctx_id = ctx_id
    simics.SIM_break_simulation(f"line hit at 0x{addr:x}")

line_cid = expect_no_error(notify_iface.notify_line(
    ctx_query, "debug_example.c", 59, 0, line_cb, cbdata))

cbdata.ctx_id = None

simics.SIM_continue(0)
stest.expect_different(cbdata.ctx_id, None)
stest.expect_equal(cbdata.stop_reason, "line")

print_current_line(cbdata.ctx_id)
print_local_variables(cbdata.ctx_id)

# A manual investigation of the variables will show that user.type seems bad.
# Find why user.type contains an illegal value but getting the address of that
# variable and planting a write breakpoint for that address.
investigated_symbol = "user.type"
addr_list = expect_no_error(symbol_iface.symbol_address(cbdata.ctx_id, 0,
                                                        investigated_symbol))
stest.expect_equal(len(addr_list), 1, "One address expected")
symbol_addr = addr_list[0]
symbol_value = expect_no_error(
    symbol_iface.expression_value(cbdata.ctx_id, 0, 0, investigated_symbol))
symbol_size = expect_no_error(symbol_iface.expression_value(
    cbdata.ctx_id, 0, 0, f"sizeof {investigated_symbol}"))
print(f"Address of {investigated_symbol}: 0x{symbol_addr:0{symbol_size * 2}x}")
print(f"Value: 0x{symbol_value:x}")

def addr_cb(cb_data, tcf_obj, ctx_id, cpu, insn_addr, data_addr, size):
    print(f"Addresses 0x{data_addr:x}-0x{data_addr + size - 1:x} written by"
          f" '{cpu.name}'@{cpu.steps}")
    stest.expect_equal(cb_data.ctx_id, ctx_id,
                       "Hit for a different context than created")
    cb_data.stop_reason = "addr"
    simics.SIM_break_simulation("address written")

addr_cid = expect_no_error(notify_iface.notify_address(
    ctx_query, symbol_addr, symbol_size, simics.Sim_Access_Write, False,
    addr_cb, cbdata))

simics.SIM_restore_snapshot("creation")
read_value = None
while read_value != symbol_value:
    simics.SIM_continue(0)
    stest.expect_equal(cbdata.stop_reason, "addr")
    read_bytes = expect_no_error(
        symbol_iface.address_read(cbdata.ctx_id, symbol_addr, symbol_size))
    read_value = int.from_bytes(read_bytes, byteorder='little', signed=False)

# Cancel the address notification so that it does not hit again.
notify_iface.cancel(addr_cid)

# Print the stack where the simulation stopped.
stack = expect_no_error(symbol_iface.stack_frames(cbdata.ctx_id, 0, 10))
print("Stack:")
for (i, frame) in enumerate(stack):
    func_name = frame.get("function-name") or "&lt;unknown&gt;"
    print(f"{i}. 0x{frame['address']:016x}: {func_name}")

# Run to known source if needed.
if len(stack) &gt; 0 and stack[0].get("source-line") is None:
    run_to_known_source(cbdata.ctx_id)

print_current_line(cbdata.ctx_id)

# Manual investigation shows that this is after the strcpy line.
line_addrs = expect_no_error(symbol_iface.symbol_address(cbdata.ctx_id, 0,
                                                         "line"))
stest.expect_equal(len(line_addrs), 1, "One address should match 'line'")
line_addr = line_addrs[0]

# Read the data (plus one extra byte) that is copied to p-&gt;info and check if
# the string is terminated or not.
read_str = expect_no_error(symbol_iface.address_read(cbdata.ctx_id,
                                                     line_addr, 21))
terminated = False
for byte in read_str:
    if byte == 0:
        terminated = True
        break
print(f"The copied string is {'' if terminated else 'not '}terminated")

# Uninstall all installed notifications.
while installed_callback_ids:
    cid = installed_callback_ids.pop()
    expect_no_error(notify_iface.cancel(cid))

</code></pre>
<p>In this example the debugger API was used to:</p>
<ul>
<li>Add a symbol file.</li>
<li>Plant notifications on when contexts are created and destroyed.</li>
<li>Plant notifications on when a variable is modified.</li>
<li>Get addresses for local variables.</li>
<li>Get source line information.</li>
<li>Get stack frames.</li>
<li>Read memory for a context.</li>
<li>Perform line stepping.</li>
</ul>
</section><section class="page" id="talos-debugging-limitations.html"><h1 id="talos-debugging-limitations.html:debugger-limitations"><a href="#talos-debugging-limitations.html:debugger-limitations">3.4 Debugger Limitations</a></h1>
<p>This section lists limitations for the Simics debugger in the current release of Simics.</p>
<p><strong>General</strong></p>
<ul>
<li>32-bit x86 that uses segmentation will not work properly with the debugger as it works with linear addresses.</li>
<li>Xtensa register windows are not handled by the debugger.</li>
</ul>
<p><strong>Linux Tracker</strong></p>
<ul>
<li>The Linux trackers only allow access to the currently active software node on each processor core. Therefore it is not possible to access the memory of inactive tasks.</li>
<li>The Linux tracker does not automatically detect the load addresses of dynamically loaded software. You have to enter this information manually.</li>
</ul>
<p><strong>Breakpoints</strong></p>
<ul>
<li>You cannot plant a watchpoint on a local variable.</li>
<li>When planting an expression breakpoint, the expression will be evaluated when the breakpoint is hit. If the expression is not valid, no error will be reported and the target will stop as if the expression was evaluated successfully.</li>
</ul>
</section><section class="page" id="code-coverage.html"><h1 id="code-coverage.html:code-coverage"><a href="#code-coverage.html:code-coverage">4 Code Coverage</a></h1>
</section><section class="page" id="code-coverage-introduction.html"><h1 id="code-coverage-introduction.html:code-coverage-introduction"><a href="#code-coverage-introduction.html:code-coverage-introduction">4.1 Code coverage introduction</a></h1>
<p>Using Simics, it is possible to do coverage analysis of the code running on the target system. This analysis is performed using the unmodified binary running on the simulated system by profiling which machine instructions are executed. The result can be presented on source level or instruction level. For instruction level it is also possible to get branch coverage and a count on how many times an instruction at a specific address has been executed. It is also possible to save reports which can later be combined with other code coverage runs or used for report creation.</p>
<p>There are many ways to use the code coverage feature, both manually and as part of an automated run. However, there are basically two different use cases. In the first case both collection and analysis is done at the same time. The second case divides the collection and analysis into two different steps, possibly even combining multiple runs into one report before doing the analysis. This has the added benefit that it is possible to get the combined coverage from multiple test runs, as long as the binaries are the same.</p>
<p>The code coverage implementation is based on the Simics debugger, which makes it possible to use context queries to specify which context the code coverage collection should be performed on. For more details about context queries, see section <a class="reference" href="#talos-debugging-queries.html">3.2</a>. For most use-cases it is recommended to use one of the available OS Awareness trackers as this will provide knowledge about what is running on the system. OS Awareness is described in section <a class="reference" href="#target-software-tracking.html">2</a>.</p>
<p>For a list of available commands, see section <a class="reference" href="#code-coverage-commands.html">4.4</a>. For a detailed walk through of common use cases, see section <a class="reference" href="#code-coverage-workflow.html">4.3</a>.</p>
</section><section class="page" id="requirements.html"><h1 id="requirements.html:requirements"><a href="#requirements.html:requirements">4.2 Requirements</a></h1>
<p>To be able to perform code coverage analysis, the processor model needs to support instruction profiling. In order to generate a full code coverage report that includes disassembly, either the used processor model must implement the <code>class_disassembly</code> interface or there must exist a disassemble module for the architecture type. Otherwise only source coverage will be available in the report.</p>
<p>It is often recommended to use one of the available software trackers, as that keeps track of what is running on the system. This makes it possible to match an executed instruction with the correct software entity.</p>
<p>A good thing to remember is that the quality of the source code mapping depends highly on the debug information and the optimization level.</p>
</section><section class="page" id="code-coverage-workflow.html"><h1 id="code-coverage-workflow.html:work-flow"><a href="#code-coverage-workflow.html:work-flow">4.3 Work flow</a></h1>
<p>In this chapter we will look into how code coverage can be collected and how the HTML report will look like. We will look at two different examples, one where we run code coverage for a Linux user space program and one where we run code coverage for a UEFI system.</p>
<h2 id="code-coverage-workflow.html:code-coverage-for-a-linux-user-space-program"><a href="#code-coverage-workflow.html:code-coverage-for-a-linux-user-space-program">4.3.1 Code coverage for a Linux user space program</a></h2>
<h3 id="code-coverage-workflow.html:preparations"><a href="#code-coverage-workflow.html:preparations">4.3.1.1 Preparations</a></h3>
<p>The most basic use case is to collect coverage and generate a code coverage report in the same run.</p>
<p>For this example, we will use the firststeps machine that comes with the <em>QSP-x86</em> package. First we upload the <code>worker-opt</code> binary to the target system. The Linux image used by the firststeps machine is already configured to have the <code>simics-agent</code> application running. We will use it to transfer files to the simulated machine.</p>
<p>Please boot the <code>targets/qsp-x86/firststeps.simics</code> target system and then issue the following commands inside Simics:</p>
<pre><code class="language-simics">simics&gt; <strong>$worker_opt_file = (lookup-file "%simics%/targets/qsp-x86/images/worker-opt")</strong>
simics&gt; <strong>$agent = (start-agent-manager)</strong>
simics&gt; <strong>$handle = ($agent.connect-to-agent)</strong>
simics&gt; <strong>$handle.upload -executable $worker_opt_file /root</strong>
simics&gt; <strong>$handle.run-until-job</strong>
</code></pre>
<p>Before we can start collecting code coverage we need to enable the Linux tracker and set up symbol file information.</p>
<pre><code class="language-simics">simics&gt; <strong>board.software.enable-tracker</strong>
simics&gt; <strong>add-symbol-file $worker_opt_file context-query = "'worker-opt'"</strong>
</code></pre>
<h3 id="code-coverage-workflow.html:collection"><a href="#code-coverage-workflow.html:collection">4.3.1.2 Collection</a></h3>
<p>The <code>collect-coverage</code> command is used to start collecting code coverage data from the simulation. The <code>collect-coverage</code> command takes a context query for which to collect coverage.</p>
<p>We will start collecting code coverage for the next created context that matches our context query. For more information about the available options, see the built-in help.</p>
<pre><code class="language-simics">simics&gt; <strong>$cc = (collect-coverage context-query = "'worker-opt'")</strong>
</code></pre>
<p>It is finally time to run the test program. This can be done by inputting the command on the target console and then running the simulation until the program completes.</p>
<pre><code class="language-simics"><strong>./worker-opt 5 8 10</strong>
</code></pre>
<p>Depending on where the file were compiled, we may have to add a path map. Since "%simics%" may return the path from any package or project we give the exact file name here. However, normally only the directory needs to be provided.</p>
<pre><code class="language-simics">simics&gt; <strong>$cc.add-path-map "/tmp/worker_opt.c" "%simics%/targets/qsp-x86/worker_opt.c"</strong>
</code></pre>
<p>When the program has finished, or when the test case of interest is completed it is time to generate a coverage report. Again, there are many options for how to generate the HTML report available, see the built-in help for more details.</p>
<pre><code class="language-simics">simics&gt; <strong>$cc.html-report coverage-report</strong>
</code></pre>
<p>If we use a web browser to open <code>index.html</code> located in <code>coverage-report</code> directory, we will see something like figure <a class="reference" href="#code-coverage-workflow.html:coverage-worker-opt-start">16</a>.</p>
<p>The current page shows all known source files that were used to compile the program, in this case the <code>worker_opt.c</code> file. We can also see the number of executed lines and how many executable lines there are; together with a ratio, given in percentage. This is shown both in total and per file.</p>
<figure id="code-coverage-workflow.html:coverage-worker-opt-start">
<p><img alt="" src="worker-opt-html-start.png"></p><figcaption>Figure 16. Code Coverage Main Page</figcaption><p></p>
</figure>
<p>If we follow the link to the <code>worker_opt.c</code> file, we are provided much more details about that particular file. First, there is a short summary about the coverage, where we can see how much coverage it is for this source file and from which mappings it was referenced, see figure <a class="reference" href="#code-coverage-workflow.html:coverage-worker-opt-src-header">17</a>. This is followed by the entire source file, an excerpt of the <code>worker_opt.c</code> is shown in figure <a class="reference" href="#code-coverage-workflow.html:coverage-worker-opt-src-file">18</a>. The source file is marked with green if a line was executed and red for executable lines that were not executed. Lines that are grey are not executable, this includes comment, lines that were optimized away and parts of multiline expressions. Remember that the quality of the source to instruction mapping is heavily dependent on compiler optimization level. A line will be counted as executed if at least one instruction that has been executed has a mapping to the source line in question.</p>
<figure id="code-coverage-workflow.html:coverage-worker-opt-src-header">
<p><img alt="" src="worker-opt-html-source-header.png"></p><figcaption>Figure 17. Code Coverage Source Header Details</figcaption><p></p>
</figure>
<figure id="code-coverage-workflow.html:coverage-worker-opt-src-file">
<p><img alt="" src="worker-opt-html-source-file.png"></p><figcaption>Figure 18. Code Coverage Source File Details</figcaption><p></p>
</figure>
<p>To get information on disassembly level we can click the <code>Disassembly</code> link in the header. This will take us to the disassembly overview page as seen in figure <a class="reference" href="#code-coverage-workflow.html:coverage-worker-opt-dis-main">19</a>. This contains an overview of how many instructions the program consists of and how many of those that were executed. See the <code>Explanation</code> page for information and limitations about disassembly information.</p>
<figure id="code-coverage-workflow.html:coverage-worker-opt-dis-main">
<p><img alt="" src="worker-opt-html-dis-main.png"></p><figcaption>Figure 19. Disassembly Overview</figcaption><p></p>
</figure>
<p>To get even more details about the exact instructions that has been run, we can follow the link to the <code>worker_opt</code> binary, see figure <a class="reference" href="#code-coverage-workflow.html:coverage-worker-opt-dis-details">20</a>. At the top of the page, there is a summary with details about how many instructions that were executed followed by a table with known functions addresses and how much coverage each function has. There is also a source indication if there is a known source file for the particular function. Further down, the entire disassembly is available. Again, executed instructions are marked with green and instructions that has not been executed are marked with red. It is also possible to get the number of times an instruction has been executed and if a branch instruction has been taken or not. To enable this, see the built-in help for the <code>collect-coverage</code> command. Again the <code>Explanation</code> page provides more details about how such information is presented in the report.</p>
<figure id="code-coverage-workflow.html:coverage-worker-opt-dis-details">
<p><img alt="" src="coverage-worker-opt-dis-details.png"></p><figcaption>Figure 20. Source Coverage Combined</figcaption><p></p>
</figure>
<p>To demonstrate that it is possible to combine coverage from multiple runs we will save a raw coverage report as well. This is done with the <code>save</code> command.</p>
<pre><code class="language-simics">simics&gt; <strong>$cc.save worker-opt.cc</strong>
</code></pre>
<p>We will now start a second coverage collection, by using the <code>collect-coverage</code> command.</p>
<pre><code class="language-simics">simics&gt; <strong>$cc2 = (collect-coverage context-query = "'worker-opt'")</strong>
</code></pre>
<p>Again, we may have to setup a path map.</p>
<pre><code class="language-simics">simics&gt; <strong>$cc2.add-path-map "/tmp/worker_opt.c" "%simics%/targets/qsp-x86/worker_opt.c"</strong>
</code></pre>
<p>To be able to see the difference we will start the worker-opt program without any input argument this time. And run until the program has finished.</p>
<pre><code class="language-simics">simics&gt; <strong>board.serconsole.con.input "./worker-opt\n"</strong>
</code></pre>
<p>We can now add the previously saved coverage data to the currently gathered data. This is done with the <code>add-report</code> command.</p>
<pre><code class="language-simics">simics&gt; <strong>$cc2.add-report worker-opt.cc</strong>
</code></pre>
<p>To create a new html report we use the <code>html-report</code> command again, this time for the second code coverage object.</p>
<pre><code class="language-simics">simics&gt; <strong>$cc2.html-report coverage-report-2</strong>
</code></pre>
<p>We can now compare the source code coverage for the two runs. In the first run, see figure <a class="reference" href="#code-coverage-workflow.html:coverage-worker-opt-src-file">18</a>, line 65 and 67 have not been executed. In the second report, see figure <a class="reference" href="#code-coverage-workflow.html:coverage-worker-opt-src-with">21</a>, we can see that line 65 and 67 have been executed. This is expected as we provided too few arguments to the program. However, we can also see that line 69 has been executed. This is because we have combined the coverage from the two runs.</p>
<figure id="code-coverage-workflow.html:coverage-worker-opt-src-with">
<p><img alt="" src="coverage-worker-opt-src-with.png"></p><figcaption>Figure 21. Source Coverage Combined</figcaption><p></p>
</figure>
<h2 id="code-coverage-workflow.html:uefi-code-coverage"><a href="#code-coverage-workflow.html:uefi-code-coverage">4.3.2 UEFI code coverage</a></h2>
<p>Collecting code coverage for a UEFI system is fairly easy, given you have already configured the UEFI FW tracker. For more details about the tracker, see section <a class="reference" href="#uefi-fw-trk.html">2.16</a>. This example assumes that the name of the platform is <code>viper</code>.</p>
<p>First we enable the tracker.</p>
<pre><code class="language-simics">simics&gt; <strong>board.software.enable-tracker</strong>
</code></pre>
<p>Now we need to find out how to write the context query to match the root context. We can do this by listing all debug contexts and then create a context query that matches the UEFI FW tracker's root context.</p>
<pre><code class="language-simics">simics&gt; <strong>list-debug-contexts</strong>
</code></pre>
<p>We can now see that the debug context we are interested in is <code>/board/software/UEFI System/UEFI Firmware</code>. We can make a simple context query based on the name.</p>
<p>To start collecting coverage we use the <code>collect-coverage</code> command.</p>
<pre><code class="language-simics">simics&gt; <strong>$cc = (collect-coverage context-query = "'UEFI Firmware'")</strong>
</code></pre>
<p>After the code coverage collection has started it is time to start the simulation and run the UEFI system up to the point we are interested in gathering code coverage for.</p>
<p>If the UEFI FW build is unavailable at the path it was built, then code coverage will require adding a path-map to its present location. This can be set by using the per code coverage object command, <code>add-path-map</code>. It is also possible to use the global <code>add-pathmap-entry</code> command as long as the context on which code coverage is collected has not yet been destroyed (which will never happen in the UEFI case).</p>
<pre><code class="language-simics">simics&gt; <strong>$cc.add-path-map "c:\\uefi\\uefi-testfiles-build.git\\uefi-edk2-simics.git" /path/to/uefi/build</strong>
</code></pre>
<p>We can now create the HTML report, since the UEFI FW tracker provides all mappings to UEFI modules there is no need to set up those manually.</p>
<pre><code class="language-simics">simics&gt; <strong>$cc.html-report uefi-report</strong>
</code></pre>
</section><section class="page" id="code-coverage-commands.html"><h1 id="code-coverage-commands.html:commands"><a href="#code-coverage-commands.html:commands">4.4 Commands</a></h1>
<p>The code coverage feature comes with a set of commands to aid the collection of coverage, post processing of the collected data, and report generation. Here follows a short summary of the commands, for a more in depth description see the built-in help.</p>
<div class="dl">
<ul>
<li><span class="term" id="code-coverage-commands.html:dt:collect-coverage"><a href="#code-coverage-commands.html:dt:collect-coverage"><code>collect-coverage</code></a></span><br>
Start collecting code coverage.</li>
<li><span class="term" id="code-coverage-commands.html:dt:load-coverage"><a href="#code-coverage-commands.html:dt:load-coverage"><code>load-coverage</code></a></span><br>
Load a code coverage report.</li>
<li><span class="term" id="code-coverage-commands.html:dt:code_coverage-save"><a href="#code-coverage-commands.html:dt:code_coverage-save"><code>&lt;code_coverage&gt;.save</code></a></span><br>
Save the current code coverage state into a raw code coverage report.</li>
<li><span class="term" id="code-coverage-commands.html:dt:code_coverage-add-report"><a href="#code-coverage-commands.html:dt:code_coverage-add-report"><code>&lt;code_coverage&gt;.add-report</code></a></span><br>
Load a raw code coverage report into the internal state.</li>
<li><span class="term" id="code-coverage-commands.html:dt:code_coverage-add-functions"><a href="#code-coverage-commands.html:dt:code_coverage-add-functions"><code>&lt;code_coverage&gt;.add-functions</code></a></span><br>
Add function information to the internal data structures.</li>
<li><span class="term" id="code-coverage-commands.html:dt:code_coverage-add-source-info"><a href="#code-coverage-commands.html:dt:code_coverage-add-source-info"><code>&lt;code_coverage&gt;.add-source-info</code></a></span><br>
Builds source line information to the internal data structures.</li>
<li><span class="term" id="code-coverage-commands.html:dt:code_coverage-disassemble"><a href="#code-coverage-commands.html:dt:code_coverage-disassemble"><code>&lt;code_coverage&gt;.disassemble</code></a></span><br>
Build disassembly information for all mappings that has been found by the code coverage system.</li>
<li><span class="term" id="code-coverage-commands.html:dt:code_coverage-stop"><a href="#code-coverage-commands.html:dt:code_coverage-stop"><code>&lt;code_coverage&gt;.stop</code></a></span><br>
Will stop code coverage collection, existing data will be kept in order to support report generation.</li>
<li><span class="term" id="code-coverage-commands.html:dt:code_coverage-html-report"><a href="#code-coverage-commands.html:dt:code_coverage-html-report"><code>&lt;code_coverage&gt;.html-report</code></a></span><br>
Create an HTML code coverage report.</li>
<li><span class="term" id="code-coverage-commands.html:dt:code_coverage-lcov-output"><a href="#code-coverage-commands.html:dt:code_coverage-lcov-output"><code>&lt;code_coverage&gt;.lcov-output</code></a></span><br>
Output report in LCOV&nbsp;tracefile format.</li>
<li><span class="term" id="code-coverage-commands.html:dt:code_coverage-csv-output"><a href="#code-coverage-commands.html:dt:code_coverage-csv-output"><code>&lt;code_coverage&gt;.csv-output</code></a></span><br>
Output report as CSV where each line is on&nbsp;the format:<br>
<code>source file,total executable lines,lines executed</code></li>
<li><span class="term" id="code-coverage-commands.html:dt:code_coverage-add-path-map"><a href="#code-coverage-commands.html:dt:code_coverage-add-path-map"><code>&lt;code_coverage&gt;.add-path-map</code></a></span><br>
Add a path map that will be used when locating binaries and source files while building the code coverage data and report.</li>
<li><span class="term" id="code-coverage-commands.html:dt:code_coverage-clear-path-maps"><a href="#code-coverage-commands.html:dt:code_coverage-clear-path-maps"><code>&lt;code_coverage&gt;.clear-path-maps</code></a></span><br>
Remove all path maps that has been added with the <code>&lt;code_coverage&gt;.add-path-map</code> command.</li>
<li><span class="term" id="code-coverage-commands.html:dt:code_coverage-list-mappings"><a href="#code-coverage-commands.html:dt:code_coverage-list-mappings"><code>&lt;code_coverage&gt;.list-mappings</code></a></span><br>
List all mappings known to the code coverage object.</li>
<li><span class="term" id="code-coverage-commands.html:dt:code_coverage-filter-mappings"><a href="#code-coverage-commands.html:dt:code_coverage-filter-mappings"><code>&lt;code_coverage&gt;.filter-mappings</code></a></span><br>
Filter memory mappings to make it possible to only show some of them in the reports.</li>
<li><span class="term" id="code-coverage-commands.html:dt:code_coverage-combine-mappings"><a href="#code-coverage-commands.html:dt:code_coverage-combine-mappings"><code>&lt;code_coverage&gt;.combine-mappings</code></a></span><br>
Combine mappings in the report that have the same symbol file, but are located at different addresses.</li>
</ul>
</div>
</section><section class="page" id="raw-code-coverage-format.html"><h1 id="raw-code-coverage-format.html:raw-code-coverage-format"><a href="#raw-code-coverage-format.html:raw-code-coverage-format">4.5 Raw Code Coverage Format</a></h1>
<p>The idea about the raw format files is to allow any user to create code coverage reports or do some automated analysis on them, in those cases that the HTML report is not the best match.</p>
<p>The raw format file can contain all information required to create a coverage report, such as the HTML report. It may also contain partial data, such as information about available memory mappings and executed instructions. Which can later be extended in a way that it contains all required information.</p>
<p>The raw format contains Python data structures that has been marshalled using the Python pickle library. In the following description a Python-like syntax is used. Where citation around a word means that the string has that exact name. Without any quotations, that item gives a short description of what it represents and a longer description will follow further down. Items within &lt;&gt; notation describes the type of the element. An asterisk at the end of a list means zero or more of the previous elements, while a plus at the end means one or more of the previous element.</p>
<pre><code>
      {"version"&lt;string&gt;: version&lt;int&gt;,
       "features"&lt;string&gt;: {feature&lt;string&gt;: feature_specific_field&lt;unknown&gt;},
       "errors"&lt;string&gt;: [[code&lt;int&gt;, message&lt;string&gt;]*],
       "unknown"&lt;string&gt;: {address&lt;int&gt;: count&lt;int&gt;},
       "unknown_branches"&lt;string&gt;: {address&lt;int&gt;: {"taken"&lt;string&gt;: count&lt;int&gt;,
                                                   "not_taken"&lt;string&gt;: count&lt;int&gt;}},
       "mappings"&lt;string&gt;: [
           {"map"&lt;string&gt;: {"symbol_file"&lt;string&gt;: file&lt;string&gt;,
                             "address"&lt;string&gt;: address&lt;int&gt;, "size"&lt;string&gt;: size&lt;int&gt;,
                             "file_offset"&lt;string&gt;: offset&lt;int&gt;,
                             "file_size"&lt;string&gt;: size&lt;int&gt;,
                             "relocation"&lt;string&gt;: relocation&lt;int&gt;,
                             "section"&lt;string&gt;: section&lt;string&gt;},
            "covered"&lt;string&gt;: {address&lt;int&gt;: count&lt;int&gt;},
            "branches"&lt;string&gt;: {address&lt;int&gt;: {"taken"&lt;string&gt;: count&lt;int&gt;,
                                                 "not_taken"&lt;string&gt;: count&lt;int&gt;}}
            "file_table"&lt;string&gt;: {file_id&lt;string&gt;: source_file&lt;string&gt;},
            "functions"&lt;string&gt;: {address&lt;int&gt;: {"name"&lt;string&gt;: name&lt;string&gt;,
                                                  "size"&lt;string&gt;: size&lt;int&gt;}},
            "data_labels"&lt;string&gt;: {address&lt;int&gt;: {"name"&lt;string&gt;: name&lt;string&gt;}},
            "info"&lt;string&gt;: [{"address"&lt;string&gt;: address&lt;int&gt;, "op": [op&lt;int&gt;+],
                               "mnemonic"&lt;string&gt;: mnemonic&lt;string&gt;,
                               "format"&lt;string&gt;: format&lt;string&gt;,
                               "executable_lines"&lt;string&gt;: {line&lt;int&gt;: True&lt;bool&gt;},
                               "file_id"&lt;string&gt;: file_id&lt;string&gt;}*],
            "src_info"&lt;string&gt;: {"file_id"&lt;string&gt;:
                                 {line&lt;int&gt;: [[start_address&lt;int&gt;, end_address&lt;int&gt;]*]}},
            "removed_data"&lt;string&gt;: {address&lt;int&gt;: {"size"&lt;string&gt;: size&lt;int&gt;}},
            "cpu_classes": [cpu_class&lt;string&gt;*],
            "disassembly_class": cpu_class&lt;string&gt;,
            "errors"&lt;string&gt;: [[code&lt;int&gt;, message&lt;string&gt;]*]}*],
       "cpu_classes": [cpu_class&lt;string&gt;*],
       "unknown_mappings"&lt;string&gt;: [
           {"map"&lt;string&gt;: {"address"&lt;string&gt;: address&lt;int&gt;,
                            "size"&lt;string&gt;: size&lt;int&gt;},
            "covered"&lt;string&gt;: {address&lt;int&gt;: count&lt;int&gt;}}]*}
    
</code></pre>
<ul>
<li>
<p><code>version</code> - The version of the code coverage raw format that was used to create the raw file. This version number is only increased when there is a change to the format that is either extending the previous version or breaking it (should be very rare).</p>
</li>
<li>
<p><code>features</code> - A dictionary that maps a <code>feature</code> to its <code>feature_specific_field</code> information. Available features are:</p>
<ul>
<li><code>access_count</code> - This feature is used to count how many times an instruction has been executed. The <code>feature_specific_field</code> is a bool, where <code>True</code> indicates that the feature is enabled.</li>
<li><code>branch_coverage</code> - This feature is used to collect branch coverage on instruction level. The <code>feature_specific_field</code> is a bool, where <code>True</code> indicates that the feature is enabled.</li>
</ul>
</li>
<li>
<p><code>errors</code> - A list with zero or more entries, containing an error code and the matching error message for any errors that are not bound to a specific mapping.</p>
</li>
<li>
<p><code>unknown</code> - A dictionary which in turn maps executed addresses without any known mappings, at the execution time, to a count of how many times it was executed. In order for the execution counter to be valid, the <code>access_count</code> feature must be enabled. Otherwise, it will always be one for such executed instruction.</p>
</li>
<li>
<p><code>unknown_branches</code> - Same as <code>mappings</code> - <code>branches</code>, but for conditional branch instructions that have executed and do not belong to any mapping.</p>
</li>
<li>
<p><code>mappings</code> - This entry contains a list of each mapping that was known to the code coverage system while collecting data. The following entries are available</p>
<ul>
<li>
<p><code>map</code> - A key containing a unique description of the mapping. Which has the following identifiers:</p>
<ul>
<li><code>symbol_file</code> - Gives the location of the module backing up the mapping.</li>
<li><code>address</code> - Specifies the loaded address of the mapping.</li>
<li><code>size</code> - Specifies the size of the mapping.</li>
<li><code>file_offset</code> - Specifies the offset into the file where this segment or section can be found.</li>
<li><code>file_size</code> - Specifies the size of the entry in the file.</li>
<li><code>relocation</code> - Specifies the relocation address.</li>
<li><code>section</code> - Optional field, included when only one section of a symbol file is used as mapping.</li>
</ul>
</li>
<li>
<p><code>covered</code> - This field works just like <code>unknown</code> field, except that this is per module and contains all executed addresses that were mapped to this mapping while executing.</p>
</li>
<li>
<p><code>branches</code> - Keeps track of all branch instructions and how many times a branch at the given <code>address</code> was taken or not taken. Only available if <code>branch_coverage</code> feature was enabled when collecting data.</p>
</li>
<li>
<p><code>file_table</code> - Maps <code>file_id</code> to a full source file path.</p>
</li>
<li>
<p><code>functions</code> - Contains a function's start <code>address</code>, <code>name</code>, and <code>size</code>.</p>
</li>
<li>
<p><code>data_labels</code> - Non-executable symbols in executable sections, containing the symbol's <code>address</code> and <code>name</code>.</p>
</li>
<li>
<p><code>info</code> - Contains a list, with one element per disassembled address, where each entry has the following members:</p>
<ul>
<li><code>address</code> - The address of the disassembled instruction</li>
<li><code>op</code> - A list of opcodes making up the instruction</li>
<li><code>mnemonic</code> - The mnemonic of the instruction</li>
<li><code>format</code> - Instruction format, currently only present for ARM. Tells if the instruction has <code>arm</code>, <code>thumb</code> or <code>aarch64</code> format.</li>
<li><code>file_id</code> - A reference to the source file in the <code>file_table</code>. Only exists if source info has been added and exists for this <code>address</code></li>
<li><code>executable_lines</code> - Describes which source lines the instruction belongs to. Only exists if source info has been added and exists for this <code>address</code></li>
</ul>
</li>
</ul>
<p>The raw data contains either this field or <code>src_info</code>, never both.</p>
<ul>
<li><code>src_info</code> - A dictionary with information about executable lines and addresses for source files. Each item in the dictionary is source file where the key corresponds to a <code>file_id</code> in <code>file_table</code>.</li>
</ul>
<p>The value of that item is another dictionary where there is an executable source <code>line</code> of that file and the value is a list of address ranges that correspond to that source line. Each address range in this list is a list of two elements, <code>start_address</code> and <code>end_address</code>, where the latter is inclusive.</p>
<p>A source line can be considered executed if any of the addresses inside its address ranges is found in the <code>covered</code> entry.</p>
<p>The raw data contains either this field or <code>info</code>, never both.</p>
<ul>
<li><code>cpu_classes</code> - Optional field. Keeps track of which cpu classes have been run in this specific mapping when collecting coverage.</li>
<li><code>disassembly_class</code> - Optional field. Specifies which processor class has been used to disassemble this mapping. This field is only present when disassembling was done using a processor interface, not when a disassemble module was used.</li>
<li><code>removed_data</code> - Address ranges in the mapping that have been removed because they were considered to be data. The dictionary has the start address as key the <code>size</code> of the removed region as value. The name of the removed symbol should be retrievable from <code>data_labels</code> using the start address.</li>
<li><code>errors</code> - A per module error list, containing an error <code>code</code> and a <code>message</code>.</li>
</ul>
</li>
<li>
<p><code>cpu_classes</code> - Optional field. Keeps track of which cpu classes have been used to collect coverage with.</p>
</li>
<li>
<p><code>unknown_mappings</code> - This entry contains a list of each mapping that was known to the code coverage system while collecting data, but did not have a symbol file name. The following entries are available</p>
<ul>
<li>
<p><code>map</code> - A key containing the location of the unknown mapping. It has the following identifiers:</p>
<ul>
<li><code>address</code> - Specifies the loaded address of the mapping.</li>
<li><code>size</code> - Specifies the size of the mapping.</li>
</ul>
</li>
<li>
<p><code>covered</code> - This field works just like <code>unknown</code> field, except that this is per module and contains all executed addresses that were mapped to this mapping while executing.</p>
</li>
</ul>
</li>
</ul>
</section><section class="page" id="explanation-of-source-coverage.html"><h1 id="explanation-of-source-coverage.html:explanation-of-source-coverage"><a href="#explanation-of-source-coverage.html:explanation-of-source-coverage">4.6 Explanation of source coverage</a></h1>
<p>This section will explain why the source reports can sometimes look like it would be incorrect and why the reports might differ from reports created by other tools, such as <em>gcov</em>.</p>
<p>Simics code coverage will rely only on what the debug information provides and does not have any extra information about if a source line is considered executable, contains branches, etc. Only lines which have instructions associated with them are considered executable, this means for example that variable declarations will not be marked as executable and that only one line of a multi-line expression might be marked as executable.</p>
<p>Sometimes the source report might look strange, especially when optimization and inlining is involved. As an example, see figure <a class="reference" href="#explanation-of-source-coverage.html:coverage-explained-case">22</a>, which is a simple example that shows how a uncovered line can occur between two covered lines, without any branches involved. Similar cases usually occur when running coverage on a Linux kernel.</p>
<figure id="explanation-of-source-coverage.html:coverage-explained-case">
<p><img alt="" src="code-coverage-red-line-between-green.png"></p><figcaption>Figure 22. Source report for the inlined <code>helper</code> function.</figcaption><p></p>
</figure>
<p>One would likely expect that line <em>50</em> would be green if both line <em>49</em> and line <em>51</em> are green as there is no branch involved. But this does not have to be the case and the report is actually correct.</p>
<p>This function is defined in a header file and will be inlined into two other functions, named <code>one</code> and <code>another</code>. Line <em>48</em> will be optimized out when inlining into the <code>another</code> function, while line <em>50</em> will be optimized out for the <code>one</code> function. Line <em>49</em> and <em>51</em> will be included in both functions. In the example only the <code>one</code> function has been executed so lines included in that will be green, while lines only included in the <code>another</code> function will be red. If a shared line has been executed by any function it will be marked as green.</p>
<p>The output in figure <a class="reference" href="#explanation-of-source-coverage.html:coverage-explained-case-with-functions">23</a> is the same collected coverage as above, but with the <code>-show-line-functions</code> flag passed to the <code>&lt;code_coverage&gt;.html-report</code> command. This will show which functions make use of each line. This reveals what was explained above, that line <em>50</em> is only included by the <code>another</code> function and therefore it is red as the <code>another</code> function has not executed. Line <em>48</em> is only included by the <code>one</code> function, but that function has executed so that line is green. Both lines <em>49</em> and <em>51</em> are used by both functions so they will be green as one of the functions has executed.</p>
<figure id="explanation-of-source-coverage.html:coverage-explained-case-with-functions">
<p><img alt="" src="code-coverage-red-line-between-green-with-functions.png"></p><figcaption>Figure 23. Source report for the inlined <code>helper</code> function, showing functions that use each line.</figcaption><p></p>
</figure>
</section><section class="page" id="code-coverage-limitations.html"><h1 id="code-coverage-limitations.html:limitations"><a href="#code-coverage-limitations.html:limitations">4.7 Limitations</a></h1>
<div class="dl">
<ul>
<li>
<p><span class="term" id="code-coverage-limitations.html:dt:disassembly"><a href="#code-coverage-limitations.html:dt:disassembly">Disassembly</a></span><br>
Disassembly is done per executable section, starting at the first address of each function and taking instruction by instruction until the next function or end of section. If function information is not available then disassembly will be done from the beginning of the section to the end of the section instead. The latter behavior can be forced by using the <code>-whole-section</code> flag with the <em>disassemble</em> command. Data in the executable section may corrupt the disassembly, especially for variable length instruction platforms, as this data is also treated as instructions and disassembled. Disassembly will be performed on data from the original executable file, so any code that is modified in memory (compressed code as an example) will not be reflected in the report. Code that is not part of any executable section, will not be included in the report.</p>
</li>
<li>
<p><span class="term" id="code-coverage-limitations.html:dt:sections"><a href="#code-coverage-limitations.html:dt:sections">Sections</a></span><br>
When disassembling an executable section, it is assumed that the executable section has the same architecture for the entire mapping, this is taken from the binary. Code that mixes different processor modes, 16, 32 and 64 bit for example, may therefore end up with incorrect disassembly.</p>
</li>
<li>
<p><span class="term" id="code-coverage-limitations.html:dt:pdb-format"><a href="#code-coverage-limitations.html:dt:pdb-format">PDB format</a></span><br>
PDB symbol information is only supported on Microsoft* Windows*.</p>
</li>
<li>
<p><span class="term" id="code-coverage-limitations.html:dt:quality"><a href="#code-coverage-limitations.html:dt:quality">Quality</a></span><br>
This code coverage implementation is purely based on available debug information and does not require modifications to the binary. This means that the executable source lines and executed source lines information depends highly on the quality of debug information. Usually this improves by decreasing optimization level. Due to inlining of functions and various optimizations the source coverage may be hard to interpret.</p>
</li>
<li>
<p><span class="term" id="code-coverage-limitations.html:dt:architectures"><a href="#code-coverage-limitations.html:dt:architectures">Architectures</a></span><br>
For disassembly, only classes that implement the <code>class_disassembly</code> interface plus x86 and ARM families are supported. Other architectures where the processor model supports instrumentation, source only coverage can be output.</p>
<p>When disassembling without the <code>class_disassembly</code> interface, some instructions that were added in recent architectures might not be disassembled correctly in the disassembly report.</p>
</li>
<li>
<p><span class="term" id="code-coverage-limitations.html:dt:vmp"><a href="#code-coverage-limitations.html:dt:vmp">VMP</a></span><br>
VMP will not be engaged while code coverage is collecting data.</p>
</li>
<li>
<p><span class="term" id="code-coverage-limitations.html:dt:branch-coverage"><a href="#code-coverage-limitations.html:dt:branch-coverage">Branch coverage</a></span><br>
Currently only x86 and ARM families support branch coverage.</p>
</li>
<li>
<p><span class="term" id="code-coverage-limitations.html:dt:arm-branch-coverage"><a href="#code-coverage-limitations.html:dt:arm-branch-coverage">ARM branch coverage</a></span><br>
For branch coverage on ARM only <code>B&lt;cond&gt;</code>, <code>CBZ</code>, <code>CBNZ</code>, <code>TBZ</code> and <code>TBNZ</code> instructions are handled. Any other conditional instructions, including <code>BL</code>, <code>BX</code> and similar are not included in branch coverage. Neither are Thumb instructions made conditional by an IT-block handled by branch coverage.</p>
</li>
<li>
<p><span class="term" id="code-coverage-limitations.html:dt:x86-16-bit-real-mode"><a href="#code-coverage-limitations.html:dt:x86-16-bit-real-mode">x86 16-bit real mode</a></span><br>
Instructions in 16-bit real mode will be disassembled as 32-bit instructions. This is because the ELF header or sections do not have any information about 16-bit mode. This can result in that both disassembly and source coverage for 16-bit real mode code gets incorrect.</p>
</li>
</ul>
</div>
</section><section class="page" id="caches.html"><h1 id="caches.html:cache-simulation"><a href="#caches.html:cache-simulation">5 Cache Simulation</a></h1>
</section><section class="page" id="caches-introduction.html"><h1 id="caches-introduction.html:introduction-to-cache-simulation-with-simics"><a href="#caches-introduction.html:introduction-to-cache-simulation-with-simics">5.1 Introduction to Cache Simulation with Simics</a></h1>
<p>By default, Simics does not model any cache system. It uses its own memory system to achieve high speed simulation, and modeling a hardware cache model would only slow it down. Simics exposes however, by the instrumentation API, the flow of memory operations coming from the processor, and thus allows users to write tracing tools and collect statistics on the memory behavior of their simulations.</p>
<p>Additionally, Simics lets user-written <em>timing models</em> control how long memory transaction takes. <em>Stalling</em> the execution, as it is called in Simics, helps improving the timing accuracy of the simulation, as compared to a real system. Historically, the timing model/snoop device interfaces has been use in Simics to model caches. Since those interfaces block memory accesses from being looked up in a fast address translation table in Simics, the execution speed has suffered considerably. From Simics 6, the instrumentation API has been available as a core feature and this has improved the performance on cache modeling. The instrumentation API works with the fast table lookup and makes Simics very suitable for various types of cache simulation:</p>
<div class="dl">
<ul>
<li>
<p><span class="term" id="caches-introduction.html:dt:cache-profiling"><a href="#caches-introduction.html:dt:cache-profiling">Cache Profiling</a></span><br>
The goal is to gather information about the cache behavior of a system or an application, e.g., explore different prefetching algorithms. Unless the application runs on multiprocessors, takes a lot of interrupts or runs a lot of system-level code, the timing of the memory operations is often irrelevant, thus no stalling is necessary.</p>
<p>Note that this type of simulation <em>does not change</em> the execution of the target program. It could be done by using Simics as a simple memory operation trace generator, and then computing the cache state evolution afterwards or during the simulation.</p>
</li>
<li>
<p><span class="term" id="caches-introduction.html:dt:cache-timing"><a href="#caches-introduction.html:dt:cache-timing">Cache Timing</a></span><br>
The goal is to study the timing behavior of the transactions, in which case a transaction to memory should take much more time than, for example, a transaction to an L1 cache. This is useful when studying interactions between several CPUs, or to estimate the number of cycles per instruction (CPI) of an application. Simics models can be used for such a simulation.</p>
<p>This type of simulation <em>modifies</em> the execution, since interrupts and multi-processor interaction will be influenced by the timing provided by the cache model. However, unless the target program is not written properly, the execution will always be correct, although different from the execution obtained without any cache model.</p>
<p>There are two types of possible modeling techniques for this class. Either a mechanistic model, where you try to implement as many details as possible in the cache system, possibly with slower simulation speed, or a statistical model, where you try to estimate the time from a set of events that happens in the cache system. This can be achieved by using regression models calculated from more detailed simulation models or from real hardware. In this case the simulation speed may be better since you may cut the number of events that need be collected, but the regression models can still give you a good approximation. Of course both of these methods, has trade offs between simulation speed and accuracy. They can also be combined to estimate the time of different parts of the memory hierarchy with either a mechanistic approach or a statistical.</p>
</li>
<li>
<p><span class="term" id="caches-introduction.html:dt:cache-content-simulation"><a href="#caches-introduction.html:dt:cache-content-simulation">Cache Content Simulation</a></span><br>
It is possible to change Simics coherency model by allowing a cache model to contain data that is different from the contents of the memory. Such a model needs to properly handle the memory transactions as it must be able to change the values of loads and stores.</p>
<p>Note that this kind of simulation is difficult to do and requires a well-written, bug-free cache model, since it can prevent the target program from executing properly. The instrumentation API supports this kind of modeling since it allows memory accesses to be redirected from memory into the cache model data storage for each cache line.</p>
</li>
</ul>
</div>
<p>Simics comes with a cache model called <code>simple_cache</code>, which allows cached profiling and cache timing: it handles one transaction at a time in a flat way: all needed operations (copy-back, fetch, etc.) are performed in order and at once. The cache returns the sum of the stall times reported for each operation. This cache should not be considered as a final solution for cache modeling, rather it should be seen as starting point with some of the basic cache concepts modeled. The source code is available so it should be possible to extend it with new features (the module is called simple-cache-tool).</p>
<p>Before going further and describing the simple cache in more details, a few things should be mentioned:</p>
<ul>
<li>For performance and correctness we will not penalize a single instruction, i.e., stalling it as many cycles the transaction takes (both instruction access and data access), instead all extra stalls are collected in an other object and at regular intervals the entire processor is stalled the given added penalty. Although, not currently modeled by the simple cache, this scheme allows more complex models such a out of order execution of the transactions and simultaneously outstanding transactions. Stalling a single instruction would be meaningless, i.e., model a completely serial processor, would be way off in terms of correct timing. This also means that you cannot look at small code snippets and get a good time estimate, but on average running much longer this will give better time estimates.</li>
<li>For simplicity, Simics does not model incoherence. In Simics, the memory is <em>always</em> up to date with the latest CPU and device transactions. This property holds even when doing cache simulation with Simics standard model, as it does not contain any data, only cache line status information. But as mentioned above it is possible to create such a cache.</li>
<li>Currently DMA accesses are not seen by the <code>simple_cache</code>.</li>
</ul>
</section><section class="page" id="simulating-a-simple-cache.html"><h1 id="simulating-a-simple-cache.html:simulating-a-simple-cache"><a href="#simulating-a-simple-cache.html:simulating-a-simple-cache">5.2 Simulating a Simple Cache</a></h1>
<p>Caches models are not currently well integrated with the component system that Simics uses for other devices. For that reason, users are typically required to create caches and connect them by hand. This approach offers, on the other hand, total control on the configuration process. There are however some help commands that can be used to add simple cache hierarchies, and we will study them below.</p>
<p>Here is an example on how to create three level caches by using the instrumentation framework.</p>
<p>First you need to create a cache tool object with the following command:</p>
<pre><code>
  new-simple-cache-tool name = cachetool -connect-all
</code></pre>
<p>If you want to simulate simple timing you can add a cycle staller object to the cache tool as well:</p>
<pre><code>
  new-cycle-staller name = cs0 stall-interval = 10000
  new-simple-cache-tool name = cachetool cycle-staller = cs0 -connect-all
</code></pre>
<p>The cycle-staller object adds extra stalls from the caches to the processors at a given interval (here 10000 cycles). The purpose of this method compared to stalling the processor at each memory access is that is much more efficient to do it. The staller will sum up all penalty cycles from the caches, and then apply them as a single stall time at the end of the interval.</p>
<p>If only cache statistics such as hit rates etc. are requested the cycle staller can be omitted.</p>
<p>The <code>new-simple-cache-tool</code> command creates an instrumentation tool that works as a handler for all processors added to the tool. The <code>-connect-all</code> flag tells the command to connect to all the processors in the configuration. Simics usually does not make any distinction between single cores and cores with hardware threads. Each thread will be regarded a "processor", and thus you will get a connection for each hardware threads present in the configuration. A connection is small Simics object that handles the association between the caches and the processor hardware threads.</p>
<p>You can also use the <em>processors</em> argument to the command to list only a certain group of processors (threads) to connect to. This can be useful for heterogeneous setups where different core have different cache settings. In such scenario you should create more than one cache tool.</p>
<p>The cache tool installs instrumentation callbacks for every memory operation and redirects them to the caches. The callbacks can be installed on different access types such as data operation and instruction fetches, and this is used to dispatch the access to the correct first level cache, the instruction cache or the data cache.</p>
<p>Now we are going to add the cache models to the tool. We use the commands <code>add-l1d-cache</code> (level one data cache), <code>add-l1i-cache</code> (level one instruction cache), <code>add-l2-cache</code> (level two cache for both data and instructions), and then <code>add-l3-cache</code> (shared level tree cache among the cores).</p>
<pre><code>
(cachetool.add-l1d-cache name = l1d line-size = 64 sets = 64 ways = 12
 -ip-read-prefetcher prefetch-additional = 1)

(cachetool.add-l1i-cache name = l1i line-size = 64 sets = 64 ways = 8)

(cachetool.add-l2-cache name = l2 line-size = 64 sets = 1024 ways = 20
 -prefetch-adjacent prefetch-additional = 4)

(cachetool.add-l3-cache name = l3 line-size = 64 sets = 8192 ways = 12)
</code></pre>
<p>This is an example of added caches to a QSP (quick start platform) that consists of 1 cpu socket (cpu0), with 2 cores and 2 threads per core. Before the caches are added the processor hierarchy looks like:</p>
<p>(Notice, the following examples shows just selected output from the <code>list-objects -tree</code> command.)</p>
<pre><code>
 cpu0 ┐
      ├ core[0][0]
      ├ core[0][1]
      ├ core[1][0]
      ├ core[1][1]
</code></pre>
<p>and after when the caches has been added:</p>
<pre><code>
 cpu0 ┐
      ├ cache[0] ┐
      │          ├ l1d 
      │          ├ l1i 
      │          └ l2
      ├ cache[1] ┐
      │          ├ l1d 
      │          ├ l1i 
      │          └ l2
      ├ core[0][0]
      ├ core[0][1]
      ├ core[1][0]
      ├ core[1][1]
      ├ directory_l1 
      ├ directory_l2 
      ├ directory_l3 
      ├ l3 
</code></pre>
<p>As you can see, there are added caches for all the cores. The cache[0] namespace keeps the caches for core 0, and cache[1] for core 1 respectively. The two hardware threads core[0][0] and core[0][1] will share the caches under cache[0], and core[1][0] and core[1][1] will share the caches under cache[1]. All accesses from the threads go first to l1d/l1i and then to l2. The l3 cache is shared between both cores. The directory objects keeps a cache directory for each cache level that keeps track of the cache coherency. The caches models a simple MESI protocol for each level. The directories also talk to each other to keep the consistency for all levels.</p>
<p>You can also list the cache objects created in a table by the following command:</p>
<pre><code>
simics&gt; list-objects class = simple_cache -all
┌──────────────┬──────────────────────────┐
│    Class     │          Object          │
├──────────────┼──────────────────────────┤
│&lt;simple_cache&gt;│board.mb.cpu0.cache[0].l1d│
│&lt;simple_cache&gt;│board.mb.cpu0.cache[0].l1i│
│&lt;simple_cache&gt;│board.mb.cpu0.cache[0].l2 │
│&lt;simple_cache&gt;│board.mb.cpu0.l3          │
└──────────────┴──────────────────────────┘
</code></pre>
<p>There is also a command, <code>&lt;simple_cache_tool&gt;.list-caches</code>, to list the caches connected to a specific <code>simple_cache_tool</code>. For example:</p>
<pre><code>
    simics&gt; cachetool.list-caches
┌─────┬──────────────────────────┬────┬────┬─────────┬──────────┐
│Row #│       Cache Object       │Sets│Ways│Line Size│Total Size│
├─────┼──────────────────────────┼────┼────┼─────────┼──────────┤
│    1│board.mb.cpu0.cache[0].l1d│  64│  12│       64│ 48.00 kiB│
│    2│board.mb.cpu0.cache[0].l1i│  64│   8│       64│ 32.00 kiB│
│    3│board.mb.cpu0.cache[0].l2 │1024│  20│       64│  1.25 MiB│
│    4│board.mb.cpu0.l3          │4096│  12│       64│  3.00 MiB│
└─────┴──────────────────────────┴────┴────┴─────────┴──────────┘
</code></pre>
<p>Here some size properties of the caches is also displayed.</p>
<p>All the configuration parameters to the <code>&lt;simple_cache&gt;</code>.add-{l1d,l1i,l2,l3}-cache commands are listed here:</p>
<ul>
<li><code>line-size</code> the cache line size, default 64 (bytes).</li>
<li><code>sets</code> the number of cache sets, i.e., number of indices.</li>
<li><code>ways</code> sets the cache associativity, i.e., the total number of cache lines will be sets * ways, default number of ways is 1.</li>
<li><code>-write-through</code> if the cache should be a write through cache, i.e., all writes will be passed through to the next level (even cache hits). Default is not to write through.</li>
<li><code>-no-write-allocate</code> if the cache should not allocate lines upon a cache write miss. If no write allocate the cache will write through on write misses. Default is to do write allocate, by first reading the cache line.</li>
<li><code>read-penalty</code> sets the time in cycle it takes to read from the cache.</li>
<li><code>read-miss-penalty</code> sets the time in cycles it takes to miss in the cache. So for a miss both the read penalty and read miss penalty will be added. Usually this is only set for the last cache to set the time it takes to reach memory.</li>
<li><code>write-penalty</code> sets the time in cycle it takes to write to the cache.</li>
<li><code>write-miss-penalty</code> sets the time in cycle it takes to write and miss in the cache. So for a miss both the write penalty and write miss penalty will be added. Usually this is only set for the last cache to set the time it takes to reach memory.</li>
<li><code>prefetch-additional</code> sets how many consecutive cache lines to fetch additionally to the one that missed.</li>
<li><code>-prefetch-adjacent</code> means that the cache will, on a miss, prefetch the adjacent cache line as well, so the total fetch region is cache line size times 2, naturally aligned.</li>
<li><code>-ip-read-prefetcher</code> adds an instruction pointer stride prefetcher for reads</li>
<li><code>-ip-write-prefetcher</code> adds an instruction pointer stride prefetcher for writes</li>
<li><code>-no-issue</code> this is a special flag for the add-l1i-cache command which prevents the CPU to do any instruction fetch accesses to the instruction cache. This is useful if the instruction cache should be called from another tool, such as a branch predictor tool that drives the instructions cache. If not set, the instruction cache will be called for each new cache block that the CPU fetches.</li>
</ul>
<p>The penalties from above is only relevant if you add the cycle staller object.</p>
<p>If you run the simulation for a while, say 1 000 000 000 cycles, with the <code>run-cycles</code> command, you will get information about a cache with the <code>cache.print-statistics</code> command.</p>
<p>So, from the table above choose one cache object, and do for instance:</p>
<pre><code>
simics&gt; board.mb.cpu0.cache[0].l1d.print-statistics
  
</code></pre>
<p>The output will be something like the following. See chapter <em>Understanding the Statistics of Simple Cache</em> below for more information about the statistics.</p>
<pre><code>

┌─────┬───────────────────────────────────┬────────┬─────┐
│Row #│              Counter              │ Value  │  %  │
├─────┼───────────────────────────────────┼────────┼─────┤
│    1│read accesses                      │10571090│     │
│    2│read misses                        │  194075│ 1.84│
│    3│write accesses                     │ 3704615│     │
│    4│write misses                       │  152557│ 4.12│
│    5│prefetch accesses                  │  323980│     │
│    6│prefetch misses                    │  253378│78.21│
│    7│prefetched lines used              │  139516│43.06│
│    8│evicted lines (total)              │  599242│     │
│    9│evicted modified lines             │  172067│28.71│
│   10│entire cache flushes (invd, wbinvd)│       8│     │
│   11│uncachable read accesses           │56531126│     │
│   12│uncachable write accesses          │38655295│     │
└─────┴───────────────────────────────────┴────────┴─────┘
  
</code></pre>
<p>The table can also be exported to a comma separated value file (csv), by using the <code>.export-table-csv</code> command, e.g.,</p>
<pre><code>
simics&gt; board.mb.cpu0.cache[0].l1d.export-table-csv file = my-stats.csv
  
</code></pre>
<p>You can also view the content of a cache with the <code>.print-cache-content</code> command, e.g.,</p>
<pre><code>
simics&gt; board.mb.cpu0.cache[0].l1d.print-cache-content -no-row-column

┌─────┬────────────────┬────────────────┬────────────────┬────────────────┐
│Index│      Way0      │      Way1      │      Way2      │      Way3      │
├─────┼────────────────┼────────────────┼────────────────┼────────────────┤
│    0│M:0xdffd4b00:2:-│S:0xdffef000:1:-│S:0xdffce000:0:-│M:0xdffcf200:3:-│
│    1│E:0xdffedf40:2:-│E:0xdffcf240:1:P│M:0xdffcf040:3:-│S:0xdffce040:0:-│
│    2│S:0xdffce080:1:-│S:0xdffcf280:2:-│M:0xdffcf180:3:-│E:0xdffedf80:0:-│
│    3│M:0xdffd4ac0:1:-│E:0xdffcf2c0:3:P│E:0xdffcf1c0:0:S│E:0xdffedfc0:2:-│
└─────┴────────────────┴────────────────┴────────────────┴────────────────┘
</code></pre>
<p>The <code>-no-row-column</code> removes the default Row column from the table, which is useful since it reduces possible confusion with the Index column.</p>
<p>This example shows a small cache with only 4 sets and 4 ways. The first letter of each cache line shows the state of the cache line in the MESI cache protocol. M is modified, E is Exclusive, S is shared, and I is Invalid. The next field is the tag, or rather the physical address of the cache line. The next number tells the age of the cache line among the ways in the set. 0 means the most recently used (MRU) and higher number means older up to the highest number representing the leased recently used (LRU) line. The last letter shows the prefetch status. P means the line has been prefetched but not used yet, and S means that line is currently part of a stride prefetching scheme.</p>
<p>There is a flag to the command, <code>-no-invalid-sets</code>, that filters out sets with only invalid lines.</p>
<p>Also, the table printed will default to only show a maximum of 40 sets. To show more or fewer of the sets use the <em>max</em> argument to the command to set the limit.</p>
</section><section class="page" id="programmatically-constructing-a-cache-hierarchy.html"><h1 id="programmatically-constructing-a-cache-hierarchy.html:programmatically-constructing-a-cache-hierarchy"><a href="#programmatically-constructing-a-cache-hierarchy.html:programmatically-constructing-a-cache-hierarchy">5.3 Programmatically constructing a cache hierarchy</a></h1>
<p>Using <code>simple_cache</code>, we can programmatically (here using Python) setup a cache hierarchy not limited to the commands described in the previous section.</p>
<p>You still need a cache instrumentation tool and its connections to build on. It is from the connection that is associated with a processor (or hardware thread) you build up the hierarchy.</p>
<p>The important attributes in each cache are those that connect the caches together. The <code>next_level</code> attribute of the cache should point to the next level cache, if any, and the <code>prev_level</code> should point to the caches of the previous level, if any. The <code>prev_level</code> attribute is a list of cache objects, e.g., the level 2 cache can have both a data and an instruction cache as its previous caches. If only one previous cache object exists, only one object should be set in the list.</p>
<p>The first cache level is special. Each connection in the cache tool should point the first level data cache and instruction cache by setting the <code>dcache</code> and <code>icache</code> attribute of the connection. If there is only one first level cache, both these attribute should point to the same cache object. Several connections can point to the same cache, e.g., all the hardware threads in a core typically share the first level caches. Each hardware thread will get a connection if you use the <code>-connect-all</code> argument to the <code>new-simple-cache-tool</code> command.</p>
<p>The first level caches should also be set up to point back to the connections, using the <code>cache_conn</code> attribute. This attribute should be set to the first connection pointing to the cache, e.g., if a core has two hardware threads the attribute should be set to the connection representing the first hardware thread.</p>
<p>All the cache levels need a <code>simple_directory</code> object. This object keeps track of where each cache lines are stored in that level and make sure the cache coherency is fulfilled. Each directory object need to be setup to point to the next level directory using the <code>next_directory</code> attribute.</p>
<p>For simplicity the following example does not involve hardware threads.</p>
<pre><code>
from simics import *

# create an instrumentation connection object for each processor
run_command("new-simple-cache-tool name = cachetool -connect-all")

# put all objects under my_caches namespace
mc = pre_conf_object("my_caches", "namespace")

mc.dir3 = pre_conf_object("simple_directory")
mc.dir2 = pre_conf_object("simple_directory", next_directory = mc.dir3)
mc.dir1 = pre_conf_object("simple_directory", next_directory = mc.dir2)

mc.l3 = pre_conf_object("simple_cache",
                        cache_block_size = 64,
                        cache_set_number = 4096,
                        cache_ways = 12,
                        prefetch_additional = 3,
                        prefetch_adjacent = True,
                        read_penalty = 80,
                        read_miss_penalty = 200,
                        write_back = True,
                        write_allocate = True,
                        directory = mc.dir3)

all_l2 = []
l1d_names = []
l1i_names = []
num = 0

mc.cache = pre_conf_object("index_map")

# loop through all connections and add caches to the associated processors
for conn in conf.cachetool.connections:
    mc.cache[num] = pre_conf_object("namespace")
    mc.cache[num].l2 = pre_conf_object("simple_cache",
                                       cache_block_size = 64,
                                       cache_set_number = 1024,
                                       cache_ways = 20,
                                       prefetch_additional = 3,
                                       prefetch_adjacent = True,
                                       read_penalty = 20,
                                       write_back = True,
                                       write_allocate = True,
                                       directory = mc.dir2,
                                       next_level = mc.l3)

    mc.cache[num].l1d = pre_conf_object("simple_cache",
                                        cache_block_size = 64,
                                        cache_set_number = 64,
                                        cache_ways = 12,
                                        ip_read_prefetcher = True,
                                        prefetch_additional = 1,
                                        read_penalty = 4,
                                        write_back = True,
                                        write_allocate = True,
                                        directory = mc.dir1,
                                        next_level = mc.cache[num].l2)

    mc.cache[num].l1i = pre_conf_object("simple_cache",
                                        cache_block_size = 64,
                                        cache_set_number = 64,
                                        cache_ways = 8,
                                        prefetch_additional = 1,
                                        read_penalty = 4,
                                        directory = mc.dir1,
                                        next_level = mc.cache[num].l2)

    l1d_names.append(f"my_caches.cache[{num}].l1i")
    l1i_names.append(f"my_caches.cache[{num}].l1d")

    mc.cache[num].l2.prev_level = [mc.cache[num].l1d, mc.cache[num].l1i]

    mc.cache[num].l1d.cache_conn = conn
    mc.cache[num].l1i.cache_conn = conn

    all_l2.append(mc.cache[num].l2)
    num += 1

mc.l3.prev_level = all_l2

SIM_add_configuration([mc], None)

# set attributes in the connections to refer to the 1st level caches
num = 0
for conn in conf.cachetool.connections:
    conn.dcache = SIM_get_object(l1d_names[num])
    conn.icache = SIM_get_object(l1i_names[num])
    conn.issue_instructions = True
    num += 1
</code></pre>
<p>The caches are put an a namespace (cache[N]) to keep the processor associated caches together. The shared level three cache (l3) and the directory objects are left on the top level. This is the partial output from <code>list-objects -tree</code>.</p>
<pre><code>
├ cachetool ┐
│           ├ con0
│           └ con1
├ my_caches ┐
│           ├ cache[0] ┐
│           │          ├ l1d
│           │          ├ l1i
│           │          └ l2
│           ├ cache[1] ┐
│           │          ├ l1d
│           │          ├ l1i
│           │          └ l2
│           ├ dir1
│           ├ dir2
│           ├ dir3
│           └ l3
</code></pre>
<p>You can also see the cache tool that has two connection objects, con0 and con1. These are associated with the two processors in this example setup. It is possible to put the cache objects anywhere in the object hierarchy by giving them hierarchical names.</p>
</section><section class="page" id="workload-positioning-and-cache-models.html"><h1 id="workload-positioning-and-cache-models.html:workload-positioning-and-cache-models"><a href="#workload-positioning-and-cache-models.html:workload-positioning-and-cache-models">5.4 Workload Positioning and Cache Models</a></h1>
<p>In the previous examples, it is worth noticing that connecting the caches to the processors can be done separately from defining the system. It is thus possible to define and remove the caches at any time during the simulation: for example, the operating system boot and workload setup can be done with Simics in normal mode to create a checkpoint. The checkpoint is then reloaded and the caches are then setup.</p>
<p>To get decent cache statistics, it is important to run at least a 10 - 100 million instructions to warm up the caches before actually starting to do measurements. Note that this is only a rough advice; the precise warm-up time needed will depend on the cache model and the workload. A simple way is to make sure that the entire last-level cache is filled with data in all ways, but this has turned out to be an over estimate. All workloads does not need the entire cache to be filled. For more information on cache warming, see the paper <em>Adaptive Cache Warming for Faster Simulations</em> from RAPIDO ’17 January 23-25, 2017.</p>
<p>To tear down and remove the cache hierarchy you can use the command <code>cachetool.delete</code> (will not remove any namespace objects that have been inserted). You can also temporarily disable the caches by using the <code>cachetool.disable-instrumentation</code> command. And then enable them again by <code>cachetool.enable-instrumentation</code>.</p>
<p>When the caches are disabled the performance is much better but it not as fast as removing the caches altogether.</p>
</section><section class="page" id="using-simple-cache.html"><h1 id="using-simple-cache.html:using-simple-cache"><a href="#using-simple-cache.html:using-simple-cache">5.5 Using Simple Cache</a></h1>
<p>Let us have a more detailed look at <code>simple_cache</code>. It has the following features:</p>
<ul>
<li>Configurable cache line size, number of sets and associativity. Note that the line size must be a power of 2, and that the number of sets (indices) also must be a power of two.</li>
<li>Physical index and tag (no support for virtual address tags).</li>
<li>Configurable write allocate/write back policy.</li>
<li>LRU replacement policy.</li>
<li>Sample MESI protocol.</li>
<li>Support for several processors connected to one cache and any number of cache levels.</li>
<li>Configurable penalties for read/write accesses to the cache, and read/write accesses initiated by the cache to the next level cache. Also the snoop penalty can be configured.</li>
<li>Some prefetching algorithms implemented</li>
<li>Cache statistics.</li>
</ul>
<p>Transactions are handled one at a time; all operations are done in order, at once, and a total stall time is returned. The transaction is not reissued afterwards. Here is a short description of the way <code>simple_cache</code> handles a transaction:</p>
<ul>
<li>
<p>If the transaction is an instruction fetch the connection object will send the transaction to the instruction cache, unless the connection has been configured not to send any instruction fetches.</p>
</li>
<li>
<p>If the transaction is data the connection objects will send the transaction to the data cache.</p>
</li>
<li>
<p>If the transaction is a prefetch (instruction) a prefetch transaction will be sent to the data cache.</p>
</li>
<li>
<p>If the transaction is uncacheable, the connection object will ignore it and not send the transaction to the cache.</p>
</li>
<li>
<p>If the transaction is a read hit, <code>simple_cache</code> returns <code>read_penalty</code> cycles of penalty.</p>
</li>
<li>
<p>If the transaction is a read miss, <code>simple_cache</code> will use the LRU algorithm to determine the cache line to allocate.</p>
<p>If the replacement cache line needs to be emptied with modified data, a write-back transaction is initiated to the next level cache. In this case, a <code>write_penalty</code> from the next level cache is added.</p>
<p>The new data is fetched from the next level, incurring <code>read_penalty</code> cycles penalty added to the penalty returned by the next level. The <code>read_miss_penalty</code> is also added to the stall time.</p>
</li>
<li>
<p>The snoop_penalty is added when sending snoop transactions to the other caches (modeled by the directory objects). If the other cache needs to empty a line that penalty is also added.</p>
</li>
<li>
<p>The total penalty returned is the sum of <code>penalty_read</code>, plus the penalties associated with the copy-back (if any), plus the penalties associated with the line fetch, plus the read_miss_penalty, and then the snooping penalty.</p>
</li>
<li>
<p>If the transaction is a write hit, <code>simple_cache</code> returns <code>write_penalty</code> cycles of penalty.</p>
</li>
<li>
<p>If the transaction is a write miss, the write penalty is added, then it depends on if the cache is a write allocate (add penalties for reading the cache line first) or a write through where the transaction is sent to the next level (and write_miss penalty is added).</p>
</li>
<li>
<p>Instruction fetches and prefeches are handles as the read transactions except that prefetches are not added to the stall penalty.</p>
</li>
</ul>
<p>Note the use of the <code>(read/write)_penalty</code> and the <code>(read/write)_miss_penalty</code>, where the first ones are added regardless if it is a hit or a miss (the time to reach the cache) and the second ones are the cost of having an additional miss. Usually, the write penalties may be set to zero to model (unlimited) store buffers.</p>
</section><section class="page" id="understanding-the-statistics-of-simple-cache.html"><h1 id="understanding-the-statistics-of-simple-cache.html:understanding-the-statistics-of-simple-cache"><a href="#understanding-the-statistics-of-simple-cache.html:understanding-the-statistics-of-simple-cache">5.6 Understanding the Statistics of Simple Cache</a></h1>
<p>The following statistics are available in a <code>simple_cache</code>:</p>
<div class="dl">
<ul>
<li><span class="term" id="understanding-the-statistics-of-simple-cache.html:dt:read-accesses"><a href="#understanding-the-statistics-of-simple-cache.html:dt:read-accesses">Read accesses</a></span><br>
Total number of read accesses</li>
<li><span class="term" id="understanding-the-statistics-of-simple-cache.html:dt:read-misses"><a href="#understanding-the-statistics-of-simple-cache.html:dt:read-misses">Read misses</a></span><br>
Total number of read accesses</li>
<li><span class="term" id="understanding-the-statistics-of-simple-cache.html:dt:write-accesses"><a href="#understanding-the-statistics-of-simple-cache.html:dt:write-accesses">Write accesses</a></span><br>
Total number of write accesses</li>
<li><span class="term" id="understanding-the-statistics-of-simple-cache.html:dt:write-misses"><a href="#understanding-the-statistics-of-simple-cache.html:dt:write-misses">Write misses</a></span><br>
Total number of write misses</li>
<li><span class="term" id="understanding-the-statistics-of-simple-cache.html:dt:write-backs"><a href="#understanding-the-statistics-of-simple-cache.html:dt:write-backs">Write backs</a></span><br>
Total number of write backes to this caches (from previous level)</li>
<li><span class="term" id="understanding-the-statistics-of-simple-cache.html:dt:write-backs-misses"><a href="#understanding-the-statistics-of-simple-cache.html:dt:write-backs-misses">Write backs misses</a></span><br>
Total number of write backes misses to this caches (from previous level)</li>
<li><span class="term" id="understanding-the-statistics-of-simple-cache.html:dt:request-for-write-accesses"><a href="#understanding-the-statistics-of-simple-cache.html:dt:request-for-write-accesses">Request for write accesses</a></span><br>
previous level wants to write to this line but missed and now request it for writing at this level</li>
<li><span class="term" id="understanding-the-statistics-of-simple-cache.html:dt:request-for-write-misses"><a href="#understanding-the-statistics-of-simple-cache.html:dt:request-for-write-misses">Request for write misses</a></span><br>
previous level wants to write to this line but missed and now request it for writing at this level but misses</li>
<li><span class="term" id="understanding-the-statistics-of-simple-cache.html:dt:prefetch-accesses"><a href="#understanding-the-statistics-of-simple-cache.html:dt:prefetch-accesses">Prefetch accesses</a></span><br>
Prefetches from either hardware prefetching or from instructions (software)</li>
<li><span class="term" id="understanding-the-statistics-of-simple-cache.html:dt:prefetch-misses"><a href="#understanding-the-statistics-of-simple-cache.html:dt:prefetch-misses">Prefetch misses</a></span><br>
Prefetches from either hardware prefetching or from instructions (software) that misses</li>
<li><span class="term" id="understanding-the-statistics-of-simple-cache.html:dt:request-for-write-prefetch-accesses"><a href="#understanding-the-statistics-of-simple-cache.html:dt:request-for-write-prefetch-accesses">Request for write prefetch accesses</a></span><br>
previous level wants to prefetch a write to this line but missed and now request it for write prefetching at this level</li>
<li><span class="term" id="understanding-the-statistics-of-simple-cache.html:dt:request-for-write-prefetch-misses"><a href="#understanding-the-statistics-of-simple-cache.html:dt:request-for-write-prefetch-misses">Request for write prefetch misses</a></span><br>
previous level wants to prefetch a write to this line but missed and now request it for write prefetching at this level, and misses</li>
<li><span class="term" id="understanding-the-statistics-of-simple-cache.html:dt:prefetches-used"><a href="#understanding-the-statistics-of-simple-cache.html:dt:prefetches-used">Prefetches used</a></span><br>
Prefetches that was later used for reading or writing, i.e., not wasted prefetches</li>
<li><span class="term" id="understanding-the-statistics-of-simple-cache.html:dt:prefetch-instructions"><a href="#understanding-the-statistics-of-simple-cache.html:dt:prefetch-instructions">Prefetch instructions</a></span><br>
Number of prefetch instructions directed to the cache</li>
<li><span class="term" id="understanding-the-statistics-of-simple-cache.html:dt:instruction-fetch-accesses"><a href="#understanding-the-statistics-of-simple-cache.html:dt:instruction-fetch-accesses">Instruction fetch accesses</a></span><br>
Total number of instruction fetches</li>
<li><span class="term" id="understanding-the-statistics-of-simple-cache.html:dt:instruction-fetch-misses"><a href="#understanding-the-statistics-of-simple-cache.html:dt:instruction-fetch-misses">Instruction fetch misses</a></span><br>
Total number of instruction fetches misses</li>
<li><span class="term" id="understanding-the-statistics-of-simple-cache.html:dt:evicted-modified"><a href="#understanding-the-statistics-of-simple-cache.html:dt:evicted-modified">Evicted modified</a></span><br>
Total number of evicted cache lines that was modified and needed to be written back to the next level</li>
<li><span class="term" id="understanding-the-statistics-of-simple-cache.html:dt:evicted-total"><a href="#understanding-the-statistics-of-simple-cache.html:dt:evicted-total">Evicted total</a></span><br>
Total number of evicted cache lines (including evicted modified)</li>
<li><span class="term" id="understanding-the-statistics-of-simple-cache.html:dt:evicted-total-2"><a href="#understanding-the-statistics-of-simple-cache.html:dt:evicted-total-2">Evicted total</a></span><br>
Total number of evicted cache lines (including evicted modified)</li>
<li><span class="term" id="understanding-the-statistics-of-simple-cache.html:dt:cache-flush-instructions"><a href="#understanding-the-statistics-of-simple-cache.html:dt:cache-flush-instructions">Cache flush instructions</a></span><br>
Number of cache flush instructions for flushing entire cache, inv and wbinvd</li>
<li><span class="term" id="understanding-the-statistics-of-simple-cache.html:dt:cache-line-flushs"><a href="#understanding-the-statistics-of-simple-cache.html:dt:cache-line-flushs">Cache line flushs</a></span><br>
Number of cache lins flush instructions (clflush)</li>
<li><span class="term" id="understanding-the-statistics-of-simple-cache.html:dt:uncachable-reads"><a href="#understanding-the-statistics-of-simple-cache.html:dt:uncachable-reads">Uncachable reads</a></span><br>
Total number of non-cacheable reads</li>
<li><span class="term" id="understanding-the-statistics-of-simple-cache.html:dt:uncachable-writes"><a href="#understanding-the-statistics-of-simple-cache.html:dt:uncachable-writes">Uncachable writes</a></span><br>
Total number of non-cacheable writes</li>
</ul>
</div>
<p>Here is an example of the statistics using the print-statistics command:</p>
<pre><code>
simics&gt; board.mb.cpu0.cache[0].l1d.print-statistics
Using the 'board.mb.cpu0.core[0][0]' processor for the Steps/Count column
┌─────┬───────────────────────────────────┬─────────┬─────┐
│Row #│              Counter              │  Value  │  %  │
├─────┼───────────────────────────────────┼─────────┼─────┤
│    1│read accesses                      │724945650│     │
│    2│read misses                        │  2678946│ 0.37│
│    3│write accesses                     │555916819│     │
│    4│write misses                       │ 12439648│ 2.24│
│    5│prefetch accesses                  │  8120411│     │
│    6│prefetch misses                    │  5158065│63.52│
│    7│prefetched lines used              │  3533041│43.51│
│    8│prefetch instructions              │   298374│     │
│    9│evicted modified lines             │ 13465148│66.41│
│   10│evicted total lines                │ 20275891│     │
│   11│uncachable read accesses           │ 56576127│     │
│   12│uncachable write accesses          │ 39916459│     │
└─────┴───────────────────────────────────┴─────────┴─────┘
</code></pre>
<p>Counts with a value of zero are not printed.</p>
</section><section class="page" id="feature-list-stall-cache.html"><h1 id="feature-list-stall-cache.html:processor-specific-features-and-limitations"><a href="#feature-list-stall-cache.html:processor-specific-features-and-limitations">6 Processor-specific Features and Limitations</a></h1>
<p>All types of cache modeling features are not supported by all processor types. The instrumentation API need to be supported in order to do cache modeling for a specific processor.</p>
<p>Currently ARC, ARM, MIPS, PPC, X86 and Xtensa target architectures support instrumentation.</p>
</section><section class="page" id="uefidbg-dbghelp.html"><h1 id="uefidbg-dbghelp.html:handling-dbghelp-dll"><a href="#uefidbg-dbghelp.html:handling-dbghelp-dll">A Handling DBGHELP.DLL</a></h1>
<p>To be able to debug a PE binary that has been compiled with <em>Microsoft Visual Studio<sup>*</sup></em>, the library <code>DBGHELP.DLL</code> must be available for Simics. Because of licensing reasons, <code>DBGHELP.DLL</code> cannot be distributed with Simics. When required, Simics will load <code>DBGHELP.DLL</code> from <code>%simics%/win64/lib/DBGHELP.DLL</code>. If this fails, <code>DBGHELP.DLL</code> will instead be loaded from the default installation directories of either <em>Visual Studio</em> or <em>Windows Driver Kits</em>:</p>
<ul>
<li><code>        C:\Program Files (x86)\Microsoft Visual Studio [version]\Common7\IDE\Remote Debugger\x64\dbghelp.dll    </code></li>
<li><code>        C:\Program Files (x86)\Windows Kits\[version]\Debuggers\x64\dbghelp.dll      </code></li>
</ul>
<p>If <code>DBGHELP.DLL</code> could not be loaded, an Simics will log an error, and the user is required to perform these steps:</p>
<ol>
<li>
<p>Quit Simics.</p>
</li>
<li>
<p>Find a 64-bit version of <code>DBGHELP.DLL</code>, or if not available, install either <em>Visual Studio</em> or download and install <em>Windows Driver Kit</em> from <a href="https://developer.microsoft.com/en-us/windows/hardware/windows-driver-kit" rel="noopener noreferrer" target="_top">https://developer.microsoft.com/en-us/windows/hardware/windows-driver-kit</a></p>
</li>
<li>
<p>If <code>DBGHELP.DLL</code> cannot be automatically loaded by Simics, or if a specific version <code>DBGHELP.DLL</code> is needed, copy it to either to the Simics project or installation:</p>
<div class="dl">
<ul>
<li>
<p><span class="term" id="uefidbg-dbghelp.html:dt:simics-project"><a href="#uefidbg-dbghelp.html:dt:simics-project">Simics project</a></span><br>
Do one of the following:</p>
<ul>
<li>Create the directory <code>[project]\win64\lib</code> and copy <code>DBGHELP.DLL</code> to this directory.</li>
<li>From Simics CLI, use the command <code>&lt;tcf_agent&gt;.copy-dbghelp</code>.</li>
</ul>
</li>
<li>
<p><span class="term" id="uefidbg-dbghelp.html:dt:simics-installation"><a href="#uefidbg-dbghelp.html:dt:simics-installation">Simics installation</a></span><br>
To do this administor permissions are required. Copy <code>DBGHELP.DLL</code> to:</p>
<p><code>C:\Program Files\Simics\Simics 6\Simics 6.0\win64\lib</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>Restart Simics. Information about <code>DBGHELP.DLL</code> can be seen by running:<br>
<code>&lt;tcf_agent&gt;.status</code>.</p>
</li>
</ol>
</section><section class="page" id="uefi-fw-trk-uefi-notification-update.html"><h1 id="uefi-fw-trk-uefi-notification-update.html:update-uefi-for-notification-tracking"><a href="#uefi-fw-trk-uefi-notification-update.html:update-uefi-for-notification-tracking">B Update UEFI For Notification Tracking</a></h1>
<p>When using the UEFI Firmware Tracker with an UEFI BIOS that has been updated to handle notification tracking, SEC, PEI and DXE modules are tracked with almost zero performance penalty.
This appendix describes how to update the UEFI BIOS to allow notification tracking.</p>
<div class="note">
<p>Enabling notification tracking on an UEFI system that has not been updated for notification tracking should not cause any problems, even though it does not improve the tracking in any way. For notification tracking to work, UEFI must be updated according to this appendix.</p>
</div>
<h2 id="uefi-fw-trk-uefi-notification-update.html:step-1-add-extra-action-pecoffextraactionlib"><a href="#uefi-fw-trk-uefi-notification-update.html:step-1-add-extra-action-pecoffextraactionlib">B.1 Step 1 - Add Extra Action (PeCoffExtraActionLib)</a></h2>
<p>We start with updating the <em>Platform Description File (.dsc)</em> to add the library library <em>PeCoffExtraActionLib</em> which will provide module data to the tracker.
In our example, this platform description file is <code>SimicsX58Pkg/SimicsX58PkgIa32X64.dsc</code>.
Search for <code>PeCoffExtraActionLibDebug</code> in the <code>.dsc</code> file, and replace:</p>
<pre><code>|MdePkg/Library/BasePeCoffExtraActionLibNull/BasePeCoffExtraActionLibNull.inf
</code></pre>
<p>with:</p>
<pre><code>|SourceLevelDebugPkg/Library/PeCoffExtraActionLibDebug/PeCoffExtraActionLibDebug.inf
</code></pre>
<p>This will add the module <code>PeCoffExtraActionLibDebug</code> module to the build when also not building with <code>$(SOURCE_DEBUG_ENABLE)</code>.</p>
<h2 id="uefi-fw-trk-uefi-notification-update.html:step-2-disable-default-extra-action-trigger"><a href="#uefi-fw-trk-uefi-notification-update.html:step-2-disable-default-extra-action-trigger">B.2 Step 2 - Disable Default Extra Action Trigger</a></h2>
<p>Next, the default extra action load/unload trigger must be disabled to allow adding a custom trigger, which is to read register <code>CR3</code>.
This is done by changing the value of <code>PcdDebugLoadImageMethod</code> when not building with <code>$(SOURCE_DEBUG_ENABLE)</code>.
Search for <em>PcdDebugLoadImageMethod</em>, in the platform description file and add this before the <code>!endif</code>:</p>
<pre><code>!else
  gEfiSourceLevelDebugPkgTokenSpaceGuid.PcdDebugLoadImageMethod|0x0
</code></pre>
<p>The end result should be:</p>
<pre><code>!ifdef $(SOURCE_DEBUG_ENABLE)
  gEfiSourceLevelDebugPkgTokenSpaceGuid.PcdDebugLoadImageMethod|0x2
!else
  gEfiSourceLevelDebugPkgTokenSpaceGuid.PcdDebugLoadImageMethod|0x0
!endif
</code></pre>
<p>This will disable the default trigger of <code>PeCoffLoaderExtraActionCommon</code> and allow us to add our own trigger, which is described in the next step.</p>
<h2 id="uefi-fw-trk-uefi-notification-update.html:step-3-add-custom-trigger-read-cr3"><a href="#uefi-fw-trk-uefi-notification-update.html:step-3-add-custom-trigger-read-cr3">B.3 Step 3 - Add Custom Trigger (Read CR3)</a></h2>
<p>As a final step, add <em>reading</em> of <code>CR3</code> to the extra action library.
Reading CR3 be used to trigger a notification that is intercepted by the tracker.
Add a call to <code>AsmReadCr3</code> in <code>PeCoffLoaderExtraActionCommon</code> directly after the call to <code>AsmWriteDr3</code> in the file <code>SourceLevelDebugPkg/Library/PeCoffExtraActionLibDebug/PeCoffExtraActionLib.c</code>.</p>
<p>The result end should be similar to:</p>
<pre><code>AsmWriteDr0 (Signature);
AsmWriteDr1 ((UINTN) ImageContext-&gt;PdbPointer);
AsmWriteDr2 ((UINTN) ImageContext);
AsmWriteDr3 (IO_PORT_BREAKPOINT_ADDRESS);
AsmReadCr3 (); # &lt;--- Trigger Simics UEFI Tracker
</code></pre>
<h2 id="uefi-fw-trk-uefi-notification-update.html:patch"><a href="#uefi-fw-trk-uefi-notification-update.html:patch">B.4 Patch</a></h2>
<p>If these instructions were difficult to understand, copy the below patch to a text editor, preferably one with a patch move and read the patch to understand the changes.
The patch is <em>unlikely to apply cleanly</em> on your specific platform description file, but reading the patch should make it possibly to apply the changes to a different platform description file.</p>
<pre><code>diff --git a/SimicsX58Pkg/SimicsX58PkgIa32.dsc b/SimicsX58Pkg/SimicsX58PkgIa32.dsc
index fc969fe..9154743 100644
--- a/SimicsX58Pkg/SimicsX58PkgIa32.dsc
+++ b/SimicsX58Pkg/SimicsX58PkgIa32.dsc
@@ -103,7 +103,7 @@
   PeCoffExtraActionLib|SourceLevelDebugPkg/Library/PeCoffExtraActionLibDebug/PeCoffExtraActionLibDebug.inf
   DebugCommunicationLib|SourceLevelDebugPkg/Library/DebugCommunicationLibSerialPort/DebugCommunicationLibSerialPort.inf
 !else
-  PeCoffExtraActionLib|MdePkg/Library/BasePeCoffExtraActionLibNull/BasePeCoffExtraActionLibNull.inf
+  PeCoffExtraActionLib|SourceLevelDebugPkg/Library/PeCoffExtraActionLibDebug/PeCoffExtraActionLibDebug.inf
   DebugAgentLib|MdeModulePkg/Library/DebugAgentLibNull/DebugAgentLibNull.inf
 !endif
   CpuExceptionHandlerLib|MdeModulePkg/Library/CpuExceptionHandlerLibNull/CpuExceptionHandlerLibNull.inf
@@ -252,6 +252,8 @@

 !ifdef $(SOURCE_DEBUG_ENABLE)
   gEfiSourceLevelDebugPkgTokenSpaceGuid.PcdDebugLoadImageMethod|0x2
+!else
+  gEfiSourceLevelDebugPkgTokenSpaceGuid.PcdDebugLoadImageMethod|0x0
 !endif
</code></pre>
</section>