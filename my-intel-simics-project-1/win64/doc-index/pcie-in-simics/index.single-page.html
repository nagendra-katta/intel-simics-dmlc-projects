<!doctype html>
<meta charset=utf8>
<link rel=stylesheet href="../simics.css">
<title>PCIe Modeling Library</title>

<section class="page" id="index.html"><h1 id="index.html:pcie-modeling-library"><a href="#index.html:pcie-modeling-library">PCIe Modeling Library</a></h1>
<h2 id="index.html:supported-hardware-features"><a href="#index.html:supported-hardware-features">Supported Hardware Features</a></h2>
<p>Simics PCIe modeling library supports up to <strong>PCI Express Base
Specification Revision 6.0</strong>. Some of the features it supports with
little or no modeling effort are:</p>
<ul>
<li>Sending and receiving PCIe Messages</li>
<li>Upstream and downstream I/O and Memory operations</li>
<li>Legacy PCI Interrupts</li>
<li>Message Signalled Interrupts (MSI)</li>
<li>Message Signalled Interrupts X (MSI-X)</li>
<li>Resizable BARs (RBAR)</li>
<li>Virtual Function Resizable BARs (VFRBAR)</li>
<li>Single Root I/O Virtualization (SR-IOV)</li>
<li>Address Translation Service (ATS)</li>
</ul>
<h2 id="index.html:simics-pcie-abstraction"><a href="#index.html:simics-pcie-abstraction">Simics PCIe Abstraction</a></h2>
<p>PCIe is simulated in Simics on a functional level, which means that
models typically operate slightly above the Transaction Layer. Simics
does not simulate individual TLPs, it simulates relevant parts of the
TLP and conveys the information along the route to the target
destination.</p>
<p>A Transaction Layer Package (TLP) in PCIe comes in four different
types: Config, Memory, I/O, and Message. All of these are issued using
the <code>transaction_t</code> data structure. The various bits of information
required to complete an operation (PASID, RequesterID, etc.) are
attached to the <code>transaction_t</code> as <code>atoms</code>.</p>
</section><section class="page" id="quickstart.html"><h1 id="quickstart.html:quickstart"><a href="#quickstart.html:quickstart">Quickstart</a></h1>
<h2 id="quickstart.html:endpoint"><a href="#quickstart.html:endpoint">Endpoint</a></h2>
<p>To create a PCIe endpoint:</p>
<ul>
<li>Import <code>"pcie/common.dml"</code></li>
<li>Add the template <code>pcie_endpoint</code> to the top level of your device code.</li>
<li>Set <code>init_val</code> for the registers <code>device_id</code> and <code>vendor_id</code> in the
<code>pcie_config</code> bank.</li>
<li>If your endpoint defines optional capabilities: set the <code>init_val</code> of
the <code>capabilities_ptr</code> register and add capability templates for the
capabilities present.</li>
<li>Create one or several banks that implement the application logic
present in your endpoint. These will be mapped by the Base Address
Register(s) created in the next step.</li>
<li>Add Base Address registers present in your endpoint, using either the
<code>memory_base_address_64</code> or the <code>memory_base_address_32</code> template.
To map in the application logic is done by setting the <strong>map_obj</strong>
parameter to the banks you created in the previous step.
Sizing the BAR is done by setting the <strong>size_bits</strong> parameter
in the Base Address Register.</li>
</ul>
<figure id="quickstart.html:simple-endpoint-example">
<figcaption>Figure 1. Simple Endpoint</figcaption>
<pre><code class="language-dml">dml 1.4;
device endpoint;
import "pcie/common.dml";

is pcie_endpoint;

bank pcie_config {
    register vendor_id { param init_val = 0x8086; }
    register device_id { param init_val = 0x4042; }
    register bar0 @ 0x10 is memory_base_address_64 {
        // 4k BAR allocation
        param size_bits = 12;
        param map_obj = app0.obj;
    }
    register bar2 @ 0x18 is memory_base_address_64 {
        // 32 MB BAR allocation
        param size_bits = 25;
        param map_obj = app2.obj;
    }
    register capabilities_ptr {
        // points to the base address of the first capability
        param init_val = 0x40;
    }

    group ssid is ssid_capability {
        param base = 0x40;
        param next_ptr = 0x60;
        register ssvid { param init_val = 0x8086; }
    }

    group msi is msi_capability {
        param base = 0x60;
        param next_ptr = 0x0;
        param is_64bit_capable = true;
        param is_pvm_capable = true;
        param is_emd_capable = true;
        param num_vectors = 2;
    }
}

bank app0 {
    // defines application logic tied to BAR0
    register intr size 1 @ 0x0 is write {
        method write(uint64 value) {
            pcie_config.msi.raise(0);  // raise MSI vector 0 on write
        }
    }
}

bank app2 {
    // application logic tied to BAR2 goes here
}
</code></pre>
</figure>
<h2 id="quickstart.html:multi-function-endpoint"><a href="#quickstart.html:multi-function-endpoint">Multi-Function Endpoint</a></h2>
<p>To create a Multi-Function PCIe endpoint:</p>
<ul>
<li>Import <code>"pcie/common.dml"</code></li>
<li>Add the template <code>pcie_multifunction_endpoint</code> to the top level of your device code.</li>
<li>Define one bank for each function in your endpoint, using the template <code>type_0_bank</code></li>
<li>For each bank, apply the appropriate steps from section <a class="reference" href="#quickstart.html:endpoint">Endpoint</a></li>
</ul>
<figure id="quickstart.html:simple-mf-endpoint-example">
<figcaption>Figure 2. Simple Multi-Function Endpoint</figcaption>
<pre><code class="language-dml">dml 1.4;
device endpoint;
import "pcie/common.dml";

is pcie_multifunction_endpoint;

bank f0 is type_0_bank {
    param function = 0;

    register vendor_id { param init_val = 0x8086; }
    register device_id { param init_val = 0x4042; }
    register bar0 @ 0x10 is memory_base_address_64 {
        // 32 MB BAR allocation
        param size_bits = 25;
        param map_obj = app0.obj;
    }
    register capabilities_ptr { param init_val = 0x40; }

    group ssid is ssid_capability {
        param base = 0x40;
        param next_ptr = 0x60;
        register ssvid { param init_val = 0x8086; }
    }

    group msi is msi_capability {
        param base = 0x60;
        param next_ptr = 0x0;
        param is_64bit_capable = true;
        param is_pvm_capable = true;
        param is_emd_capable = true;
        param num_vectors = 2;
    }
}
bank f1 is type_0_bank {
    param function = 1;

    register vendor_id { param init_val = 0x8086; }
    register device_id { param init_val = 0x4043; }

    register bar0 @ 0x10 is memory_base_address_64 {
        // 16 MB BAR allocation
        param size_bits = 24;
        param map_obj = app2.obj;
    }
}

bank app0 {
    // defines application logic tied to f0.BAR0
}

bank app2 {
    // application logic tied to f1.BAR0 goes here
}
</code></pre>
</figure>
<h2 id="quickstart.html:switch"><a href="#quickstart.html:switch">Switch</a></h2>
<ul>
<li>Import <code>"pcie/common.dml"</code></li>
<li>Create subdevices for your upstream and downstream ports, adding the template
<code>pcie_downstream_port</code> to the downstream ports and <code>pcie_upstream_port</code> to the
upstream port.</li>
<li>Connect the downstream ports to the upstream port</li>
<li>Set <code>init_val</code> for the registers <code>device_id</code> and <code>vendor_id</code> in the
<code>pcie_config</code> bank of each subdevice.</li>
<li>If your ports have additional capabilities: set <code>init_val</code> of the
<code>capabilities_ptr</code> register and add capability templates for the
capabilities present.</li>
<li>The prefetchable memory is by default 64-bit, one has to override
field <code>cap</code> in registers <code>bank_config.prefetchable.base</code> and
<code>bank_config.prefetchable.limit</code> to make it 32-bit.</li>
<li>If your switch implements application logic:
<ul>
<li>Add e.g. banks that implement the registers that control this application
logic.</li>
<li>Add Base Address registers using either the <code>memory_base_address_64</code>
or the <code>memory_base_address_32</code> template.
To map in the application logic is done by setting the <strong>map_obj</strong>
parameter to the banks you created in the previous step.
Sizing the BAR is done by setting the <strong>size_bits</strong> parameter
in the Base Address Register.</li>
</ul>
</li>
</ul>
<p>Here is a simple Switch example with one upstream port and four
downstream ports. The upstream port has MSI-X capability and built-in
application logic tied to BAR0:</p>
<figure id="quickstart.html:simple-switch-example">
<figcaption>Figure 3. Simple Switch</figcaption>
<pre><code>dml 1.4;
device pcie_switch;
import "pcie/common.dml";

subdevice usp "Upstream Port" {
    is pcie_upstream_port;
    bank pcie_config {
        register vendor_id { param init_val = 0x8086; }
        register device_id { param init_val = 0x4042; }
    }
    register bar0 @ 0x10 is memory_base_address_64 {
        // 8 MB BAR allocation
        param size_bits = 23;
        param map_obj = app0.obj;
    }

    register capabilities_ptr { param init_val = 0x40; }

    group msix is msix_capability {
        param base = 0x40;
        param next_ptr = 0x0;
        param num_vectors = 32;
        param table_offset_bir = 0x1000;
        param pba_offset_bir = 0x5000;
        param data_bank = msix_data;
    }
}

subdevice dsp[i &lt; 3] "Downstream Port" {
    is pcie_downstream_port;
    is post_init;
    method post_init() {
        // connect this port to the internal bus of the upstream port
        // the second argument is the DeviceID, i.e. bus/device/function
        // where the device-number is bits 7:3
        pcie_device.connected(usp.downstream_port.obj, 1 &lt;&lt; 3);
    }
    bank pcie_config {
        register vendor_id { param init_val = 0x8086; }
        register device_id { param init_val = 0x4043; }
    }
}

bank app0 {
    // application logic tied to BAR0 in the upstream port goes here
}

bank msix_data is msix_table;  // storage for MSI-X table and pba

</code></pre>
</figure>
<h2 id="quickstart.html:root-complex"><a href="#quickstart.html:root-complex">Root Complex</a></h2>
<ul>
<li>Import <code>"pcie/common.dml"</code></li>
<li>Apply the <code>pcie_bridge</code> template to the top level of your device code.</li>
<li>Create subdevices for your downstream ports, applying the template
<code>pcie_root_port</code> to all of them.</li>
<li>Connect the downstream ports to the <code>downstream_port</code> object created
by the <code>pcie_bridge</code> template.</li>
<li>Set <code>init_val</code> for the registers <code>device_id</code> and <code>vendor_id</code> in the
<code>pcie_config</code> bank of each downstream port.</li>
<li>If your ports have additional capabilities: set <code>init_val</code> of the
<code>capabilities_ptr</code> register and add capability templates for the
capabilities present.</li>
<li>The prefetchable memory is by default 64-bit, one has to override
field <code>cap</code> in registers <code>bank_config.prefetchable.base</code> and
<code>bank_config.prefetchable.limit</code> to make it 32-bit.</li>
<li>If your Root Complex has integrated endpoints (RCiEPs) you can
implement these as subdevices in the RC, or as external devices. In
any case, they need to be connected to the <code>downstream_port</code> of the
RC.</li>
</ul>
<p>Here is an example root complex with one root port and two integrated
endpoints, one implemented directly in the code and one that is created
as a subobject, using another class:</p>
<figure id="quickstart.html:simple-rc-example">
<figcaption>Figure 4. Simple Root Complex</figcaption>
<pre><code class="language-dml">dml 1.4;
device root_complex;

param use_io_memory = true;
import "pcie/common.dml";

is pcie_bridge;

subdevice rp "PCIe Root Port" {
    is pcie_root_port;
    is post_init;
    method post_init() {
        // connect this port to the internal bus of the RC
        // the second argument is the DeviceID, i.e. bus/device/function
        // where the device-number is bits 7:3
        pcie_device.connected(dev.downstream_port.obj, 0);
    }
    bank pcie_config {
        register vendor_id { param init_val = 0x8086; }
        register device_id { param init_val = 0x4043; }
        register class_code { param init_val = 0x20000; }
    }
}

subdevice iep_A "Integrated Endpoint A" {
    is pcie_endpoint;
    is hreset;
    is post_init;
    method post_init() {
        // connect this integrated endpoint to the internal bus of the RC
        // the second argument is the DeviceID, i.e. bus/device/function
        // where the device-number is bits 7:3
        pcie_device.connected(dev.downstream_port.obj, 1 &lt;&lt; 3);
    }
    bank pcie_config {
        register vendor_id { param init_val = 0x8086; }
        register device_id { param init_val = 0x4044; }

        register bar0 @ 0x10 is memory_base_address_64 {
            param size_bits = 12;
            param map_obj = app0.obj;
        }

        register capabilities_ptr { param init_val = 0x40; }

        group msix is msix_capability {
            param base = 0x40;
            param next_ptr = 0x0;
            param num_vectors = 32;
            param table_offset_bir = 0x1000;
            param pba_offset_bir = 0x5000;
            param data_bank = msix_data;
        }
    }

    bank app0 {
        // application logic tied to BAR0 in the integrated endpoint goes here
    }

    bank msix_data is msix_table;  // storage for MSI-X table and pba
}

connect iep_B "Integrated Endpoint B"{
    is post_init;
    is init_as_subobj;
    param classname = "some_class";
    interface pcie_device;
    method post_init() {
        // connect this integrated endpoint to the internal bus of the RC
        // the second argument is the DeviceID, i.e. bus/device/function
        // where the device-number is bits 7:3
        pcie_device.connected(dev.downstream_port.obj, 2 &lt;&lt; 3);
    }
}
</code></pre>
</figure>
<h2 id="quickstart.html:sample-devices"><a href="#quickstart.html:sample-devices">Sample Devices</a></h2>
<p>There are some sample PCIe devices distributed in Simics base. Currently, this
includes <code>sample-pcie-device</code>, which is a simple PCIe device with some
capabilities and a memory BAR mapped register bank. There is also the
<code>standard-pcie-switch</code>, which also has a component wrapper
<code>standard-pcie-switch-comp</code>. It's a switch with 4 downstream ports. All ports in
implement 3 capabilities. This switch can be used in any platform that supports
PCIe to provide the ability to expand the PCIe hierarchy.</p>
</section><section class="page" id="high-level-design.html"><h1 id="high-level-design.html:high-level-design"><a href="#high-level-design.html:high-level-design">High level design</a></h1>
<p>This is a high-level description of how PCIe is implemented in
Simics. If you write your device in DML, most of the details below are
automatically handled by the DML templates.</p>
<p>The Simics PCIe modeling framework provides the ability to model</p>
<ul>
<li>Endpoints</li>
<li>Multifunction Endpoints</li>
<li>Root Complexes</li>
<li>Switches</li>
<li>Bridges</li>
</ul>
<p>A PCIe device must implement the <code>pcie_device</code> interface. This
interface is used to indicate when the device is connected,
disconnected, and to signal a hot reset.</p>
<p>An RC, Switch or other bridges, must use helper-objects of the class
<code>pcie-downstream-port</code> to simulate the downstream port(s). Each port
facing downstream, i.e. each Virtual PCIe-PCIe bridge in the RC or
Switch (represented by a Type 1 Configuration Header), should have a
<code>pcie-downstream-port</code>. Each downstream port can connect to one or
several (external) PCIe devices. The upstream-facing port of a Switch
should have a <code>pcie-downstream-port</code> with the (internal) Virtual
PCIe-PCIe bridge(s) connected as devices. The below image illustrates
a sample PCIe hierarchy in Simics, yellow boxes represent
<code>pcie-downstream-ports</code>.</p>
<img alt="a PCIe hierarchy" height="500px" src="pcie-hierarchy.png">
<p>The <code>pcie-downstream-port</code> routes messages and manages the Config, IO
and Memory address spaces for its connected downstream devices. There
is a translator-port <code>downstream</code> which receives downstream
transactions and redirects them to the downstream devices connected to
it. There are also specialized translator-ports <code>cfg</code>, <code>msg</code>, <code>io</code>,
and <code>mem</code> which can be used to send transactions of their specific type.</p>
<img alt="a Simics pcie-downstream-port" height="500px" src="pcie-downstream-port.png">
<p>The interface <code>pcie_port_control</code> is implemented by the
pcie-downstream-port, it is used by whoever owns the port to configure
it, and to signal hot reset. The <code>pcie-downstream-port</code> also implements
the <code>pcie_map</code> interface, which the Endpoints below it use to claim
ranges in the downstream address space (e.g. Memory and I/O BARs), and
add (virtual) functions. An endpoint starts an upstream transaction by
issuing it to its connected <code>pcie-downstream-port</code></p>
<p>Endpoints issue upstream transactions through the <code>pcie-downstream-port</code>
object of the RC/Switch to which they are connected. The
pcie-downstream-port acts as a translator and will direct all upstream
transactions to its <code>upstream_target</code>, typically the host memory in
case of an RC, or the upstream target in case of a Switch.</p>
<p>Endpoints must add their functions and map other resources such as
Memory and I/O BARs (as configured in the relevant registers of the
Type 0 Configuration Header). This is done through the <code>pcie_map</code>
interface of the <code>pcie-downstream-port</code> object to which they are
connected.</p>
<p>Switches have an upstream port which is connected to the
pcie-downstream-port of either a Root Complex or another Switch. As
the downstream port(s) of the Switch are configured, they must map the
resources of these ports in the <code>pcie-downstream-port</code> of the RC/Switch
to which they are connected. For example, the Message and
Configuration range bounded by secondary and subordinate bus
registers, as well as the Memory and IO ranges bounded by base and
limit registers.</p>
</section><section class="page" id="pcie-in-dml.html"><h1 id="pcie-in-dml.html:pcie-in-dml"><a href="#pcie-in-dml.html:pcie-in-dml">PCIe in DML</a></h1>
<p>Simics provides a set of DML templates to assist in writing models for
PCIe compliant devices. The templates are available in
<code>[simics]/src/devices/dml-lib/pcie/</code>.</p>
<h2 id="pcie-in-dml.html:endpoints"><a href="#pcie-in-dml.html:endpoints">Endpoints</a></h2>
<p>A typical endpoint device would use the <a class="reference" href="#common.html:pcie_endpoint">pcie_endpoint</a>
template. This template defines the <code>pcie_config</code> register bank which
simulates a Type 0 Configuration header. It also defines a <strong>connect</strong> for
the upstream target, implements the required interfaces, and handles the
mapping of resources defined in any base address registers.</p>
<img alt="a PCIe Endpoint" height="300px" src="pcie-endpoint.png">
<h3 id="pcie-in-dml.html:configuration-header"><a href="#pcie-in-dml.html:configuration-header">Configuration Header</a></h3>
<p>The configuration header of a PCIe device is a register bank,
typically named pcie_config, which uses the template
<a class="reference" href="#common.html:physical_config_bank">physical_config_bank</a>. A register bank would normally
not instantiate this template directly, but use either of
<a class="reference" href="#common.html:type_0_bank">type_0_bank</a> or <a class="reference" href="#bridge.html:type_1_bank">type_1_bank</a> instead. An
endpoint that uses the <code>pcie_endpoint</code> template automatically gets a
bank <code>pcie_config</code> which is an instance of the
<a class="reference" href="#common.html:type_0_bank">type_0_bank</a> template. All instances of
<a class="reference" href="#common.html:physical_config_bank">physical_config_bank</a> will be mapped in the
configuration space of the upstream port when the device is connected,
and all base address registers in the bank will be mapped in the
appropriate address space, according to the type. If more than one
instance of <code>physical_config_bank</code> exists in the same device,
i.e. when simulating a multi-function-device, they must be separated
by assigning different values to the parameter <code>function</code>. Sample code
for a simple multi-function endpoint is available in the quick-start
<a class="reference" href="#quickstart.html:multi-function-endpoint">Multi-Function Endpoint</a> section.</p>
<h3 id="pcie-in-dml.html:device-id-vendor-id-and-class-code"><a href="#pcie-in-dml.html:device-id-vendor-id-and-class-code">Device ID, Vendor ID and Class Code</a></h3>
<p>The <code>pcie_config</code> bank defines the registers <code>vendor_id</code>, <code>device_id</code>
and <code>class_code</code>. An endpoint must assign init values for these,
according to the specification of the hardware that is to be
simulated. Sample code for setting Vendor ID, Device ID and Class Code
is available in the quick-start <a class="reference" href="#quickstart.html:endpoint">Endpoint</a> section.
Depending on the device to be modeled, the init value for other
registers might also need to be customized.</p>
<h3 id="pcie-in-dml.html:capabilities"><a href="#pcie-in-dml.html:capabilities">Capabilities</a></h3>
<p>PCIe defines optional "Capabilities" and "Extended
Capabilities". These are available as templates, configurable by
parameters. The templates are designed to be applied on groups, and
all templates require the parameters <code>base</code> and <code>next_ptr</code> to be
defined. The <code>base</code> parameter defines the address of the first
register in the capability structure. The <code>next_ptr</code> defines the base
address of the first address in the next capability structure (or zero
if this is the last capability). For example, the
<a class="reference" href="#quickstart.html:endpoint">Endpoint</a> in the quick-start section has the
Subsystem ID (SSID) and Message Signaled Interrupts (MSI) capabilities
defined</p>
<p>Note that except where explicitly noted, the capability templates just
define the registers and fields from the PCIe specification. The
actual functionality must then be implemented by the device code. See
<a href="#dml-template-reference.html">DML Template Reference</a> for more details.</p>
<h3 id="pcie-in-dml.html:base-address-registers"><a href="#pcie-in-dml.html:base-address-registers">Base Address Registers</a></h3>
<p>An endpoint typically defines at least one base address register. In
Simics these are declared by creating registers in the bank that
corresponds to the configuration header (typically <code>pcie_config</code>).
The base address registers must use one of the base address templates,
for example the <a class="reference" href="#common.html:memory_base_address_64">memory_base_address_64</a>. The
<a class="reference" href="#quickstart.html:endpoint">Endpoint</a> in the quick-start section defines two
Memory Base Address registers, <code>bar0</code> and <code>bar2</code>. Each of them is tied
to a register bank that will be mapped when the Memory Space Enable
bit in the Command register is written as '1'.</p>
<p>There are a number of different templates that can be used to simulate
base address registers, and they can be customized using various
parameters. These are described in the <a href="#common.html:abstract_base_address">Common
Templates</a> section of this document.</p>
<h3 id="pcie-in-dml.html:interrupts"><a href="#pcie-in-dml.html:interrupts">Interrupts</a></h3>
<p>PCIe functions can send legacy interrupts using the
<code>raise_legacy_interrupt</code> and <code>lower_legacy_interrupt</code> methods in the
<code>pcie_config</code> bank. If the function has an MSI and/or MSI-X capability, it
can use the appropriate <a class="reference" href="#pcie-in-dml.html:capabilities">Capabilities</a> template to implement this and
send message signalled interrupts by using the <code>raise</code> method in the
group using the <code>msi_capability</code> or <code>msix_capability</code> template. The
<a class="reference" href="#quickstart.html:endpoint">Endpoint</a> in the quick-start section, for example,
has MSI capability and raises MSI vector 0 when the <code>intr</code> register in <code>app0</code> is
written. If a function has both an MSI and an MSI-X capability, it's important
to either call the <code>raise()</code> method on both capabilities (if the capability is
disabled, it is a no-op), or use the <code>enabled()</code> method on both capabilities to
check which one is enabled before calling the applicable <code>raise()</code> method.</p>
<h4 id="pcie-in-dml.html:the-msi-x-capability"><a href="#pcie-in-dml.html:the-msi-x-capability">The MSI-X Capability</a></h4>
<p>MSI-X is less straight forward compared to MSI. With MSI-X, there is the MSI-X
Table and the MSI-X PBA structure that both reside in BAR mapped memory space.
The library is able to handle all of this accordingly, but there is more
configuration needed compared to MSI where its simple to just instantiate the
MSI capability template and be done with it.</p>
<h5 id="pcie-in-dml.html:example-1-bar-containing-msi-x-table-and-msi-x-pba"><a href="#pcie-in-dml.html:example-1-bar-containing-msi-x-table-and-msi-x-pba">Example: 1 BAR Containing MSI-X Table and MSI-X PBA</a></h5>
<pre><code class="language-dml">dml 1.4;
device msix_example_1;
import "pcie/common.dml";

is pcie_endpoint;

bank pcie_config {
    register capabilities_ptr { param init_val = 0x40; }
    // bar is a BAR register at position 1 since it is at offset 0x14
    register bar @ 0x14 is (memory_base_address_64) { param size_bits = 12; }

    is defining_msix_capability;
    param msix_offset = 0x40;
    param msix_next_ptr = 0;
    param msix_num_vectors = 32;
    // The Table and PBA params contains the BIR value at the 3 lower bits and
    // the offset at the remaining 29 bits.
    param msix_table_offset_bir = 1;
    param msix_pba_offset_bir = ((0x10 * msix_num_vectors) &lt;&lt; 3) | 1;
    param msix_data_bank = msix_data;
}

// Internal representation of the MSI-X state
bank msix_data is msix_table {
    param msix_bank = pcie_config;
}
</code></pre>
<p>Here we have an endpoint with one function that contains an MSI-X capability. We
have set the <code>msix_table_offset_bir</code> param to 1. This param represents the
values Table BIR and Table Offset in the MSI-X capability structure. Since Table
BIR becomes 1, and Table Offset also becomes 0, the MSI-X Table will end up in
the memory region mapped by <code>bar</code> (which is at position 1) at offset 0. With
<code>msix_pba_offset_bir</code> being <code>((0x10 * msix_num_vectors) &lt;&lt; 3) | 1</code>, with `(0x10</p>
<ul>
<li>msix_num_vectors)` being the size of the MSI-X Table, the PBA BIR is also 1,
but the offset makes the PBA start just after where the Table has ended (in the
same memory region). Few notes:</li>
</ul>
<ul>
<li>The content of the <code>msix_data</code>, which instantiates <code>msix_table</code>, should not
need any consideration by the user, since this is a library implementation
detail.</li>
<li>An MSI-X interrupt would in this case have been raised using
<code>pcie_config.msix.raise(&lt;vector&gt;)</code>.</li>
<li>There must exist a BAR register definition in the bank where the
<code>msix_capability</code> is instantiated on an offset which is in line with the BIR
selection for both the Table and the PBA.</li>
<li>The MSI-X Table and PBA must not necessarily reside on the same BAR mapped
memory-region.</li>
<li>It is allowed for MSI-X Table and PBA to utilize an already occupied BAR as
per the PCIe specification. The library however only supports that data (which
is mapped by setting the <code>map_obj</code> param in the BAR register definition) would
start at offset 0 of memory-region mapped by the BAR register. The MSI-X Table
and PBA can have any offset (as long as it does not overlap with valid access
points in the <code>map_obj</code>).</li>
</ul>
<h3 id="pcie-in-dml.html:read-write-pcie-memory"><a href="#pcie-in-dml.html:read-write-pcie-memory">Read/Write PCIe Memory</a></h3>
<p>Simics PCIe uses the <code>transaction_t</code> data type for all
transactions. The <a class="reference" href="#common.html:config_bank">config_bank</a> template provides utility
methods for reading and writing to the PCIe memory space. These
methods reside in the group <code>memory</code> and operate on the
<code>upstream_target</code>. Details are available in the
<a class="reference" href="#common.html:memory-methods">Memory methods</a> section of this document. Below is a
sample DML device which defines a method that reads 8 bytes from PCIe
memory and writes it back with all bits flipped.</p>
<figure id="pcie-in-dml.html:example-memory-read-write">
<figcaption>Figure 5. Example memory reading and writing</figcaption>
<pre><code class="language-dml">dml 1.4;
device endpoint;
import "pcie/common.dml";

is pcie_endpoint;

method process_data(uint64 address) {
    local (pcie_error_t err, uint64 value) = pcie_config.memory.read(addr, 8);
    if (err != PCIE_Error_No_Error) {
        log error: "failed to read PCIe memory @ 0x%x", address;
        return;
    }
    err = pcie_config.memory.write(addr, ~value, 8);
    if (err != PCIE_Error_No_Error)
        log error: "failed to write PCIe memory @ 0x%x", address;
}
</code></pre>
</figure>
<h3 id="pcie-in-dml.html:send-receive-messages"><a href="#pcie-in-dml.html:send-receive-messages">Send/Receive Messages</a></h3>
<p>Just like for memory transactions, the <a class="reference" href="#common.html:config_bank">config_bank</a>
template defines a group <code>message</code> with utility methods for sending
and receiving messages. By default, the methods for receiving just log
an "unimpl" string and return <code>false</code>, indicating that the device did
not accept the message. Device code must override the methods for the
messages it wishes to service, and return <code>true</code> if the message is
accepted. As with the <code>memory</code> group, the methods for sending messages
operate on <code>upstream_target</code>.</p>
<p>Here is a sample DML device which accepts 'Vendor Defined Type 0'
messages and sends a 'Vendor Defined Type 1' message upstream, with
the address bits inverted. The available methods are described in more
detail in the <a href="#common.html:message-methods-sending">Sending</a> and
<a href="#common.html:message-methods-receiving">Receiving</a> Messages sections.</p>
<figure id="pcie-in-dml.html:example-send-receive-message">
<figcaption>Figure 6. Example sending and receiving messages</figcaption>
<pre><code class="language-dml">dml 1.4;
device endpoint;
import "pcie/common.dml";

is pcie_endpoint;

bank pcie_config {
    // ...
    group message {
        method vendor_defined_type_0(transaction_t *t, uint64 addr) -&gt; (bool) {
            log info, 2: "VDM Type 0 received, address: 0x%x", addr;
            local pcie_error_t err = message.send(
                ~addr, PCIE_Vendor_Defined_Type_1, PCIE_Msg_Route_Upstream);
            return err == PCIE_Error_No_Error;
        }
    }
    // ..
}
</code></pre>
</figure>
<h2 id="pcie-in-dml.html:resets"><a href="#pcie-in-dml.html:resets">Resets</a></h2>
<p>PCIe defines two types of resets: Conventional Reset and <code>FLR</code> (Function Level Reset)</p>
<p>Conventional Reset is divided into three categories: <code>Cold</code>, <code>Warm</code> and <code>Hot</code></p>
<p><code>Cold</code> reset in the PCIe library is the same as instantiating the PCIe device in Simics.
<code>Warm</code> reset is modelled in the library.
<code>Hot</code> reset is defined in the PCIe specification and is modelled. <code>FLR</code> is also modelled in the library.</p>
<h3 id="pcie-in-dml.html:warm-reset"><a href="#pcie-in-dml.html:warm-reset">Warm Reset</a></h3>
<p><code>Warm</code> reset is modelled with the <code>hard_reset</code> templates and a <code>HRESET</code> signal port exists
trigger a <code>warm</code> reset externally. All registers go back to their initial state.</p>
<h3 id="pcie-in-dml.html:hot-reset"><a href="#pcie-in-dml.html:hot-reset">Hot Reset</a></h3>
<p><code>Hot</code> reset is modelled with the <code>soft_reset</code> templates, (defined in DML Utilities), in the library.
In PCIe <code>Hot</code> reset is triggered by an inband signal.
In Simics the inband signal is modelled through the <code>pcie_device</code>
interface method <code>hot_reset</code>. When an upstream port triggers
this method a <code>soft_reset</code> is invoked on the PCIe device, resetting
each PCIe <code>function</code> below the object implementing the <code>pcie_device</code>
interface. Register fields inheriting template <code>pcie_sticky</code>
are not affected by a <code>Hot</code> reset. The library adds the template <code>pcie_sticky</code>
to all fields defined as <code>sticky</code> in the specification.</p>
<h3 id="pcie-in-dml.html:flr"><a href="#pcie-in-dml.html:flr">FLR</a></h3>
<p><code>FLR</code> only applies to <code>Endpoints</code> and is modelled with the <code>pcie_function_level_reset</code> templates
in the library. <code>FLR</code> operates on function level.
Firmware can reset individual functions in a multi function device by invoking <code>FLR</code>.
Each <code>type_0_bank</code> inherits template <code>pcie_function_level_reset</code>.
Firmware invokes an <code>FLR</code> by writing <code>1</code> to field <code>bcre_iflr</code> in the
Device Control Register or to field <code>iflr</code> in the Control register in the PCI AF capability.
An <code>FLR</code> is initiated by invoking  method <code>pcie_function_level_reset</code> on the functions PCIe config bank.
It causes all <code>FLR</code> relevant fields to reset to their initial state and resets relevant states
within the PCIe device.
To add custom <code>FLR</code> logic to a model the user has to override the <code>pcie_function_level_reset</code> method
in the <code>bank</code>.</p>
<figure id="pcie-in-dml.html:example-flr">
<figcaption>Figure 7. Example FLR implementation</figcaption>
<pre><code class="language-dml">dml 1.4;
device endpoint;
import "pcie/common.dml";

saved int my_function_state;

is pcie_endpoint;
bank pcie_config {
    register capabilities_ptr {
        param init_val = 0x40;
    }

    is defining_exp_capability;
    param exp_offset = capabilities_ptr.init_val;
    param exp_next_ptr = 0x0;
    param exp_dp_type = PCIE_DP_Type_EP;

    method pcie_function_level_reset() {
        default();
        log info, 2: "Resetting function";
        my_function_state = 0;
    }
}
</code></pre>
</figure>
<h3 id="pcie-in-dml.html:adding-shared-reset-logic"><a href="#pcie-in-dml.html:adding-shared-reset-logic">Adding shared reset logic</a></h3>
<p>To add custom reset logic that needs to be run for all PCIe resets: <code>Warm</code>, <code>Hot</code> and <code>FLR</code>,
one should utilize the <code>pcie_after_reset</code> method at the top of the PCIe config bank. It
will by default be invoked by all PCIe reset types.</p>
<figure id="pcie-in-dml.html:example-shared-reset-logic">
<figcaption>Figure 8. Example adding custom reset logic invoked by all PCIe reset types.</figcaption>
<pre><code class="language-dml">dml 1.4;
device endpoint;
import "pcie/common.dml";

is pcie_endpoint;
bank pcie_config {
    saved int state;
    method pcie_after_reset() {
        default();
        log info, 2: "Resetting model";
        state = 0;
    }
}
</code></pre>
</figure>
<h3 id="pcie-in-dml.html:hardware-initialized-registers-and-fields-hwinit"><a href="#pcie-in-dml.html:hardware-initialized-registers-and-fields-hwinit">Hardware initialized registers and fields (HwInit)</a></h3>
<p>The <code>pcie_config</code> bank has a parameter <code>use_standard_access_templates</code> that
defaults to <code>true</code>. When this parameter is set to <code>true</code>,
the library automatically adds templates <code>read_only</code>, <code>hwinit</code> and <code>ignore_write</code>
to registers and fields according to PCIe specification.
The <code>hwinit</code> template by default makes the field <code>read-only</code>. See
<a href="#dml-template-reference.html">DML Template Reference</a> for more details for the <code>hwinit</code> template.</p>
<p>The actual implementation of <code>HwInit</code> in vendor hardware implementations
varies because the PCIe specification states that the Hwinit behaviour is vendor
defined to a large extent. Therefore the <code>HwInit</code> behaviour in the lib can be tailored
to accommodate vendor functionality.
Here are a few examples of <code>HwInit</code> hardware behaviour which the library can model:</p>
<figure id="pcie-in-dml.html:example-hwinit-hreset">
<figcaption>Figure 9. Example to allow firmware to write once to each hwinit field after hard reset or instantiation</figcaption>
<pre><code class="language-dml">dml 1.4;
device endpoint;
import "pcie/common.dml";

is pcie_endpoint;
bank pcie_config {
    in each (hwinit) {
        param writable_after_hreset = true;
    }
}
</code></pre>
</figure>
<figure id="pcie-in-dml.html:example-hwinit-input-signal">
<figcaption>Figure 10. Example where input signal controls writable access to hwinit fields</figcaption>
<pre><code class="language-dml">dml 1.4;
device endpoint;
import "pcie/common.dml";

is pcie_endpoint;

bank pcie_config {
    in each (hwinit) {
        param writable_once_only = false;
    }
}
port hwinit_control_signal is signal_port {
    implement signal {
        method signal_raise() {
            default();
            pcie_config.unlock_hwinit_registers();
        }
        method signal_lower() {
            default();
            pcie_config.lock_hwinit_registers();
        }
    }
}
</code></pre>
</figure>
<figure id="pcie-in-dml.html:example-hwinit-disable">
<figcaption>Figure 11. Example to disable hwinit behaviour entirely</figcaption>
<pre><code class="language-dml">dml 1.4;
device endpoint;
import "pcie/common.dml";

is pcie_endpoint;

bank pcie_config {
    in each (hwinit) {
        param writable_after_hreset = true;
        param writable_once_only = false;
    }
}
</code></pre>
</figure>
<h2 id="pcie-in-dml.html:root-complexes-and-switches"><a href="#pcie-in-dml.html:root-complexes-and-switches">Root Complexes and Switches</a></h2>
<p>A PCIe device that is not an endpoint, i.e. a Root Port or a a Switch
Port, is simulated with the help of an object of the class
<code>pcie-downstream-port</code>.</p>
<p>A root or switch port would typically use the
<a class="reference" href="#bridge.html:pcie_root_port">pcie_root_port</a> template. The <code>pcie_root_port</code> template
creates a port object <code>downstream_port</code> of the class
<code>pcie-downstream-port</code> and defines a bank <code>pcie_config</code> which is an
instance of the <a class="reference" href="#bridge.html:type_1_bank">type_1_bank</a> template. It also defines a
connect to an upstream target and provides default implementations for
the interface <code>transaction_translator</code> to handle upstream
transactions.</p>
<p>The <a class="reference" href="#bridge.html:type_1_bank">type_1_bank</a> template automatically handles the
standard base address registers for IO, Memory, and Prefetchable memory.
It maps the configured ranges in the appropriate address space of the
connected upstream target, forwarding them to its downstream
port. Here is an overview image of a sample RC with one root port and
one Root Complex Integrated Endpoint (RCiEP)</p>
<img alt="a PCIe Root Complex" height="500px" src="pcie-root-complex.png">
<p>And here is an overview image of a sample Switch with one upstream and
three downstream ports.</p>
<img alt="a PCIe Switch" height="500px" src="pcie-switch.png">
<p>The quick-start section contains sample code for creating a similar
<a class="reference" href="#quickstart.html:root-complex">Root Complex</a> and <a class="reference" href="#quickstart.html:switch">Switch</a></p>
<h3 id="pcie-in-dml.html:handling-upstream-traffic"><a href="#pcie-in-dml.html:handling-upstream-traffic">Handling upstream traffic</a></h3>
<p>The <code>pcie_root_port</code> automatically forwards all upstream traffic to
its <code>upstream_target</code>. A port that wishes to change that can either
redirect traffic of a certain type by setting any or all of the
parameters <code>def</code>, <code>msg</code>, <code>mem</code>, <code>io</code>, and <code>cfg</code> in the group <code>txl</code> to
a valid map target. Setting it to <code>NULL</code> will block upstream traffic
of that type. See the documentation for the
<a class="reference" href="#bridge.html:pcie_translator">pcie_translator</a> template for more information.</p>
<h3 id="pcie-in-dml.html:handling-upstream-messages"><a href="#pcie-in-dml.html:handling-upstream-messages">Handling upstream messages</a></h3>
<p>Messages can be handled by creating instances of the template
<code>handling_messages</code> in the <code>upstream_message</code> port. This port is
created automatically by the <a class="reference" href="#bridge.html:pcie_root_port">pcie_root_port</a> template. See the
documentation for the <a class="reference" href="#bridge.html:handling_messages">handling_messages</a> template for more
information. Here is an example that handles Vendor Defined Message
Type 0:</p>
<figure id="pcie-in-dml.html:example-upstream-message">
<figcaption>Figure 12. Example upstream message handling</figcaption>
<pre><code class="language-dml">dml 1.4;
device rp;
import "pcie/common.dml";

is pcie_root_port;

port upstream_message {
    group vdm0 is handling_messages {
        method message(transaction_t *t, uint64 addr,
                       pcie_message_type_t type) -&gt; (pcie_error_t) {
            if (type != PCIE_Vendor_Defined_Type_0) {
                // message not handled here
                return PCIE_Error_Not_Set;
            }

            log info: "VDM0 received";
            return PCIE_Error_No_Error;
        }
    }
}
</code></pre>
</figure>
<h2 id="pcie-in-dml.html:other-bridges"><a href="#pcie-in-dml.html:other-bridges">Other bridges</a></h2>
<p>A device that wishes to bridge PCIe to/from host memory, without
necessarily being a Type 1 device, would use the <a class="reference" href="#bridge.html:pcie_bridge">pcie_bridge</a>
template. Like <code>pcie_root_port</code>, the template creates a port object
<code>downstream_port</code> but it doesn't create any register bank and instead
of an <code>upstream_target</code> it has a connect <code>host_memory</code> to which it
translates requests.</p>
<h2 id="pcie-in-dml.html:pcie-6-message-segment-routing"><a href="#pcie-in-dml.html:pcie-6-message-segment-routing">PCIe 6 Message Segment Routing</a></h2>
<p>Segment routing across PCIe hierarchies is supported in PCIe 6 and
the PCIe modeling library provides templates and methods to support it.</p>
<p>Segment routing consists of two parts:</p>
<ol>
<li>Configuring the segment number for each PCIe hierarchy within a Root Complex.</li>
<li>Route messages upstream if destination segment does not match the source segment number.</li>
</ol>
<p>The first part requires as per PCIe 6 specification that configuration requests
contain the segment number for the hierarchy. It is up to the root complex
to append <code>ATOM_transaction_pcie_destination_segment</code> atom to downstream
configuration requests. The PCIe library will capture this atom and store
its value internally. This is true for Root Ports, Switches and Endpoints.
For segment routing to work all relevant devices in the hierarchy must instantiate
the <code>dev3_capability</code> capability. For instance if an endpoint wants to route a message
to a target that is part of another PCIe hierarchy all upstream ports connecting
the endpoints to the Root Complex must have the <code>dev3_capability</code> instantiated.</p>
<p>The second part is handled automatically within the PCIe library up until the Root Complex.
But first the message initiator must setup the message transfer utilizing
the <code>send_custom</code> method. More details in the <a href="#common.html:message-methods-sending">Sending</a>
Message section.</p>
<figure id="pcie-in-dml.html:example-send-message-with-segment">
<figcaption>Figure 13. Example sending message upstream with segment number</figcaption>
<pre><code class="language-dml">dml 1.4;
device endpoint;
import "pcie/common.dml";

is pcie_endpoint;

bank pcie_config {
    // ...
    is defining_dev3_capability;
    param dev3_offset = 0x100;
    param dev3_next_ptr = dev3_offset + 0x100;
    // ..

    method send_message(uint16 target_id, uint8 segment_number) {
        local atom_t extra_atoms[2];

        extra_atoms[0] = ATOM_pcie_destination_segment(segment_number);
        extra_atoms[1] = ATOM_list_end(0);
        local bytes_t data;

        local pcie_error_t ret = message.send_custom(target_id &lt;&lt; 48,
                                                    PCIE_Vendor_Defined_Type_0,
                                                    PCIE_Msg_Route_ID,
                                                    data,
                                                    extra_atoms);
    }
}
</code></pre>
</figure>
<figure id="pcie-in-dml.html:example-root-complex-with-multiple-segments">
<figcaption>Figure 14. Example of root complex with multiple PCIe segments supporting message routing across segments.</figcaption>
<pre><code>dml 1.4;
device root_complex;
</code></pre>
<pre><code>import "utility.dml";
import "pcie/common.dml";

param pcie_version = 6.0;

param nbr_segments = 4;

group segment[segment_id &lt; nbr_segments] {
    subdevice bridge is pcie_bridge {
        group txl_target {
            param msg = dev.upstream_messages.map_target;
        }
    }
    subdevice root_port is (pcie_root_port, post_init) {
        bank pcie_config {
            register capabilities_ptr {
                param init_val = 0x40;
            }
            is defining_pm_capability;
            param pm_offset = capabilities_ptr.init_val;
            param pm_next_ptr = pm_offset + 0x10;

            is defining_exp_capability;
            param exp_offset = pm_next_ptr;
            param exp_next_ptr = exp_offset + 0x30;
            param exp_dp_type = PCIE_DP_Type_RP;

            is defining_dev3_capability;
            param dev3_offset = exp_next_ptr;
            param dev3_next_ptr = dev3_offset + 0x100;
        }
        method post_init() {
            pcie_device.connected(bridge.downstream_port.obj, 0);
        }
    }
}
port upstream_messages is (init_mt) {
    implement transaction_translator {
        method translate(uint64 addr,
                         access_t access,
                         transaction_t *t,
                         exception_type_t (*callback)(translation_t txl,
                                                      transaction_t *tx,
                                                      cbdata_call_t cbd),
                         cbdata_register_t cbdata) -&gt; (exception_type_t) default {
            local pcie_msg_route_t route =
                ATOM_get_transaction_pcie_msg_route(t);
            local const uint8* seg_id =
                ATOM_transaction_pcie_destination_segment(t);

            local translation_t txl;
            switch (route) {
            case PCIE_Msg_Route_ID:
                if (seg_id != NULL &amp;&amp; *seg_id &lt; nbr_segments) {
                    txl.target = segment[*seg_id].bridge.downstream_port.map_target;
                }
                break;
            case PCIE_Msg_Route_Upstream:
                txl.target = dev.message.map_target;
                break;
            default:
                log error: "%s, Unexpected pcie routing type: %d", this.qname, route;
                return Sim_PE_IO_Not_Taken;
            }
            if (txl.target) {
                log info, 2:
                    "Forwarding messages: %s, %s, segment=%d, address=0x%x, to: %s",
                    pcie_message_type_name(ATOM_get_transaction_pcie_msg_type(t)),
                    pcie_route_type_name(ATOM_get_transaction_pcie_msg_route(t)),
                    *seg_id,
                    addr,
                    SIM_object_name(SIM_map_target_object(txl.target));
            }
            return callback(txl, t, cbdata);
        }
    }
}

port message is (message_port);
</code></pre>
</figure>
<h3 id="pcie-in-dml.html:data-object-exchange"><a href="#pcie-in-dml.html:data-object-exchange">Data Object Exchange</a></h3>
<p>Note! As of PCIe 6.1, DOE protocols are now referred to as DOE features.</p>
<p>Data Object Exchange (DOE) is supported and can be implemented in a device using
the <code>doe_capability</code> template. This template by default implements DOE Discovery
protocol. New protocols can be added easily by adding entries in the <code>doe</code> group
of the <code>doe_capability</code>. The DOE Discovery protocol implementation will detect
and report those accordingly with no modifications to the DOE Discovery
implementation. Below is an example of implementing DOE in a PCIe device with a
custom DOE protocol.</p>
<figure id="pcie-in-dml.html:example-doe">
<figcaption>Figure 15. Example of device with DOE and a custom DOE protocol</figcaption>
<pre><code class="language-dml">dml 1.4;
device endpoint;
import "pcie/common.dml";

is pcie_endpoint;

bank pcie_config {
    register capabilities_ptr { param init_val = 0x40; }
    is defining_doe_capability;
    param doe_offset = 0x40;
    param doe_next_ptr = doe_offset + 0x100;
    param doe_mailbox_len = 50;
    param doe_interrupt_support = true;
    group doe {
        group protocols {
            group test_protocol is doe_test_protocol {}
        }
    }
}

template doe_test_protocol is doe_protocol {
    param vendor_id = 0x00FF;
    param data_object_type = 1;

    method handle_request(const uint32 *req, uint18 req_len) {
        local uint32 res[3];

        local doe_header_t res_header;
        res_header.vendor_id = vendor_id;
        res_header.data_object_type = data_object_type;
        res_header.length = 3;
        memcpy(res, &amp;res_header, sizeof(res_header));

        res[2] = 0xABCDEF;
        try {
            mailbox.push_buffer(res, sizeof(res) / sizeof(res[0]));
            response_ready(sizeof(res) / sizeof(res[0]));
        } catch {
            response_error();
        }
    }
}
</code></pre>
</figure>
<p>Pushing the response can be done with either the <code>push</code> or the <code>push_buffer</code>
methods of the <code>mailbox</code>. Each handling of a data object must conclude with
either a <code>response_ready(res_len)</code> or <code>response_error()</code> invocation.</p>
<h3 id="pcie-in-dml.html:physical-layer"><a href="#pcie-in-dml.html:physical-layer">Physical layer</a></h3>
<p>The template <code>pcie_phy</code> adds a port to a device with the name <code>phy</code>. This is
intended to be used as a target for transactions which are related to the
physical layer in PCIe. The current default transaction handler in this port
handles transactions that contain the <code>pcie_link_negotiation</code> atom. It will try
to do link training by comparing the incoming max speed/width with its own max
speed/width and let the transaction initiator know the maximum common value of
the respective property. This is essentially a simplification of the T1 and T2
ordered sets that are actually communicated in a real PCIe link. Transactions in
this layer are expected to have a BDF in <code>address[31:16]</code>. The bus number is
unused as the transactions only traverse over <em>one</em> link. The function is
currently also unused as the transaction will end up in the top-level of a
device.</p>
<h4 id="pcie-in-dml.html:downstream-port-of-switch-supporting-link-training-and-hot-plug"><a href="#pcie-in-dml.html:downstream-port-of-switch-supporting-link-training-and-hot-plug">Downstream Port of Switch Supporting Link Training and Hot-Plug</a></h4>
<p>Take the standard PCIe switch distributed as part of Simics Base. It indicates
support of link speeds and widths using extended capability structures.
Additionally, the supported values have been set in the link registers of the
PCI Express Capability Structure. It also supports Hot-Plug along with having
an attention button and a power indicator. The latter two are useful for
Hot-Plug removal and software reporting status of Hot-Plug operations. Support
for these features are enabled using <code>param</code>s found in the <code>exp_capability</code> and
<code>exp_slot</code> templates. This will result in the device emitting interrupts for
Slot and Link related events if software has enabled it. In the case where
interrupts might be generated by firmware in the device rather by hardware in
the device, shared methods found in the <code>exp_slot</code> template can be overridden to
fit a certain use case.</p>
<figure id="pcie-in-dml.html:switch-example">
<figcaption>Figure 16. PCIe Switch supporting Hot-Plug and Link Training</figcaption>
<pre><code>dml 1.4;

device standard_pcie_switch;
param classname = "standard-pcie-switch";

param desc = "standard PCIe switch";

param documentation = "A standard PCIe switch with 4 downstream slots that"
                    + " contains the mandatory capabilities for a PCIe"
                    + " function in all ports.";

import "pcie/common.dml";

param pcie_version = 6.0;


template switch_port is pcie_port {
    bank pcie_config {
        register device_id { param init_val = 0x0370; }
        register vendor_id { param init_val = 0x8086; }
        register capabilities_ptr { param init_val = 0x40; }

        register bar0 @ 0x10 is (memory_base_address_64) {
            param size_bits = 14;
        }

        is defining_pm_capability;
        param pm_offset = capabilities_ptr.init_val;
        param pm_next_ptr = pm_offset + 0x08;

        is defining_msix_capability;
        param msix_offset = pm_next_ptr;
        param msix_next_ptr = msix_offset + 0x0C;
        param msix_num_vectors = 32;
        param msix_table_offset_bir = 0;
        param msix_pba_offset_bir = (0x10 * msix_num_vectors) &lt;&lt; 3;
        param msix_data_bank = msix_data;

        is defining_exp_capability;
        param exp_offset = msix_next_ptr;
        param exp_next_ptr = 0x0;
        group exp {
            param has_links = true;
            group link {
                param max_link_speed = PCIE_Link_Speed_32;
                param max_link_width = PCIE_Link_Width_x8;
            }
        }

        is defining_dlf_capability;
        param dlf_offset = 0x100;
        param dlf_next_ptr = dlf_offset + 0x0C;
        is defining_pl16g_capability;
        param pl16g_offset = dlf_next_ptr;
        param pl16g_next_ptr = pl16g_offset + 0x28;
        param pl16g_max_link_width = PCIE_Link_Width_x8;
        param pl16g_max_lanes = PCIE_Link_Width_x8;
        is defining_pl32g_capability;
        param pl32g_offset = pl16g_next_ptr;
        param pl32g_next_ptr = 0;
        param pl32g_max_lanes = PCIE_Link_Width_x8;
    }

    bank msix_data is msix_table {
        param msix_bank = pcie_config;
    }
}

subdevice usp is (pcie_upstream_port, switch_port) {
    bank pcie_config {
        param exp_dp_type = PCIE_DP_Type_UP;
    }
}

subdevice dsp[i &lt; 4] is (pcie_downstream_port, pcie_link_training,
                         switch_port, post_init) {
    bank pcie_config {
        param exp_dp_type = PCIE_DP_Type_DP;

        group exp {
            param has_hotplug_capable_slot = true;
            param has_attention_button_slot = true;
            group slot {
                param has_power_indicator = true;
            }
        }
    }


    method post_init() {
        pcie_device.connected(usp.downstream_port.obj, i &lt;&lt; 3);
    }
}
</code></pre>
</figure>
<p>Note that the downstream ports also have to instantiate the template
<code>pcie_link_training</code> for link training support. This will ensure that when a
device is connected, link training will be initiated to the device on the other
side of the link. For link training to be successful, the device on the other
side of the link also has to have a function(s) that contain link attributes in
their PCIe Express Capability Structure (for example by setting the params
<code>max_link_speed</code> and <code>max_link_width</code> in the link group) as done for the switch
in the example above.</p>
<h2 id="pcie-in-dml.html:error-signaling"><a href="#pcie-in-dml.html:error-signaling">Error Signaling</a></h2>
<p>There are 3 (in-band) error signaling mechanisms defined in the PCIe
specification:</p>
<ul>
<li>Completion status</li>
<li>Error messages</li>
<li>Error forwarding / data poisoning</li>
</ul>
<p>The PCIe library has support for the first two mechanisms to various degrees (as
discussed below).</p>
<h3 id="pcie-in-dml.html:completion-status"><a href="#pcie-in-dml.html:completion-status">Completion Status</a></h3>
<p>A completion packet in PCIe includes a completion status field in the its
header. This is implemented in the library as an atom <code>pcie_error_ret</code>. The
library sets this in some occasions when handling a request, but it can also be
set by the user of the library in applicable contexts. The requester is then
able to inspect the <code>pcie_error_ret</code> atom to determine if the request was
successful or not.</p>
<h3 id="pcie-in-dml.html:error-messages"><a href="#pcie-in-dml.html:error-messages">Error messages</a></h3>
<p>Error messages are messages sent by functions in the PCIe hierarchy that
encounter errors (device specific internal errors or errors defined in the PCIe
specification) to the Root Complex (more specifically the applicable root port).
These messages could also be sent by root complex integrated endpoints, where
they instead would be sent to a Root Complex Event Collector (RCEC) if implemented.
Note that the library currently has no functional support for Error Messages
being collected by an RCEC.</p>
<h4 id="pcie-in-dml.html:submitting-and-handling-errors"><a href="#pcie-in-dml.html:submitting-and-handling-errors">Submitting and Handling Errors</a></h4>
<p>PCIe functions may utilize the <code>emit_errors</code> group in the <code>config_bank</code> to
submit errors using either <code>emit_errors.submit_correctable_error()</code>,
<code>emit_errors.submit_uncorrectable_error()</code> or
<code>emit_errors.submit_uncorrectable_error_advisory_non_fatal()</code>. The library will
then set the applicable status bits in the PCI configuration header as well as
in the PCI Express Capability Structure. It will however currently not set
applicable AER bits and will not consider applicable AER mask and severity bits.
Disregarding AER, if software otherwise has configured the device to send error
messages for an error type, the library will send these messages automatically.</p>
<p>Root ports (that have instantiated <code>pcie_root_port</code>) may instantiate the
<code>handling_err_messages</code> template in their local message target port (by default
the <code>upstream_message</code> port in root port). In this instantiation, the
<code>handle_error_message()</code> method can be implemented to handle incoming error
signaling messages coming from downstream functions.</p>
</section><section class="page" id="ats.html"><h1 id="ats.html:address-translation-services-ats"><a href="#ats.html:address-translation-services-ats">Address Translation Services (ATS)</a></h1>
<h2 id="ats.html:ats-capability"><a href="#ats.html:ats-capability">ATS capability</a></h2>
<p>The ATS capability is modelled with template <code>ats_capability</code>.
See chapter <a href="#extended-capabilities.html">Extended Capabilities templates</a>
for the template and its methods definitions.</p>
<p>Template <code>ats_upstream_translator</code> shall be used for Root Complexes
to handle upstream ATS transactions. See chapter <a href="#bridge.html">Bridge and Type 1 templates</a>
for the template and its method definitions.</p>
<h3 id="ats.html:ats-translation"><a href="#ats.html:ats-translation">ATS Translation</a></h3>
<p>Translation requests and completions are modelled as a Simics read transaction with a payload.
The transaction contains the following atoms to represent request and completion:</p>
<ul>
<li><code>ATOM_pcie_at</code></li>
<li><code>ATOM_pcie_byte_count_ret</code></li>
<li><code>ATOM_pcie_ats_translation_request_cxl_src</code></li>
<li><code>ATOM_pcie_ats_translation_request_no_write</code></li>
<li><code>ATOM_pcie_pasid</code></li>
</ul>
<p><code>ATOM_pcie_at</code> shall be set to <em>PCIE_AT_Translation_Request</em>.</p>
<p><code>ATOM_pcie_byte_count_ret</code> shall be set by TA to present how many valid
completion entries it has filled into the read payload. <code>ATOM_pcie_byte_count_ret</code>
is set to 4 * the number of valid completion entries.</p>
<p>The transaction payload consists of one or more entries of type
<code>pcie_ats_translation_completion_entry_t</code> to be filled in by the Translation Agent.</p>
<p>ATC Endpoints can use the <code>translation_request</code> method in template <code>ats_capability</code> to
issue an Address Translation Request.</p>
<p>Root complexes shall override the default <code>issue</code> method on port <code>ats_request</code>
to implement the Translation Request logic.</p>
<h3 id="ats.html:ats-invalidation"><a href="#ats.html:ats-invalidation">ATS Invalidation</a></h3>
<p>Invalidations are modelled with two PCIe messages represented by two Simics write transactions:</p>
<ul>
<li><code>PCIE_ATS_Invalidate</code> (Invalidation Request Message)</li>
<li><code>PCIE_ATS_Invalidate_Completion</code> (Invalidation Completion Message)</li>
</ul>
<p>The invalidation request message consists of the following atoms together with a payload:</p>
<ul>
<li><code>ATOM_pcie_ats_invalidate_request_itag</code></li>
<li><code>ATOM_pcie_pasid</code></li>
</ul>
<p>The payload is of type <code>pcie_ats_invalidate_request_payload_t</code> and has the same content
as the message body in the PCIe specification.</p>
<p>The Root Complex can use method <code>ats_invalidate</code>, defined in template <code>ats_upstream_translator</code>,
to send an ATS invalidation request message.</p>
<p>When the ATC endpoint receives the invalidation request method, <code>invalidate_received</code>,
in template <code>ats_capability</code> will be called. The device model has to override the default
method and add the required logic to handle the invalidation.</p>
<p>The ATC endpoint can use method <code>invalidate_complete</code> in template <code>ats_capability</code>
to send the invalidation completion message back to the TA.</p>
<p>The Root Complex can instantiate template <code>handling_ats_messages</code> to start accepting
ATS invalidate completion messages. It has to override method
<code>ats_invalidate_completion</code> to include its invalidation completion logic.
The instantiation of template <code>handling_ats_messages</code>
has to be done under the <code>port</code> that inherits the <code>message_port</code> template.
For Root Complexes inheriting template <code>pcie_bridge</code> the <code>port</code> is defined
as <code>port message</code>. See chapter <a href="#bridge.html">Bridge and Type 1 templates</a>
for definitions of these templates.</p>
<h2 id="ats.html:ats-translated-untranslated-requests"><a href="#ats.html:ats-translated-untranslated-requests">ATS translated/untranslated requests</a></h2>
<p>ATS translated/untranslated request uses <code>ATOM_pcie_at</code> and shall
be set to either <em>PCIE_AT_Translated</em> or <em>PCIE_AT_Untranslated</em>.</p>
<p>For endpoints doing DMA, methods: <code>memory_write_bytes</code> and <code>memory_read_buf</code>
in template <code>ats_capability</code> can be used to easily construct AT memory requests.</p>
<p>For Root Complexes ports <code>ats_translated</code> and <code>ats_untranslated</code>
defined in template <code>ats_upstream_translator</code> receives all incoming
AT memory requests. The device model has to override the default implementations
of these ports to achieve the desired behaviour.</p>
<h2 id="ats.html:page-request-services-prs"><a href="#ats.html:page-request-services-prs">Page Request Services (PRS)</a></h2>
<p>The Page Request Services are modelled with the following <code>atoms</code>:</p>
<ul>
<li><code>ATOM_pcie_prs_page_request</code></li>
<li><code>ATOM_pcie_prs_page_group_response</code></li>
<li><code>ATOM_pcie_prs_stop_marker</code></li>
<li><code>ATOM_pcie_pasid</code></li>
</ul>
<p><code>ATOM_pcie_prs_page_request</code> is of data type <code>pcie_prs_page_request_t</code>.
<code>ATOM_pcie_prs_page_group_response</code> is of data type <code>pcie_prs_page_group_response_t</code>
and its response codes are listed in enum <code>pcie_prs_response_code_t</code>. <code>ATOM_pcie_prs_stop_marker</code> is just a <code>bool</code>.</p>
<p>The Root Complex can instantiate template <code>handling_prs_messages</code> to start accepting
PRS Request Page and PRS Stop Marker messages. It has to override method
<code>page_request_receive</code> to include the logic to manage Page Request and Stop Marker
messages. The instantiation of template <code>handling_prs_messages</code>
has to be done under the <code>port</code> that inherits the <code>message_port</code> template.
For Root Complexes inheriting template <code>pcie_bridge</code> the <code>port</code> is defined
as <code>port message</code>. See chapter <a href="#bridge.html">Bridge and Type 1 templates</a>
for definitions of these templates. The Root Complex can respond to the
Page requests by using method <code>page_group_response</code> which is part of template
<code>handling_prs_messages</code>.</p>
<p>For Endpoints template <code>prs_capability</code> instantiates all PRS logic and registers
provided by the PCIe library. See chapter <a href="#extended-capabilities.html">Extended Capabilities templates</a>
for the template and its methods definitions.</p>
<h2 id="ats.html:sample-multi-channel-dma-endpoint-utilizing-prs-pasid-and-ats"><a href="#ats.html:sample-multi-channel-dma-endpoint-utilizing-prs-pasid-and-ats">Sample Multi Channel DMA Endpoint utilizing PRS, PASID and ATS</a></h2>
<figure id="ats.html:example-endpoint-dma">
<figcaption>Figure 17. Example of DMA Endpoint.</figcaption>
<pre><code>dml 1.4;

device sample_pcie_ats_prs_dma;
param classname = "sample-pcie-ats-prs-dma";
param desc = "sample PCIe Endpoint utilizing ATS and PRS for DMA";

param documentation = "DMA endpoint with eight concurrent channels."
                    + " Each DMA channel starts with allocating the necessary pages"
                    + " using PRS. The DMA then performs an ATS translation followed"
                    + " by the actual DMA operating on the translated addresses."
                    + " After the DMA is finished it issues a stop marker message to the TA"
                    + " to free up the pages.";

param pcie_version = 6.0;

import "pcie/common.dml";

is pcie_endpoint;

param NBR_CHANNELS = 8;

method umin(uint64 a, uint64 b) -&gt; (uint64) {
    return a &lt; b ? a : b;
}

connect device_memory is (map_target) {
    param documentation = "Memory in device endpoint";
    param configuration = "required";
}
connect irq_dma_done[i &lt; NBR_CHANNELS] is signal_connect {
    param documentation = "Interrupt signal raised by DMA channel"
                        + " when it is finished";
}


bank pcie_config {
    register capabilities_ptr {
        param init_val = 0x40;
    }
    is defining_pm_capability;
    param pm_offset = capabilities_ptr.init_val;
    param pm_next_ptr = pm_offset + 0x10;

    is defining_exp_capability;
    param exp_offset = pm_next_ptr;
    param exp_next_ptr = 0x0;
    param exp_dp_type = PCIE_DP_Type_EP;

    is defining_ats_capability;
    param ats_offset = 0x100;
    param ats_next_ptr = ats_offset + 0x100;

    is defining_pasid_capability;
    param pasid_offset = ats_next_ptr;
    param pasid_next_ptr = pasid_offset + 0x20;
    group pasid {
        register capability {
            field trwps { param init_val = 1; }
            // pasid in range 0 - 0xfffff
            field mpw { param init_val = 0x14; }
        }
    }

    is defining_prs_capability;
    param prs_offset = pasid_next_ptr;
    param prs_next_ptr = 0;

    group prs {
        register status {
            field pasid { param init_val = 1; }
        }
        method page_response_received(transaction_t *t,
                                      uint64 addr) -&gt; (bool) {

            if (ATOM_transaction_pcie_prs_page_group_response(t) != NULL
                &amp;&amp; ATOM_transaction_pcie_pasid(t) != NULL) {
                local pcie_prs_page_group_response_t msg = {
                    .u16 = ATOM_get_transaction_pcie_prs_page_group_response(t),
                    ...
                };
                local pcie_pasid_info_t pasid = {
                    .u32 = ATOM_get_transaction_pcie_pasid(t),
                    ...
                };

                for (local int i = 0; i &lt; dma.len; i++)
                    if (dma[i].prs_page_response(msg, pasid))
                        return true;
                return false;
            } else {
                log error:
                    "%s, Expected atoms pcie_prs_page_group_response"
                  + " and pcie_pasid", this.qname;
                return false;
            }
        }
    }
}

bank regs {
    param register_size = 8;

    group channel[i &lt; NBR_CHANNELS ] {
        register dma_dev @ 0x0 + i * 0x30 {
            field addr @ [63:12] "64-bit device address for DMA";
        }
        register dma_host @ 0x8 + i * 0x30 {
            field addr @ [63:12] "64-bit host address for DMA";
        }
        register dma_len @ 0x10 + i * 0x30 {
            param documentation = "Max 64k for single DMA transfer";
            field len @ [15:0];
        }
        register dma_start @ 0x18 + i * 0x30 {
            field start @ [31] "Start DMA" {
                is write;

                method write(uint64 value) {
                    if (value == 1) {
                        if (dma_status.busy.get() != 0) {
                            log spec_viol: "Cannot start DMA while busy!";
                            return;
                        }
                        local uint64 haddr = dma_host.addr.val &lt;&lt; 12;
                        local int lsbit = pcie_config.ats.control.stu.lsbit();
                        if (haddr[lsbit - 1:0] != 0) {
                            log spec_viol:
                                "DMA host address must be ATS STU aligned";
                            return;
                        }
                        dma[i].start(haddr,
                                     dma_dev.addr.val &lt;&lt; 12,
                                     dma_len.len.val,
                                     pasid.pasid.val,
                                     rnw.val ? true : false);
                    }
                }
            }
            field rnw @ [0] "DMA Read from host = 1, Write to host = 0";
        }
        register dma_status @ 0x20 + i * 0x30 {
            field busy @ [0] "DMA is busy with ongoing transfer" {
                is (read, get);
                method read() -&gt; (uint64) {
                    return get();
                }
                method get() -&gt; (uint64) {
                    return dma[i].pending ? 1 : 0;
                }
            }
        }
        register pasid @ 0x28 + i * 0x30 {
            field pasid @ [19:0] "PASID to be used for DMA transfer";
        }
    }
}

group dma[n &lt; NBR_CHANNELS] {
    saved bool pending;
    saved uint64 host_addr;
    saved uint64 dev_addr;
    saved uint32 size;
    saved bool is_read;
    saved uint20 pasid;

    method start(uint64 host_addr,
                     uint64 dev_addr,
                     uint32 size,
                     uint20 pasid_value,
                     bool is_read) {
        assert(!pending);
        this.pending = true;
        this.host_addr = host_addr;
        this.dev_addr = dev_addr;
        this.size = size;
        this.is_read = is_read;
        this.pasid = pasid_value;
        this.request_pages();
    }
    method request_pages() {
        local int nbr_stus =
            pcie_config.ats.translation_size_to_entries(size);
        local uint64 stu_size = pcie_config.ats.control.stu.size();
        local int nbr_pages = nbr_stus * stu_size / 4096;

        for (local int i = 0; i &lt; nbr_pages; i++) {
            local pcie_prs_page_request_t request = {
                .field = {
                    .r = is_read ? 1 : 0,
                    .w = is_read ? 0 : 1,
                    .l = i == (nbr_pages - 1) ? 1 : 0,
                    .prgi = n,
                    .page_addr = (this.host_addr + (i * 4096)) &gt;&gt; 12,
                },
                ...
            };
            local pcie_pasid_info_t p = { .field = { .pasid = this.pasid, ...}, ...};
            local pcie_error_t ret = pcie_config.prs.page_request(request, &amp;p);
            if (ret != PCIE_Error_No_Error) {
                log error:
                    "%s PRS request denied %s", this.qname, pcie_error_name(ret);
                return;
            }
        }
    }
    method prs_page_response(pcie_prs_page_group_response_t msg,
                             pcie_pasid_info_t p) -&gt; (bool) {
        if (!this.pending)
            return false;

        if (p.field.pasid == this.pasid &amp;&amp; msg.field.prgi == n) {
            if (msg.field.response_code == PCIE_PRS_Response_Success) {
                after: try_ats_and_dma();
            } else {
                log info, 1: "Page response indicated error: %s",
                    pcie_config.prs.response_code_name(msg.field.response_code);
                this.pending = false;
            }
            return true;
        } else {
            return false;
        }
    }
    method try_ats_and_dma() {
        local int nbr_entries =
            pcie_config.ats.translation_size_to_entries(size);
        local pcie_ats_translation_completion_entry_t entries[nbr_entries];
        local bool no_write = is_read;

        // For the DMA the PRS operate on page size, having an STU
        // greater than 4096 can lead to the follow up ATS request
        // to be shifted to align with STU, thus pages not allocated by PRS
        // can here be requested which is not desired. To prevent this
        // the DMA must align its host address to STU to ensure 1:1 mapping
        // between PRS requests and ATS translation requests
        local int stu_lsb = pcie_config.ats.control.stu.lsbit();
        assert(host_addr[stu_lsb - 1:0] == 0);

        local pcie_pasid_info_t p = { .field = { .pasid = this.pasid, ...}, ...};
        local pcie_error_t ret;
        local int valid_entries;
        (ret, valid_entries) =
            pcie_config.ats.translation_request(host_addr,
                                                entries,
                                                nbr_entries,
                                                &amp;p,
                                                no_write,
                                                false);

        if (ret != PCIE_Error_No_Error) {
            log error:
                "%s ATS request denied %s", this.qname, pcie_error_name(ret);
            return;
        }

        for (local int i = 0; i &lt; valid_entries; i++) {
            local (uint64 translated_addr, uint64 txl_size) =
                pcie_config.ats.get_translation_range(entries[i]);

            local uint64 dma_size = umin(txl_size, this.size);
            try {
                do_dma(translated_addr, dev_addr, dma_size, is_read);
            } catch {
                log error:
                    "DMA %s failed for ATS address 0x%08X, device address: 0x%08X",
                    is_read ? "Read" : "Write", translated_addr, dev_addr;
                return;
            }
            this.size -= dma_size;
            this.dev_addr += dma_size;
        }
        assert(this.size == 0);
        free_pages();
        this.pending = false;
        irq_dma_done[n].set_level(1);
        irq_dma_done[n].set_level(0);
    }

    method do_dma(uint64 translated_addr,
                  uint64 dev_addr,
                  uint32 size,
                  bool is_read) throws {
        if (is_read)
            dma_read(translated_addr, dev_addr, size);
        else
            dma_write(translated_addr, dev_addr, size);
    }

    method dma_write(uint64 translated_addr,
                     uint64 dev_addr,
                     uint32 size) throws {
        local uint8 data[size];

        local bytes_t buf = { .data = data, . len = size };

        device_memory.read_bytes(dev_addr, size, data);

        local pcie_pasid_info_t p = { .field = { .pasid = this.pasid, ...}, ...};
        local pcie_error_t ret;
        ret = pcie_config.ats.memory_write_bytes(buf,
                                                 translated_addr,
                                                 PCIE_AT_Translated,
                                                 &amp;p);
        if (ret != PCIE_Error_No_Error)
            throw;
    }

    method dma_read(uint64 translated_addr,
                    uint64 dev_addr,
                    uint32 size) throws {
        local uint8 data[size];
        local buffer_t buf = { .data = data, . len = size };
        local pcie_pasid_info_t p = { .field = { .pasid = this.pasid, ...}, ...};

        local pcie_error_t ret;
        ret = pcie_config.ats.memory_read_buf(buf,
                                              translated_addr,
                                              PCIE_AT_Translated,
                                              &amp;p);
        if (ret != PCIE_Error_No_Error)
            throw;

        device_memory.write_bytes(dev_addr, size, data);
    }
    method free_pages() {
        local pcie_pasid_info_t p = { .field = { .pasid = this.pasid, ...}, ...};
        local pcie_error_t ret = pcie_config.prs.send_stop_marker(&amp;p);

        if (ret != PCIE_Error_No_Error) {
            log error: "Failed to free pages for PASID %d: %s",
                p.u32, pcie_error_name(ret);
        }
    }
}
</code></pre>
</figure>
<h2 id="ats.html:sample-pcie-ats-endpoint-implementing-an-address-translation-cache"><a href="#ats.html:sample-pcie-ats-endpoint-implementing-an-address-translation-cache">Sample PCIe ATS Endpoint implementing an Address Translation Cache</a></h2>
<p>The sample device below implements an ATC using the ATS framework in
the library. Port <code>device_memory_request</code> handles incoming untranslated
transactions from the device and forwards them ATS translated upstream.</p>
<p>Implemented features:</p>
<ul>
<li>Internal <code>cache</code> to store previous ATS translation completions.</li>
<li>Different access rights for read/write/execute transactions.</li>
<li>Any STU size set by the ATS capability control register (<code>pcie_config.ats.control</code>).</li>
<li>Translations consisting of multiple STUs and completion entries.</li>
<li>Contiguous virtual address space mapped to separate physical STUs.</li>
<li>ATS Translation Invalidation</li>
<li>Checkpointing</li>
<li>PASID</li>
</ul>
<p>Note: Current implementation does not support checkpointing of deferred transactions.</p>
<p>Example use cases:</p>
<ul>
<li>Endpoint Device with DMA</li>
<li>Accelerator accessing host memory</li>
</ul>
<figure id="ats.html:example-endpoint-atc">
<figcaption>Figure 18. Example of Endpoint Implementing an Address Translation Cache.</figcaption>
<pre><code>dml 1.4;

device sample_pcie_ats_endpoint;
param classname = "sample-pcie-ats-endpoint";
param desc = "sample PCIe Endpoint with an ATS Cache";

param pcie_version = 6.0;

import "simics/util/interval-set.dml";
import "pcie/common.dml";

is pcie_endpoint;

attribute PASID is (uint64_attr);

method umax(uint64 a, uint64 b) -&gt; (uint64) {
    return a &gt; b ? a : b;
}

bank pcie_config {
    register capabilities_ptr {
        param init_val = 0x40;
    }
    is defining_pm_capability;
    param pm_offset = capabilities_ptr.init_val;
    param pm_next_ptr = pm_offset + 0x10;

    is defining_exp_capability;
    param exp_offset = pm_next_ptr;
    param exp_next_ptr = 0x0;
    param exp_dp_type = PCIE_DP_Type_EP;

    is defining_ats_capability;
    param ats_offset = 0x100;
    param ats_next_ptr = ats_offset + 0x100;
    group ats {
        // Method called by PCIe library when an invalidation request message
        // is received for Translation Agent.
        method invalidate_received(transaction_t *t,
                                   uint64 dev_addr) -&gt; (bool) {
            local pcie_ats_invalidate_request_payload_t payload;
            payload.u64 = SIM_get_transaction_value_le(t);

            local uint8 itag = ATOM_get_transaction_pcie_ats_invalidate_request_itag(t);
            local uint16 requester_id =
                ATOM_get_transaction_pcie_requester_id(t);

            local (uint64 addr, uint64 size) = this.get_invalidation_range(payload);
            cache.evict(addr, size);

            // Must inform Simics core the translation has been revoked.
            // Look at documentation for SIM_translation_changed
            // for more details.
            SIM_translation_changed(device_memory_request.obj);
            after: this.respond(requester_id, 1 &lt;&lt; itag);
            return true;
        }
        method respond(uint16 requester_id, uint32 itag_vector) {
            // Calls helper method in PCIe lib to send Invalidation Completion
            // message to Translation Agent.
            local pcie_error_t ret = this.invalidate_complete(requester_id, itag_vector);
            if (ret != PCIE_Error_No_Error) {
                log error: "%s failed: %s",
                    pcie_message_type_name(PCIE_ATS_Invalidate_Completion),
                    pcie_error_name(ret);
            }
        }
    }
    is defining_pasid_capability;
    param pasid_offset = ats_next_ptr;
    param pasid_next_ptr = 0;
    group pasid {
        register capability {
            field eps { param init_val = 1; }
            field pms { param init_val = 1; }
            field trwps { param init_val = 1; }
            // pasid in range 0 - 0xffff
            field mpw { param init_val = 0x10; }
        }
    }
}

// The endpoint device uses this port to handle untranslated memory requests
// which the ATC tries to convert to a translated memory request
// before forwarding the transaction upstream.
port device_memory_request {
    implement transaction_translator {
        method translate(uint64 addr,
                         access_t access,
                         transaction_t *prev,
                         exception_type_t (*callback)(translation_t txl,
                                                      transaction_t *tx,
                                                      cbdata_call_t cbd),
                         cbdata_register_t cbdata) -&gt; (exception_type_t) {
            local translation_t txl;

            local bool hit;
            local (uint64 base, uint64 start, uint64 size);
            local pcie_ats_translation_completion_entry_t te;

            (hit, base, start, size, te) = lookup_address(addr, prev, access);
            txl.base = base;
            txl.start = start;
            txl.size = size;
            if (!hit) {
                assert(txl.base == txl.start);
                log info, 4:
                    "Missed translation in range 0x%08X-0x%08X access=0x%x",
                    txl.base, txl.base + txl.size - 1, access;
                return callback(txl, prev, cbdata);
            }

            local transaction_t t;

            local bool add_pasid;
            local pcie_pasid_info_t pasid;
            // AT translated requests are only allowed if field trwpe is set
            // Untranslated does not require that bit
            if (pcie_config.pasid.control.pe.val == 1 &amp;&amp;
                (te.field.u == 1 || pcie_config.pasid.control.trwpe.val == 1)) {
                add_pasid = true;
                pasid.field.pasid = PASID.val;
                pasid.field.exe = (access &amp; Sim_Access_Execute) != 0 ? 1 : 0;
            }

            local atom_t atoms[5] = {
                ATOM_pcie_type(PCIE_Type_Mem),
                ATOM_pcie_requester_id(pcie_config.get_device_id()),
                ATOM_pcie_at(te.field.u == 1 ? PCIE_AT_Untranslated : PCIE_AT_Translated),
                add_pasid ? ATOM_pcie_pasid(pasid.u32) : ATOM_list_end(0),
                ATOM_list_end(0),
            };

            t.prev = prev;
            t.atoms = atoms;
            txl.target = upstream_target.map_target;

            log info, 3: "Translating range 0x%08X-0x%08X to 0x%08X-0x%08X",
                txl.base, txl.base + txl.size - 1,
                txl.start, txl.start + txl.size - 1;
            return callback(txl, &amp;t, cbdata);
        }
    }
}


// Sends ATS request to Translation Agent.
// Utilizes several helper methods defined in the ATS capability template.
method do_ats_request(uint64 addr,
                      uint64 size,
                      access_t access) -&gt; (exception_type_t) {
    local uint64 atc_size = size + addr[11:0];
    local int nbr_entries =
        pcie_config.ats.translation_size_to_entries(atc_size);
    local pcie_ats_translation_completion_entry_t entries[nbr_entries];

    local bool no_write = (access &amp; Sim_Access_Write) == 0;

    local pcie_error_t ret;
    local int valid_entries;
    local int stu_lsb = pcie_config.ats.control.stu.lsbit();
    local uint64 base_addr = addr[63:stu_lsb] &lt;&lt; stu_lsb;

    local bool add_pasid;
    local pcie_pasid_info_t pasid;

    if (pcie_config.pasid.control.pe.val) {
        add_pasid = true;
        pasid.field.pasid = PASID.val;
        if (pcie_config.pasid.control.epe.val)
            pasid.field.exe = (access &amp; Sim_Access_Execute) != 0 ? 1 : 0;
    }
    (ret, valid_entries) = pcie_config.ats.translation_request(base_addr,
                                                               entries,
                                                               nbr_entries,
                                                               add_pasid ? &amp;pasid : NULL,
                                                               no_write,
                                                               false);
    switch(ret) {
    case PCIE_Error_No_Error:
        for (local int i = 0; i &lt; valid_entries; i++) {
            local (uint64 start, uint64 txl_size) =
                pcie_config.ats.get_translation_range(entries[i]);

            cache.insert(base_addr, txl_size, entries[i]);
            base_addr += txl_size;
        }
        return Sim_PE_No_Exception;
    case PCIE_Error_Unsupported_Request:
        log info, 1:
            "%s ATS request denied %s",
            this.qname, pcie_error_name(ret);
        return Sim_PE_IO_Not_Taken;
    default:
        log error:
            "%s error in ATS translation request %s",
            this.qname, pcie_error_name(ret);
        return Sim_PE_IO_Not_Taken;
    }
}

// Check internal AT Cache for translation, otherwise
// it tries to do an ATS request followed by a second cache lookup.
method lookup_address(uint64 addr, transaction_t *t, access_t access) -&gt;
                       (
                       bool,    // Hit
                       uint64,  // Base
                       uint64,  // Translated address
                       uint64,  // size
                       pcie_ats_translation_completion_entry_t // TA completion entry
                       ) {
    local uint64 lookup_size = umax(SIM_transaction_size(t),
                                    pcie_config.ats.control.stu.size());
    local (bool hit,
           uint64 base,
           uint64 start,
           uint64 size,
           pcie_ats_translation_completion_entry_t te) = cache.lookup(addr, access);

    if (!hit) { // Try do an AT request
        if (SIM_transaction_is_inquiry(t))
            return (false, base, start, size, te);

        local exception_type_t v = do_ats_request(addr, lookup_size, access);
        if (v != Sim_PE_No_Exception)
            return (false, base, start, size, te);

        (hit, base, start, size, te) = cache.lookup(addr, access);
        assert(hit);
    }
    return (true, base, start, size, te);
}

// Sample cache to showcase basics for implementing ATS with the PCIe library.
// Utilizes the interval library in Simics core.
group cache is (init) {
    session interval_set_t map;

    method init() {
        init_interval(&amp;map, 1);
    }
    attribute storage {
        param documentation = "Attribute to support checkpointing of the AT Cache";
        param type = "[[iii]*]";
        param internal = true;
        method set(attr_value_t value) throws {
            for (local int i = 0; i &lt; SIM_attr_list_size(value); ++i) {
                local attr_value_t it = SIM_attr_list_item(value, i);

                local uint64 start = SIM_attr_integer(SIM_attr_list_item(it, 0));
                local uint64 end = SIM_attr_integer(SIM_attr_list_item(it, 1));
                local pcie_ats_translation_completion_entry_t e = {
                    .u64 = SIM_attr_integer(SIM_attr_list_item(it, 2)),
                    ...
                };
                insert_interval(&amp;map, start, end, cast(e.u64, void *));
            }
        }
        method get() -&gt; (attr_value_t) {
            local attr_value_t map_list = SIM_alloc_attr_list(0);

            for_all_intervals(&amp;map, &amp;collect_map_item, &amp;map_list);
            return map_list;
        }
        independent method collect_map_item(uint64 start,
                                            uint64 end,
                                            void *ptr,
                                            void *data) {
            local attr_value_t *map_list = data;

            local pcie_ats_translation_completion_entry_t e = {
                .u64 = cast(ptr, uintptr_t),
                ...
            };

            local attr_value_t m = SIM_make_attr_list(
                3,
                SIM_make_attr_uint64(start),
                SIM_make_attr_uint64(end),
                SIM_make_attr_uint64(e.u64)
            );


            local int old_size = SIM_attr_list_size(*map_list);
            SIM_attr_list_resize(map_list, old_size + 1);
            SIM_attr_list_set_item(map_list, old_size, m);
        }
    }

    method lookup(uint64 addr,
                  access_t access)
                               -&gt; (bool,    // Hit
                                   uint64,  // Base address
                                   uint64,  // Translated Address
                                   uint64,  // size
                                   pcie_ats_translation_completion_entry_t
                                   ) {
        local uint64 base;
        local uint64 base_end;
        local range_node_t *match_list;
        local int match_count = get_interval_vector_and_range(&amp;map,
                                                              addr,
                                                              &amp;match_list,
                                                              &amp;base,
                                                              &amp;base_end);
        log info, 4: "lookup addr: 0x%x, base=0x%x, end=0x%x, mc=%d",
            addr, base, base_end, match_count;

        local pcie_ats_translation_completion_entry_t dummy;

        local uint64 base_size = base_end - base + 1;
        if (match_count == 1) {
            local pcie_ats_translation_completion_entry_t e = {
                .u64 = cast(match_list[0].ptr, uintptr_t),
                ...
            };
            if (((access &amp; Sim_Access_Read) != 0) &amp;&amp; e.field.r == 0) {
                return (false, base, base, base_size, dummy);
            }
            if (((access &amp; Sim_Access_Write) != 0) &amp;&amp; e.field.w == 0) {
                return (false, base, base, base_size, dummy);
            }
            if (((access &amp; Sim_Access_Execute) != 0) &amp;&amp; e.field.exe == 0) {
                return (false, base, base, base_size, dummy);
            }

            local (uint64 start, uint64 txl_size) =
                pcie_config.ats.get_translation_range(e);

            assert(base_size == txl_size);
            return (true, base, start, base_size, e);
        } else {
            return (false, base, base, base_size, dummy);
        }
    }
    method insert(uint64 addr,
                  uint64 size,
                  pcie_ats_translation_completion_entry_t t_entry) {
        insert_interval(&amp;map, addr,
                        addr + size - 1, cast(t_entry.u64, void *));
    }
    method evict(uint64 evict_addr, uint64 size) {
        local uint64 base;
        local uint64 base_end;
        local range_node_t *match_list;
        local int match_count = get_interval_vector_and_range(&amp;map,
                                                              evict_addr,
                                                              &amp;match_list,
                                                              &amp;base,
                                                              &amp;base_end);
        for (local int i = 0; i &lt; match_count; i++)
            remove_interval(&amp;map, evict_addr,
                            evict_addr + size - 1, match_list[i].ptr);
    }
}
method destroy() {
    free_interval(&amp;cache.map);
}
</code></pre>
</figure>
<h2 id="ats.html:sample-pcie-root-complex-acting-as-an-ats-and-prs-translation-agent-ta"><a href="#ats.html:sample-pcie-root-complex-acting-as-an-ats-and-prs-translation-agent-ta">Sample PCIe Root Complex acting as an ATS and PRS Translation Agent (TA)</a></h2>
<p>The sample root complex showcases a TA that does a linear mapping between
host memory space and device memory space. Attributes <code>UNTRANSLATED_AREA</code> and
<code>TRANSLATED_AREA</code> define the linear mapping. Attribute <code>STU</code> sets the STU
size of the TA. The root complex supports PRS. Attribute <code>ENABLE_PASID_CHECK</code>
can be turned on to block AT translated request with a <code>PASID</code> and an address range
that has not been allocated by PRS. Bank <code>regs</code> contains registers to showcase the ATS invalidation procedure.</p>
<figure id="ats.html:example-root-complex-ta">
<figcaption>Figure 19. Example of Root Complex Implementing a Translation Agent.</figcaption>
<pre><code>dml 1.4;

device sample_pcie_root_complex_ats;
param classname = "sample-pcie-root-complex-ats";

param use_io_memory = false;

import "utility.dml";
import "pcie/common.dml";
import "simics/util/bitcount.dml";
import "simics/util/interval-set.dml";

param desc = "sample PCIe ATS Root Complex implementation";
param documentation = "Sample Root Complex that implements an ATS/PRS Translation Agent";

is pcie_bridge;
is ats_upstream_translator;

attribute STU is uint64_attr "Smallest Translation Unit";
attribute UNTRANSLATED_AREA is uint64_attr;
attribute TRANSLATED_AREA is uint64_attr;

attribute ENABLE_PASID_CHECK is bool_attr {
    param documentation = "When set to true all ATS translated requests are verified that"
                        + " their PASID value has gone through the Page Request Service"
                        + " for that address range.";
}

// Cache to keep track of PRS pages approved for a given PASID
group pasid_cache is (init) {
    session interval_set_t map;

    method init() {
        init_interval(&amp;map, 1);
    }

    method _pasid_holder(pcie_pasid_info_t pasid) -&gt; (uintptr_t) {
        // Pasid 0 is a valid value, to not be treated as a NULL pointer
        // bit 32 is set to 0
        return cast((1 &lt;&lt; 32) | pasid.u32, uintptr_t);
    }
    /* Insert page with PASID into cache */
    method insert(pcie_pasid_info_t pasid, uint64 addr) {
        log info, 4: "Inserting PASID=0x%x @ 0x%08x", pasid.u32, addr;

        local uintptr_t ptr = _pasid_holder(pasid);
        insert_interval(&amp;map, addr, addr + 4096 - 1, cast(ptr, void *));
    }
    /* Evict all cached pages with matching PASID */
    method evict(pcie_pasid_info_t pasid) {
        log info, 4: "Evicting PASID=0x%x", pasid.u32;

        local uintptr_t ptr = _pasid_holder(pasid);
        remove_interval(&amp;map, 0, cast(-1, uint64), cast(ptr, void *));
    }
    /* Check if there is an allocated page */
    method verify(pcie_pasid_info_t pasid, uint64 addr) -&gt; (bool, uint64, uint64) {
        local uint64 base;
        local uint64 base_end;
        local range_node_t *match_list;
        local int match_count = get_interval_vector_and_range(&amp;map,
                                                              addr,
                                                              &amp;match_list,
                                                              &amp;base,
                                                              &amp;base_end);
        log info, 4: "Lookup PASID=0x%x @ 0x%08x, mc=%d",
            pasid.u32, addr, match_count;
        local uint64 size = base_end - base + 1;
        for (local int i = 0; i &lt; match_count; i++) {
            if (cast(match_list[i].ptr, uintptr_t) == _pasid_holder(pasid))
                return (true, base, size);
        }

        log info, 1: "No cached page @ 0x%08x with PASID 0x%x", addr, pasid.u32;
        return (false, base, size);
    }
}

port message {
    group ats_messages is handling_ats_messages {
        method ats_invalidate_completion(transaction_t *t, uint64 addr) -&gt; (bool) {
            local uint32 itag_vec =
                ATOM_get_transaction_pcie_ats_invalidate_completion_itag_vector(t);
            if ((1 &lt;&lt; regs.itag.itag.val) == itag_vec) {
                regs.itag_vec.val = itag_vec;
                return true;
            } else {
                return false;
            }
        }
    }
    group prs_messages is (handling_prs_messages) {
        method page_request_received(transaction_t *t, uint64 addr) -&gt; (bool) {
            local pcie_pasid_info_t pasid = {
                .u32 = ATOM_get_transaction_pcie_pasid(t),
                ...
            };

            if (ATOM_get_transaction_pcie_prs_stop_marker(t)) {
                pasid_cache.evict(pasid);
                return true;
            } else if (ATOM_transaction_pcie_prs_page_request(t) != NULL) {
                local pcie_prs_page_request_t msg = {
                    .u64 = ATOM_get_transaction_pcie_prs_page_request(t),
                    ...
                };
                try {
                    local (uint64 base, uint64 start, uint64 size) =
                        translate_address(msg.field.page_addr &lt;&lt; 12);
                    local uint64 translated_page = start + (msg.field.page_addr &lt;&lt; 12) - base;

                    log info, 4: "pa: 0x%08x, translated pa:0x%08x",
                        msg.field.page_addr &lt;&lt; 12, translated_page;
                    pasid_cache.insert(pasid, translated_page);


                    if (msg.field.l == 1) {  // Last page request in group
                        after: prepare_response(ATOM_get_transaction_pcie_device_id(t),
                                                msg.field.prgi,
                                                PCIE_PRS_Response_Success,
                                                pasid);
                    }
                    return true;
                } catch {
                    after: prepare_response(ATOM_get_transaction_pcie_device_id(t),
                                            msg.field.prgi,
                                            PCIE_PRS_Response_Failure,
                                            pasid);
                    return true;
                }
            } else {
                log error: "%s, Expected either ATOM prs_stop_marker or pcie_prs_page_request",
                    this.qname;
                return false;
            }
        }
        method prepare_response(uint16 target_id, uint16 prs_group_idx,
                                pcie_prs_response_code_t response_code, pcie_pasid_info_t pasid) {
            this.page_group_response(downstream_port.map_target, target_id, prs_group_idx,
                                     response_code, &amp;pasid);
        }
    }
}

method translate_address(uint64 addr) -&gt; (
                                          uint64,  // base
                                          uint64,  // start
                                          uint64   // size
                                         ) throws {
    local uint64 size = 0x1000 &lt;&lt; STU.val;
    local uint64 base = addr[63:log2_64(size)] &lt;&lt; log2_64(size);

    if (base &lt; UNTRANSLATED_AREA.val) {
        log error: "Invalid translation 0x%08X", addr;
        throw;
    }

    local uint64 offset = base - UNTRANSLATED_AREA.val;

    return (base, TRANSLATED_AREA.val + offset, size);
}

bank regs {
    register invalidate_addr size 8 @ 0x0;
    register invalidate_size size 8 @ 0x8;
    register device_id       size 2 @ 0x10;
    register pasid           size 2 @ 0x12;
    register itag            size 1 @ 0x14 {
        field itag @ [4:0];
    }
    register invalidate      size 8 @ 0x20 {
        field invalidate @ [0] is (write) {
            method write(uint64 value) {
                local uint32 p = pasid.val;

                local pcie_error_t ret = ats_invalidate(downstream_port.map_target,
                                                        device_id.val,
                                                        cast(&amp;p, pcie_pasid_info_t*),
                                                        invalidate_addr.val,
                                                        invalidate_size.val,
                                                        false,
                                                        itag.val);
                if (ret == PCIE_Error_No_Error)
                    result.val = 1;
                else
                    result.val = 0x2;
            }
        }
        field result @ [2:1] is (ignore_write);
    }
    register itag_vec       size 4 @ 0x30 is (clear_on_read);
}

/*
 * Memory requests not translated by the ATC arrive here
 * Sample implementation sets address bit 63 and forwards transaction to host memory.
 */
port ats_untranslated {
    implement transaction_translator {
        method translate(uint64 addr,
                         access_t access,
                         transaction_t *t,
                         exception_type_t (*callback)(translation_t txl,
                                                      transaction_t *tx,
                                                      cbdata_call_t cbd),
                         cbdata_register_t cbdata) -&gt; (exception_type_t) {
            local translation_t txl;
            txl.base[63] = addr[63];
            txl.start[63] = 1;
            txl.size[63] = 1;
            txl.target = host_memory.map_target;
            log info: "AT Untranslated -&gt; base 0x%x start 0x%x size 0x%x",
                txl.base, txl.start, txl.size;
            return callback(txl, t, cbdata);
        }
    }
}

/*
 * Memory requests that are already translated by the ATC arrive here
 */
port ats_translated {
    implement transaction_translator {
        method translate(uint64 addr,
                         access_t access,
                         transaction_t *t,
                         exception_type_t (*callback)(translation_t txl,
                                                      transaction_t *tx,
                                                      cbdata_call_t cbd),
                         cbdata_register_t cbdata) -&gt; (exception_type_t) {

            if (ENABLE_PASID_CHECK.val) {
                local translation_t txl;
                local pcie_error_ret_t *pex = ATOM_get_transaction_pcie_error_ret(t);
                if (ATOM_transaction_pcie_pasid(t) == NULL) {
                    log info, 1:
                        "AT translated request @ 0x%08x is missing PASID", addr;
                    if (pex)
                        pex-&gt;val = PCIE_Error_Completer_Abort;
                    return callback(txl, t, cbdata);
                }

                local pcie_pasid_info_t pasid = {
                    .u32 = ATOM_get_transaction_pcie_pasid(t),
                    ...
                };
                local (bool valid, uint64 base, uint64 size) = pasid_cache.verify(pasid, addr);
                txl.base = base;
                txl.start = base;
                txl.size = size;
                if (!valid) {
                    log info, 1:
                        "AT translated request @ 0x%08x invalid PASID:0x%x", addr, pasid.u32;
                    if (pex)
                        pex-&gt;val = PCIE_Error_Completer_Abort;
                } else {
                    txl.target = host_memory.map_target;
                }
                return callback(txl, t, cbdata);
            }
            log info, 3: "Forwarding ATS translation 0x%08X to host memory", addr;
            return default(addr, access, t, callback, cbdata);
        }
    }
}

/*
 * ATS Translation requests arrive here.
 */
port ats_request {
    implement transaction {
        method issue(transaction_t *t,
                     uint64 addr) -&gt; (exception_type_t) {
            local pcie_error_ret_t *ret =
                ATOM_get_transaction_pcie_error_ret(t);

            local uint64 size = SIM_transaction_size(t);

            local bool no_write = ATOM_get_transaction_pcie_ats_translation_request_no_write(t);
            local int nbr_entries = size / sizeoftype(pcie_ats_translation_completion_entry_t);

            local bool pasid_present = ATOM_transaction_pcie_pasid(t) != NULL;
            local pcie_pasid_info_t pasid = { .u32 = ATOM_get_transaction_pcie_pasid(t), ... };

            local (uint64 base, uint64 start, uint64 txl_size);

            try {
                (base, start, txl_size) = translate_address(addr);
            } catch {
                log info, 1: "Cannot fulfill ATS request";
                if (ret)
                    ret-&gt;val = PCIE_Error_Completer_Abort;
                return Sim_PE_IO_Error;
            }

            local pcie_ats_translation_completion_entry_t e[nbr_entries];
            for (local int i = 0; i &lt; nbr_entries; i++) {
                e[i].field.s = txl_size &gt; 4096 ? 1 : 0;
                e[i].field.r = 1;
                e[i].field.w = no_write ? 0 : 1;
                e[i].field.r = 1;
                e[i].field.exe = pasid.field.exe;
                e[i].field.priv = pasid.field.priv;
                e[i].field.translated_addr = (start + (txl_size * i)) &gt;&gt; 12;

                log info, 3: "Translating region 0x%08x-0x%08x to 0x%08x-0x%08x",
                    base + (txl_size * i),
                    base + (txl_size * i) + txl_size - 1,
                    e[i].field.translated_addr &lt;&lt; 12,
                    (e[i].field.translated_addr &lt;&lt; 12) + txl_size - 1;

                if (e[i].field.s == 1) {
                    // Mark size of translation
                    local int zero_bit = log2_64(txl_size) - 1;
                    e[i].field.translated_addr[zero_bit - 12] = 0;
                    if ((zero_bit - 12) &gt; 0)
                        e[i].field.translated_addr[zero_bit - 12 - 1:0] = cast(-1, uint64);
                }
            }

            local pcie_byte_count_ret_t *bc =
                ATOM_get_transaction_pcie_byte_count_ret(t);
            if (bc)
                bc-&gt;val = size;

            local bytes_t bytes = { .data = cast(e, uint8*), .len = size };
            SIM_set_transaction_bytes(t, bytes);
            if (ret)
                ret-&gt;val = PCIE_Error_No_Error;

            return Sim_PE_No_Exception;
        }
    }
}
</code></pre>
</figure>
</section><section class="page" id="sriov.html"><h1 id="sriov.html:single-root-i-o-virtualization-and-sharing-sr-iov"><a href="#sriov.html:single-root-i-o-virtualization-and-sharing-sr-iov">Single Root I/O Virtualization and Sharing (SR-IOV)</a></h1>
<p>The SR-IOV capability is modelled with template sriov_capability. See <a href="./extended-capabilities.html#single-root-i-o-virtualization-sr-iov-extended-capability-registers">Single
Root I/O Virtualization (SR-IOV) Extended Capability
registers</a>
for the template and its methods definitions.</p>
<p>Template
<a href="./extended-capabilities.html#virtual-function-type-0-bank"><code>vf_type_0_bank</code></a>
shall be used to implement the virtual functions, and templates
<a href="./extended-capabilities.html#virtual-function-base-address"><code>vf_bar_64</code>/<code>vf_bar_32</code></a>
should be used to implement the BARs for them.</p>
<p>Since an SR-IOV device contains more than one function (at least one physical
and one virtual), the device that implements the SR-IOV capability shall
instantiate the
<a href="#common.html:pcie_multifunction_endpoint"><code>pcie_multifunction_endpoint</code></a>
template.</p>
<h2 id="sriov.html:physical-function-pf"><a href="#sriov.html:physical-function-pf">Physical Function (PF)</a></h2>
<p>The physical function always instantiates <code>type_0_bank</code> and contains the SR-IOV
capability, and instantiating this capability requires the implementation of the
<a href="#extended-capabilities.html:methods-2">methods</a> <code>get_offset()</code> and
<code>get_stride()</code> as well as setting the <code>virtual_functions</code> param appropriately.
The methods are self-explanatory, while setting the <code>virtual_functions</code> param
may not be as obvious. The idea here is to set the it to a <code>sequence</code> of type
<code>vf_type_0_bank </code> using the
<a href="../dml-1.4-reference-manual/language.html#each-in-expressions">"Each-in"</a>
expressions. An example of this would be <code>param virtual_functions = (each vf_type_0_bank in (dev));</code></p>
<p>BAR registers for the virtual functions reside within the SR-IOV capability
structure. Note that a BAR register in the SR-IOV capability is used for all
virtual functions that are associated with the physical function. It maps the
same resource type for all virtual functions that are enabled. Implementing
SR-IOV BAR registers is done by the aforementioned
<a href="./extended-capabilities.html#virtual-function-base-address"><code>vf_bar_64</code>/<code>vf_bar_32</code></a>
templates. These should reside on an offset relative to the capability base that
is in line with what is specified in the PCI Express Base Specification.
Instantiation of these templates require the implementation of the
<code>get_vf_bar_map()</code> method, which can for example return a bank object.</p>
<p>A complete SR-IOV capability instantiation could look like this:</p>
<pre><code class="language-dml">dml 1.4;
device setting_virtual_functions;
param desc = "SR-IOV Example 1";
param documentation = "An example of how to instantiate the SR-IOV capability";

import "pcie/common.dml";

is pcie_multifunction_endpoint;

param number_of_vfs = 10;

subdevice PF {
    bank pcie_config is type_0_bank {
        // Other capabilities here...

        is defining_sriov_capability;
        param sriov_offset = 0x100;
        param sriov_next_ptr = 0;
        param sriov_virtual_functions = (each vf_type_0_bank in (dev));
        group sriov {
            register vf_bar_01 @ base + 0x24 is vf_bar_64 "VF BAR0-1" {
                method get_vf_bar_map(uint64 vf_number) -&gt; (conf_object_t *) throws {
                    if ((vf_number == 0) || (vf_number &gt; VF.len))
                        throw;
                    return VF[vf_number - 1].bar01.obj;
                }
            }
            method get_offset() -&gt; (uint16) { return 0x100; }
            method get_stride() -&gt; (uint16) { return 0x10; }
        }
    }
    // Other banks here...
}

subdevice VF[i &lt; number_of_vfs] {
    bank pcie_config is vf_type_0_bank { param vf_number = i + 1; }
    bank bar01 { }
}
</code></pre>
<h2 id="sriov.html:virtual-functions-vfs"><a href="#sriov.html:virtual-functions-vfs">Virtual functions (VFs)</a></h2>
<p>Virtual functions are implemented by configuration banks that instantiate the
<code>vf_type_0_bank</code>. Note that given a number of virtual functions the SR-IOV
capability supports, that number of virtual function configuration banks have to
be <em>statically</em> allocated during compile time.</p>
<p>The PCIe capabilities in virtual functions should not instantiate the same
capability templates as the physical functions. There are SR-IOV equivalent
capability templates that are prepended with <code>sriov_</code> before the capability type
(for example <code>defining_sriov_msix_capability</code> instead of
<code>defining_msix_capability</code>). Note that there are currently only a few SR-IOV
variants of the capability templates available in the library, but more will be
added in the future.</p>
<p>As the PF might share logical implementation details with the VFs, the subdevice
structure in the example above lends it self well to not having to accommodate
the logical implementation for the PF and the VFs respectively, as it should
work the same for both function types. In the example below, more implementation
details are added to the example above to clarify this statement.</p>
<pre><code class="language-dml">dml 1.4;
device setting_virtual_functions;
param desc = "SR-IOV Example 2";
param documentation = "An example of how to structure an SR-IOV capable device";

import "pcie/common.dml";

is pcie_multifunction_endpoint;

param number_of_vfs = 10;

template common_function_logic {
    bank pcie_config {
        register class_code { param init_val = 0x123456; }
        register capabilities_ptr {
            param init_val = 0x40;
        }

        param msix_offset           default 0x40;
        param msix_next_ptr         default 0;
        param msix_num_vectors      default 1024;
        param msix_table_offset_bir default 0x1003;
        param msix_pba_offset_bir   default 0x5003;
        param msix_data_bank        default msix_data;
    }

    bank msix_data is msix_table {
        param msix_bank = pcie_config;
    }

    bank bar01 {
        register hello size 2 @ 0x0 is write {
            method write(uint64 value) {
                default(value);
                log info, 1: "Hello from %s", this.qname;
            }
        }
    }
}

subdevice PF is common_function_logic {
    bank pcie_config is type_0_bank {
        register vendor_id {param init_val = 0x1234; }
        register device_id { param init_val = 0xabcd; }
        register bar01 @ 0x10 is (memory_base_address_64) {
            param map_obj = PF.bar01.obj;
        }

        is defining_msix_capability;

        is defining_sriov_capability;
        param sriov_offset = 0x100;
        param sriov_next_ptr = 0;
        param sriov_virtual_functions = (each vf_type_0_bank in (dev));
        group sriov {
            register vf_device_id { param init_val = 0xabcd; }
            register vf_bar_01 @ base + 0x24 is vf_bar_64 "VF BAR0-1" {
                method get_vf_bar_map(uint64 vf_number) -&gt; (conf_object_t *) throws {
                    if ((vf_number == 0) || (vf_number &gt; VF.len))
                        throw;
                    return VF[vf_number - 1].bar01.obj;
                }
            }
            method get_offset() -&gt; (uint16) { return 0x100; }
            method get_stride() -&gt; (uint16) { return 0x10; }
        }
    }
}

subdevice VF[i &lt; number_of_vfs] is common_function_logic {
    bank pcie_config is vf_type_0_bank {
        param vf_number = i + 1;
        is defining_sriov_msix_capability;
    }
}
</code></pre>
<h2 id="sriov.html:sample-sr-iov-endpoint"><a href="#sriov.html:sample-sr-iov-endpoint">Sample SR-IOV Endpoint</a></h2>
<p>Refer to the sample SR-IOV device in <code>src/devices/sample-pcie-sriov-device</code>
included with the Simics base package for a more elaborate example including two
physical functions with a number of virtual functions each.</p>
</section><section class="page" id="dml-template-reference.html"><h1>DML template reference</h1></section><section class="page" id="common.html"><h1>Common and Type 0 templates</h1>
<h2 id="common.html:pcie_endpoint"><a href="#common.html:pcie_endpoint">pcie_endpoint</a></h2>
<p>Used by devices that simulate a single PCIe function with a Type 0
header. Implements the <code>pcie_device</code> interface, defines a <code>pcie_config</code> bank
of type <code>type_0_bank</code>, and an <code>upstream_target</code> connect.
Also defines a <code>phy</code> port that handles transactions related to
the PCIe physical layer.</p>
<p>Inherits templates: <code>pcie_phy</code>, <code>pcie_hreset</code>, <code>pcie_hot_reset</code>, <code>pcie_device</code>.</p>
<h2 id="common.html:pcie_multifunction_endpoint"><a href="#common.html:pcie_multifunction_endpoint">pcie_multifunction_endpoint</a></h2>
<p>Similar to <code>pcie_endpoint</code> but doesn't define a <code>pcie_config</code> bank. Can be
used by devices that simulate multiple functions. A device using this
template must define at least one bank that is an instance of the
<code>physical_config_bank</code> template. Also defines a <code>phy</code> port that handles
transactions related to the PCIe physical layer.</p>
<p>Inherits templates: <code>pcie_phy</code>, <code>pcie_hreset</code>, <code>pcie_hot_reset</code>, <code>pcie_device</code>.</p>
<h2 id="common.html:pcie_device"><a href="#common.html:pcie_device">pcie_device</a></h2>
<p>Implements the <code>pcie_device</code> interface, with default methods for connect and
disconnect that finds all instances of <code>physical_config_bank</code> in this device
and lets them map/demap themselves and their resources in the upstream
target.</p>
<p>Assumes that there is a connect <code>upstream_target</code> which it sets/clears
when the device is connected/disconnected.</p>
<h2 id="common.html:config_bank"><a href="#common.html:config_bank">config_bank</a></h2>
<p>Base template for register banks that implement a PCIe configuration
header. Defines the registers that are common to both Type 0 and Type 1
headers, as well as many utility methods. Typically not used
directly. Inherit one of the derived templates, e.g. <code>type_0_bank</code> or
<code>type_1_bank</code> instead.</p>
<p>Uses the following parameters</p>
<ul>
<li><code>function</code>: The PCIe function number that this bank will use, default 0</li>
<li><code>is_physical</code>: Whether this bank is a physical function, default true</li>
</ul>
<h3 id="common.html:common-methods"><a href="#common.html:common-methods">Common methods</a></h3>
<h4 id="common.html:update_function-uint16-device_id"><a href="#common.html:update_function-uint16-device_id"><code>update_function(uint16 device_id)</code></a></h4>
<p>Updates the mapping of this function's configuration header in the
upstream target, using the parameter <strong>device_id</strong>.</p>
<h4 id="common.html:del_function"><a href="#common.html:del_function"><code>del_function()</code></a></h4>
<p>Deletes the function from the PCIe hierarchy. The configuration header
is no longer accessible over PCIe wire. Additional resources like BARs
are still mapped and must be unmapped separately by the user.</p>
<h4 id="common.html:disable_function"><a href="#common.html:disable_function">`disable_function()</a></h4>
<p>Temporarily disables the function from the PCIe hierarchy.
The configuration header, BAR resources, expansion ROM
and downstream traffic are no longer accessible over PCIe wire.</p>
<h4 id="common.html:enable_function"><a href="#common.html:enable_function">`enable_function()</a></h4>
<p>Enables the function into the PCIe hierarchy.
The configuration header, BAR resources, expansion ROM
and downstream traffic are now accessible over PCIe wire.</p>
<p>A function must be added to the PCIe hierarchy for the enablement
to take effect.</p>
<h4 id="common.html:get_device_id-uint16"><a href="#common.html:get_device_id-uint16"><code>get_device_id() -&gt; (uint16)</code></a></h4>
<p>Returns the Device ID of this function, as known by the upstream target.
Uses the parameter <strong>pcie_obj</strong> which defaults to <strong>obj</strong>.</p>
<h4 id="common.html:verify_pasid-pcie_pasid_info_t-pasid-bool"><a href="#common.html:verify_pasid-pcie_pasid_info_t-pasid-bool"><code>verify_pasid(pcie_pasid_info_t pasid) -&gt; (bool)</code></a></h4>
<p>Verifies the function is correctly configured to support the contents of
the <code>pasid</code> argument. If the check fails it is considered a modelling error.
Returns true on success.</p>
<h4 id="common.html:verify_pasid_with_at-pcie_pasid_info_t-pasid-pcie_at_t-at-bool"><a href="#common.html:verify_pasid_with_at-pcie_pasid_info_t-pasid-pcie_at_t-at-bool"><code>verify_pasid_with_at(pcie_pasid_info_t pasid, pcie_at_t at) -&gt; (bool)</code></a></h4>
<p>Verifies the function is correctly configured to support the contents of the <code>pasid</code>
argument and the type of argument <code>at</code>.
If the check fails it is considered a modelling error.
Returns true on success.</p>
<h4 id="common.html:del_mappings-pcie_type_t-type"><a href="#common.html:del_mappings-pcie_type_t-type"><code>del_mappings(pcie_type_t type)</code></a></h4>
<p>Deletes all BAR mappings of type <strong>type</strong>, that this function has added.</p>
<h4 id="common.html:update_mappings-pcie_type_t-type"><a href="#common.html:update_mappings-pcie_type_t-type"><code>update_mappings(pcie_type_t type)</code></a></h4>
<p>Updates all BAR mappings of type <strong>type</strong>, that this function has added.</p>
<h4 id="common.html:lock_hwinit_registers"><a href="#common.html:lock_hwinit_registers"><code>lock_hwinit_registers()</code></a></h4>
<p>Locks all registers that use the template <code>hwinit</code></p>
<h4 id="common.html:unlock_hwinit_registers"><a href="#common.html:unlock_hwinit_registers"><code>unlock_hwinit_registers()</code></a></h4>
<p>Unlocks all registers that use the template <code>hwinit</code></p>
<h4 id="common.html:raise_legacy_interrupt"><a href="#common.html:raise_legacy_interrupt"><code>raise_legacy_interrupt()</code></a></h4>
<p>Raises the PCIe Legacy Interrupt pin INTx, as configured in the
<code>interrupt_pin</code> register and if enabled in the <code>status.ins</code> register
field.</p>
<h4 id="common.html:lower_legacy_interrupt"><a href="#common.html:lower_legacy_interrupt"><code>lower_legacy_interrupt()</code></a></h4>
<p>Lowers the PCIe Legacy Interrupt pin INTx, as configured in the
<code>interrupt_pin</code> register</p>
<h4 id="common.html:issue_transaction-transaction_t-t-uint64-addr-pcie_error_t"><a href="#common.html:issue_transaction-transaction_t-t-uint64-addr-pcie_error_t"><code>issue_transaction(transaction_t *t, uint64 addr) -&gt; (pcie_error_t)</code></a></h4>
<p>Low-level method for issuing a transaction into some PCIe address space.
Prepends required PCIe atoms to a transaction before issuing it to
<code>upstream_target</code>.</p>
<h3 id="common.html:memory-methods"><a href="#common.html:memory-methods">Memory methods</a></h3>
<p>Utility methods for reading and writing PCIe Memory data. Reads or
writes PCIe Memory data in <code>upstream_target.map_target</code>.</p>
<h4 id="common.html:memory-read-uint64-addr-uint64-size-pcie_error_t-uint64"><a href="#common.html:memory-read-uint64-addr-uint64-size-pcie_error_t-uint64"><code>memory.read(uint64 addr, uint64 size) -&gt; (pcie_error_t, uint64)</code></a></h4>
<h4 id="common.html:memory-read_bytes-uint64-addr-buffer_t-buf-pcie_error_t"><a href="#common.html:memory-read_bytes-uint64-addr-buffer_t-buf-pcie_error_t"><code>memory.read_bytes(uint64 addr, buffer_t buf) -&gt; (pcie_error_t)</code></a></h4>
<h4 id="common.html:memory-write-uint64-addr-uint64-value-uint64-size-pcie_error_t"><a href="#common.html:memory-write-uint64-addr-uint64-value-uint64-size-pcie_error_t"><code>memory.write(uint64 addr, uint64 value, uint64 size) -&gt; (pcie_error_t)</code></a></h4>
<h4 id="common.html:memory-write_bytes-uint64-addr-bytes_t-bytes-pcie_error_t"><a href="#common.html:memory-write_bytes-uint64-addr-bytes_t-bytes-pcie_error_t"><code>memory.write_bytes(uint64 addr, bytes_t bytes) -&gt; (pcie_error_t)</code></a></h4>
<h3 id="common.html:message-methods-receiving"><a href="#common.html:message-methods-receiving">Message methods - receiving</a></h3>
<p>The following methods handle receiving messages. Their default
implementations are meant to be overridden by devices that wish to
handle the particular type of message. Unless otherwise noted, the
default implementation logs an <strong>unimpl</strong> message and returns
<code>false</code>, which indicates a 'Completer Abort'.</p>
<h4 id="common.html:message-operation-transaction_t-t-uint64-addr-bool"><a href="#common.html:message-operation-transaction_t-t-uint64-addr-bool"><code>message.operation(transaction_t *t, uint64 addr) -&gt; (bool)</code></a></h4>
<p>Main method for receiving messages. Inspects the message type and
redirects to the appropriate method for handling that specific
message.</p>
<h4 id="common.html:message-ats_invalidate-transaction_t-t-uint64-addr-bool"><a href="#common.html:message-ats_invalidate-transaction_t-t-uint64-addr-bool"><code>message.ats_invalidate(transaction_t *t, uint64 addr) -&gt; (bool)</code></a></h4>
<h4 id="common.html:message-prs_request-transaction_t-t-uint64-addr-bool"><a href="#common.html:message-prs_request-transaction_t-t-uint64-addr-bool"><code>message.prs_request(transaction_t *t, uint64 addr) -&gt; (bool)</code></a></h4>
<h4 id="common.html:message-prs_response-transaction_t-t-uint64-addr-bool"><a href="#common.html:message-prs_response-transaction_t-t-uint64-addr-bool"><code>message.prs_response(transaction_t *t, uint64 addr) -&gt; (bool)</code></a></h4>
<p>These three methods redirect to their <code>*_received</code> counterparts in
the <code>ats_capability</code> group, if present.</p>
<h4 id="common.html:message-vendor_defined_type_1-transaction_t-t-uint64-addr-bool"><a href="#common.html:message-vendor_defined_type_1-transaction_t-t-uint64-addr-bool"><code>message.vendor_defined_type_1(transaction_t *t, uint64 addr) -&gt; (bool)</code></a></h4>
<p>PCIe demands that Vendor Defined Type 1 messages are silently
ignored, if not implemented. This method logs <strong>unimpl</strong> on level 2
and returns <code>true</code>, by default.</p>
<h4 id="common.html:message-pm_active_state_nak-transaction_t-t-uint64-addr-bool"><a href="#common.html:message-pm_active_state_nak-transaction_t-t-uint64-addr-bool"><code>message.pm_active_state_nak(transaction_t *t, uint64 addr) -&gt; (bool)</code></a></h4>
<h4 id="common.html:message-pm_turn_off-transaction_t-t-uint64-addr-bool"><a href="#common.html:message-pm_turn_off-transaction_t-t-uint64-addr-bool"><code>message.pm_turn_off(transaction_t *t, uint64 addr) -&gt; (bool)</code></a></h4>
<h4 id="common.html:message-unlock-transaction_t-t-uint64-addr-bool"><a href="#common.html:message-unlock-transaction_t-t-uint64-addr-bool"><code>message.unlock(transaction_t *t, uint64 addr) -&gt; (bool)</code></a></h4>
<h4 id="common.html:message-set_slot_power_limit-transaction_t-t-uint64-addr-bool"><a href="#common.html:message-set_slot_power_limit-transaction_t-t-uint64-addr-bool"><code>message.set_slot_power_limit(transaction_t *t, uint64 addr) -&gt; (bool)</code></a></h4>
<h4 id="common.html:message-vendor_defined_type_0-transaction_t-t-uint64-addr-bool"><a href="#common.html:message-vendor_defined_type_0-transaction_t-t-uint64-addr-bool"><code>message.vendor_defined_type_0(transaction_t *t, uint64 addr) -&gt; (bool)</code></a></h4>
<h4 id="common.html:message-hot_plug-transaction_t-t-uint64-addr-bool"><a href="#common.html:message-hot_plug-transaction_t-t-uint64-addr-bool"><code>message.hot_plug(transaction_t *t, uint64 addr) -&gt; (bool)</code></a></h4>
<p>Hot Plug messages are obsolete, according to PCIe, but must be
silently ignored.  This method logs <strong>unimpl</strong> on level 2 and
returns 2, by default.</p>
<h4 id="common.html:message-unknown-transaction_t-t-uint64-addr-pcie_message_type_t-code-bool"><a href="#common.html:message-unknown-transaction_t-t-uint64-addr-pcie_message_type_t-code-bool"><code>message.unknown(transaction_t *t, uint64 addr, pcie_message_type_t code) -&gt; (bool)</code></a></h4>
<p>This method handles message types that are unknown to
<code>message.operation</code>, and gets the message type as a parameter.</p>
<h3 id="common.html:message-methods-sending"><a href="#common.html:message-methods-sending">Message methods - sending</a></h3>
<p>The following methods can be used to send PCIe messages.
The <strong>addr</strong> parameter contains the 8-byte address-field of the message.
As in a real world TLP, the Device ID is the upper bits (63 through 48) of
the address, while the lower bits may hold other message-specific
information. The <strong>type</strong> and <strong>route</strong> parameters indicate the
message type and the routing information.</p>
<p>For <code>message.send_bytes</code> the additional parameter <strong>bytes</strong> is used
for sending data in the message payload.</p>
<p>For <code>message.send_custom</code> the additional parameter <strong>extra_atoms</strong> is used
for devices to append additional required atoms that are not added automatically
by the library. These could be vendor specific atoms,
the destination segment atom (Sim_Atom_Id_pcie_destination_segment), etc.</p>
<h4 id="common.html:message-send-uint64-addr-pcie_message_type_t-type-pcie_msg_route_t-route-pcie_error_t"><a href="#common.html:message-send-uint64-addr-pcie_message_type_t-type-pcie_msg_route_t-route-pcie_error_t"><code>message.send(uint64 addr, pcie_message_type_t type, pcie_msg_route_t route) -&gt; (pcie_error_t)</code></a></h4>
<h4 id="common.html:message-send_bytes-uint64-addr-pcie_message_type_t-type-pcie_msg_route_t-route-bytes_t-bytes"><a href="#common.html:message-send_bytes-uint64-addr-pcie_message_type_t-type-pcie_msg_route_t-route-bytes_t-bytes"><code>message.send_bytes(uint64 addr, pcie_message_type_t type, pcie_msg_route_t route, bytes_t bytes</code></a></h4>
<h4 id="common.html:message-send_custom-uint64-addr-pcie_message_type_t-type-pcie_msg_route_t-route-bytes_t-bytes-atom_t-extra_atoms"><a href="#common.html:message-send_custom-uint64-addr-pcie_message_type_t-type-pcie_msg_route_t-route-bytes_t-bytes-atom_t-extra_atoms"><code>message.send_custom(uint64 addr, pcie_message_type_t type, pcie_msg_route_t route, bytes_t bytes, atom_t extra_atoms[]</code></a></h4>
<h4 id="common.html:transaction_access-transaction_t-t-uint64-offset-void-aux-exception_type_t"><a href="#common.html:transaction_access-transaction_t-t-uint64-offset-void-aux-exception_type_t"><code>transaction_access(transaction_t *t, uint64 offset, void *aux) -&gt; (exception_type_t)</code></a></h4>
<p>Entrypoint for access into the bank. Redirects to message or default
bank operation, depending on the type of the transaction. The pointer to
the transaction is passed as <code>aux</code> to the default operation, allowing
lower level methods to inspect and set atoms. Sets the <code>pcie_error_ret</code>
atom if present, and not set by lower level methods.</p>
<h2 id="common.html:physical_config_bank"><a href="#common.html:physical_config_bank">physical_config_bank</a></h2>
<p>Base-template for physical functions, type 0 and 1.
Inherits <strong>config_bank</strong>.</p>
<h2 id="common.html:type_0_bank"><a href="#common.html:type_0_bank">type_0_bank</a></h2>
<p>Inherits <strong>physical_config_bank</strong> and adds Type 0 specific registers.</p>
<h2 id="common.html:pcie_no_function_level_reset"><a href="#common.html:pcie_no_function_level_reset">pcie_no_function_level_reset</a></h2>
<p>Applied directly to registers and fields that are not explicitly <code>sticky</code> or
<code>hwinit</code> in the specification but shall still according to specification
not be affected by an FLR (Function Level Reset) of the PCIe function.</p>
<p>Inherits template <code>pcie_function_level_reset</code> and blocks default
pcie_function_level_reset functionality
and prevent propagation of <code>pcie_function_level_reset</code> to DML child
objects underneath the DML object.</p>
<h2 id="common.html:pcie_sticky"><a href="#common.html:pcie_sticky">pcie_sticky</a></h2>
<p>Applied directly to <code>registers</code> and <code>fields</code> that are explicitly <code>sticky</code>
in the specification. The template causes FLR and Hot-Reset to have no
effect on these <code>registers</code> and <code>fields</code>.</p>
<p>Inherits templates <code>soft_reset</code> and <code>pcie_no_function_level_reset</code>.
It blocks default soft_reset functionality by overriding method <code>soft_reset</code>,
and prevents propagation of <code>soft_reset</code> to DML child objects underneath
the DML object. The PCIe library models Hot Reset with the <code>soft_reset</code>
templates defined in DML utilities.</p>
<h2 id="common.html:hwinit"><a href="#common.html:hwinit">hwinit</a></h2>
<p>Implements the HwInit access restrictions, as described in the PCIe
specification. Inherits templates <code>init_val</code>, <code>write</code>,
<code>hard_reset</code>, <code>soft_reset</code> and <code>pcie_sticky</code>.</p>
<p>Uses the following parameters:</p>
<ul>
<li><code>writable_after_hreset</code>: Is the register or field writable after hard reset, default false</li>
<li><code>writable_once_only</code>: Is the register or field writable once only, default true</li>
</ul>
<h2 id="common.html:pcie_desc"><a href="#common.html:pcie_desc">pcie_desc</a></h2>
<p>Inherits the <code>desc</code> template"</p>
<h2 id="common.html:pcie_write"><a href="#common.html:pcie_write">pcie_write</a></h2>
<p>Inherits the <code>write</code> template and requires the <code>register</code> or <code>field</code> to
implement method <code>pcie_write(uint64 val)</code>. The method is invoked upon a
write access.</p>
<h2 id="common.html:pcie_read"><a href="#common.html:pcie_read">pcie_read</a></h2>
<p>Inherits the <code>read</code> template and requires the <code>register</code> or <code>field</code> to
implement method <code>pcie_read() -&gt; (uint64)</code>. The method is invoked upon a
read access.</p>
<h2 id="common.html:pcie_register_write_action"><a href="#common.html:pcie_register_write_action">pcie_register_write_action</a></h2>
<p>Inherits the <code>register</code> template and declares method <code>pcie_write_action(uint64 value)</code>
which is invoked after the field write dispatching has taken place.</p>
<h2 id="common.html:pcie_register_read_action"><a href="#common.html:pcie_register_read_action">pcie_register_read_action</a></h2>
<p>Inherits the <code>register</code> template and declares method <code>pcie_read_action()</code>
which is invoked after the field read dispatching has taken place.</p>
<h2 id="common.html:pcie_write_1_clears"><a href="#common.html:pcie_write_1_clears">pcie_write_1_clears</a></h2>
<p>Inherits the <code>write</code> template and clears the bits with 1s written to.</p>
<h2 id="common.html:pcie_init"><a href="#common.html:pcie_init">pcie_init</a></h2>
<p>Inherits the <code>init_val</code> template and requires the <code>register</code> or <code>field</code> to
implement method <code>pcie_init()</code>. The method is invoked upon object creation
and device reset.</p>
<h2 id="common.html:abstract_base_address"><a href="#common.html:abstract_base_address">abstract_base_address</a></h2>
<p>Can be used to implement an object that is similar to the Base Address
Registers in the PCIe configuration header.</p>
<p>The parameter <strong>type</strong> indicates in which upstream address space the resource
should be mapped. If the type is <code>PCIE_Type_Memory</code> or <code>PCIE_Type_IO</code> the
register will be called to update its resources when <code>command.mem</code> and
<code>command.io</code>, respectively, is written. If this is not desired, <strong>type</strong> can
be set to <code>PCIE_Type_Other</code> and the parameter <strong>map_type</strong> can be used to
indicate in which address space the resource should be mapped.</p>
<p>The parameter <strong>map_obj</strong> indicates which object will be mapped.</p>
<p>Users of this template must:</p>
<ul>
<li>Define the method <code>get_map_info() -&gt; (map_info_t)</code></li>
<li>Define the method <code>enabled() -&gt; (bool)</code></li>
<li>Assign the parameter map_type;</li>
<li>Assign the parameter map_obj;</li>
</ul>
<h2 id="common.html:pcie_base_address"><a href="#common.html:pcie_base_address">pcie_base_address</a></h2>
<p>Implements the common functionality for Memory and I/O Base Address Registers
as specified in PCIe. It has a single unsized field <strong>address</strong>.</p>
<p>The parameter <strong>map_obj</strong> indicates which object will be mapped.</p>
<p>The parameter <strong>size_bits</strong> defaults to 12 and defines the number of address
bits that this base address register uses. If a Resizable BAR
capability is present and indicates that it controls the size of this BAR the
size from the relevant RBAR Control register will be used instead.</p>
<p>Users of this template must:</p>
<ul>
<li>Define the bit-range for the field <strong>address</strong></li>
<li>Define the method <code>enabled() -&gt; (bool)</code></li>
<li>Assign the parameters map_type and map_obj;</li>
<li>Assign the parameter size_bits, if different from the default '12'.</li>
</ul>
<h2 id="common.html:memory_base_address"><a href="#common.html:memory_base_address">memory_base_address</a></h2>
<p>Implements a Memory Base Address Register as specified in PCIe.</p>
<p>The parameter <strong>map_obj</strong> indicates which object will be mapped.</p>
<p>The parameter <strong>size_bits</strong> defaults to 12 and defines the number of address
bits that this base address register uses. If a Resizable BAR
capability is present and indicates that it controls the size of this BAR the
size from the relevant RBAR Control register will be used instead.</p>
<p>64-bit BARs are by default <code>prefetchable</code> and 32-bit BARs are by
default <strong>not</strong> <code>prefetchable</code>.</p>
<p>Users of this template must:</p>
<ul>
<li>Assign the parameter map_obj;</li>
<li>Assign the parameter size_bits, if different from the default '12'.</li>
</ul>
<h2 id="common.html:memory_base_address_32"><a href="#common.html:memory_base_address_32">memory_base_address_32</a></h2>
<p>Inherits the <code>memory_base_address</code> template. Used to model
32-bit BAR registers.</p>
<h2 id="common.html:memory_base_address_64"><a href="#common.html:memory_base_address_64">memory_base_address_64</a></h2>
<p>Inherits the <code>memory_base_address</code> template. Used to model
64-bit BAR registers.</p>
<h2 id="common.html:io_base_address"><a href="#common.html:io_base_address">io_base_address</a></h2>
<p>Implements an I/O Base Address Register as specified in PCIe.</p>
<p>The parameter <strong>map_obj</strong> indicates which object will be mapped.</p>
<p>The parameter <strong>size_bits</strong> defaults to 12 and defines the number of address
bits that this base address register uses. If a Resizable BAR
capability is present and indicates that it controls the size of this BAR the
size from the relevant RBAR Control register will be used instead.</p>
<p>Users of this template must:</p>
<ul>
<li>Assign the parameter map_obj;</li>
<li>Assign the parameter size_bits, if different from the default '12'.</li>
</ul>
<h2 id="common.html:defining_expansion_rom"><a href="#common.html:defining_expansion_rom">defining_expansion_rom</a></h2>
<p>Defines a register <code>expansion_rom_base</code>, as defined in PCIe. Additionally,
creates a group <code>expansion</code> which holds sub objects for a ROM and an image,
sized according to the parameter <strong>size_bits</strong>, which defaults to 11. The ROM
will be mapped in PCIe Memory Space, when enabled. Group <code>expansion</code> will inherit
the <code>rom_subobj</code> template. This template will set all necessary parameters for
group <code>expansion</code>.</p>
<p>Users of this template must:</p>
<ul>
<li>Assign the parameter size_bits, if different from the default '11'.</li>
</ul>
<h2 id="common.html:rom_subobj"><a href="#common.html:rom_subobj">rom_subobj</a></h2>
<p>Defines two subobjects in order to create a ROM:</p>
<ul>
<li><code>rom</code></li>
<li><code>image</code></li>
</ul>
<p>Users of this template must:</p>
<ul>
<li>Assign the parameter <code>size</code>.</li>
</ul>
<h2 id="common.html:upstream_target"><a href="#common.html:upstream_target">upstream_target</a></h2>
<p>Defines a pseudo-connect <code>upstream_target</code>, used by many other PCIe
templates.</p>
<h2 id="common.html:pcie_hreset"><a href="#common.html:pcie_hreset">pcie_hreset</a></h2>
<p>Inherits the <code>hreset</code> template from DML utilities.
Invokes <code>hard_reset()</code> on the object instantiating this template.
For instance if the object instantiating this template is a DML <code>subdevice</code>
the <code>soft_reset</code> will be isolated to only affect the <code>subdevice</code> and not the entire
DML device.</p>
<h2 id="common.html:pcie_hot_reset"><a href="#common.html:pcie_hot_reset">pcie_hot_reset</a></h2>
<p>Inherits template <code>soft_reset</code> and applies the <code>soft_reset</code> template
to all registers and fields below the DML object. The <code>soft_reset</code>
template is used to model a <code>hot</code> reset in PCIe.</p>
<h2 id="common.html:pcie_function_level_reset-function-level-reset"><a href="#common.html:pcie_function_level_reset-function-level-reset">pcie_function_level_reset (Function Level Reset)</a></h2>
<p>PCIe Type 0 config banks will inherit this template. An is FLR triggered
by invoking method <code>pcie_function_level_reset</code> on the PCIe config bank
resetting the state of all relevant registers for FLR.</p>
<h2 id="common.html:pcie_phy"><a href="#common.html:pcie_phy">pcie_phy</a></h2>
<p>Adds a port <code>phy</code> that implements the <code>transaction_interface_t</code>. Only applicable
for PCIe endpoints and switch upstream ports.
Port <code>phy</code> is used for low level PCIe physical link exchanges. The library
implements link training through this port. A root port or a switch downstream port
initiates a link training transaction that ends up in this port.</p>
<p>The <code>transaction_interface_t</code> method <code>issue(transaction_t *t, uint64 addr) -&gt; (exception_type_t)</code>
in port <code>phy</code> can be overridden to extend the <code>phy</code> with additional physical link exchanges.
To modify the link training functionality one can override method
<code>handle_link_training(pcie_link_negotiation_t *lg) -&gt; (bool)</code> in port <code>phy</code>.</p>
</section><section class="page" id="bridge.html"><h1>Bridge and Type 1 templates</h1>
<h2 id="bridge.html:pcie_bridge"><a href="#bridge.html:pcie_bridge">pcie_bridge</a></h2>
<p>To be used by devices bridging PCIe to/from e.g. host memory. Inherits
<code>pcie_translator</code>. Defines a port object <code>downstream_port</code> and a connect
<code>host_memory</code> to which upstream <strong>Mem</strong> transactions are forwarded, by
default. Defines a port <code>message</code>, to which <strong>Msg</strong> transactions are
forwarded, by default. The <code>message</code> port inherits the <code>message_port</code>
template. Other transaction types are terminated, by default.</p>
<h2 id="bridge.html:pcie_port"><a href="#bridge.html:pcie_port">pcie_port</a></h2>
<p>Inherits <code>pcie_device</code> and <code>pcie_translator</code>. Defines a connect
<code>upstream_target</code> and a port object <code>downstream_port</code>. Defines a port
<code>upstream_message_router</code> which routes upstream messages either to itself or
forwards them further upstream or reroutes them downstream. Defines a port
<code>upstream_message</code> which handles upstream transactions of type <strong>Msg</strong>
directed at this PCIe port.</p>
<h2 id="bridge.html:pcie_downstream_port"><a href="#bridge.html:pcie_downstream_port">pcie_downstream_port</a></h2>
<p>To be used by Downstream Switch Ports. Inherits <code>pcie_port</code> and
<code>pcie_hotplug_port</code>.</p>
<h2 id="bridge.html:pcie_root_port"><a href="#bridge.html:pcie_root_port">pcie_root_port</a></h2>
<p>To be used by Root Ports. Inherits <code>pcie_downstream_port.</code></p>
<h2 id="bridge.html:pcie_upstream_port"><a href="#bridge.html:pcie_upstream_port">pcie_upstream_port</a></h2>
<p>To be used by Upstream Switch Ports. Inherits <code>pcie_port</code>.</p>
<h2 id="bridge.html:message_port"><a href="#bridge.html:message_port">message_port</a></h2>
<p>Implements <code>transaction</code> interface where it receives and dispatches
transactions of type <strong>Msg</strong> to instances (on the same level) of the
<code>handling_messages</code> template. Unhandled messages will be terminated
with error or silently dropped depending on type of <strong>Msg</strong>.</p>
<h2 id="bridge.html:message_translator"><a href="#bridge.html:message_translator">message_translator</a></h2>
<p>Implements <code>transaction_translator</code> interface where it receives translator
requests of type <strong>Msg</strong> from downstream. Forwards messages depending
on <code>pcie_msg_route</code> atom. Messages to be routed upstream are forwarded to
parameter <code>default_target</code>, messages to be routed downstream are forwarded to
<code>downstream_port</code> and messages targeting this PCIe port are forwarded to
parameter <code>local_target</code> for local handling of the message.
parameter <code>is_root_port</code> is used to determine if messages with routing type
of <code>PCIE_Msg_Route_Upstream</code> should be forwarded to <code>local_target</code> instead of
<code>default_target</code> for Error Messages.</p>
<h2 id="bridge.html:handling_messages"><a href="#bridge.html:handling_messages">handling_messages</a></h2>
<p>Should be implemented by (DML) objects that wants to handle PCIe messages
dispatched by the <code>message_port</code> template. When a message is received on a
<code>message_port</code> instance, it will iterate over instances of this template (in
an undefined order) and call the <code>message</code> method. Note that downstream
messages have stub-methods in the <code>pcie_config.message</code> group and are not
handled by instancing this template.</p>
<h3 id="bridge.html:methods"><a href="#bridge.html:methods">Methods</a></h3>
<h4 id="bridge.html:message-transaction_t-t-uint64-addr-pcie_message_type_t-type-pcie_error_t"><a href="#bridge.html:message-transaction_t-t-uint64-addr-pcie_message_type_t-type-pcie_error_t">message(transaction_t *t, uint64 addr, pcie_message_type_t type) -&gt; (pcie_error_t)</a></h4>
<p>Called by the <code>message_port</code> template when a PCIe message is received.
Must return <code>PCIE_Error_Not_Set</code> if the message is <em>not</em>
handled. Returning anything else means that the message was handled by
this method call.</p>
<h2 id="bridge.html:handling_ats_messages"><a href="#bridge.html:handling_ats_messages">handling_ats_messages</a></h2>
<p>Stub methods for an RC receiving ATS messages. Inherits
<code>handling_messages</code></p>
<h4 id="bridge.html:ats_invalidate_completion-transaction_t-t-uint64-addr-bool"><a href="#bridge.html:ats_invalidate_completion-transaction_t-t-uint64-addr-bool">ats_invalidate_completion(transaction_t *t, uint64 addr) -&gt; (bool)</a></h4>
<p>Called when a ATS Invalidation Completion message is received. Device model
has to override the default implementation to process the message.
Returns <code>true</code> if processing of the message was successful.
Default implementation always returns <code>false</code>.</p>
<h2 id="bridge.html:handling_prs_messages"><a href="#bridge.html:handling_prs_messages">handling_prs_messages</a></h2>
<p>Template for an RC receiving and sending PRS messages. Method
<code>page_request_received</code> must be overridden to implement the
logic to handle a page request message. Inherits <code>handling_messages</code>.</p>
<h4 id="bridge.html:method-page_group_response-map_target_t-mt-uint16-target_id-uint16-prs_group_idx-pcie_prs_response_code_t-response_code-pcie_pasid_info_t-pasid-pcie_error_t"><a href="#bridge.html:method-page_group_response-map_target_t-mt-uint16-target_id-uint16-prs_group_idx-pcie_prs_response_code_t-response_code-pcie_pasid_info_t-pasid-pcie_error_t">method page_group_response(map_target_t *mt, uint16 target_id, uint16 prs_group_idx, pcie_prs_response_code_t response_code, pcie_pasid_info_t *pasid) -&gt; (pcie_error_t)</a></h4>
<p>Sends a Page Response message to <strong>target_id</strong> via <strong>mt</strong>.
Argument <strong>pasid</strong> can be set to NULL to leave out the PASID
from the transaction.</p>
<h4 id="bridge.html:page_request_received-transaction_t-t-uint64-addr-bool"><a href="#bridge.html:page_request_received-transaction_t-t-uint64-addr-bool">page_request_received(transaction_t *t, uint64 addr) -&gt; (bool)</a></h4>
<p>Stub method, called when a Page Request message is received.  Should
return <code>true</code> if the message was handled correctly or <code>false</code> if the
message could not be handled. The default implementation logs an
<strong>unimpl</strong> message and returns <code>false</code>.</p>
<h2 id="bridge.html:pcie_translator"><a href="#bridge.html:pcie_translator">pcie_translator</a></h2>
<p>Default PCIe translator, implementing <code>transaction_translator</code>. Redirects
transactions based on the <code>pcie_type</code> atom.  Transactions are forwarded
according to parameters <code>msg</code>, <code>mem</code>, <code>io</code> and <code>cfg</code> in the group
<code>txl_target</code>. By default, all parameters point to the parameter <code>def</code> which
defaults to <code>NULL</code>, i.e. transactions are terminated.</p>
<h2 id="bridge.html:ats_upstream_translator"><a href="#bridge.html:ats_upstream_translator">ats_upstream_translator</a></h2>
<p>Stub template for handling ATS transactions. Inherits <code>pcie_translator</code>.
Defines the ports <code>ats_untranslated</code>, <code>ats_translated</code> and <code>ats_request</code> to
which <strong>Memory</strong> transactions are forwarded according to the <code>pcie_at</code>
atom. All other transactions are handled according to the default behavior of
<code>pcie_translator</code>. The port <code>ats_request</code> implements <code>transaction</code> with the
method <code>issue</code> which by default logs an <strong>unimpl</strong> message and returns
<code>PCIE_Error_Completer_Abort</code>. The two other ports implement
<code>transaction_translator</code> and forward all transactions to
<code>host_memory.map_target</code>, by default.</p>
<h4 id="bridge.html:ats_invalidate-map_target_t-mt-uint16-target_id-const-pcie_pasid_info_t-pasid-uint64-untranslated_addr-uint64-size-bool-global-uint8-itag-pcie_error_t"><a href="#bridge.html:ats_invalidate-map_target_t-mt-uint16-target_id-const-pcie_pasid_info_t-pasid-uint64-untranslated_addr-uint64-size-bool-global-uint8-itag-pcie_error_t">ats_invalidate(map_target_t *mt, uint16 target_id, const pcie_pasid_info_t *pasid, uint64 untranslated_addr, uint64 size, bool global, uint8 itag) -&gt; (pcie_error_t)`</a></h4>
<p>Sends an ATS invalidation message via <strong>mt</strong> to an endpoint to
invalidate a translated address. The method automatically masks the lower
bits of the provided <code>untranslated_addr</code> according to PCIe specification
based on the <code>size</code> argument. Argument <code>pasid</code> can be set to NULL
in order to leave out the <code>pcie_pasid</code> atom from the transaction.</p>
<h2 id="bridge.html:type_1_bank"><a href="#bridge.html:type_1_bank">type_1_bank</a></h2>
<p>Inherits <strong>physical_config_bank</strong> and adds Type 1 specific registers.
Automatically handles mapping of the downstream_target, according to the
secondary/subordinate and base/limit registers. Handles broadcasting of
downstream messages to downstream_target.</p>
<h2 id="bridge.html:type_1_base_address"><a href="#bridge.html:type_1_base_address">type_1_base_address</a></h2>
<p>Implements the common functionality of Type 1 base address groups such as
<code>io</code>, <code>memory</code> and <code>prefetchable</code>. Handles mapping of the relevant
downstream ranges into the upstream target address spaces. Inherits
<code>abstract_base_address</code>.</p>
<h2 id="bridge.html:downstream_port"><a href="#bridge.html:downstream_port">downstream_port</a></h2>
<p>Can be applied to a connect to automatically create a <code>pcie-downstream-port</code>
object with map targets for <code>cfg</code>, <code>msg</code>, <code>mem</code> and <code>io</code>. The interface
<code>pcie_port_control</code> and <code>transaction</code> are connected to the <code>downstream</code> port
of the automatically created object.</p>
<h2 id="bridge.html:pcie_hotplug_port"><a href="#bridge.html:pcie_hotplug_port">pcie_hotplug_port</a></h2>
<p>This template should only be applied to a Downstream Port of PCI Express
Switch or a Root Port of PCI Express Root Complex.</p>
<p>When instantiating this template, an implementation of the
<code>pcie_hotplug_events</code> interface will be added to the device. When a method of
this interface is invoked, it will check if the device has a PCI Express
Capability Structure that has support for the incoming Hot-Plug event. If it
does, it will trigger a Hot-Plug event.</p>
<p>This template also adds handling of the Hot-Plug PCIe message types defined
in this library.</p>
<h2 id="bridge.html:pcie_link_training"><a href="#bridge.html:pcie_link_training">pcie_link_training</a></h2>
<p>Can be applied to objects that inherit the pcie_downstream_port or the
pcie_root_port template. Applying this template will implement the
pcie_link_training interface. Implementing this interface will allow the
object to initiate link training by the trigger method being invoked.</p>
<p>The template will also set the link_training_target in the link group of the
PCI Express Capability Structure in the device.</p>
<p>Parameters:</p>
<ul>
<li><code>pcie_link_training_target</code>: A map_target_t pointer that is not <code>NULL</code>
during <code>post_init</code>, default <code>downstream_port.phy.map_target</code></li>
</ul>
</section><section class="page" id="capabilities-list.html"><h1>List of capability templates</h1>
<p>These are templates for PCIe (Extended)
Capabilities. Most templates only define the registers with their
standard access restrictions. If additional behavior is required, the user of
the template must implement it manually. Note that the functionality of many
capabilities are out of scope for a functional simulator such as
Simics, in these cases it is usually sufficient to simulate the
registers with their reset values.</p>
<p>The following capability templates define registers and fields, and have
partial or full functional behavior implemented:</p>
<ul>
<li><a href="#capabilities.html:pci-express-capability-registers">PCI Express Capability registers</a></li>
<li><a href="#capabilities.html:message-signaled-interrupts-msi-capability-registers">Message Signaled Interrupts (MSI) Capability registers</a></li>
<li><a href="#capabilities.html:message-signaled-interrupts-x-msi-x-capability-registers">Message Signaled Interrupts X (MSI-X) Capability registers</a></li>
<li><a href="#extended-capabilities.html:address-translation-service-ats-capability-registers">Address Translation Service (ATS) Capability registers</a></li>
<li><a href="#extended-capabilities.html:resizable-bar-rbar-capability-registers">Resizable BAR (RBAR) Capability registers</a></li>
<li><a href="#extended-capabilities.html:vf-resizable-bar-vfrbar-capability-registers">VF Resizable BAR (VFRBAR) Capability registers</a></li>
<li><a href="#extended-capabilities.html:pasid-extended-capability-structure-registers">PASID Extended Capability Structure registers</a></li>
<li><a href="#extended-capabilities.html:single-root-i-o-virtualization-sr-iov-extended-capability-registers">Single Root I/O Virtualization (SR-IOV) Extended Capability registers</a></li>
<li><a href="#extended-capabilities.html:data-object-exchange-extended-capability-registers">Data Object Exchange Extended Capability registers</a></li>
<li><a href="#extended-capabilities.html:virtual-function-type-0-bank">Virtual Function Type 0 Bank</a></li>
<li><a href="#extended-capabilities.html:virtual-function-base-address">Virtual Function Base Address</a></li>
</ul>
<p>The following capability templates <em>only</em> define registers and fields, users
must implement all required behavior:</p>
<ul>
<li><a href="#capabilities.html:power-management-capability-registers">Power Management Capability registers</a></li>
<li><a href="#capabilities.html:vpd-capability-registers">VPD Capability registers</a></li>
<li><a href="#capabilities.html:subsystem-id-and-subsystem-vendor-id-capability-registers">Subsystem ID and Subsystem Vendor ID Capability registers</a></li>
<li><a href="#capabilities.html:conventional-pci-advanced-features-capability-af-registers">Conventional PCI Advanced Features Capability (AF) registers</a></li>
<li><a href="#capabilities.html:enhanced-allocation-ea-capability-registers">Enhanced Allocation (EA) Capability registers</a></li>
<li><a href="#capabilities.html:flattening-portal-bridge-fpb-capability-registers">Flattening Portal Bridge (FPB) Capability registers</a></li>
<li><a href="#capabilities.html:null-capability-registers">Null Capability registers</a></li>
<li><a href="#extended-capabilities.html:advanced-error-reporting-aer-capability-registers">Advanced Error Reporting (AER) Capability registers</a></li>
<li><a href="#extended-capabilities.html:virtual-channel-vc-capability-registers">Virtual Channel (VC) Capability registers</a></li>
<li><a href="#extended-capabilities.html:device-serial-number-dsn-capability-registers">Device Serial Number (DSN) Capability registers</a></li>
<li><a href="#extended-capabilities.html:device-power-budgeting-dpb-capability-registers">Device Power Budgeting (DPB) Capability registers</a></li>
<li><a href="#extended-capabilities.html:root-complex-link-declaration-rcld-capability-registers">Root Complex Link Declaration (RCLD) Capability registers</a></li>
<li><a href="#extended-capabilities.html:root-complex-internal-link-control-rcilc-capability-registers">Root Complex Internal Link Control (RCILC) Capability registers</a></li>
<li><a href="#extended-capabilities.html:root-complex-event-collector-endpoint-association-rcecea-capability-registers">Root Complex Event Collector Endpoint Association (RCECEA) Capability registers</a></li>
<li><a href="#extended-capabilities.html:multi-function-virtual-channel-mfvc-capability-registers">Multi-Function Virtual Channel (MFVC) Capability registers</a></li>
<li><a href="#extended-capabilities.html:rcrb-header-rcrb-capability-registers">RCRB Header (RCRB) Capability registers</a></li>
<li><a href="#extended-capabilities.html:vendor-specific-extended-capability-vsec-registers">Vendor-Specific Extended Capability (VSEC) registers</a></li>
<li><a href="#extended-capabilities.html:access-control-services-acs-capability-registers">Access Control Services (ACS) Capability registers</a></li>
<li><a href="#extended-capabilities.html:alternate-routing-id-ari-capability-registers">Alternate Routing ID (ARI) Capability registers</a></li>
<li><a href="#extended-capabilities.html:multicast-mc-capability-registers">Multicast (MC) Capability registers</a></li>
<li><a href="#extended-capabilities.html:page-request-service-prs-capability-registers">Page Request Service (PRS) Capability registers</a></li>
<li><a href="#extended-capabilities.html:dynamic-power-allocation-dpa-capability-registers">Dynamic Power Allocation (DPA) Capability registers</a></li>
<li><a href="#extended-capabilities.html:transaction-processing-hints-tph-requester-extended-capability-registers">Transaction Processing Hints (TPH) Requester Extended Capability registers</a></li>
<li><a href="#extended-capabilities.html:latency-tolerance-reporting-ltr-capability-registers">Latency Tolerance Reporting (LTR) Capability registers</a></li>
<li><a href="#extended-capabilities.html:secondary-pci-express-spe-capability-registers">Secondary PCI Express (SPE) Capability registers</a></li>
<li><a href="#extended-capabilities.html:ln-requester-extended-capability-registers">LN Requester Extended Capability registers</a></li>
<li><a href="#extended-capabilities.html:downstream-port-containment-dpc-extended-capability-registers">Downstream Port Containment (DPC) Extended Capability registers</a></li>
<li><a href="#extended-capabilities.html:l1-pm-substates-extended-capability-registers">L1 PM Substates Extended Capability registers</a></li>
<li><a href="#extended-capabilities.html:precision-time-management-ptm-capability-registers">Precision Time Management (PTM) Capability registers</a></li>
<li><a href="#extended-capabilities.html:m-pcie-extended-capability-registers">M-PCIe Extended Capability registers</a></li>
<li><a href="#extended-capabilities.html:frs-queueing-extended-capability-registers">FRS Queueing Extended Capability registers</a></li>
<li><a href="#extended-capabilities.html:readiness-time-reporting-extended-capability-registers">Readiness Time Reporting Extended Capability registers</a></li>
<li><a href="#extended-capabilities.html:data-link-feature-extended-capability-registers">Data Link Feature Extended Capability registers</a></li>
<li><a href="#extended-capabilities.html:physical-layer-16-0-gt-s-extended-capability-registers">Physical Layer 16.0 GT/s Extended Capability registers</a></li>
<li><a href="#extended-capabilities.html:lane-margining-at-the-receiver-extended-capability-registers">Lane Margining at the Receiver Extended Capability registers</a></li>
<li><a href="#extended-capabilities.html:physical-layer-32-0-gt-s-extended-capability-registers">Physical Layer 32.0 GT/s Extended Capability registers</a></li>
<li><a href="#extended-capabilities.html:physical-layer-64-0-gt-s-extended-capability-registers">Physical Layer 64.0 GT/s Extended Capability registers</a></li>
<li><a href="#extended-capabilities.html:designated-vendor-specific-extended-capability-dvsec-registers">Designated Vendor-Specific Extended Capability (DVSEC) registers</a></li>
<li><a href="#extended-capabilities.html:hierarchy-id-extended-capability-registers">Hierarchy ID Extended Capability registers</a></li>
<li><a href="#extended-capabilities.html:native-pcie-enclosure-management-npem-extended-capability-registers">Native PCIe Enclosure Management (NPEM) Extended Capability registers</a></li>
<li><a href="#extended-capabilities.html:alternate-protocol-extended-capability-registers">Alternate Protocol Extended Capability registers</a></li>
<li><a href="#extended-capabilities.html:system-firmware-intermediary-sfi-extended-capability-registers">System Firmware Intermediary (SFI) Extended Capability registers</a></li>
<li><a href="#extended-capabilities.html:device-3-extended-capability-registers">Device 3 Extended Capability registers</a></li>
<li><a href="#extended-capabilities.html:flit-logging-extended-capability-registers">Flit Logging Extended Capability registers</a></li>
<li><a href="#extended-capabilities.html:flit-performance-measurement-extended-capability-registers">Flit Performance Measurement Extended Capability registers</a></li>
<li><a href="#extended-capabilities.html:flit-error-injection-extended-capability-registers">Flit Error Injection Extended Capability registers</a></li>
<li><a href="#extended-capabilities.html:shadow-functions-extended-capability-registers">Shadow Functions Extended Capability registers</a></li>
<li><a href="#extended-capabilities.html:integrity-and-data-encryption-extended-capability-registers">Integrity and Data Encryption Extended Capability registers</a></li>
<li><a href="#extended-capabilities.html:null-extended-capability-registers">Null Extended Capability registers</a></li>
</ul>
</section><section class="page" id="capabilities.html"><h1>Capabilities templates</h1>
<p>These are templates for PCIe Capabilities. They are designed to be applied
on a <code>group</code>. For convenience there exists a template
<code>defining_xyz_capability</code> for each capability <code>xyz</code> which defines a group
<code>xyz</code> with the <code>xyz_capability</code> applied. Most templates only define the
registers with their standard access restrictions. If additional behavior is
needed, the user of the template must implement this manually.</p>
<p>Each capability template uses the following parameters:</p>
<ul>
<li><code>base</code>: Base address of the capability header</li>
<li><code>next_ptr</code>: Value of the next_ptr field in the capability header</li>
</ul>
<h2 id="capabilities.html:power-management-capability-registers"><a href="#capabilities.html:power-management-capability-registers">Power Management Capability registers</a></h2>
<ul>
<li>name: <code>pm_capability</code></li>
<li>implemented: registers only</li>
</ul>
<h2 id="capabilities.html:pci-express-capability-registers"><a href="#capabilities.html:pci-express-capability-registers">PCI Express Capability registers</a></h2>
<ul>
<li>name: <code>exp_capability</code></li>
<li>implemented: functional</li>
</ul>
<h3 id="capabilities.html:parameters"><a href="#capabilities.html:parameters">Parameters:</a></h3>
<ul>
<li><code>has_hotplug_capable_slot</code>: Device has a native PCIe Hot-Plug capable slot.
This param will set the <em>has_hotplug_capable</em> in the instantiated
<em>exp_slot</em> template, default false</li>
<li><code>has_attention_button_slot</code>: Attention button present in slot. This param
will set the <em>has_attention_button</em> in the instantiated <em>exp_slot</em>
template, default false</li>
<li><code>has_links</code>: Presence of <strong>links</strong> registers, default
<em>has_hotplug_capable_slot</em></li>
<li><code>has_slots</code>: Presence of <strong>slots</strong> registers, default
<em>has_hotplug_capable_slot</em></li>
<li><code>has_root</code>: Presence of <strong>root</strong> registers, default false</li>
<li><code>dp_type</code>: Device/port type, as indicated in <code>exp.capability.dpt</code> register field, (<a href="#capabilities.html:device-port-type-constants">see constants</a>), default <code>PCIE_DP_Type_EP</code>.</li>
<li><code>cap_version</code>: Version of this capability structure, as indicated in <code>exp.capability.cv</code> register field, default 2</li>
<li><code>imn</code>: The MSI/MSI-X vector used for the interrupt message generated in
association with any of the status bits of this Capability structure,
default 0</li>
</ul>
<h4 id="capabilities.html:adds-groups"><a href="#capabilities.html:adds-groups">Adds groups:</a></h4>
<ul>
<li><code>device</code> which instantiates template <code>exp_dev</code>.</li>
<li><code>link</code> which instantiates template <code>exp_link</code>. Optionally added depending on param <code>has_links</code>.</li>
<li><code>slot</code> which instantiates template <code>exp_slot</code>. Optionally added depending on param <code>has_slots</code>.</li>
<li><code>root</code> which instantiates template <code>exp_root</code>. Optionally added depending on param <code>has_root</code>.</li>
</ul>
<h4 id="capabilities.html:device-port-type-constants-for-field-exp-capability-dpt"><a href="#capabilities.html:device-port-type-constants-for-field-exp-capability-dpt">Device/port type constants for field <code>exp.capability.dpt</code> <span id="capabilities.html:device-port-type-constants"><span></span></span></a></h4>
<p><code>PCIE_DP_Type_EP</code>, <code>PCIE_DP_Type_Legacy_EP</code>, <code>PCIE_DP_Type_RCiEP</code>, <code>PCIE_DP_Type_RCEC</code>,
<code>PCIE_DP_Type_RP</code>, <code>PCIE_DP_Type_UP</code>, <code>PCIE_DP_Type_DP</code>, <code>PCIE_DP_Type_BridgeX</code>, <code>PCIE_DP_Type_XBridge</code></p>
<h3 id="capabilities.html:pci-express-capability-device-registers"><a href="#capabilities.html:pci-express-capability-device-registers">PCI Express Capability Device registers</a></h3>
<ul>
<li>name: <code>exp_dev</code></li>
<li>implemented: functional</li>
</ul>
<h4 id="capabilities.html:set_status_error-uint8-error_type-bool-is_ur-throws"><a href="#capabilities.html:set_status_error-uint8-error_type-bool-is_ur-throws"><code>set_status_error(uint8 error_type, bool is_ur) throws</code></a></h4>
<p>Sets the bits in the status register related to error signaling.</p>
<h3 id="capabilities.html:pci-express-capability-link-registers"><a href="#capabilities.html:pci-express-capability-link-registers">PCI Express Capability Link registers</a></h3>
<ul>
<li>name: <code>exp_link</code></li>
<li>implemented: link training</li>
</ul>
<h4 id="capabilities.html:parameters-2"><a href="#capabilities.html:parameters-2">Parameters:</a></h4>
<ul>
<li><code>dll_link_active_reporting</code>: Link supports DLL Link Active Reporting, default false</li>
<li><code>max_link_speed</code>: Max link speed provided as a value of the
pcie_link_speed_t enum, default PCIE_Link_Speed_Undefined</li>
<li><code>max_link_width</code>: Max link width provided as a value of the
pcie_link_width_t enum, PCIE_Link_Width_Undefined</li>
<li><code>link_bandwidth_notifications</code>: Support Link Bandwidth Notifications,
default ((dp_type == PCIE_DP_Type_DP) || (dp_type == PCIE_DP_Type_RP))</li>
</ul>
<h4 id="capabilities.html:methods"><a href="#capabilities.html:methods">Methods</a></h4>
<h4 id="capabilities.html:set_link_training_target-map_target_t-target"><a href="#capabilities.html:set_link_training_target-map_target_t-target"><code>set_link_training_target(map_target_t *target)</code></a></h4>
<p>Sets the default link training target when <code>do_link_training()</code> is called
with NULL.</p>
<h4 id="capabilities.html:do_link_training-map_target_t-target"><a href="#capabilities.html:do_link_training-map_target_t-target"><code>do_link_training(map_target_t *target)</code></a></h4>
<p>Initiates link training by sending a link training transaction to either
the to the target set with <code>set_link_training_target()</code>. Returns true if
link negotiation was deemed successful. Will set the status.ls and
status.nlw fields if the negotiation was successful. Negotiation can only
be successful if both the initiator and the link training target has the
params max_link_speed and max_link_width in their respective link groups
set. <code>do_link_training</code> will by default only send a link training
transaction to device 0. This method can be overridden for custom
functionality where support for bifurcation might for instance be
necessary.</p>
<h4 id="capabilities.html:get_target_link_speed-pcie_link_speed_t"><a href="#capabilities.html:get_target_link_speed-pcie_link_speed_t"><code>get_target_link_speed() -&gt; (pcie_link_speed_t)</code></a></h4>
<p>Returns the target link speed. This would be the maximum link speed if
there is no target link speed.</p>
<h4 id="capabilities.html:get_max_link_width-pcie_link_width_t"><a href="#capabilities.html:get_max_link_width-pcie_link_width_t"><code>get_max_link_width() -&gt; (pcie_link_width_t)</code></a></h4>
<p>Returns the maximum link width</p>
<h4 id="capabilities.html:set_link_attributes-pcie_link_speed_t-speed-pcie_link_width_t-width"><a href="#capabilities.html:set_link_attributes-pcie_link_speed_t-speed-pcie_link_width_t-width"><code>set_link_attributes(pcie_link_speed_t speed, pcie_link_width_t width)</code></a></h4>
<p>Sets the status.ls and status.nlw fields.</p>
<h3 id="capabilities.html:pci-express-capability-slot-registers"><a href="#capabilities.html:pci-express-capability-slot-registers">PCI Express Capability Slot registers</a></h3>
<ul>
<li>name: <code>exp_slot</code></li>
<li>implemented: functional</li>
</ul>
<h4 id="capabilities.html:parameters-3"><a href="#capabilities.html:parameters-3">Parameters:</a></h4>
<ul>
<li><code>is_hotplug_capable</code>: Slot is native PCIe Hot-Plug capable, default false</li>
<li><code>has_power_indicator</code>: Slot has a power indicator, default false</li>
<li><code>has_power_controller</code>: Slot has a power controller, default false</li>
<li><code>has_mrl_sensor</code>: Slot has an MRL sensor, default false</li>
<li><code>has_command_completions</code>: Slot sends command completed notifications, default false</li>
</ul>
<h4 id="capabilities.html:methods-2"><a href="#capabilities.html:methods-2">Methods</a></h4>
<h4 id="capabilities.html:presence_change_event-pcie_hotplug_pd_t-state-bool"><a href="#capabilities.html:presence_change_event-pcie_hotplug_pd_t-state-bool"><code>presence_change_event(pcie_hotplug_pd_t state) -&gt; (bool)</code></a></h4>
<p>Sets the presence detect state field to <code>state</code>. If the state has
changed, also sets the presence detect changed field and notifies
software if applicable. Returns true if event was registered</p>
<h4 id="capabilities.html:mrl_sensor_event-pcie_hotplug_mrl_t-state-bool"><a href="#capabilities.html:mrl_sensor_event-pcie_hotplug_mrl_t-state-bool"><code>mrl_sensor_event(pcie_hotplug_mrl_t state) -&gt; (bool)</code></a></h4>
<p>Sets the MRL sensor state field to <code>state</code>. If the state has changed,
also sets the MRL sensor changed field and notifies software if
applicable. Returns true if event was registered</p>
<h4 id="capabilities.html:data_link_layer_event-bool-is_active-bool"><a href="#capabilities.html:data_link_layer_event-bool-is_active-bool"><code>data_link_layer_event(bool is_active) -&gt; (bool)</code></a></h4>
<p>Sets the Data Link Layer Link Active in the link status register to
<code>is_active</code>. If this field changes value, also sets the Data Link Layer
state changed field in the slot status register and notifies software if
applicable. Returns true if event was registered</p>
<h4 id="capabilities.html:power_fault_event-bool"><a href="#capabilities.html:power_fault_event-bool"><code>power_fault_event() -&gt; (bool)</code></a></h4>
<p>Sets the Power Fault Detected field and notifies software if applicable.
Returns true if event was registered</p>
<h4 id="capabilities.html:attention_button_event-bool"><a href="#capabilities.html:attention_button_event-bool"><code>attention_button_event() -&gt; (bool)</code></a></h4>
<p>Sets the Attention Button Pressed field and notifies software if
applicable. Returns true if event was registered</p>
<h4 id="capabilities.html:hotplug_event_enabled-int-type-bool"><a href="#capabilities.html:hotplug_event_enabled-int-type-bool"><code>hotplug_event_enabled(int type) -&gt; (bool)</code></a></h4>
<p>Returns true if slot has Hot-Plug event types of type <code>type</code> enabled. The
available types are <code>param</code>:s defined in this file that have the prefix
SLOT_ and LINK_.</p>
<h4 id="capabilities.html:hotplug_capable-int-type"><a href="#capabilities.html:hotplug_capable-int-type"><code>hotplug_capable(int type)</code></a></h4>
<p>Returns true if the slot is capable of handling Hot-Plug events of type
<code>type</code>. The available types are <code>param</code>:s defined in this file that have
the prefix SLOT_ and LINK_.</p>
<h3 id="capabilities.html:pci-express-capability-root-registers"><a href="#capabilities.html:pci-express-capability-root-registers">PCI Express Capability Root registers</a></h3>
<ul>
<li>name: <code>exp_root</code></li>
<li>implemented: registers only</li>
</ul>
<h2 id="capabilities.html:vpd-capability-registers"><a href="#capabilities.html:vpd-capability-registers">VPD Capability registers</a></h2>
<ul>
<li>name: <code>vpd_capability</code></li>
<li>implemented: registers only</li>
</ul>
<h2 id="capabilities.html:message-signaled-interrupts-msi-capability-registers"><a href="#capabilities.html:message-signaled-interrupts-msi-capability-registers">Message Signaled Interrupts (MSI) Capability registers</a></h2>
<ul>
<li>name: <code>msi_capability</code></li>
<li>implemented: functional</li>
</ul>
<h3 id="capabilities.html:parameters-4"><a href="#capabilities.html:parameters-4">Parameters:</a></h3>
<ul>
<li><code>is_64bit_capable</code>: Support 64-bit addresses, i.e. <code>address</code> register is
8 bytes instead of 4.</li>
<li><code>is_pvm_capable</code>: Support Per-Vector-Masking, i.e. the <code>mask</code> register is
present.</li>
<li><code>is_emd_capable</code>: Support extended message data, i.e. the <code>data</code> register
is 8 bytes instead of 4.</li>
<li><code>num_vectors</code>: The number of interrupt vectors supported.</li>
</ul>
<h3 id="capabilities.html:methods-3"><a href="#capabilities.html:methods-3">Methods</a></h3>
<h4 id="capabilities.html:signal_all_pending"><a href="#capabilities.html:signal_all_pending"><code>signal_all_pending()</code></a></h4>
<p>Signals all pending MSI's</p>
<h4 id="capabilities.html:raise-uint8-i"><a href="#capabilities.html:raise-uint8-i"><code>raise(uint8 i)</code></a></h4>
<p>Raises MSI <code>i</code> if capable and enabled, and signals it if not masked</p>
<h4 id="capabilities.html:lower-uint8-i"><a href="#capabilities.html:lower-uint8-i"><code>lower(uint8 i)</code></a></h4>
<p>Lowers MSI <code>i</code></p>
<h2 id="capabilities.html:message-signaled-interrupts-x-msi-x-capability-registers"><a href="#capabilities.html:message-signaled-interrupts-x-msi-x-capability-registers">Message Signaled Interrupts X (MSI-X) Capability registers</a></h2>
<ul>
<li>name: <code>msix_capability</code></li>
<li>implemented: functional</li>
</ul>
<h3 id="capabilities.html:parameters-5"><a href="#capabilities.html:parameters-5">Parameters:</a></h3>
<ul>
<li><code>table_offset_bir</code>: Initial value of the Table Offset/BIR register (at
offset 0x4 in the MSI-X capability structure).</li>
<li><code>pba_offset_bir</code>: Initial value of the PBA Offset/BIR register (at
offset 0x8 in the MSI-X capability structure).</li>
<li><code>data_bank</code>: The bank which holds the Table and Pending Bits data, which
must use the template <code>msix_table</code></li>
<li><code>num_vectors</code>: Number of interrupt vectors supported.</li>
</ul>
<h3 id="capabilities.html:methods-4"><a href="#capabilities.html:methods-4">Methods</a></h3>
<h4 id="capabilities.html:raise-uint16-i"><a href="#capabilities.html:raise-uint16-i"><code>raise(uint16 i)</code></a></h4>
<p>Raises MSI-X <code>i</code> if enabled, and signals it if not masked</p>
<h4 id="capabilities.html:lower-uint16-i"><a href="#capabilities.html:lower-uint16-i"><code>lower(uint16 i)</code></a></h4>
<p>Lowers MSI-X <code>i</code></p>
<h3 id="capabilities.html:msix_table"><a href="#capabilities.html:msix_table">msix_table</a></h3>
<p>Template to model the msix table data and pending bits.</p>
<h4 id="capabilities.html:parameters-6"><a href="#capabilities.html:parameters-6">Parameters:</a></h4>
<ul>
<li><code>num_vectors</code>: Number of MSI-X vectors</li>
<li><code>msix_bank</code>: Bank containing the group instantiating the MSI-X capability.</li>
</ul>
<h2 id="capabilities.html:subsystem-id-and-subsystem-vendor-id-capability-registers"><a href="#capabilities.html:subsystem-id-and-subsystem-vendor-id-capability-registers">Subsystem ID and Subsystem Vendor ID Capability registers</a></h2>
<ul>
<li>name: <code>ssid_capability</code></li>
<li>implemented: registers only</li>
</ul>
<h2 id="capabilities.html:conventional-pci-advanced-features-capability-af-registers"><a href="#capabilities.html:conventional-pci-advanced-features-capability-af-registers">Conventional PCI Advanced Features Capability (AF) registers</a></h2>
<ul>
<li>name: <code>af_capability</code></li>
<li>implemented: FLR</li>
</ul>
<h2 id="capabilities.html:enhanced-allocation-ea-capability-registers"><a href="#capabilities.html:enhanced-allocation-ea-capability-registers">Enhanced Allocation (EA) Capability registers</a></h2>
<ul>
<li>name: <code>ea_capability</code></li>
<li>implemented: registers only</li>
</ul>
<h2 id="capabilities.html:flattening-portal-bridge-fpb-capability-registers"><a href="#capabilities.html:flattening-portal-bridge-fpb-capability-registers">Flattening Portal Bridge (FPB) Capability registers</a></h2>
<ul>
<li>name: <code>fpb_capability</code></li>
<li>implemented: registers only</li>
</ul>
<p>Fields and access restrictions to be added upon request.</p>
<h2 id="capabilities.html:null-capability-registers"><a href="#capabilities.html:null-capability-registers">Null Capability registers</a></h2>
<ul>
<li>name: <code>null_capability</code></li>
<li>implemented: registers only</li>
</ul>
</section><section class="page" id="extended-capabilities.html"><h1>Extended Capabilities templates</h1>
<p>These are templates for PCIe Extended Capabilities. They are designed to be
applied on a <code>group</code>. For convenience there exists a template
<code>defining_xyz_capability</code> for each capability <code>xyz</code> which defines a group
<code>xyz</code> with the <code>xyz_capability</code> applied.  Most templates only define the
registers with their standard access restrictions.  If additional behavior is
needed, the user of the template must implement this manually.</p>
<p>Each extended capability template uses the following parameters:</p>
<ul>
<li><code>base</code>: Base address of the capability header</li>
<li><code>next_ptr</code>: Value of the next_ptr field in the capability header</li>
</ul>
<h2 id="extended-capabilities.html:advanced-error-reporting-aer-capability-registers"><a href="#extended-capabilities.html:advanced-error-reporting-aer-capability-registers">Advanced Error Reporting (AER) Capability registers</a></h2>
<ul>
<li>name: <code>aer_capability</code></li>
<li>implemented: registers only</li>
</ul>
<h2 id="extended-capabilities.html:virtual-channel-vc-capability-registers"><a href="#extended-capabilities.html:virtual-channel-vc-capability-registers">Virtual Channel (VC) Capability registers</a></h2>
<ul>
<li>name: <code>vc_capability</code></li>
<li>implemented: registers only</li>
</ul>
<h2 id="extended-capabilities.html:device-serial-number-dsn-capability-registers"><a href="#extended-capabilities.html:device-serial-number-dsn-capability-registers">Device Serial Number (DSN) Capability registers</a></h2>
<ul>
<li>name: <code>dsn_capability</code></li>
<li>implemented: registers only</li>
</ul>
<h2 id="extended-capabilities.html:device-power-budgeting-dpb-capability-registers"><a href="#extended-capabilities.html:device-power-budgeting-dpb-capability-registers">Device Power Budgeting (DPB) Capability registers</a></h2>
<ul>
<li>name: <code>dpb_capability</code></li>
<li>implemented: registers only</li>
</ul>
<h2 id="extended-capabilities.html:root-complex-link-declaration-rcld-capability-registers"><a href="#extended-capabilities.html:root-complex-link-declaration-rcld-capability-registers">Root Complex Link Declaration (RCLD) Capability registers</a></h2>
<ul>
<li>name: <code>rcld_capability</code></li>
<li>implemented: registers only</li>
</ul>
<p>Uses the following parameters:</p>
<ul>
<li><code>num_links</code>: number of links.</li>
</ul>
<h2 id="extended-capabilities.html:root-complex-internal-link-control-rcilc-capability-registers"><a href="#extended-capabilities.html:root-complex-internal-link-control-rcilc-capability-registers">Root Complex Internal Link Control (RCILC) Capability registers</a></h2>
<ul>
<li>name: <code>rcilc_capability</code></li>
<li>implemented: registers only</li>
</ul>
<h2 id="extended-capabilities.html:root-complex-event-collector-endpoint-association-rcecea-capability-registers"><a href="#extended-capabilities.html:root-complex-event-collector-endpoint-association-rcecea-capability-registers">Root Complex Event Collector Endpoint Association (RCECEA) Capability registers</a></h2>
<ul>
<li>name: <code>rcecea_capability</code></li>
<li>implemented: registers only</li>
</ul>
<p>Uses the following parameters:</p>
<ul>
<li><code>version</code>: version number of this capability, default 2</li>
</ul>
<h2 id="extended-capabilities.html:multi-function-virtual-channel-mfvc-capability-registers"><a href="#extended-capabilities.html:multi-function-virtual-channel-mfvc-capability-registers">Multi-Function Virtual Channel (MFVC) Capability registers</a></h2>
<ul>
<li>name: <code>mfvc_capability</code></li>
<li>implemented: registers only</li>
</ul>
<h2 id="extended-capabilities.html:rcrb-header-rcrb-capability-registers"><a href="#extended-capabilities.html:rcrb-header-rcrb-capability-registers">RCRB Header (RCRB) Capability registers</a></h2>
<ul>
<li>name: <code>rcrb_capability</code></li>
<li>implemented: registers only</li>
</ul>
<h2 id="extended-capabilities.html:vendor-specific-extended-capability-vsec-registers"><a href="#extended-capabilities.html:vendor-specific-extended-capability-vsec-registers">Vendor-Specific Extended Capability (VSEC) registers</a></h2>
<ul>
<li>name: <code>vsec_capability</code></li>
<li>implemented: registers only</li>
</ul>
<h2 id="extended-capabilities.html:access-control-services-acs-capability-registers"><a href="#extended-capabilities.html:access-control-services-acs-capability-registers">Access Control Services (ACS) Capability registers</a></h2>
<ul>
<li>name: <code>acs_capability</code></li>
<li>implemented: registers only</li>
</ul>
<h2 id="extended-capabilities.html:alternate-routing-id-ari-capability-registers"><a href="#extended-capabilities.html:alternate-routing-id-ari-capability-registers">Alternate Routing ID (ARI) Capability registers</a></h2>
<ul>
<li>name: <code>ari_capability</code></li>
<li>implemented: registers only</li>
</ul>
<h2 id="extended-capabilities.html:address-translation-service-ats-capability-registers"><a href="#extended-capabilities.html:address-translation-service-ats-capability-registers">Address Translation Service (ATS) Capability registers</a></h2>
<ul>
<li>name: <code>ats_capability</code></li>
<li>implemented: functional</li>
</ul>
<p>This is a partially functional template; the user must implement the method
<code>invalidate_received</code>.</p>
<h3 id="extended-capabilities.html:methods"><a href="#extended-capabilities.html:methods">Methods</a></h3>
<h4 id="extended-capabilities.html:invalidate_received-transaction_t-t-uint64-addr-bool"><a href="#extended-capabilities.html:invalidate_received-transaction_t-t-uint64-addr-bool"><code>invalidate_received(transaction_t *t, uint64 addr) -&gt; (bool)</code></a></h4>
<p>Called by the standard PCIe templates when an ATS Invalidate message
is received. The default implementation logs an <code>unimpl</code> message and
returns <code>false</code>, indicating a 'Completer Abort'.</p>
<h4 id="extended-capabilities.html:translation_request-unint64-addr-pcie_ats_translation_completion_entry_t-entries-int-nbr_entries-const-pcie_pasid_info_t-pasid-bool-no_write-bool-cxl_src-pcie_error_t-int"><a href="#extended-capabilities.html:translation_request-unint64-addr-pcie_ats_translation_completion_entry_t-entries-int-nbr_entries-const-pcie_pasid_info_t-pasid-bool-no_write-bool-cxl_src-pcie_error_t-int"><code>translation_request(unint64 addr, pcie_ats_translation_completion_entry_t *entries, int nbr_entries, const pcie_pasid_info_t *pasid, bool no_write, bool cxl_src)-&gt; (pcie_error_t, int)</code></a></h4>
<p>Issue a translation request to Translation Agent (TA).
Set <code>pasid</code> to NULL to exclude the <code>pcie_pasid</code> atom in the transaction.
Returns error status and number of valid completion entries
the TA has filled in.</p>
<h4 id="extended-capabilities.html:translation_size_to_entries-uint64-size-uint64"><a href="#extended-capabilities.html:translation_size_to_entries-uint64-size-uint64"><code>translation_size_to_entries(uint64 size) -&gt; (uint64)</code></a></h4>
<p>Calculates the maximum number of translation completion entries required
for TA to cover the requested translation of <code>size</code>.</p>
<h4 id="extended-capabilities.html:get_translation_range-pcie_ats_translation_completion_entry_t-entry-uint64-uint64"><a href="#extended-capabilities.html:get_translation_range-pcie_ats_translation_completion_entry_t-entry-uint64-uint64"><code>get_translation_range(pcie_ats_translation_completion_entry_t entry) -&gt; (uint64, uint64)</code></a></h4>
<p>Decodes the completion entry and returns the <code>translated</code> address
and the <code>size</code> of the translated region.</p>
<h4 id="extended-capabilities.html:get_invalidation_range-pcie_ats_invalidate_request_payload_t-payload-uint64-uint64"><a href="#extended-capabilities.html:get_invalidation_range-pcie_ats_invalidate_request_payload_t-payload-uint64-uint64"><code>get_invalidation_range(pcie_ats_invalidate_request_payload_t payload) -&gt; (uint64, uint64)</code></a></h4>
<p>Decodes the invalidation request message and returns the <code>untranslated</code> address
and the <code>size</code> of the untranslated region.</p>
<h4 id="extended-capabilities.html:invalidate_complete-uint64-destination_id-uint32-itag_vector-pcie_error_t"><a href="#extended-capabilities.html:invalidate_complete-uint64-destination_id-uint32-itag_vector-pcie_error_t"><code>invalidate_complete(uint64 destination_id, uint32 itag_vector) -&gt; (pcie_error_t)</code></a></h4>
<p>Sends the invalidation message to TA found at B:D:F <code>destination_id</code>.
Returns PCIE_Error_No_Error on success.</p>
<h4 id="extended-capabilities.html:memory_read_buf-buffer_t-buf-uint64-addr-pcie_at_t-at-const-pcie_pasid_info_t-pasid-pcie_error_t"><a href="#extended-capabilities.html:memory_read_buf-buffer_t-buf-uint64-addr-pcie_at_t-at-const-pcie_pasid_info_t-pasid-pcie_error_t"><code>memory_read_buf(buffer_t buf, uint64 addr, pcie_at_t at, const pcie_pasid_info_t *pasid) -&gt; (pcie_error_t)</code></a></h4>
<p>Performs an ATS Translated/Untranslated Memory Read.
The input argument <code>at</code> specifies which AT type. Input argument <code>pasid</code>
contains PASID, set to NULL to exclude the <code>pcie_pasid</code> atom in
the transaction. Returns a pcie_error_t.
Requires that an <code>upstream_target</code> is defined.
Should only be used with <code>at</code> set to: PCIE_AT_Untranslated
or PCIE_AT_Translated.</p>
<h4 id="extended-capabilities.html:memory_write_bytes-bytes_t-bytes-uint64-addr-pcie_at_t-at-const-pcie_pasid_info_t-pasid-pcie_error_t"><a href="#extended-capabilities.html:memory_write_bytes-bytes_t-bytes-uint64-addr-pcie_at_t-at-const-pcie_pasid_info_t-pasid-pcie_error_t"><code>memory_write_bytes(bytes_t bytes, uint64 addr, pcie_at_t at, const pcie_pasid_info_t *pasid) -&gt; (pcie_error_t)</code></a></h4>
<p>Performs an ATS Translated/Untranslated Memory Write.
The input argument <code>at</code> specifies which AT type. Input argument <code>pasid</code>
contains PASID, set to NULL to exclude the <code>pcie_pasid</code> atom in
the transaction. Returns a pcie_error_t.
Requires that an <code>upstream_target</code> is defined.
Should only be used with <code>at</code> set to: PCIE_AT_Untranslated
or PCIE_AT_Translated.</p>
<h2 id="extended-capabilities.html:multicast-mc-capability-registers"><a href="#extended-capabilities.html:multicast-mc-capability-registers">Multicast (MC) Capability registers</a></h2>
<ul>
<li>name: <code>mc_capability</code></li>
<li>implemented: registers only</li>
</ul>
<h2 id="extended-capabilities.html:page-request-service-prs-capability-registers"><a href="#extended-capabilities.html:page-request-service-prs-capability-registers">Page Request Service (PRS) Capability registers</a></h2>
<ul>
<li>name: <code>prs_capability</code></li>
<li>implemented: register definitions and methods to send and receive PRS message.</li>
<li>model specific: Method <code>page_group_response_received</code> has to be overridden with device logic. Registers <code>status</code> and <code>alloc</code> has to be implemented if required.</li>
</ul>
<h4 id="extended-capabilities.html:page_request-pcie_prs_page_request_t-request-const-pcie_pasid_info_t-pasid-pcie_error_t"><a href="#extended-capabilities.html:page_request-pcie_prs_page_request_t-request-const-pcie_pasid_info_t-pasid-pcie_error_t"><code>page_request(pcie_prs_page_request_t request, const pcie_pasid_info_t *pasid) -&gt; (pcie_error_t)</code></a></h4>
<p>Sends a Page Request message. Input argument <code>pasid</code>
contains PASID, set to NULL to exclude the <code>pcie_pasid</code> atom in
the transaction.</p>
<h4 id="extended-capabilities.html:send_stop_marker-const-pcie_pasid_info_t-pasid-pcie_error_t"><a href="#extended-capabilities.html:send_stop_marker-const-pcie_pasid_info_t-pasid-pcie_error_t"><code>send_stop_marker(const pcie_pasid_info_t *pasid) -&gt; (pcie_error_t)</code></a></h4>
<p>Sends a stop marker message upstream. Input argument <code>pasid</code>
contains PASID, set to NULL to exclude the <code>pcie_pasid</code> atom from
the transaction.</p>
<h4 id="extended-capabilities.html:page_response_received-transaction_t-t-uint64-addr-bool"><a href="#extended-capabilities.html:page_response_received-transaction_t-t-uint64-addr-bool"><code>page_response_received(transaction_t *t, uint64 addr) -&gt; (bool)</code></a></h4>
<p>Called by the standard PCIe templates when a Page Response message is
received. The default implementation logs an <code>unimpl</code> message and
returns <code>false</code>.</p>
<h2 id="extended-capabilities.html:resizable-bar-rbar-capability-registers"><a href="#extended-capabilities.html:resizable-bar-rbar-capability-registers">Resizable BAR (RBAR) Capability registers</a></h2>
<ul>
<li>name: <code>rbar_capability</code></li>
<li>implemented: functional</li>
</ul>
<p>The standard PCIe templates for Base Address Registers automatically find
and use the size configured in instances of this template, when enabled.</p>
<p>Uses the following parameters:</p>
<ul>
<li><code>num_bars</code>: Number of resizable bars present in this capability.</li>
<li><code>bar_indexes</code>: list of integers, setting <code>init_val</code> of <code>control.id</code> field for each RBAR</li>
<li><code>bar_capabilities</code>: list of integers, setting <code>init_val</code> of <code>capability</code> register for each RBAR</li>
</ul>
<h2 id="extended-capabilities.html:vf-resizable-bar-vfrbar-capability-registers"><a href="#extended-capabilities.html:vf-resizable-bar-vfrbar-capability-registers">VF Resizable BAR (VFRBAR) Capability registers</a></h2>
<ul>
<li>name: <code>vf_rbar_capability</code></li>
<li>implemented: functional</li>
</ul>
<p>This template works just like the Resizable Bar (RBAR) template, but is
detected and used by the standard PCIe templates for Virtual Function Base
Address Registers instead.</p>
<h2 id="extended-capabilities.html:dynamic-power-allocation-dpa-capability-registers"><a href="#extended-capabilities.html:dynamic-power-allocation-dpa-capability-registers">Dynamic Power Allocation (DPA) Capability registers</a></h2>
<ul>
<li>name: <code>dpa_capability</code></li>
<li>implemented: registers only</li>
</ul>
<p>Uses the following parameters:</p>
<ul>
<li><code>num_substates</code>: number of power allocation registers, default 1</li>
</ul>
<h2 id="extended-capabilities.html:transaction-processing-hints-tph-requester-extended-capability-registers"><a href="#extended-capabilities.html:transaction-processing-hints-tph-requester-extended-capability-registers">Transaction Processing Hints (TPH) Requester Extended Capability registers</a></h2>
<ul>
<li>name: <code>tph_capability</code></li>
<li>implemented: registers only</li>
</ul>
<p>Uses the following parameters:</p>
<ul>
<li><code>num_tables</code>: number of TPH ST Table registers, default 1</li>
</ul>
<h2 id="extended-capabilities.html:latency-tolerance-reporting-ltr-capability-registers"><a href="#extended-capabilities.html:latency-tolerance-reporting-ltr-capability-registers">Latency Tolerance Reporting (LTR) Capability registers</a></h2>
<ul>
<li>name: <code>ltr_capability</code></li>
<li>implemented: registers only</li>
</ul>
<h2 id="extended-capabilities.html:secondary-pci-express-spe-capability-registers"><a href="#extended-capabilities.html:secondary-pci-express-spe-capability-registers">Secondary PCI Express (SPE) Capability registers</a></h2>
<ul>
<li>name: <code>spe_capability</code></li>
<li>implemented: registers only</li>
</ul>
<p>Uses the following parameters:</p>
<ul>
<li><code>max_link_width</code>: number of Equalization Control registers, no default</li>
</ul>
<h2 id="extended-capabilities.html:pasid-extended-capability-structure-registers"><a href="#extended-capabilities.html:pasid-extended-capability-structure-registers">PASID Extended Capability Structure registers</a></h2>
<ul>
<li>name: <code>pasid_capability</code></li>
<li>implemented: functional</li>
</ul>
<h4 id="extended-capabilities.html:verify_pasid-pcie_pasid_info_t-pasid-bool"><a href="#extended-capabilities.html:verify_pasid-pcie_pasid_info_t-pasid-bool">verify_pasid(pcie_pasid_info_t pasid) -&gt; (bool)</a></h4>
<p>Verifies that the <code>PASID</code> capability is configured correctly
to support the contents of the <code>pasid</code> argument.
If the check fails it is considered a modelling error.
Returns true on success.</p>
<h4 id="extended-capabilities.html:verify_pasid_with_at-pcie_pasid_info_t-pasid-pcie_at_t-at-bool"><a href="#extended-capabilities.html:verify_pasid_with_at-pcie_pasid_info_t-pasid-pcie_at_t-at-bool">verify_pasid_with_at(pcie_pasid_info_t pasid, pcie_at_t at) -&gt; (bool)</a></h4>
<p>Verifies that the <code>PASID</code> capability is configured correctly
to support the contents of the <code>pasid</code> argument and the type of argument <code>at</code>.
If the check fails is considered a modelling error.
Returns true on success.</p>
<h2 id="extended-capabilities.html:ln-requester-extended-capability-registers"><a href="#extended-capabilities.html:ln-requester-extended-capability-registers">LN Requester Extended Capability registers</a></h2>
<ul>
<li>name: <code>lnr_capability</code></li>
<li>implemented: registers only</li>
</ul>
<h2 id="extended-capabilities.html:downstream-port-containment-dpc-extended-capability-registers"><a href="#extended-capabilities.html:downstream-port-containment-dpc-extended-capability-registers">Downstream Port Containment (DPC) Extended Capability registers</a></h2>
<ul>
<li>name: <code>dpc_capability</code></li>
<li>implemented: registers only</li>
</ul>
<p>Uses the following parameters:</p>
<ul>
<li><code>root_port</code>: presence of PIO registers, default false</li>
</ul>
<h2 id="extended-capabilities.html:l1-pm-substates-extended-capability-registers"><a href="#extended-capabilities.html:l1-pm-substates-extended-capability-registers">L1 PM Substates Extended Capability registers</a></h2>
<ul>
<li>name: <code>l1pms_capability</code></li>
<li>implemented: registers only</li>
</ul>
<p>Fields to be added upon request.</p>
<h2 id="extended-capabilities.html:precision-time-management-ptm-capability-registers"><a href="#extended-capabilities.html:precision-time-management-ptm-capability-registers">Precision Time Management (PTM) Capability registers</a></h2>
<ul>
<li>name: <code>ptm_capability</code></li>
<li>implemented: registers only</li>
</ul>
<p>Fields to be added upon request</p>
<h2 id="extended-capabilities.html:m-pcie-extended-capability-registers"><a href="#extended-capabilities.html:m-pcie-extended-capability-registers">M-PCIe Extended Capability registers</a></h2>
<ul>
<li>name: <code>mpcie_capability</code></li>
<li>implemented: registers only</li>
</ul>
<h2 id="extended-capabilities.html:frs-queueing-extended-capability-registers"><a href="#extended-capabilities.html:frs-queueing-extended-capability-registers">FRS Queueing Extended Capability registers</a></h2>
<ul>
<li>name: <code>frsq_capability</code></li>
<li>implemented: registers only</li>
</ul>
<p>Fields to be added upon request</p>
<h2 id="extended-capabilities.html:readiness-time-reporting-extended-capability-registers"><a href="#extended-capabilities.html:readiness-time-reporting-extended-capability-registers">Readiness Time Reporting Extended Capability registers</a></h2>
<ul>
<li>name: <code>rtr_capability</code></li>
<li>implemented: registers only</li>
</ul>
<p>Fields to be added upon request</p>
<h2 id="extended-capabilities.html:data-link-feature-extended-capability-registers"><a href="#extended-capabilities.html:data-link-feature-extended-capability-registers">Data Link Feature Extended Capability registers</a></h2>
<ul>
<li>name: <code>dlf_capability</code></li>
<li>implemented: registers only</li>
</ul>
<h2 id="extended-capabilities.html:physical-layer-16-0-gt-s-extended-capability-registers"><a href="#extended-capabilities.html:physical-layer-16-0-gt-s-extended-capability-registers">Physical Layer 16.0 GT/s Extended Capability registers</a></h2>
<ul>
<li>name: <code>pl16g_capability</code></li>
<li>implemented: registers only</li>
</ul>
<p>Uses the following parameters:</p>
<ul>
<li><code>max_link_width</code>: maximum link width, no default</li>
<li><code>max_lanes</code>: maximum number of lanes, no default</li>
</ul>
<h2 id="extended-capabilities.html:lane-margining-at-the-receiver-extended-capability-registers"><a href="#extended-capabilities.html:lane-margining-at-the-receiver-extended-capability-registers">Lane Margining at the Receiver Extended Capability registers</a></h2>
<ul>
<li>name: <code>lmar_capability</code></li>
<li>implemented: registers only</li>
</ul>
<p>Uses the following parameters:</p>
<ul>
<li><code>max_lanes</code>: number of lane control and status registers, no default</li>
</ul>
<h2 id="extended-capabilities.html:physical-layer-32-0-gt-s-extended-capability-registers"><a href="#extended-capabilities.html:physical-layer-32-0-gt-s-extended-capability-registers">Physical Layer 32.0 GT/s Extended Capability registers</a></h2>
<ul>
<li>name: <code>pl32g_capability</code></li>
<li>implemented: registers only</li>
</ul>
<p>Uses the following parameters:</p>
<ul>
<li><code>max_link_width</code>: maximum link width, no default</li>
<li><code>max_lanes</code>: maximum number of lanes, no default</li>
</ul>
<h2 id="extended-capabilities.html:physical-layer-64-0-gt-s-extended-capability-registers"><a href="#extended-capabilities.html:physical-layer-64-0-gt-s-extended-capability-registers">Physical Layer 64.0 GT/s Extended Capability registers</a></h2>
<ul>
<li>name: <code>pl64g_capability</code></li>
<li>implemented: registers only</li>
</ul>
<p>Uses the following parameters:</p>
<ul>
<li><code>max_link_width</code>: maximum link width, no default</li>
<li><code>max_lanes</code>: maximum number of lanes, no default</li>
</ul>
<h2 id="extended-capabilities.html:designated-vendor-specific-extended-capability-dvsec-registers"><a href="#extended-capabilities.html:designated-vendor-specific-extended-capability-dvsec-registers">Designated Vendor-Specific Extended Capability (DVSEC) registers</a></h2>
<ul>
<li>name: <code>dvsec_capability</code></li>
<li>implemented: registers only</li>
</ul>
<h2 id="extended-capabilities.html:hierarchy-id-extended-capability-registers"><a href="#extended-capabilities.html:hierarchy-id-extended-capability-registers">Hierarchy ID Extended Capability registers</a></h2>
<ul>
<li>name: <code>hid_capability</code></li>
<li>implemented: registers only</li>
</ul>
<h2 id="extended-capabilities.html:native-pcie-enclosure-management-npem-extended-capability-registers"><a href="#extended-capabilities.html:native-pcie-enclosure-management-npem-extended-capability-registers">Native PCIe Enclosure Management (NPEM) Extended Capability registers</a></h2>
<ul>
<li>name: <code>npem_capability</code></li>
<li>implemented: registers only</li>
</ul>
<h2 id="extended-capabilities.html:alternate-protocol-extended-capability-registers"><a href="#extended-capabilities.html:alternate-protocol-extended-capability-registers">Alternate Protocol Extended Capability registers</a></h2>
<ul>
<li>name: <code>ap_capability</code></li>
<li>implemented: registers only</li>
</ul>
<p>Fields to be added upon request</p>
<h2 id="extended-capabilities.html:system-firmware-intermediary-sfi-extended-capability-registers"><a href="#extended-capabilities.html:system-firmware-intermediary-sfi-extended-capability-registers">System Firmware Intermediary (SFI) Extended Capability registers</a></h2>
<div class="register" id="extended-capabilities.html:sfi_capability">
<p>Fields and access restrictions to be added upon request</p>
<h2 id="extended-capabilities.html:single-root-i-o-virtualization-sr-iov-extended-capability-registers"><a href="#extended-capabilities.html:single-root-i-o-virtualization-sr-iov-extended-capability-registers">Single Root I/O Virtualization (SR-IOV) Extended Capability registers</a></h2>
<ul>
<li>name: <code>sriov_capability</code></li>
<li>implemented: functional</li>
</ul>
<p>This is a partially functional template; users must implement the methods
<code>get_offset</code> and <code>get_stride</code>, create an array of DML-objects that simulate
the configuration header for each virtual function, and add instances of the
<code>vf_base_address</code> template for each VF BAR that is implemented by the
physical function.</p>
<p>Uses the following parameters:</p>
<ul>
<li><code>virtual_functions</code>: A sequence of <code>vf_type_0_bank</code> objects simulating the
virtual functions.</li>
</ul>
<h3 id="extended-capabilities.html:methods-2"><a href="#extended-capabilities.html:methods-2">Methods</a></h3>
<ul>
<li>
<p><code>get_offset() -&gt; (uint16)</code></p>
<p>Returns the offset to the first virtual function, must be implemented
by the user.</p>
</li>
<li>
<p><code>get_stride() -&gt; (uint16)</code></p>
<p>Returns the stride between virtual functions, must be implemented by
the user.</p>
</li>
</ul>
<h2 id="extended-capabilities.html:device-3-extended-capability-registers"><a href="#extended-capabilities.html:device-3-extended-capability-registers">Device 3 Extended Capability registers</a></h2>
<ul>
<li>name: <code>dev3_capability</code></li>
<li>implemented: registers only</li>
</ul>
<h2 id="extended-capabilities.html:flit-logging-extended-capability-registers"><a href="#extended-capabilities.html:flit-logging-extended-capability-registers">Flit Logging Extended Capability registers</a></h2>
<ul>
<li>name: <code>fl_capability</code></li>
<li>implemented: registers only</li>
</ul>
<h2 id="extended-capabilities.html:flit-performance-measurement-extended-capability-registers"><a href="#extended-capabilities.html:flit-performance-measurement-extended-capability-registers">Flit Performance Measurement Extended Capability registers</a></h2>
<ul>
<li>name: <code>fpm_capability</code></li>
<li>implemented: registers only</li>
</ul>
<p>Uses the following parameters:</p>
<ul>
<li><code>n_lpms</code>: Number of LTSSM Performance Measurement Status Registers, no default</li>
</ul>
<h2 id="extended-capabilities.html:flit-error-injection-extended-capability-registers"><a href="#extended-capabilities.html:flit-error-injection-extended-capability-registers">Flit Error Injection Extended Capability registers</a></h2>
<ul>
<li>name: <code>fei_capability</code></li>
<li>implemented: registers only</li>
</ul>
<h2 id="extended-capabilities.html:shadow-functions-extended-capability-registers"><a href="#extended-capabilities.html:shadow-functions-extended-capability-registers">Shadow Functions Extended Capability registers</a></h2>
<ul>
<li>name: <code>sf_capability</code></li>
<li>implemented: registers only</li>
</ul>
<p>Uses the following parameters:</p>
<ul>
<li><code>n_sfi</code>: Number of Shadow Functions Instance Registers, no default</li>
</ul>
<h2 id="extended-capabilities.html:data-object-exchange-extended-capability-registers"><a href="#extended-capabilities.html:data-object-exchange-extended-capability-registers">Data Object Exchange Extended Capability registers</a></h2>
<ul>
<li>name: <code>doe_capability</code></li>
<li>implemented: functional</li>
</ul>
<p>Uses the following parameters:</p>
<ul>
<li><code>mailbox_len</code>: Length of request and response mailbox</li>
<li><code>interrupt_support</code>: Use interrupts for DOE related events</li>
</ul>
<h3 id="extended-capabilities.html:methods-3"><a href="#extended-capabilities.html:methods-3">Methods</a></h3>
<ul>
<li>
<p><code>method response_ready(uint18 res_len)</code></p>
<p>This method should be called when the incoming DOE request has been
finnished processing. This means that if the request requires a response,
that should have been written to the provided response buffer. In the case
where no response is needed, or silently discarding the request is
desried, this method should still be called but with \p res_len set to 0.</p>
<p>@note After this method has been called, neither the request or the
response buffer should be accessed.</p>
<p>@note only one of <code>response_error()</code> and <code>response_ready()</code> should be
called during the processing of a DOE request.</p>
<p><code>@param[in]  res_len The length of the response</code><br></p>
</li>
<li>
<p><code>method response_error()</code></p>
<p>This method should be called when an internal error has been encountered
during processing of the DOE request.</p>
<p>@note After this method has been called, neither the request or the
response buffer should be accessed.</p>
<p>@note only one of <code>response_error()</code> and <code>response_ready()</code> should be
called during the processing of a DOE request.</p>
</li>
<li>
<p><code>shared method doe_abort()</code>
This method can optionally be overridden to handle scenarios where doe
requests are aborted.</p>
</li>
<li>
<p><code>shared method doe_get_dimn() -&gt; (uint11)</code>
This method can optionally be overridden to control the value of the
"DOE Interrupt Message Number" (dimn) bits. This provides the flexability
to check the "Multiple Message Enable" bits in MSI for example, or other
things might affect what the value of the dimn bits.</p>
</li>
</ul>
<h3 id="extended-capabilities.html:doe-templates"><a href="#extended-capabilities.html:doe-templates">DOE Templates</a></h3>
<ul>
<li><code>template doe_protocol</code></li>
</ul>
<p>The doe_protocol template should be used to define user-defined DOE
protocols. These should be added to a doe_capability instance accordingly.
The way this is done is by adding them to the protocols group in the
doe_capability. Example:</p>
<pre><code>template doe_custom_protocol is doe_protocol {
    param vendor_id = 0x1234;
    param data_object_type = 0;

    shared method handle_request(const uint32 *req, uint18 req_len) {
        return 0;
    }
}

bank pcie_config {
    ...
    is defining_doe_capability;
    group doe {
        group protocols {
            group custom_protocol is doe_custom_protocol;
        }
    }
    ...
}
</code></pre>
<h4 id="extended-capabilities.html:methods-4"><a href="#extended-capabilities.html:methods-4">Methods</a></h4>
<ul>
<li><code>shared method handle_request(const uint32 *req, uint18 req_len_dw);</code></li>
</ul>
<p>The implementation of this abstract method should handle a DOE request for
the implemented protocol. This method must at some point (or schedule an
event that at some point) call the method <code>response_ready(res, res_len)</code> (
or <code>response_error()</code> which is defined in the instantiating template
doe_capability. This should be done when the response has been written to
the <code>mailbox</code> fifo. The call should contain the length of the response.</p>
<p><code>@param[in]  res     The request buffer</code><br>
<code>@param[in]  req_len The length of the request</code><br></p>
<h2 id="extended-capabilities.html:integrity-and-data-encryption-extended-capability-registers"><a href="#extended-capabilities.html:integrity-and-data-encryption-extended-capability-registers">Integrity and Data Encryption Extended Capability registers</a></h2>
<ul>
<li>name: <code>ide_capability</code></li>
<li>implemented: registers only</li>
</ul>
<h2 id="extended-capabilities.html:null-extended-capability-registers"><a href="#extended-capabilities.html:null-extended-capability-registers">Null Extended Capability registers</a></h2>
<ul>
<li>name: <code>null_capability_ext</code></li>
<li>implemented: registers only</li>
</ul>
<h2 id="extended-capabilities.html:virtual-function-type-0-bank"><a href="#extended-capabilities.html:virtual-function-type-0-bank">Virtual Function Type 0 Bank</a></h2>
<ul>
<li>name: <code>vf_type_0_bank</code></li>
<li>implemented: functional</li>
</ul>
<p>Can be used to implement Virtual Functions, used by SR-IOV capability.
Inherits the <code>config_bank</code> template. Note that this template must use the
<code>vf_base_address</code> template to implement its Base Address Registers.</p>
<h2 id="extended-capabilities.html:virtual-function-base-address"><a href="#extended-capabilities.html:virtual-function-base-address">Virtual Function Base Address</a></h2>
<ul>
<li>name: <code>vf_base_address</code></li>
<li>implemented: functional</li>
</ul>
<p>Can be used to implement Base Address Registers in the SR-IOV capability
header. Inherits the template <code>memory_base_address</code>. Expects the parameter
<code>map_obj</code> to be an array of mappable objects, one for each Virtual Function.</p>
</div></section><section class="page" id="migration.html"><h1 id="migration.html:migrating-devices-written-with-the-legacy-pci-library"><a href="#migration.html:migrating-devices-written-with-the-legacy-pci-library">Migrating Devices Written With the Legacy PCI Library</a></h1>
<p>This section of the documentation focuses on providing a guide for how to
migrate PCIe devices written with the legacy PCI library (devices that import
<code>pci/common.dml</code> for endpoint implementations or <code>pci/pcie-to-pcie.dml</code> for port
implementations). Additionally a short overview of some high-level differences
between the two libraries is provided. For a proper understanding of this
library, it is important to read the other sections of the <a href="#index.html">PCIE Modelling
Library Documentation</a>.</p>
<h2 id="migration.html:high-level-difference"><a href="#migration.html:high-level-difference">High-level Difference</a></h2>
<p>The new PCIe library utilizes modern Simics features, such as <code>transaction_t</code>,
<code>atom_t</code>, <code>map_target_t</code> and <code>transaction_translator</code> in its implementation. The
transaction_t data type has a number of advantages compared to the
generic_memory_operation data type that the prior library was based on. It
provides better traceability, easier debugging, asynchronous operations and the
ability to easily add inspectable extensions. Improved performance for an device
doing DMA is also a benefit. In addition, <code>atom_t</code> maps well to different TLP
headers or fields.</p>
<p>Furthermore, the new library is implemented
from the ground up using modern DML 1.4. While there is a 1.4 version of the old
library, it was initially implemented using 1.2 and the 1.4 is a compatibility
port. With modern DML, more PCIe specific functionality can be handled by the
library without the user of the library having to do it. An example of this is
having to reference all the functions banks for multi-function endpoint in a
param. Similarly with BAR registers of a function having to be referenced in
param. It also simplifies for the user to override aspects of the library
without changes necessarily needed in the library itself or having to fork the
library.</p>
<p>The library also provides support for partial migration of parts of a PCIe
topology implemented using the legacy PCI library.
<code>pcie-downstream-port-legacy</code>, which can be utilized in switch and root ports
implemented with the new PCIe library, allows for connecting devices that are
implemented using the legacy PCI library. Similarly, the
<code>legacy-upstream-pcie-adapter</code> allows for connecting devices implemented with
the new PCIe library, to a port implemented using the legacy PCI library.</p>
<h3 id="migration.html:pci-bus-and-pcie-downstream-port"><a href="#migration.html:pci-bus-and-pcie-downstream-port"><code>pci-bus</code> and <code>pcie-downstream-port</code></a></h3>
<p>The legacy PCI library, which implements a PCI(e) hierarchy using a <code>pci-bus</code> or
<code>pcie-bus</code>. These are devices that implement the <code>pci_bus</code> Simics interface and
represent a PCI(e) bus. An endpoint or root/switch port would then reside on
such a bus by being set in the bus' <code>pci_devices</code> attribute. Say you have a
switch, it has an internal bus stemming from the upstream port where only the
upstream downstream ports may reside. Then each downstream port creates a new
bus underneath it where endpoints or upstream ports would reside. Each bus in
this case would be a <code>pci-bus</code> or <code>pcie-bus</code> object when using the legacy PCI
library. You could say that the legacy PCI(e) library was bus oriented i.e. the
main abstraction was the <code>pci-bus</code> or <code>pcie-bus</code> and that stems from that it was
originally developed for PCI which is bus oriented and PCIe support was added on
top of it. The new library drops the bus centric legacy and is modelled around
ports. This maps more easily to the current PCIe specification which to a large
extent is focused on point to point links with ports at both ends (with the
obvious exception of PCIE switches). Hence, with the new library the main
abstractions are instead <code>pcie-downstream-port</code> or
<code>pcie-downstream-port-legacy</code>. Each root/switch port implemented with the new
library (a device or subdevice that instantiates one of the template
<code>pcie_&lt;root/upstream/downstream&gt;_port</code>) will also create a subdevice object of
the class <code>pcie-downstream-port</code> (can be overridden to the legacy compatible
variant or a custom variant). Devices would then reside on the <code>devices</code>
attribute of the <code>pcie-downstream-port</code> object or (<code>pci_devices</code> attribute in
the case of connecting a legacy device to <code>pcie-downstream-port-legacy</code>).</p>
<p><code>pcie-downstream-port</code>:s, unlike <code>pci-bus</code>, does not require creating
memory-space objects for each of <code>cfg</code>, <code>mem</code> and <code>io</code> space, as it is handles
this internally. This simplifies component code from</p>
<pre><code class="language-python">bus = self.add_pre_obj('pci_bus', pcie-bus)
bus.memory_space = self.add_pre_obj('pci_mem', 'memory-space)
bus.conf_space = self.add_pre_obj('pci_conf', 'memory-space')
bus.io_space = self.add_pre_obj('pci_io', 'memory-space')
bus.pci_devices = []
</code></pre>
<p>to</p>
<pre><code class="language-python">dp = self.add_pre_obj(pcie_dp', pcie-downstream-port)
dp.devices = []
</code></pre>
<p>Additionally, when using <code>pci-bus</code>, even after placing a PCIe port device in the
<code>pci_devices</code> attribute, one also has to set the <code>secondary_bus</code> of the port
device to the bus as well. This is not needed with <code>pcie-downstream-port</code> as the
port implemented with the new library only has to be put in the <code>devices</code> or
<code>pci_device</code> attribute of the <code>pcie-downstream-port(-legacy)</code>.</p>
<p>Refer to the <a href="#high-level-design.html">High level design</a> section of the
documentation to get a more elaborate high-level overview of the new PCIe
library.</p>
<h3 id="migration.html:the-old-library-is-considered-legacy"><a href="#migration.html:the-old-library-is-considered-legacy">The Old Library is Considered Legacy</a></h3>
<p>The new PCIe library supports many more features from more recent versions of
the PCIe specification. No new features are being implemented for the old
library as it is considered legacy.</p>
<h2 id="migration.html:steps-for-migrating-devices"><a href="#migration.html:steps-for-migrating-devices">Steps for Migrating Devices</a></h2>
<p>This section describes common steps for migrating different PCIe devices
implemented with the legacy PCI library. Keep in mind that the device that is
being migrated might be doing some custom utilization of the legacy library, and
migrating such things is most likely not covered by this section. However,
reading these steps, along with the rest of the documentation for this library,
might provide clues on how to go about migrating that custom logic.</p>
<h3 id="migration.html:single-function-endpoints"><a href="#migration.html:single-function-endpoints">Single Function Endpoints</a></h3>
<ol>
<li>If the device to be migrated is not written in DML 1.4 (but rather 1.2),
first port it to 1.4. Instruction for this can be found in <a href="../dml-1.4-reference-manual/port-dml.html">Porting DML 1.2
to DML 1.4</a>.</li>
<li>Import the new library instead of the old library: <code>import pci/common.dml</code> -&gt;
<code>import pcie/common.dml</code></li>
<li>If the device instantiates the <code>pcie_device</code>, instead instantiate
<code>pcie_endpoint</code>. Also remove the <code>pci_hotplug</code> param if defined.</li>
<li>Set the <code>pcie_version</code> param to a suitable value.</li>
<li>Start by migrating the pci config bank to be implemented using the new
library.
<ol>
<li>Rename the <code>pci_config</code> bank to `pcie_config``.</li>
<li>Remove the <code>base_address_register</code> param in the <code>pcie_config</code> bank</li>
<li>Migrate the capabilities in the PCI and PCIe configuration space to
utilize the new capability templates (link to doc where these are
documented).</li>
<li>Ensure that the capabilities_ptr points to the first capability in the
non-extended PCI configuration space.</li>
<li>The existing bar registers should already be instantiating
<code>memory_base_address_64</code> or <code>memory_base_address_32</code>. Remove the
<code>map_func</code> params from these registers and add a new param <code>map_obj</code>.
This param should be an object that should be mapped by this bar
register. The object will start at offset 0 in the mapped area by the BAR
register. This object could for instance be a bank (example where the
device has a bank defined in dml with the name "my_bank"): <code>param map_obj = my_bank.obj</code>.</li>
</ol>
</li>
<li>Remove the <code>function</code> <code>param</code> and the <code>function_mapped_bank</code> template
instantiations in banks that were mapped by BAR registers.</li>
<li>If the device uses legacy PCI interrupts, change the handling of the
interrupt_pin values from calling
<code>pci_raise_interrupt(...)</code>/<code>pci_lower_interrupt(...)</code> to either
<code>pcie_config.raise_legacy_interrupt()</code>/<code>pcie_config.lower_legacy_interrupt()</code>
<ol>
<li>
<p>Note that if the device instead uses
<code>pci_raise_interrupt_pin()</code>/<code>pci_lower_interrupt_pin()</code> and uses INTx
emulation in a way that is not allowed by the PCIe spec (for example
having a single function being able to assert multiple virtual pins). One
has to utilize the <code>pcie_config.set_legacy_interrupt()</code> method along with
checking and setting the applicable INTx registers in the config bank:</p>
<pre><code class="language-dml">dml 1.4;
device legacy_irq_dev;
import "pcie/common.dml";
is pcie_endpoint;

template custom_legacy_irq {
    method assert_intx(pci_interrupt_pin_t pin) {
        this.status.ins.set(1);
        if (this.command.id.val == 0)
            this.set_legacy_interrupt(pin, 1);
    }

    attribute raise_legacy_irq is (pseudo_attr, uint64_attr) {
        method set(attr_value_t val) throws {
            local pci_interrupt_pin_t pin = SIM_attr_integer(val);
            if ((pin &gt;= PCI_INTERRUPT_INTA) &amp;&amp; (pin &lt;= PCI_INTERRUPT_INTD))
                pcie_config.assert_intx(pin);
        }
    }
}

bank pcie_config is custom_legacy_irq {
    // ...
}
</code></pre>
<p>Where pin would be the +1 value of that would have been passed to
<code>pci_raise_interrupt_pin()</code>.</p>
</li>
<li>
<p>Calls to <code>pci_data_from_memory(...)</code>/<code>pci_data_to_memory(...)</code> should be
replaced with calls to
<code>pcie_config.memory.read_bytes()</code>/<code>pcie_config.memory.write_bytes()</code></p>
</li>
</ol>
</li>
<li>If the device uses MSI and/or MSI-X.
<ol>
<li>For MSI, assuming the MSI capability instantiation in the config bank has
been migrated to the capability templates from the new library, MSI
interrupts can be handled by calling
<code>pcie_config.msi.raise()</code>/<code>pcie_config.msi.lower()</code>.</li>
<li>For MSI-X, when the MSI-X capability instantiation in the config bank has
been migrated to the capability templates from the new library, the
<code>msix_data_bank</code> param in the MSI-X capability must be set. This should be a
bank that has instantiated the <code>msix_table</code> template. This bank in turn
should set a param <code>msix_bank</code> to a bank that is associated with this MSIX
table (in a single function endpoint that would be pcie_config). Then
instead of calling
<code>pci_config.pci_raise_msix_interrupt()</code>/<code>pci_config.pci_lower_msix_interrupt()</code>,
one would call <code>pcie_config.msix.raise()</code>/<code>pcie_config.msix.lower()</code>.</li>
</ol>
</li>
</ol>
<h3 id="migration.html:multi-function-endpoints"><a href="#migration.html:multi-function-endpoints">Multi-function Endpoints</a></h3>
<p>Similar process to the single function endpoint migration process. Steps that
differ will be mentioned below.</p>
<ol>
<li>If the device instantiates the <code>pci_mf_device</code>, instead import
<code>pcie_multifunction_endpoint</code>. Also remove the <code>param pcie_device=true</code> from
the device (and <code>pci_hotplug</code> if defined).</li>
<li>Remove the <code>mf_banks</code> param.</li>
<li>In each physical function bank, replace the <code>mf_fun</code> param with <code>function</code>
(with the same value).</li>
<li>In each physical function bank, replace the instantiation of the
<code>pci_config_type_0_mf</code> instantiation with <code>type_0_bank</code> template.</li>
<li>Remove any instantiations of <code>providing_legacy_interrupts</code> and
<code>providing_dma_methods</code>. Legacy interrupts and DMA can be achieved similarly
to the single endpoints explained previously (call the interrupt or memory
methods defined in the config bank).</li>
<li>In each physical function bank, if it has the ARI capability
<ol>
<li>Remove the use of the ARI capability template from the legacy PCIe
library (<code>defining_pcie_ari_capability_v3</code>) and instead use
<code>defining_ari_capability</code>.</li>
<li>The nfn field should now instead be set within the <code>capability</code> register
in the <code>ari</code> group of the function bank.</li>
</ol>
</li>
</ol>
<h3 id="migration.html:functions-implementing-sr-iov"><a href="#migration.html:functions-implementing-sr-iov">Functions Implementing SR-IOV</a></h3>
<p>Similar process to the single/multi-function endpoint migration. Additional
steps described below.</p>
<ol>
<li>Locate all physical functions (the <code>pci_config</code> or banks that instantiate
<code>pci_config_type_0_mf</code>) that are associated with virtual functions.</li>
<li>Assuming the instantiation of the SR-IOV capability template from the old
library has been replaced with the template from the new one.
<ol>
<li>Remove the <code>sriov_vf_bars</code> param and the sriov_total_vfs register.</li>
<li>Move the SR-IOV BAR registers to group <code>sriov</code> (created by the
instantiation of <code>defining_sriov_capability</code>). Have these registers
still instantiating the <code>vf_bar_64</code> or the <code>vf_bar_32</code> template (there's
a new implementation for these templates in the new library).</li>
<li>The register containing the VF device id should be renamed
sriov_vf_device_id -&gt; vf_device_id and be moved to the <code>sriov</code> group.
It's value should be set with param init_val.</li>
<li>Remove the sriov_first_vf_offset and replace it by implementing the
<code>get_offset()</code> method in the <code>sriov</code> group.</li>
<li>Remove the sriov_vf_stride and replace it by implementing the
<code>get_stride()</code> method in the <code>sriov</code> group.</li>
</ol>
</li>
<li>Set the param <code>sriov_virtual_functions</code> in each physical function that
instantiates the <code>defining_sriov_capability</code> template. This param should point
to an array of banks that instantiate the <code>vf_type_0_bank</code> template. In each
SR-IOV BAR register, set the param map_obj to an array of banks that is equal to
the number of virtual functions.</li>
</ol>
<h3 id="migration.html:root-complex-and-switches"><a href="#migration.html:root-complex-and-switches">Root Complex and Switches</a></h3>
<p>PCIe port devices are used to construct Root Complexes (root ports) and Switches
(upstream and downstream ports). With the legacy PCI library, all the
connections for a PCIe port are handled through <code>pcie-bus</code>. The port would
reside on a bus by being placed in the <code>pci_devices</code> attribute of a <code>pcie-bus</code>,
and the bus underneath the port, the secondary bus, would be a (different)
<code>pcie_bus</code> that is set in the <code>secondary_bus</code> attribute of the port. These
connection schemes are typically handled in a component that creates multiple
instances of PCIe port devices and <code>pcie-bus</code>. With the new library, there is
more flexibility in regard to how to construct a Switch or Root Complex. For
instance, it is possible to construct the them as one Simics device, where all
the ports in the device would be subdevices. One could then place the downstream
port subdevice objects in the <code>devices</code> attribute of the upstream port subdevice
during <code>post_init</code>. However, it is still possible to construct them as a
component similarly to how it is done with the legacy library. The difference
being that one only needs to create object instances of the applicable ports and
connect them to each other using the <code>devices</code> attribute of the
<code>pcie-downstream-port</code> subdevice in each port, with no need for <code>pcie-bus</code> like
objects.</p>
<h4 id="migration.html:host-bridges"><a href="#migration.html:host-bridges">Host Bridges</a></h4>
<p>While PCIe ports are represented as PCI-PCI bridges in Switches and Root
Complexes and are PCIe function in their own right with a dedicated device/port
type in the PCI Express Capability Structure, Host Bridges in a Root Complex are
more loosely defined. A Host Bridge is defined is "Part of a Root Complex that
connects a host CPU or CPUs to a Hierarchy". How it is implemented is not
defined, meaning that different devices have likely chosen different ways of
implementing it. Sometimes the Host Bridge is represented as a function in the
Root Complex, other times that is not the case. This also means that the
implementations of Root Complex device models will not look the same in regard
to how the Host Bridge is handled.</p>
<p>An example would be the Host Bridge has been implemented as a function by
instantiating the <code>pcie_device</code> template from the legacy library and
implementing the legacy <code>pci_upstream</code> interface to handle upstream memory
transactions. Then it routes the transaction to some applicable device or memory
space. Migrating such a Host Bridge to the new library would entail first
treating it as a single function endpoint. Then remove the <code>pci_upstream</code>
interface implementation and instead implement the <code>translator</code> interface or
<code>transaction_translator</code> interface. Here, one has to keep in mind that the
legacy <code>pci_upstream</code> receives an old transaction type <code>generic_transaction_t</code>,
while the <code>transaction_translator</code> receives transaction of type <code>transaction_t</code>.
How these transactions differ from the older transaction type is out of the
scope of this documentation. An overview of transactions can be found in the
<a href="../model-builder-user-guide/transactions.html">Transactions</a> section of the
Model Builder User Guide.</p>
<h4 id="migration.html:upstream-downstream-root-ports"><a href="#migration.html:upstream-downstream-root-ports">Upstream/Downstream/Root Ports</a></h4>
<p>Similar process to the single function endpoint migration process. Steps that
differ will be mentioned below.</p>
<ol>
<li>If the device imports <code>pci\pcie-to-pcie</code> or <code>pci/bridge.dml</code>, remove these
imports (import <code>pcie/common.dml</code> instead).</li>
<li>Remove the parameters <code>forward_io</code>, <code>forward_io32</code>, <code>forward_mem</code>,
<code>forward_prefetchable</code>, <code>forward_prefetchable64</code> and <code>pci_hotplug</code>.</li>
<li>Instantiate one of the <code>pcie_root_port</code>, <code>pcie_downstream_port</code> or
<code>pcie_upstream_port</code>.</li>
<li>Hot-plug support is enabled by setting <code>param has_hotplug_capable_slot = true;</code> in the <code>exp</code> group of the PCI Express Capability structure that
should be present in the <code>pcie_config</code> bank.</li>
</ol>
<h3 id="migration.html:compatibility-with-legacy-devices"><a href="#migration.html:compatibility-with-legacy-devices">Compatibility With Legacy Devices</a></h3>
<p>Devices (both endpoints and switches) implemented with the legacy PCI library
can be connected to root/downstream ports in a PCIe hierarchy implemented with
the new library. For this to work, the root/downstream port must ensure that the
instantiated downstream port object in the root/downstream port must be of the
class <code>pcie-downstream-port-legacy</code>. This can be achieved by setting the
<code>classname</code> param accordingly in the <code>downstream_port</code> <code>connect</code> of the device
that instantiated <code>pcie_&lt;root/upstream/downstream&gt;_port</code>.</p>
</section><section class="page" id="pcie-hybrid-systems.html"><h1 id="pcie-hybrid-systems.html:connecting-external-simulators-emulators-and-hardware"><a href="#pcie-hybrid-systems.html:connecting-external-simulators-emulators-and-hardware">Connecting External Simulators, Emulators and Hardware</a></h1>
<p>Hybrid setups where part of the platform runs outside Simics is a common use case.
One challenge with hybrid platforms is to properly integrate it into Simics.
There needs to be a layer working in both directions to translate transactions,
events, API calls from one system to the other.
This chapter focuses on integrating Emulators, external
Simulators or Hardware into a Simics PCIe Hierarchy. The word Shim is defined in
this chapter as the integration layer between Simics PCIe and an external process.</p>
<h2 id="pcie-hybrid-systems.html:shim-concept"><a href="#pcie-hybrid-systems.html:shim-concept">Shim Concept</a></h2>
<p>The Shim acts upstream as a Simics PCIe device and for downstream
it will follow the IPC protocol shared with the external PCIe system.
The Shim captures all upstream Simics PCIe traffic and events and converts
them to the IPC protocol. The Shim supports asynchronous responses and concurrent
requests made by the external device. For each transaction coming from upstream
the Shim blocks Simics from progressing in time until the external device has responded
to the transaction. This is done to ensure that Simics virtual simulation time
is not affected by the response time of the external process.</p>
<p>For PCIe writes and PCIe messages the Shim will wait for the external device
to have handled the event before completing the transaction to the initiator
which could be a CPU or device.</p>
<p>For PCIe reads the Shim will wait until the external device has responded
with the read payload.</p>
<p>While the Shim waits for a response to a PCIe transaction it sent to the
external PCIe system, it can receive upstream facing PCIe transactions from
the external PCIe system. The Shim will forward those requests upstream
and send responses back to the external PCIe system.
All of this is done in a thread safe manner.</p>
<h2 id="pcie-hybrid-systems.html:integrating-a-non-simics-pcie-endpoint-to-simics"><a href="#pcie-hybrid-systems.html:integrating-a-non-simics-pcie-endpoint-to-simics">Integrating a non-Simics PCIe Endpoint to Simics</a></h2>
<figure id="pcie-hybrid-systems.html:RCiEP">
<img alt="PCIe hybrid with external RCiEP" src="ShimRCiEP.png" width="650px/">
<figcaption>Figure 20. External PCIe RCiEP integrated into Simics</figcaption>
</figure>
<figure id="pcie-hybrid-systems.html:EP_Under_RP">
<img alt="PCIe hybrid with external Endpoint connected to a Simics Root Port" src="ShimEP_Under_a_RP.png" width="650px/">
<figcaption>Figure 21. External PCIe Endpoint connected to a Simics PCIe Root Port</figcaption>
</figure>
<p>The Shim supports both regular PCIe EPs and RCiEPs.</p>
<p>The <code>Shim Frontend</code> is a DML device appearing as a regular Simics PCIe device.
It has two purposes:</p>
<ul>
<li>Forward all downstream PCIe traffic to the <code>Shim C++</code> device on a <strong>single</strong>
interface.</li>
<li>Map in the programmed BAR resources of the external device into the Root Complex
in Simics. It does this by snooping on write accesses to the BAR registers of the
Endpoint.</li>
</ul>
<p>The <code>Shim C++</code> device is responsible for:</p>
<ul>
<li>Converting the Simics PCIe data into the IPC protocol format and vice versa.</li>
<li>Blocking Simics until the external device has responded.</li>
<li>Forwarding PCIe traffic from the external device into the Simics PCIe domain
and responding back to the external device.</li>
<li>Concurrency between upstream and downstream traffic.</li>
</ul>
<p>The <code>external-connection</code> module is a separate generic module in Simics responsible for IPC.
It currently has classes to do communication over Unix sockets, TCP or Windows named pipes. The <code>Shim</code>
will interact with it over the <code>external_connection_ctl</code> and <code>external_connection_events</code> interfaces.
The Shim is not aware whether the communication is over TCP, Unix Socket or named pipes.
All of that is hidden inside the <code>external-connection</code> module.
The <code>external-connection</code> classes are <code>unix-socket-server</code>, <code>tcp-server</code> and <code>named-pipe-server</code>.</p>
<h2 id="pcie-hybrid-systems.html:integrating-a-non-simics-pcie-switch-to-simics"><a href="#pcie-hybrid-systems.html:integrating-a-non-simics-pcie-switch-to-simics">Integrating a non-Simics PCIe Switch to Simics</a></h2>
<figure id="pcie-hybrid-systems.html:ShimSwitch">
<img alt="PCIe hybrid with external switch" src="ShimSwitch.png" width="650px">
<figcaption>Figure 22. External PCIe switch with endpoints connected to Simics PCIe Root Port</figcaption>
</figure>
<p>The setup to integrate an external PCIe hierarchy to Simics is very similar
to an Endpoint. The <code>Shim Frontend</code>, written in DML, is the only difference
from the Endpoint setup on the Simics side.</p>
<p>The <code>Shim Frontend</code> when connecting an external PCIe Switch represents a shell
of the USP of the switch. It snoops on write accesses to the BAR registers of the USP
similar to the <code>Shim Frontend</code> of the Endpoint.
But it also snoops on the <em>(Prefetchable) Memory Base</em>, <em>Secondary Bus Number</em> and
<em>Subordinate Bus Number</em> registers of the USP of the Switch in order to map
in the downstream resources of the USP device into Simics.</p>
<h2 id="pcie-hybrid-systems.html:shim-source-code"><a href="#pcie-hybrid-systems.html:shim-source-code">Shim Source Code</a></h2>
<p>The source code for the Shim is distributed in module <code>sample-pcie-shim</code>.
It can be used as a starting point when integrating external PCIe subsystems.</p>
<h3 id="pcie-hybrid-systems.html:shim-frontend-source-code"><a href="#pcie-hybrid-systems.html:shim-frontend-source-code">Shim Frontend Source Code</a></h3>
<p>There are two variants of the Shim Frontend. One for PCIe ports and one
for endpoints. The file <code>pcie-shim-frontend-common.dml</code> contains the base
templates for the port and endpoints and can be reused as is.
Files <code>pcie-endpoint-shim-frontend.dml</code> and <code>pcie-port-shim-frontend.dml</code>
defines the sample device classes for the PCIe port and endpoint frontends.
They contain <em>BAR</em> registers that mirror the real hardware. These two files
would need to be redefined for each project in order to match the
<em>BARs</em> for the external PCIe device.
The frontend does <strong>not</strong> need to mirror the capability set
of the external device since it delegates all transactions to it.</p>
<h3 id="pcie-hybrid-systems.html:pcie-shim-c-source-code"><a href="#pcie-hybrid-systems.html:pcie-shim-c-source-code">PCIe Shim C++ Source Code</a></h3>
<p>The Shim base class, <strong>ShimPcie</strong>, is defined in the files <code>pcie-shim.h</code> and <code>pcie-shim.cc</code>.
The class handles the interface calls to and from the Shim PCIe DML Frontend.
The exchanges with the external process must be implemented by the user
inheriting the <strong>ShimPcie</strong> class. A set of virtual methods are declared,
these are the entry points for the external exchange implementation.
The <strong>ShimPcie</strong> class can be reused as is.</p>
<p>The Simics side of the Shim consists of two parts:
First, the implementation of the Simics interfaces to receive upstream transactions
and Hot Reset. Method <code>ShimPcie::issue</code> receives all transactions and translates
the PCIe atoms into arguments forwarded to the different function handlers
(Config, Memory, Message, IO) named <code>ShimPcie::forward...</code>.
The <code>ShimPcie::forward_...</code> functions have to be implemented by the user integrating
the external simulator/emulator/hardware.
Function <code>ShimPcie::hot_reset</code> must be implemented by the user.
Secondly, an implementation of functions <code>ShimPcie::upstream_message</code>,
<code>ShimPcie::upstream_mem_read</code> and <code>ShimPcie::upstream_mem_write</code> are part of
the <code>ShimPcie</code>. These functions create a corresponding Simics PCIe transaction
and forward it upstream.</p>
<h4 id="pcie-hybrid-systems.html:sample-pcie-traffic-over-ipc"><a href="#pcie-hybrid-systems.html:sample-pcie-traffic-over-ipc">Sample PCIe Traffic over IPC</a></h4>
<p>The <code>sample-pcie-shim</code> module also contains sample code to showcase an
IPC implementation between Simics and an external PCIe subsystem. It gives
the user a good starting point for integrating the external PCIe subsystem with Simics.</p>
<p>File <code>pcie-external-connection.cc</code> defines the class <code>PcieExternalConnection</code>.
It inherits the base class <code>ShimPcie</code> and implements the IPC functionality.
The <code>PcieExternalConnection</code> class implements interface <code>external_connection_event</code>
in order to interact with the Simics <code>external-connection</code> module classes.
Supported IPC mechanisms in the <code>external-connection</code> module are
<em>Unix Sockets</em>, <em>TCP</em> or Windows <em>Named Pipes</em>.</p>
<p>File <code>ExternalPcieFormat.h</code> defines the packet format used for the
sample PCIe IPC traffic.</p>
<p>Methods:</p>
<ul>
<li><code>PcieExternalConnection::write_async</code> sends the packet to the
external process.</li>
<li><code>PcieExternalConnection::wait_for_response</code> After a request packet is sent to the external
process Simics will wait in this method for a response. This method blocks Simics from
progressing in virtual simulation time. Concurrent packet requests coming from the
external process is handled by this method as well. It called in <em>Simics cell context</em>.</li>
<li><code>PcieExternalConnection::on_input</code> is called whenever there is packet data to be read.
This method runs in <em>Simics Threaded context</em>. Only a small subset of the Simics API functions
are allowed to be executed in this context. The method reads the available data and
pushes it into a ring buffer. It then either posts a Simics event to schedule processing
of the packet in Simics <em>Cell Context</em> or it wakes up the blocking thread that executes
the <code>PcieExternalConnection::wait_for_response</code> method.</li>
<li><code>PcieExternalConnection::read_input</code> reads <em>N</em> number of bytes of packet data and pushes
it into the ring buffer.</li>
</ul>
<p>The C++ code is based on the <em>Simics C++ Device API v2</em> library.
Please check out the <a href="../cc-device-api/index.html"><em>C++ Device API v2</em></a> manual.</p>
<div class="note">
The sample Shim supports a limited set of PCIe atoms.
If the external PCIe subsystem requires ATS, PRS, IDE or PCIe segment numbering
one will have to extend the sample PCIe shim.
</div>
<h3 id="pcie-hybrid-systems.html:connecting-to-a-pcie-slot"><a href="#pcie-hybrid-systems.html:connecting-to-a-pcie-slot">Connecting to a PCIe Slot</a></h3>
<p>The <code>sample-pcie-shim</code> module provides a sample component, <code>sample_pcie_shim_comp.py</code>
that adds the Shim Frontend and the Sample Shim in a component and registers
<code>PciBusUpConnector</code> to easily create and connect the objects into
the Simics PCIe hierarchy. It registers two components: <code>sample-pcie-switch-shim-comp</code>
to connect external switches and <code>sample-pcie-endpoint-shim-comp</code> to connect external
endpoints.</p>
<p>It can be connected to the Simics PCIe hierarchy with the below commands:</p>
<pre><code class="language-simics">simics&gt; <strong>load-module sample-pcie-shim</strong>
simics&gt; <strong>new-sample-pcie-switch-shim-comp name = shim socket_type = tcp</strong>
simics&gt; <strong>shim.connect-to dst = root_port</strong>
Connecting shim.upstream_target to root_port.slot[0]
</code></pre>
</section>