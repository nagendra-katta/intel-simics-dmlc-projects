<!doctype html>
<meta charset=utf8>
<link rel=stylesheet href="../simics.css">
<title>SystemC* Library</title>

<section class="page" id="index.html"><h1 id="index.html:systemc-library"><a href="#index.html:systemc-library">SystemC* Library</a></h1>
</section><section class="page" id="introduction.html"><h1 id="introduction.html:introduction"><a href="#introduction.html:introduction">1 Introduction</a></h1>
<h2 id="introduction.html:systemc-library"><a href="#introduction.html:systemc-library">1.1 SystemC* Library</a></h2>
<p>Simics SystemC* Library provides support for creating and running SystemC models in Simics. SystemC, as standardized by IEEE-1666, is a C++ class library and a methodology that can be used to create cycle-accurate or transaction-level models of hardware. When choosing to develop models in SystemC for use in Simics it is important to be aware that there exists some fundamental differences in vocabulary, methodology, and features compared to writing models directly to the Simics API. While SystemC Library attempts to minimize those differences it cannot do so completely.</p>
<p>SystemC Library provides three basic capabilities. It makes it possible to run SystemC models in Simics with only a few minor changes compared to running a stand-alone SystemC simulation. Note that none of these changes are to the SystemC model itself. SystemC Library also provides awareness and inspection capabilities of SystemC models running in Simics by connecting SystemC concepts, such as the object hierarchy and the sc_report mechanism to the corresponding Simics concepts. Support for tracing and breaking on SystemC ports and exports as well as signals is provided. Finally, SystemC Library provides a mechanism to connect SystemC models with traditional Simics models through the use of interface gaskets.</p>
<h2 id="introduction.html:systemc"><a href="#introduction.html:systemc">1.2 SystemC</a></h2>
<p>SystemC was originally designed to supplement or replace RTL and HDL modeling with languages such as Verilog or VHDL. One of the goals with SystemC 2.0 was to enable system-level modeling at a higher level of abstraction than RTL. In this tradition the SystemC kernel implements an event based timing model with delta-cycles similar to VHDL where there is an "outer" simulation loop that drives time forward and an "inner" loop that stabilizes all signals during the delta-cycles.</p>
<p>Systems modeled in SystemC are made up of a number of SystemC <em>modules</em> (C++ classes) that are connected at compile-time using ports and signals and implement their functionality in <em>processes</em> (C++ methods) and <em>threads</em> (coroutines). A SystemC module is simply a C++ class derived from <code>sc_module</code> provided by the SystemC kernel. The module includes processes and threads that are simply member functions of the class that may be "registered" as <em>sensitive</em> to a specific port. A port can represent different "activation signals"; such as the rising and falling of a clock's edge or, at a higher level of abstraction, an arbitrary C++ type being passed from one module to another via a signal connected to a port.</p>
<p>To further support system-level modeling the Transaction-level Modeling (TLM) standard was proposed as an addition to SystemC. SystemC TLM 2.0 (hereafter TLM2) extends SystemC with a set of core interfaces, a global quantum for temporal decoupling, initiator and target sockets, a generic payload and base protocol, and some utilities.</p>
<h2 id="introduction.html:about-this-document"><a href="#introduction.html:about-this-document">1.3 About this Document</a></h2>
<p>This document assumes that the reader has a basic knowledge of Simics. It is recommended to be familiar with the contents of the
<a href="../simics-user-guide/index.html">Simics User's Guide</a> and to have performed the introductory steps in
<a href="../getting-started/index.html">Getting Started with Simics</a>. It is useful if the reader is able to find relevant information in the
<a href="../reference-manual-api/index.html">API Reference Manual</a>. At the very least, the reader should be familiar with starting Simics and loading a configuration.</p>
<p>It is also recommended to be familiar with basic Simics Model Builder concepts, such as building a module, creating a module test, as well as familiarity with the C++ API. Please refer to the
<a href="../model-builder-user-guide/index.html">Model Builder User's Guide</a> and the
<a href="../cc-device-api/index.html">C++ Device API Programming Guide</a> for more information. The reader is expected to be familiar with SystemC and Transaction-level Modeling (TLM).</p>
<p>This document describes how to run SystemC models in Simics and how to integrate them with Simics models written for the Simics API. It does not try to cover how to write good SystemC models. For more details about SystemC, refer to the IEEE-1666 standard.</p>
<p>This document serves multiple purposes and has been constructed to try to meet these requirements. It starts out with a brief introduction to SystemC Library and a quick tutorial on how to get started. This is followed up by a chapter on how to connect SystemC models with Simics. That chapter starts off with a hands-on example highlighting all the building blocks including testing and configuration. The chapter follows up with some guidelines before it goes into details on how the gaskets work and how users can write their own. The chapter is rounded off by describing two common gaskets. The next chapter covers all the features. More advanced topics about how SystemC models are executed in the Simics simulator is described next. All known major limitations are listed as a separate chapter. Last chapter is about the compile-time requirements.</p>
<p>The document can be used both as a tutorial and as reference. It has not been written in such a way that it would make sense to read it from cover to cover.</p>
</section><section class="page" id="systemc-library-requirements.html"><h1 id="systemc-library-requirements.html:systemc-library-requirements"><a href="#systemc-library-requirements.html:systemc-library-requirements">2 SystemC Library Requirements</a></h1>
<p>Because C++ does not have a standardized ABI, all SystemC Library modules as well as all SystemC models built from these modules must be compiled with exactly the same compiler, compiler version, and compiler flags. It works perfectly fine to include binary SystemC models as long as they are Accellera compliant and the compiler guidelines just outlined are followed.</p>
<p>As of Simics 6 it is also possible to combine Simics SystemC modules compiled with different toolchains, provided each individual module has been constructed from a set of binaries built using the same toolchain.</p>
<p>The SystemC Library has been moved out of the <em>Simics Base</em> package to a separate package 1013 (<em>SystemC Library</em>). Users of the Simics SystemC Library must install the package 1013.</p>
<p>The SystemC Library supports the Accellera kernels 2.3.3, 2.3.4, and 3.0.0. The supported and known to be working configurations are:</p>
<table><thead><tr><th>SystemC kernel version</th><th>Linux</th><th>Windows</th></tr></thead><tbody>
<tr><td>2.3.3/2.3.4</td><td>GCC 6.4 or 12 with C++14 or C++17</td><td>MSVC 2015/2022</td></tr>
<tr><td>3.0.0</td><td>GCC 12 with C++17</td><td>MSVC 2022</td></tr>
</tbody></table>
<p>These are the only versions tested by Simics regression tests.</p>
<p>Simics does not guarantee that the Simics SystemC Library API will not change between releases. Simics' SystemC support is still being gradually improved and a completely frozen API would limit what improvements can be made. A lot of effort will, however, be made to avoid changing the API. If a change is needed, the end-user effort will be minimized.</p>
</section><section class="page" id="running-a-systemc-model-in-simics.html"><h1 id="running-a-systemc-model-in-simics.html:running-a-systemc-model-in-simics"><a href="#running-a-systemc-model-in-simics.html:running-a-systemc-model-in-simics">3 Running a SystemC Model in Simics</a></h1>
<p>The simplest case of running a SystemC model in Simics is to run it without any connections to models written in other languages, a so called <em>SystemC-only</em> model. When working with the proof of concept implementation of SystemC provided by Accellera it is common to build an executable by providing an implementation of <code>sc_main</code> that assembles the model hierarchy, starts the simulation, and performs any cleanup actions. Because of the dynamic nature of Simics the model will be a Simics module instead of a standalone application. This allows Simics to instantiate one or more copies of the model at run-time using the normal Simics configuration mechanisms. To achieve this the <code>sc_main</code> function is replaced by a Simics configuration object. The purpose of this object is the same as <code>sc_main</code>: create the model hierarchy, provide a way to start the simulation, and perform any cleanup. The difference is that now the object hierarchy is created when the Simics object is instantiated and the cleanup is done when the Simics object is destroyed. Simulation control is also handled by Simics, using standard Simics commands such as <code>continue</code> and <code>stop</code>.</p>
<h2 id="running-a-systemc-model-in-simics.html:standalone-application"><a href="#running-a-systemc-model-in-simics.html:standalone-application">3.1 Standalone application</a></h2>
<p>Here a standalone application refers to an executable that runs in its own process without Simics. Typically, <code>sc_main</code> is implemented as the entry point to the application.</p>
<p>Running a SystemC model in Simics does not affect the model's behavior and this fact can be leveraged when integrating models with Simics. It is recommended to first verify that the functionality is as expected by running the model as a standalone application before integrating with Simics. The verification is typically done using a SystemC test bench, which may be reused later as a Simics model test.</p>
<p>To get started with a SystemC-only model in Simics it is best to begin with a simple example. Create a new SystemC-only model in your project by issuing the command: <code>./bin/project-setup --sc-only-device empty-device-sc-only</code></p>
<p>This command copies a SystemC-only model skeleton from the installation into the module directory of the project with the name <code>empty-device-sc-only</code>.</p>
<p>The <code>empty-device-sc-only</code> module contains a very simple SystemC device, in three source files: <code>sc-device.h</code>, <code>sc-device.cc</code>, and <code>sc-main.cc</code>. Compiled together, these three files contain all the relevant code to run the simulation standalone, i.e., as a separate application outside of Simics. The Makefile for this standalone application is not provided but is easy to write since the only dependency for this module is the SystemC kernel. The entire source code is shown below.</p>
<ul>
<li><code>sc-device.h</code></li>
</ul>
<pre><code>#ifndef EMPTY_DEVICE_SC_ONLY_SC_DEVICE_H
#define EMPTY_DEVICE_SC_ONLY_SC_DEVICE_H

#include &lt;systemc&gt;

SC_MODULE(DeviceModel) {
  public:
    SC_CTOR(DeviceModel) : count_(10) {
        SC_THREAD(run_test);
    }

    void set_count(int count) { count_ = count; }
    int get_count() const { return count_; }

 private:
    void run_test();

    int count_;
};

sc_core::sc_module *setup(int argc, char *argv[]);
void teardown(sc_core::sc_module *top_level);

#endif  // EMPTY_DEVICE_SC_ONLY_SC_DEVICE_H
</code></pre>
<ul>
<li><code>sc-device.cc</code></li>
</ul>
<pre><code>#include "sc-device.h"

namespace {
const char *const TAG = "intel/empty-device-sc-only/info";
}

void DeviceModel::run_test() {
    while (--count_ &gt;= 0) {
        SC_REPORT_INFO(TAG, "Looping...");
        wait(sc_core::sc_time(500, sc_core::SC_NS));
    }
}

sc_core::sc_module *setup(int argc, char *argv[]) {
    DeviceModel *top = new DeviceModel("top");
    if (argc &gt; 1) {
        int count = atoi(argv[1]);
        top-&gt;set_count(count);
    }

    return top;
}

void teardown(sc_core::sc_module *top_level) {
    delete top_level;
}
</code></pre>
<ul>
<li><code>sc-main.cc</code></li>
</ul>
<pre><code>#include "sc-device.h"

int sc_main(int argc, char *argv[]) {
    sc_core::sc_module *top_level = setup(argc, argv);
    // coverity[fun_call_w_exception]
    sc_core::sc_start();
    teardown(top_level);

    return 0;
}
</code></pre>
<p>This device has a counter which counts down every 500 nano seconds. When it counts down, a message as shown below is printed to the standard output.</p>
<pre><code>  Info: intel/empty-device-sc-only/info: Looping...
</code></pre>
<p>By default, the above message is printed 10 times since counter is initialized to 10 in the constructor. This value can be modified by passing an integer argument when the application is executed.</p>
<p>Now that we have verified the functionality of this simple SystemC device, let's move on to next section on how to run it in Simics. The same behavior will be observed when it runs in Simics.</p>
<h2 id="running-a-systemc-model-in-simics.html:running-in-simics"><a href="#running-a-systemc-model-in-simics.html:running-in-simics">3.2 Running in Simics</a></h2>
<p>To create a Simics module instead of a standalone application, the file <code>sc-main.cc</code> is replaced with a similar entry-point that defines a Simics class instead of creating an application.</p>
<pre><code>#include &lt;simics/systemc/sc_factory.h&gt;
#include "sc-device.h"

#define CLASS_NAME "empty_device_sc_only"
#define CLASS_DESC "example SystemC device"
#define CLASS_DOC  "The &lt;class&gt;" CLASS_NAME "&lt;/class&gt;" \
    " class runs a SystemC-only device in Simics."

simics::systemc::RegisterModel model(CLASS_NAME, CLASS_DESC, CLASS_DOC,
                                     setup, teardown);
</code></pre>
<p>The example above may need some explanation. It registers a new configuration class with Simics. The name of the class is <code>empty_device_sc_only</code> and the documentation and short description are provided by the <em>CLASS_DOC</em> and <em>CLASS_DESC</em> constants. The class is registered by creating an instance of the <code>simics::systemc::RegisterModel</code> in the file scope, that is as a global or static variable, or in a unnamed namespace. When the module is loaded into Simics, all objects defined in file scope will be constructed and the <code>model</code> object will take care of registering the <code>empty_device_sc_only</code> class with Simics. Simics will now know how to instantiate this class, which in turn will be responsible for instantiating the rest of the SystemC subsystem, as defined by the provided <code>setup</code> function. When the configuration object is destroyed, the registered <code>teardown</code> function, if any, will be called with the return value of <code>setup</code>. The return value from <code>setup</code> and the argument to <code>teardown</code> can be a pointer to any type, the only restriction is that they have to match. It is also possible to have a <code>void</code> return value from <code>setup</code>, in which case <code>teardown</code> does not take any arguments.</p>
<p>The device can be built by running <code>make empty-device-sc-only</code> in the top-level project directory. Refer to the <em>Model Builder User's Guide</em> for more details.</p>
<div class="note">
<p>No binaries are shipped from the Simics package. Therefore, these binaries must be built before any device modules can be constructed. See <a class="reference" href="#building-required-libraries.html">8</a> for more details.</p>
</div>
<p>To test the device in Simics it is necessary to instantiate it. This is easily done from the Simics CLI, by calling the <code>SIM_create_object</code> function via the Python API:</p>
<pre><code class="language-simics">simics&gt; <strong>@SIM_create_object('empty_device_sc_only', 'dev')</strong>
&lt;the empty_device_sc_only 'dev'&gt;
</code></pre>
<p>To see what objects exist in the simulation, the <code>list-objects</code> command can be used:</p>
<pre><code class="language-simics">simics&gt; <strong>list-objects -show-port-objects substr = dev</strong>
┌──────────────────────────┬────────────────────────────────────────┐
│          Object          │                 Class                  │
├──────────────────────────┼────────────────────────────────────────┤
│dev                       │&lt;empty_device_sc_only&gt;                  │
│dev.cci_global            │&lt;empty_device_sc_only_cci_global&gt;       │
│dev.engine                │&lt;co-execute&gt;                            │
│dev.engine.vtime          │&lt;vtime&gt;                                 │
│dev.engine.vtime.cycles   │&lt;cycle-counter&gt;                         │
│dev.engine.vtime.ps       │&lt;ps-clock&gt;                              │
│dev.sc_event_all_dynamic  │&lt;ScEventObjectAllDynamic&gt;               │
│dev.sc_process_all_dynamic│&lt;sc_method_process_all_dynamic&gt;         │
│dev.top                   │&lt;empty_device_sc_only_sc_module&gt;        │
│dev.top.run_test          │&lt;empty_device_sc_only_sc_thread_process&gt;│
│dev.vtime                 │&lt;vtime&gt;                                 │
│dev.vtime.cycles          │&lt;cycle-counter&gt;                         │
│dev.vtime.ps              │&lt;ps-clock&gt;                              │
└──────────────────────────┴────────────────────────────────────────┘
</code></pre>
<p>In this example <code>dev</code> is the Simics configuration object that wraps the SystemC subsystem, <code>dev.top</code> is the SystemC device returned by <code>setup</code>, and <code>dev.top.run_test</code> is the thread process in dev.top that will call <code>SC_REPORT_INFO</code> and print the "Looping..." output shown in the example output below.</p>
<p>The <code>dev.engine</code>, <code>dev.vtime</code> and their sub-objects are Simics helper objects and can be ignored.</p>
<p>Before running the simulation, turn up the log-level to 2 or higher in order to show reports of INFO type and normal verbosity:</p>
<pre><code class="language-simics">simics&gt; <strong>dev.log-level 2</strong>
simics&gt; <strong>continue</strong>
[dev info] Looping... @ 0 s of intel/empty-device-sc-only/info in sc-device.cc:14
[dev info] Looping... @ 500 ns of intel/empty-device-sc-only/info in sc-device.cc:14
[dev info] Looping... @ 1 us of intel/empty-device-sc-only/info in sc-device.cc:14
[dev info] Looping... @ 1500 ns of intel/empty-device-sc-only/info in sc-device.cc:14
[dev info] Looping... @ 2 us of intel/empty-device-sc-only/info in sc-device.cc:14
[dev info] Looping... @ 2500 ns of intel/empty-device-sc-only/info in sc-device.cc:14
[dev info] Looping... @ 3 us of intel/empty-device-sc-only/info in sc-device.cc:14
[dev info] Looping... @ 3500 ns of intel/empty-device-sc-only/info in sc-device.cc:14
[dev info] Looping... @ 4 us of intel/empty-device-sc-only/info in sc-device.cc:14
[dev info] Looping... @ 4500 ns of intel/empty-device-sc-only/info in sc-device.cc:14
running&gt; <strong>stop</strong>
simics&gt; <strong></strong>
</code></pre>
</section><section class="page" id="connecting-systemc-and-simics-models.html"><h1 id="connecting-systemc-and-simics-models.html:connecting-systemc-and-simics-models"><a href="#connecting-systemc-and-simics-models.html:connecting-systemc-and-simics-models">4 Connecting SystemC and Simics Models</a></h1>
<p>Simics can be used as a framework for testing and developing SystemC models in isolation, or it can be used to integrate SystemC models with other Simics models. The integration spans from just a single model to a full virtual platform. Simics models can be written in any language as long as they use the Simics API and Simics interfaces to communicate. A Simics model consists of a Simics configuration class, instantiated as a Simics object. In Simics SystemC Library this object is called <em>adapter</em>.</p>
<p>SystemC Library makes it possible to run multiple SystemC models in the same Simics configuration at the same time, possibly instantiated at different points in time (i.e. dynamically) and optionally connected directly or indirectly to one another. It is important to understand that each adapter instance will get its own context and that communication via the SystemC scheduler between instances will not be possible; all communication between adapters must go via Simics interfaces.</p>
<p>Also note that time and ordering when communicating between multiple SystemC kernels is not defined by the IEEE SystemC specification. That is, no ordering assumptions can be made when two SystemC models communicate with each other via Simics interfaces.</p>
<p>The project-setup tool can be used to generate a new Simics module with a skeleton of a SystemC device connected to Simics via a SystemC adapter: <code>./bin/project-setup --sc-device name</code>, where <em>name</em> is the name of the new Simics module.</p>
<p>Simics contains well defined and stable interfaces for various hardware specific protocols such as Ethernet, USB, PCIe, etc. There is no SystemC standard that covers such protocols yet. Instead, each set of modules must agree on a custom protocol on top of the TLM2 base protocol and any deviations must be handled by an interconnect module. Simics contains a set of interface converters, called <em>gaskets</em>, for a number of common Simics interfaces like memory mapped I/O (MMIO), signal, PCI Express, Ethernet, I2C, etc. These gaskets convert the Simics interface into (or from) a TLM2 payload extension transmitted using the standard TLM2 interface and protocol. Simics provides utility functions to make it easy to pack or unpack the protocol-specific payload extensions.</p>
<div class="note">
<p>SystemC Library only supports Simics -&gt; SystemC and SystemC -&gt; Simics interface calls via gaskets. Direct invocation of Simics interfaces are not officially supported.</p>
</div>
<p>There is also a non-TLM2 based gasket, converting the Simics <code>signal</code> interface to/from the SystemC <code>sc_signal&lt;bool&gt;</code>.</p>
<div class="note">
<p>Signals work a bit differently when routed through Simics. There is no support for <code>sc_signal&lt;T&gt;</code> of arbitrary type T, as there is no corresponding interface in Simics that supports this. In addition, when connecting SystemC configurations via Simics interfaces it is important to understand that each adapter will have its own separate kernel context, and thus cannot rely on delta cycle communication via the scheduler; which is very common when using SystemC signals. Simics does not maintain a global order of SystemC events. There are two ways to address this problem:</p>
<ul>
<li>Integrate everything that needs to communicate via the SystemC scheduler/delta cycles with the same adapter.</li>
<li>Re-construct the model</li>
</ul>
</div>
<p>The complete list of supported gaskets can be found in the
<a href="../reference-manual-systemc-library-api/jump.html">SystemC Library API Reference Manual</a>. Users can also create their own gaskets to support additional or custom interfaces. See <a class="reference" href="#connecting-systemc-and-simics-models.html:creating-new-gaskets">4.6</a> for more details.</p>
<h2 id="connecting-systemc-and-simics-models.html:dma-example"><a href="#connecting-systemc-and-simics-models.html:dma-example">4.1 DMA example</a></h2>
<p>This section demonstrates how to expose a simple DMA device written in SystemC to Simics and how to test it using Simics Python tests. The DMA device example source code is available in the <em>Simics Base</em> package and can be added to the project by issuing the command: <code>./bin/project-setup --copy-module systemc-dma-device</code> in the Simics project directory. This DMA device has no dependency on Simics and can be built as a standalone application. By default, it is built with Intel SystemC kernel by issuing the following command: <code>make -f modules/systemc-dma-device/Makefile.standalone</code></p>
<div class="note">
<p>No binary is included for Intel SystemC kernel. It needs built in the Simics project first before building the DMA standalone application. See <a class="reference" href="#building-required-libraries.html">8</a> for more details about building Intel SystemC kernel.</p>
</div>
<p>User can also build the standalone application using their own SystemC kernel by configuring the <code>SYSTEMC_CORE_CFLAGS</code> and <code>SYSTEMC_CORE_LDFLAGS</code> flags.</p>
<p>The device's code will not be described in detail in this guide, but basically, the device implements a simple DMA device with source and destination address registers as well as a control register to start a DMA transaction and control some features such as interrupt on completion. The DMA device can work in "polling" mode, where the software checks the status bit in the control register for DMA completion, or it can work in interrupt mode where an interrupt is issued when the transfer is completed. In addition the DMA device supports reset. The interrupt and reset are modeled as SystemC signals and inbound and outbound memory accesses are modeled as SystemC TLM2 transactions. The focus of this section is on showing how these signals and transactions are translated to Simics interface calls.</p>
<p>In order to connect the SystemC DMA device to Simics an <code>Adapter</code> class is defined as shown below:</p>
<pre><code>namespace scl = simics::systemc;

class Adapter : public scl::Adapter,
                public scl::simics2tlm::TransactionGasketAdapter,
                public scl::simics2tlm::DirectMemoryUpdateGasketAdapter {
  public:
    explicit Adapter(simics::ConfObjectRef o)
        : scl::Adapter(o),
          TransactionGasketAdapter(&amp;systemc_transaction_, this),
          DirectMemoryUpdateGasketAdapter(&amp;systemc_direct_memory_update_, this),
          dma_(this, "DMADevice") {
        systemc_transaction_.set_gasket(scl::simics2tlm::createGasket(
                &amp;dma_-&gt;mmio_socket_, o));

        simics_interrupt_-&gt;set_pin(&amp;dma_-&gt;interrupt_);

        simics_memory_space_-&gt;set_gasket(scl::tlm2simics::createGasket(
                &amp;dma_-&gt;phys_mem_socket_, o));

        systemc_direct_memory_update_.set_gasket(
                simics_memory_space_-&gt;gasket());
        systemc_reset_.set_pin(&amp;dma_-&gt;reset_, false, o);
    }

    static void init_class(simics::ConfClass *cls);

    // Outgoing from DMA device to Simics
    scl::Connector&lt;scl::tlm2simics::MemorySpace&gt; simics_memory_space_;
    scl::Connector&lt;scl::systemc2simics::Signal&gt; simics_interrupt_;

    class Port : public simics::Port&lt;Adapter&gt;,
                 public scl::simics2systemc::SignalGasketAdapter {
      public:
        explicit Port(simics::ConfObjectRef o)
            : simics::Port&lt;Adapter&gt;(o),
              SignalGasketAdapter(&amp;parent()-&gt;systemc_reset_, parent()) {
        }
    };

  private:
    double get_throttle() const {
        return dma_-&gt;throttle_;
    }

    void set_throttle(double value) {
        dma_-&gt;throttle_ = value;
    }

    // Incoming from Simics to DMA device
    scl::simics2systemc::Signal systemc_reset_;
    scl::simics2tlm::Transaction systemc_transaction_;
    scl::simics2tlm::DirectMemoryUpdate systemc_direct_memory_update_;

    // DMA device implementation by SystemC/TLM
    scl::Device&lt;DMADevice&gt; dma_;
};
</code></pre>
<p>In the code example, the <code>Adapter</code> class:</p>
<ul>
<li>defines the Simics configuration class to be instantiated by Simics, and</li>
<li>implements all Simics interfaces needed, and</li>
<li>provides connectors for all outbound calls of Simics interfaces implemented by other Simics objects.</li>
</ul>
<p>A Simics interface is defined by a set of function pointers. To expose such an interface from a SystemC model to Simics the set of function pointers should be mapped to the functions of an object which implements the corresponding C++ version of the interface. A <em>simics-interface-adapter</em> is used for this purpose. It provides the necessary static functions and forwards Simics interface function calls to the object. The simics-interface-adapter must be registered with Simics, along with the <code>Adapter</code> class, as shown in the <code>init_local</code> function later in the chapter.</p>
<p>The implementation of the C++ version of the Simics interface is provided by a <em>gasket-adapter</em>. In the code example, the <code>Adapter</code> class derives from several gasket-adapter classes and thus exposes the corresponding interfaces. To expose the same type of interface multiple times, gasket-adapters on port are needed. See <a class="reference" href="#connecting-systemc-and-simics-models.html:gasket-adapter-ports">4.7</a> for more details. Additionally, gasket-adapters are responsible for managing simulation context.</p>
<p>The gasket-adapter forwards the C++ interface call to the corresponding <em>gasket</em> which then translates the call to the corresponding SystemC semantics. In the DMA example there is a gasket, called <code>simics::systemc::simics2systemc::Signal</code>, which converts a call to the Simics <code>signal</code> interface into a SystemC signal; and there is another gasket, called <code>simics::systemc::simics2tlm::IoMemory</code>, which converts a call to the Simics <code>io_memory</code> interface into a call to TLM2 <code>b_transport</code>. Each gasket must be bound to the SystemC target and corresponding gasket-adapter in the constructor of the <code>Adapter</code> class.</p>
<p>The gasket which translates Simics interface call to a TLM2 transaction is special and needs additional explanation. In fact, this gasket is a <em>gasket-owner</em> or a container for several <em>gasket-owner</em>s with specific IDs, where each gasket-owner owns one generic <em>tlm-gasket</em> object. The multiple gasket-owners and corresponding tlm-gaskets are needed for protocols where a single Simics interface is demultiplexed into multiple TLM target sockets. The gasket-owner creates a TLM generic payload with protocol specific extension which is then transmitted to the SystemC target using the tlm-gasket. Each tlm-gasket must be created and bound to the SystemC target with the help of <code>createGasket</code> factory function. Then, the tlm-gasket must be assigned to a gasket-owner which in turn must be connected to the corresponding gasket-adapter, as shown in the constructor of the <code>Adapter</code> class.</p>
<p>To connect a SystemC device to a Simics model via a Simics interface it is necessary to:</p>
<ul>
<li>
<p>Register a simics-interface-adapter on the configuration class</p>
</li>
<li>
<p>Derive the <code>Adapter</code> class from the corresponding gasket-adapter class, and initialize it with the corresponding gasket</p>
</li>
<li>
<p>Bind the SystemC target to the gasket using the gasket's member function</p>
<ul>
<li>For TLM2 sockets, create an instance of the tlm-gasket and bind it to the SystemC target socket using <code>simics2tlm::createGasket</code> factory function. Then, assign the tlm-gasket to the gasket with the help of <code>set_gasket</code> method of the gasket class</li>
</ul>
</li>
<li>
<p>Add the gasket as a member to the <code>Adapter</code> class</p>
</li>
</ul>
<p>In the example the <code>Adapter</code> uses the following gaskets and gasket-adapters:</p>
<ul>
<li><code>IoMemory</code> and <code>IoMemoryGasketAdapter</code> - for inbound MMIO, corresponding to Simics <code>io_memory</code> interface</li>
<li><code>Signal</code> and <code>SignalGasketAdapter</code> - for reset, corresponding to the Simics <code>signal</code> interface</li>
<li><code>DirectMemoryUpdate</code> and <code>DirectMemoryUpdateGasketAdapter</code> - to support SystemC direct memory interface (DMI) optimization.</li>
</ul>
<p>A gasket can be used to access the SystemC model from Simics. But it is not the only supported entry point to do this. These are the supported entry points:</p>
<ul>
<li>
<p>Gasket. Can be used for bridging from a Simics interface to a TLM/SystemC interface. For example, raising/lowering a Simics <code>signal</code> interface which connects to SystemC model via gasket will raise/lower the SystemC input signal.</p>
</li>
<li>
<p>Device utility class. Whenever the SystemC model is accessed from the adapter directly, this utility class must be used. See code example below.</p>
<pre><code>    uint32 getRegister1() const {
        return simple_device_-&gt;register1();
    }

    void setRegister1(const uint32 &amp;val) {
        register1_ = val;
        if (SIM_object_is_configured(obj())) {
            simple_device_-&gt;set_register1(val);
        }
    }
    </code></pre>
<p><code>register1</code> and <code>set_register1</code> are functions defined in SystemC model, but called from the device utility class. In this way, it ensures that the correct simulation context is set in the SC kernel.</p>
</li>
<li>
<p>Scheduler. The adapter has a helper object, <code>adapter.engine</code>, that allows for the adapter to be scheduled by Simics. When scheduled, it runs SystemC time forward via the SystemC scheduler. Simics events can be posted on the adapter and are interleaved with the SystemC events and processes. Please note that Simics events would still need to communicate with SystemC via the adapter using Simics interfaces. The helper object always runs in picoseconds so running the adapter 1 ps forward will also run the SystemC scheduler 1 ps forward.</p>
</li>
</ul>
<p>To access a Simics interface, implemented by a Simics object, from a SystemC model the Simics object must be assigned to a Simics attribute first. The attribute is created and registered with Simics using <code>ConnectorAttribute</code> helper class in the <code>init_local</code> function, and is called <em>connector-attribute</em> hereafter. The connector-attribute is needed to link the Simics attribute to the <em>connector</em>, which is a member of the <code>Adapter</code> class. The connector is a <code>Connector</code> class that wraps the gasket which is responsible for translation of the SystemC semantics to a call of the corresponding Simics interface. Also, the connector makes sure that the Simics interface that the gasket is intended to work with is implemented by the Simics object given to the connector-attribute. In the DMA example the adapter contains two connectors and hence two corresponding gaskets: one for converting a DMA SystemC TLM2 transaction to a Simics <code>memory_space</code> interface call; and the other for converting an interrupt signal issued on a DMA completion to a Simics <code>signal</code> interface call.</p>
<p>Similarly to the Simics-to-TLM case, the gasket which translates a TLM2 transaction to a Simics interface call is actually the gasket-owner which owns another <em>tlm-gasket</em>. Each tlm-gasket must be created and bound to the SystemC source, as well as assigned to a connector, as shown in the constructor of the <code>Adapter</code> class.</p>
<p>In summary, to access a Simics interface from SystemC model it is necessary to:</p>
<ul>
<li>Register a connector-attribute on the configuration class</li>
<li>Add corresponding connector, which wraps a gasket, as a member of the <code>Adapter</code> class</li>
<li>Bind the SystemC source to the connector
<ul>
<li>For TLM2 sockets, create an instance of the tlm-gasket and bind it to the SystemC source using <code>tlm2simics::createGasket</code> factory function. Then, assign the tlm-gasket to the connector with the help of arrow operator and the <code>set_gasket</code> function</li>
</ul>
</li>
</ul>
<div class="note">
<p>Calling a Simics interface-specific extension's method will result in an invocation of <code>b_transport</code> and thus <strong>must</strong> be done from an SC_THREAD process according to the SystemC IEEE specification.</p>
</div>
<p>To register the adapter with Simics an instance of the template class <code>ClassDef</code> is created the same way as if the C++ Device API is used. The <code>init_local</code> function from the DMA example is shown below:</p>
<pre><code>extern "C" void init_local(void) {
    auto cls = simics::make_class&lt;Adapter&gt;(
        "sample_tlm2_dma_device", "sample SystemC TLM2 DMA device",
        "The &lt;class&gt;sample_tlm2_dma_device&lt;/class&gt; is a Simics module"
        " encapsulating a SystemC TLM2-based dma device to demonstrate"
        " the use of the Simics SystemC Library.");
}
</code></pre>
<p>The code also demonstrates how the connector-attributes and the simics-interface-adapters are registered with Simics along with the <code>Adapter</code> class.</p>
<h2 id="connecting-systemc-and-simics-models.html:integrating-precompiled-object-files"><a href="#connecting-systemc-and-simics-models.html:integrating-precompiled-object-files">4.2 Integrating precompiled object files</a></h2>
<p>For a new SystemC model written from scratch or a simple SystemC model, it is recommended to compile it within the Simics project along with the adapter file. This approach ensures ABI compatibility since the same compiler, C++ language standard, and compiler options are used for both the SystemC model, the adapter file, and the SystemC Library libs.</p>
<p>By compiling the SystemC model within the Simics project, you can take advantage of the build system and configurations already set up for the Simics project. This simplifies the build process and ensures that all parts are compiled with the same settings.</p>
<p>However, there may be situations where the SystemC model already exists and it is challenging to integrate it into an Simics project. Or, the SystemC model source can not be provided to Simics for various reasons. In such cases, it may be necessary to compile the SystemC model outside of the Simics project. This can be done by following these steps:</p>
<div class="note">
To ensure ABI compatibility, it is required to compile all the C++ files and libraries used in the following steps with the same version of the compiler, C++ language standard, and other compiler options that can impact the ABI compatibility.
</div>
<ol>
<li>
<p><strong>Compile the SystemC model</strong>: In this step, the SystemC model is compiled separately outside of the Simics project.</p>
<p>Since Simics SystemC kernel is ABI compatible with the Accellera Standard SystemC kernel, it is not required to include the Simics SystemC kernel headers. An Accellera-compliant (ABI compatible) SystemC kernel of the same version as the one provided in Simics is OK to use when compiling the SystemC model.</p>
<p>It is required to use the <code>-fPIC</code> (Position Independent Code) compiler option when compiling the SystemC model. This ensures that the code within the shared Simics module can be loaded and executed correctly.</p>
<p>Do not link the object files with the SystemC kernel library. The missing symbols from the SystemC kernel are resolved in step 4.</p>
</li>
<li>
<p><strong>Add the .o files from step 1 to the Simics module build</strong>: The previous step generates object files (.o) for each source file in the SystemC model. These object files contain the compiled code and symbols specific to the model. They can be linked into the Simics module. This involves adding the necessary linker flags and paths in the Simics project's build system (e.g., Makefile, CMakeLists.txt) to include the SystemC model's object files during the linking phase. For example, specify the object files in the Simics Makefile variable <code>EXTRA_OBJ_FILES</code>.</p>
</li>
<li>
<p><strong>Add the dependencies needed by the .o files from step 1 to the Simics module build</strong>: This involves adding the necessary linker flags and paths in the Simics project's build system (e.g., Makefile, CMakeLists.txt) to include the SystemC model's dependencies during the linking phase. The Simics Makefile variables like MODULE_CFLAGS and MODULE_LDFLAGS could be used here.</p>
</li>
<li>
<p><strong>Build the Simics Module</strong>: Finally, the Simics module is built using the Simics project's build system. The build process includes compiling the Simics module's source files and linking them with the SystemC model's object files, along with any other necessary dependencies.</p>
</li>
</ol>
<p>By following this approach, the pre-compiled SystemC model can be integrated into the Simics project without the need to modify the original code.</p>
<p>Here is an example about how to compile a simple SystemC DMA model outside of Simics project and be used to link into a Simics module. The SystemC model in sample-tlm2-dma-device is used as an example, this model has no dependencies on the Simics files and any arbitrary SystemC model should work in the same way.</p>
<ol>
<li>
<p>Copy <code>dma-device.cc</code> and <code>dma-device.h</code> from <em>Simics SystemC Library</em> package to a folder <code>/path/to/device</code></p>
</li>
<li>
<p>Download SystemC kernel from Accellera to <code>/path/to/systemc</code></p>
</li>
<li>
<p>Write a Makefile to compile the dma-device</p>
<pre><code class="language-plaintext">CXX := /path/to/g++
CXXFLAGS := -fPIC -I/path/to/systemc/src

all: dma-device.o

%.o : %.cc
    $(CXX) $(CXXFLAGS) $^ -c
</code></pre>
</li>
<li>
<p>Compile the C++ file by invoking <code>make</code>:</p>
<pre><code class="language-plaintext">[/path/to/device] $ make
</code></pre>
</li>
<li>
<p>The generated object file <code>dma-device.o</code> can be linked into the Simics module by removing <code>dma-device.cc</code> from <code>SRC_FILES</code> and adding the following line in the Simics module's makefile:</p>
<pre><code class="language-plaintext">EXTRA_OBJ_FILES += /path/to/device/dma-device.o
</code></pre>
</li>
</ol>
<h2 id="connecting-systemc-and-simics-models.html:test-the-device-in-simics"><a href="#connecting-systemc-and-simics-models.html:test-the-device-in-simics">4.3 Test the Device in Simics</a></h2>
<p>Once the adapter has been implemented the model can be instantiated and connected in Simics like any other Simics model.</p>
<p>The vacuum target is good for simple testing, and using it the DMA device can be instantiated as follows:</p>
<pre><code class="language-simics">simics&gt; <strong>@SIM_create_object('sample_tlm2_dma_device', 'dma', phys_mem=conf.phys_mem)</strong>
&lt;the sample_tlm2_dma_device 'dma'&gt;
</code></pre>
<div class="note">
<p>You can start the vacuum target from the GUI or command line, or by issuing the following command at the Simics prompt: <strong>run-script "%simics%/targets/vacuum/vacuum.simics"</strong></p>
</div>
<p>Since the DMA device requires a memory-space where DMA operations are supposed to occur it is provided in the initial set of attributes. To access the registers in the DMA device it is necessary to map it in the IO space:</p>
<pre><code class="language-simics">simics&gt; <strong>phys_mem.add-map device = dma base = 0x1000 length = 0x100</strong>
Mapped 'dma' in 'phys_mem' at address 0x1000.
simics&gt; <strong></strong>
</code></pre>
<p>To configure and test the DMA device a pattern will be written to RAM and copied using the device:</p>
<pre><code class="language-simics">simics&gt; <strong>phys_mem.write 0x10000000 0xdeadbeef 8 -l # pattern</strong>
simics&gt; <strong>phys_mem.write 0x1004 0x10000000 4 -l # src</strong>
simics&gt; <strong>phys_mem.write 0x1008 0x10001000 4 -l # dest</strong>
simics&gt; <strong>phys_mem.write 0x1000 0xc0000008 4 -l # control (start transfer)</strong>
simics&gt; <strong>phys_mem.x 0x10001000</strong>
p:0x10001000  efbe adde 0000 0000 0000 0000 0000 0000  ................
simics&gt; <strong></strong>
</code></pre>
<p>Of course, more commonly the model will be instantiated from a module test or a component. Look in the test directory of the sample-tlm2-dma-device module's source code for more examples.</p>
<h2 id="connecting-systemc-and-simics-models.html:systemc-device-configuration"><a href="#connecting-systemc-and-simics-models.html:systemc-device-configuration">4.4 SystemC Device Configuration</a></h2>
<p>Sometimes it is necessary to pass configuration parameters to the constructor of the SystemC device. Such configuration parameters are typically passed to the adapter via Simics attributes. Since the attributes are not available in the constructor of the corresponding <code>Adapter</code> class the creation of the SystemC device has to be deferred to the <em>finalize</em> phase. The <code>Adapter</code> class has two convenient methods that are called in the beginning of the finalize phase, right after the SystemC context has been set up. These methods are <code>elaborate</code> and <code>bindGaskets</code>. The <code>elaborate</code> method is intended for SystemC elaboration where Simics configuration attributes are required. Otherwise the elaboration could be done entirely in the <code>Adapter</code> constructor. The <code>bindGaskets</code> method is used to bind gaskets and other ports created in the elaborate method. An example of the methods is shown in the <code>sample-tlm2-simple-device</code> device model:</p>
<pre><code>class Adapter : public scl::Adapter
[...]
 
    void elaborate() {
        // Because we create the Device in elaborate, any attribute setters that
        // use it must be guarded against early access (e.g. during checkpoint
        // restore)
        SimpleDevice *top = new SimpleDevice("simple_device", delay_ns_);
        scl::Device&lt;SimpleDevice&gt; d(this, top);
        simple_device_ = d;

        // Handle attribute side-effects here
        simple_device_-&gt;set_register1(register1_);
        simple_device_-&gt;set_register2(register2_);
    }

    void bindGaskets() {
        systemc_io_memory_.set_gasket(
            scl::simics2tlm::createGasket(&amp;simple_device_-&gt;target_socket, 
                                          obj()));
    }

    int delay_ns_;  // Configured by attribute

  private:
    // The SystemC TLM device wrapped by the Simics object.
    // NOTE: Must use the Device utility class to make sure any access to the
    // SystemC device is handled correctly.
    scl::Device&lt;SimpleDevice&gt; simple_device_;    

[...]
</code></pre>
<div class="note">
<p>Special care has to be taken if the adapter or SystemC model has dependencies on other Simics objects. It may be tempting to rely on the dependencies during the attribute setting phase, but this is <strong>not</strong> allowed. Simics objects, referenced by attributes, and interfaces they implement are not allowed to be accessed before the finalize phase. In the finalize phase <code>SIM_require_object</code> must be called on a Simics object first to ensure that the object is configured. See
<a href="../model-builder-user-guide/index.html">Model Builder User's Guide</a> for more details on attribute initialization order.</p>
</div>
<h2 id="connecting-systemc-and-simics-models.html:guidelines-for-configuring-systemc-model-in-simics"><a href="#connecting-systemc-and-simics-models.html:guidelines-for-configuring-systemc-model-in-simics">4.5 Guidelines for Configuring SystemC Model in Simics</a></h2>
<p>Simics and the provided SystemC Library are both very flexible and can be configured in many different ways. For example, a virtual platform project may choose to use one or multiple adapters to map SystemC devices into Simics. It is important to understand these different configuration options since the selected solution will impact the overall performance of the virtual platform.</p>
<p>Each SystemC Library based Simics module is statically linked with Intel SystemC Kernel (ISK). Each adapter instance from each such module, when created in Simics, will be assigned its own kernel context (i.e. the sc_simcontext).</p>
<p>The kernel contexts are isolated from one another, making it impossible to communicate during delta cycles between adapters using the SystemC scheduler. Hence, if really tight integration is required between two different SystemC modules, it is suggested to wrap them using a single adapter.</p>
<p>Even though Simics SystemC Library supports multiple instances of each adapter, the kernel itself is not thread-safe. This means that extra care must be taken when creating multi-cell configurations. There are two rules:</p>
<ul>
<li>The adapter must be put in the same cell as the objects it communicates with. Please run <code>check-cell-partitioning</code> to verify that the cells have been setup correctly.</li>
<li>Multiple instances of the adapter(s) in same Simics module cannot span multiple cells. To be able to run the SystemC model in multiple cells (i.e. in parallel) it must be wrapped by two separate Simics modules.</li>
</ul>
<p>For the same reason, multiple instances of adapters from the same Simics module does not work in the multicore accelerator mode either.</p>
<p>It is also encouraged to read up on the <code>set-time-quantum</code> command. This command can be used to change the fidelity of the interaction/scheduling between different Simics clocks. That is, one can specify the number of cycles that should be executed on each Simics clock before the next Simics clock is being scheduled. A large time quantum makes it possible to leverage decoupling and ISS optimizations and a small time quantum is good for tight integration between models.</p>
<p>It should also be noted that it is possible to change the number of instructions that are executed per cycle in Simics. This can also be used to tweak how much time is spent and work is done in the different models. Hence, it can be used to change tightness of interaction versus performance in the virtual platform. Please refer to the
<a href="../simics-user-guide/index.html">Simics User's Guide</a> and the
<a href="../reference-manual-api/index.html">API Reference Manual</a> for more information.</p>
<p>It is suggested that these parameters are considered for each virtual platform project and use case.</p>
<h2 id="connecting-systemc-and-simics-models.html:creating-new-gaskets"><a href="#connecting-systemc-and-simics-models.html:creating-new-gaskets">4.6 Creating New Gaskets</a></h2>
<p>As already explained, there is a chain of objects that interact in order to translate a Simics interface invocation into a SystemC signal or TLM2 transaction and vice versa. SystemC Library already provides simics-interface-adapters for the most common of Simics interfaces, gasket-adapters and gaskets needed. But for other interfaces, or custom interfaces, these classes must be provided by the model developer.</p>
<p>The best way to implement a new set of classes for an unsupported Simics interface is to base it on an existing set. The <code>SerialDevice</code> gasket and accompanied set of classes can be used as an example as it maps the Simics <code>serial_device</code> interface for both Simics → TLM and TLM → Simics directions. We will follow this example in this chapter to describe the typical set of classes to be added by the model developer. The details for each type of class can be found in the
<a href="../reference-manual-systemc-library-api/jump.html">SystemC Library API Reference Manual</a>. The new set should be added to a separate module referenced by EXTRA_MODULE_VPATH until it has eventually been merged into SystemC Library.</p>
<div class="note">
<p>Any gasket written for a standard Simics interface should be sent to the Simics team for inclusion into the library.</p>
</div>
<h3 id="connecting-systemc-and-simics-models.html:simics-to-systemc"><a href="#connecting-systemc-and-simics-models.html:simics-to-systemc">4.6.1 Simics to SystemC</a></h3>
<p>The Simics to TLM invocation chain, which translates Simics interface call to TLM2 transaction, looks like this: Simics interface → simics-interface-adapter → gasket-adapter → gasket-owner → tlm-gasket → SystemC TLM2 target socket.</p>
<p>The <code>io_memory</code> and <code>serial_device</code> are two good examples of Simics interfaces translated into TLM2. The <code>io_memory</code> interface translates to a generic payload, but the <code>serial_device</code> interface translates to a protocol specific extension using built-in Simics interface to TLM payload extension marshal/unmarshal capabilities. See the <code>SerialDeviceExtension</code> class for details.</p>
<p>It is highly recommended to use the built-in marshal/unmarshal capabilities to cut down on the number of Simics specific details exposed to the SystemC model.</p>
<p>Though it is possible to use the Simics C++ API to implement a Simics interface on the <code>Adapter</code> class and forward the interface call to the SystemC model, this is highly discurraged. It is important that the SystemC simulation context is properly set on enter and reset on exit. Failure to set SystemC simulation context will lead to a crash.</p>
<p>This is provided by a utility classes in the SystemC Library. More specifically, <code>Context</code> class used by the gasket-adapters. Also the tlm-gasket itself, defined by the <code>Gasket</code> class, provides the necessary wrappings for running the transaction in an SC_THREAD since <code>b_transport</code> method might call <code>wait</code> function.</p>
<p>For describing how custom gaskets are created we will use the <code>simics2tlm::SerialDevice</code> class as an example. The Simics header file <code>simics/devs/serial-device.h</code> specifies the Simics interface as:</p>
<pre><code>SIM_INTERFACE(serial_device) {
        int (*write)(conf_object_t *obj, int value);
        void (*receive_ready)(conf_object_t *obj);
};
</code></pre>
<p>Using the simics-interface-adapter, defined by <code>SerialDeviceSimicsAdapter</code> class, the Simics interface is translated to the corresponding C++ interface. See the file <code>simics/systemc/iface/serial_device_simics_adapter.h</code> for reference. The Simics C++ interface is defined in the file <code>simics/systemc/iface/serial_device_interface.h</code>:</p>
<pre><code>class SerialDeviceInterface {
  public:
    virtual int write(int value) = 0;
    virtual void receive_ready() = 0;
    virtual ~SerialDeviceInterface() {}
};
</code></pre>
<p>As one may notice, the same functions are provided but without the <code>conf_object_t</code> pointer as parameter. The <em>obj</em> parameter is replaced with the <code>this</code> pointer in C++.</p>
<div class="note">
<p>Though it is possible to use different function names in the two interfaces, it is recommended to keep the same names for clarity.</p>
</div>
<p>The Simics C++ interface function call is further translated to the call of corresponding function in the gasket. The translation is required to adjust simulation context before the SystemC code is entered and is performed in the <code>SerialDeviceGasketAdapter</code> class:</p>
<pre><code>class SerialDeviceGasketAdapter
    : public iface::SerialDeviceInterface,
      public GasketAdapter&lt;iface::SerialDeviceInterface&gt; {
  public:
    SerialDeviceGasketAdapter(SerialDeviceInterface *serial_device,
                              iface::SimulationInterface *simulation)
        : serial_device_(serial_device), simulation_(simulation) {
    }
    int write(int value) override {
        Context context(simulation_);
        return serial_device_-&gt;write(value);
    }
    void receive_ready() override {
        Context context(simulation_);
        serial_device_-&gt;receive_ready();
    }
    simics2tlm::GasketOwner *gasket_owner() const override {
        return dynamic_cast&lt;simics2tlm::GasketOwner *&gt;(serial_device_);
    }

  private:
    SerialDeviceInterface *serial_device_;
    iface::SimulationInterface *simulation_;
};
</code></pre>
<p>The <code>serial_device_</code> member is a helper object which combines the adjustment of the simulation context, provided by <code>simulation_</code> member, with the call of the Simics C++ interface function implemented by the gasket. The gasket is defined by the <code>SerialDevice</code> class in the <code>simics/systemc/simics2tlm/serial_device.h</code>:</p>
<pre><code>class SerialDevice : public simics::systemc::iface::SerialDeviceInterface,
                     public GasketOwner {
  public:
    virtual void gasketUpdated();
    // SerialDeviceInterface
    int write(int value);
    void receive_ready();
  private:
    ExtensionSender sender_;
    iface::SerialDeviceExtension extension_;
};
</code></pre>
<p>The <code>extension_</code> member, defined by <code>SerialDeviceExtension</code> class, provides utility functions to perform marshalling of the interface data to a protocol specific TLM extension. The TLM extension along with payload is then sent to the SystemC target with the help of the <code>sender_</code>. The protocol specific extensions are described in the <a class="reference" href="#connecting-systemc-and-simics-models.html:protocol-specific-extensions">4.6.3</a>.</p>
<h3 id="connecting-systemc-and-simics-models.html:systemc-to-simics"><a href="#connecting-systemc-and-simics-models.html:systemc-to-simics">4.6.2 SystemC to Simics</a></h3>
<p>The TLM to Simics invocation chain looks like this: SystemC TLM2 initiator socket → tlm-gasket → gasket-owner → Simics interface.</p>
<p>The <code>memory_space</code> and <code>serial_device</code> are two good examples of Simics interfaces translated from TLM2. The <code>memory_space</code> interface translates from a generic payload, but the <code>serial_device</code> interface translates from a protocol specific extension using built-in Simics interface to TLM payload extension marshal/unmarshal capabilities. See the <code>SerialDeviceExtension</code> class for details.</p>
<p>It is highly recommended to use the built-in marshal/unmarshal capabilities to cut down on the number of Simics specific details exposed to the SystemC model.</p>
<p>It is also highly recommended to use the <code>ConnectorAttribute</code> and <code>Connector</code> utility classes when implementing the connector-attribute in the adapter. See the source code for the <code>sample-tlm2-dma-device</code> module for an example of how to do this.</p>
<p>For describing how custom gaskets are created we will use the <code>tlm2simics::SerialDevice</code> class as an example. The definition of this gasket can be found in the file: <code>simics/systemc/tlm2simics/serial_device.h</code>. Being derived from the <code>TransactionHandler</code> class, the <code>SerialDevice</code> gasket class owns the tlm-gasket and performs the translation of the TLM payload to the call of the Simics interface. The translation is initiated by the tlm-gasket via the invocation of the <code>simics_transaction</code> method defined in the <code>SerialDevice</code> class:</p>
<pre><code>class SerialDevice : public InterfaceProvider,
                     public TransactionHandler,
                     public iface::SerialDeviceInterface {
  public:
    SerialDevice() : InterfaceProvider("serial_device"),
                     TransactionHandler(this,
                         iface::SerialDeviceExtension::createIgnoreReceiver()),
                     receiver_(
                         iface::SerialDeviceExtension::createReceiver(this)) {}

    // SerialDeviceInterface
    int write(int value) override;
    void receive_ready() override;
    // TransactionHandler
    iface::ReceiverInterface *receiver() override;

    virtual ~SerialDevice();

  private:
    tlm::tlm_response_status simics_transaction(
            ConfObjectRef &amp;simics_obj,
            tlm::tlm_generic_payload *trans) override;
    iface::ReceiverInterface *receiver_;
};
</code></pre>
<p>The payload is then forwarded to the <code>receiver_</code> member which utilizes the utility functions, defined in the <code>SerialDeviceExtension</code> class, to perform unmarshalling of the interface data from the protocol specific TLM payload extension and invoke the corresponding Simics C++ interface function. The protocol specific extensions are described in the <a class="reference" href="#connecting-systemc-and-simics-models.html:protocol-specific-extensions">4.6.3</a>.</p>
<p>Being derived from the <code>InterfaceProvider</code> class, the gasket gets the Simics interface, provided by the associated Simics target object, using <code>get_interface</code> template function and performs the interface call.</p>
<h3 id="connecting-systemc-and-simics-models.html:protocol-specific-extensions"><a href="#connecting-systemc-and-simics-models.html:protocol-specific-extensions">4.6.3 Protocol Specific Extensions</a></h3>
<p>Simics SystemC Library provides the gaskets which convert Simics interfaces into/from TLM2 generic payloads using SystemC extension mechanism. The extension mechanism allows extending the generic payload, aimed at modeling memory-mapped buses only, with a protocol specific set of attributes, or simply <em>extension</em>, and thus allows transporting any Simics interface specific data.</p>
<p>In SystemC Library each extension is defined by a separate class in the corresponding <code>simics/systemc/iface/*_extension.h</code> header file. As an example in this chapter we refer to the <code>SerialDeviceExtension</code> extension class for the <code>serial_device</code> Simics interface, which is defined in the <code>simics/systemc/iface/serial_device_extension.h</code> file:</p>
<pre><code>class SerialDeviceExtension : public Extension&lt;SerialDeviceExtension,
                                               SerialDeviceInterface&gt; {
  public:
    virtual void call(SerialDeviceInterface *device) {
        switch (method_.value&lt;Method&gt;()) {
        case WRITE:
            method_return_ = device-&gt;write(method_input_[0].value&lt;int&gt;());
            break;
        case RECEIVE_READY:
            device-&gt;receive_ready();
            break;
        }
    }

    virtual int write(int value) {
        method_input_.push_back(value);
        method_ = WRITE;
        send();
        return method_return_.value&lt;int&gt;();
    }
    virtual void receive_ready() {
        method_ = RECEIVE_READY;
        send();
    }

  private:
    enum Method {
        WRITE,
        RECEIVE_READY
    };
};
</code></pre>
<p>To reduce the number of Simics specific details exposed to the SystemC model the extension provides utility functions which marshal and unmarshal Simics C++ interface specific data. In general, an extension with such utility functions can be implemented for any C++ interface. To send the C++ interface data in a TLM transaction the <code>SerialDeviceExtension</code> class overrides <code>write</code> and <code>receive_ready</code> functions of the <code>SerialDeviceInterface</code> interface class. Each function packs the interface function type along with function arguments into general storage, described later, and calls the <code>send</code> function in order to attach the extension to the payload and initiate the TLM transaction. On the receiving end, there is a registered receiver, which unpacks the interface function type and its arguments from the storage and calls the corresponding C++ interface function. The unpacking is performed in the extension's <code>call</code> method.</p>
<p>The general storage is provided by the <code>method_</code>, <code>method_input_</code> and <code>method_return_</code> members of the <code>Extension</code> base class defined in the <code>simics/systemc/iface/extension.h</code> file. The <code>method_</code> member keeps the interface function type, typically declared as <code>Method</code> enumeration type in the extension class. The <code>method_input_</code> keeps the function's arguments in a STL vector, while the <code>method_return_</code> provides the function return value written in the <code>call</code> function of the extension upon successful completion of the TLM transaction.</p>
<p>There are <em>extension-sender</em> and <em>extension-receiver</em> in the SystemC Library which simplify sending and receiving the extensions.</p>
<p>The extension-sender, intended for sending the extension from Simics-to-TLM gasket to SystemC target socket, is defined by the <code>simics2tlm::ExtensionSender</code> class in the <code>simics/systemc/simics2tlm/extension_sender.h</code> file:</p>
<pre><code>class ExtensionSender : public iface::ExtensionSenderInterface {
  public:
    void init(simics2tlm::GasketInterface::Ptr gasket) {
        // coverity[copy_instead_of_move]
        gasket_ = gasket;
    }
    virtual iface::Transaction transaction() {
        return pool_.acquire();
    }
    virtual void send_extension(iface::Transaction *transaction) {
        gasket_-&gt;trigger(transaction);
    }
    virtual void send_failed(iface::Transaction *transaction) {
        SIM_LOG_ERROR(gasket_-&gt;simics_obj(), Log_TLM,
                      "Extension not processed correctly.");
    }

  private:
    simics2tlm::GasketInterface::Ptr gasket_;
    iface::TransactionPool pool_;
};
</code></pre>
<p>This extension-sender is typically added as a member to the corresponding Simics-to-TLM gasket class and is initialized with the <em>tlm-gasket</em> in the <code>init</code> function. The sender has a pool of <code>Transaction</code> objects to support multiple re-entry over the same gasket. The <code>Transaction</code> class is a thin wrapper around <code>tlm_generic_payload</code> class which supports a custom extension used by SystemC Library to track the transactions. A new <code>Transaction</code> is acquired in the above-mentioned <code>send</code> function of the <code>Extension</code> base class which also sets the corresponding extension. The function then calls <code>send_extension</code> method of the extension-sender which forwards the <code>Transaction</code> to the tlm-gasket to perform the TLM transaction. If the transaction failed, the <code>send_failed</code> method will produce Simics error message.</p>
<p>There is also a generic extension-sender, intended for sending the extension from a SystemC module to a SystemC module or to the TLM-to-Simics gasket. It is defined in the <code>simics/systemc/iface/extension_sender.h</code> file and initialized with the initiator socket. The extension-sender sends the payload along with the extension using the <code>b_transport</code> method of the socket.</p>
<p>The extension-receiver is defined by the <code>ExtensionReceiver</code> class in the <code>simics/systemc/iface/extension_receiver.h</code> file:</p>
<pre><code>template&lt;class TExtension, class TInterface&gt;
class ExtensionReceiver : public ReceiverInterface {
  public:
    explicit ExtensionReceiver(TInterface *device)
        : device_(device) {}
    bool handle(tlm::tlm_generic_payload *payload) override {
        TExtension *extension = payload-&gt;get_extension&lt;TExtension&gt;();
        if (extension &amp;&amp; extension-&gt;valid()) {
            payload-&gt;set_response_status(tlm::TLM_OK_RESPONSE);
            extension-&gt;method_call(device_);
            return true;
        }

        return false;
    }
    bool probe(tlm::tlm_generic_payload *payload) override {
        TExtension *extension = payload-&gt;get_extension&lt;TExtension&gt;();
        return extension &amp;&amp; extension-&gt;valid();
    }

  private:
    TInterface *device_;
};
</code></pre>
<p>The extension-receiver is generic: it is intended for receiving the extension in any SystemC module, including the TLM-to-Simics gasket. It is specialized with the extension type and the C++ interface type, implemented by a target object. The TLM-to-Simics gasket is just one example of the target object. If the extension of the provided type is received, the extension-receiver invokes the <code>Extension</code>'s <code>method_call</code> method which in turn invokes the <code>call</code> function of the extension to perform unmarshalling of the C++ interface specific data. The extension-receiver should be created with the help of <code>createReceiver</code> factory method of the <code>Extension</code> class, which takes the <code>device</code> pointer to the target object. There is also a <code>createIgnoreReceiver</code> factory method useful for testing the protocol specific extensions. It creates a receiver which does not require the target object, and hence does not perform C++ interface call, but terminates the transaction correctly.</p>
<p>The target object may need to receive several extensions of different types, for example, if it implements several C++ interfaces. To support this, the <em>extension-dispatcher</em>, defined in the the <code>simics/systemc/iface/extension_dispatcher.h</code> file, should be used. The extension-receivers of the expected extension types subscribe to the extension-dispatcher using <code>subscribe</code> method. When a transaction with a matching extension is received, the extension-dispatcher forwards the extension to the corresponding receiver for unmarshalling of the C++ interface specific data.</p>
<h2 id="connecting-systemc-and-simics-models.html:gasket-adapter-ports"><a href="#connecting-systemc-and-simics-models.html:gasket-adapter-ports">4.7 Gasket Adapter Ports</a></h2>
<p>As explained in the chapter <a class="reference" href="#connecting-systemc-and-simics-models.html">4</a>, Simics interfaces can be exposed directly on the conf-object by using the <em>simics-adapter</em> and <em>gasket-adapter</em> classes. To expose the same type of interface multiple times, for example an interrupt controller with many interrupt sources, each interface must be registered on individual ports. This is done by creating a port class and registering it with a dedicated port object. See the chapter <code>Port registration</code> of
<a href="../cc-device-api/index.html">Simics C++ Device API v2</a>
documentation for details. An example of this is shown in the <code>sample-tlm2-i2c-devices</code> device model.</p>
<pre><code> This adapter wraps two SystemC I2C slave devices using Simics port object.
 namespace scl = simics::systemc;

class SlaveAdapter : public scl::Adapter {
  public:
    explicit SlaveAdapter(simics::ConfObjectRef o)
        : scl::Adapter(o) {
        for (unsigned i = 0; i &lt; 2; ++i) {
            systemc_io[i].set_gasket(scl::simics2tlm::createGasket(
                &amp;i2c_slave_devs[i]-&gt;io_target_socket, o));
            systemc_i2c[i].set_gasket(scl::simics2tlm::createGasket(
                &amp;i2c_slave_devs[i]-&gt;i2c_target_socket, o));
            simics_i2c[i].set_gasket(scl::tlm2simics::createGasket(
                &amp;i2c_slave_devs[i]-&gt;i2c_master_initiator_socket, o));
        }
    }

    static void init_class(simics::ConfClass *cls);

    template &lt;int id&gt; int get_register() const;
    template &lt;int id&gt; void set_register(const int &amp;val);

    template &lt;int id&gt; int get_i2c_address() const;
    template &lt;int id&gt; void set_i2c_address(const int &amp;val);

    template &lt;int id&gt; simics::ConfObjectRef get_i2c_link() const;
    template &lt;int id&gt; void set_i2c_link(const simics::ConfObjectRef &amp;obj_ref);

    class Port : public simics::Port&lt;SlaveAdapter&gt;,
                 public scl::simics2tlm::IoMemoryGasketAdapter,
                 public scl::simics2tlm::I2cSlaveV2GasketAdapter {
      public:
        explicit Port(simics::ConfObjectRef o)
            : simics::Port&lt;SlaveAdapter&gt;(o),
              IoMemoryGasketAdapter(&amp;parent()-&gt;systemc_io[index()], parent()),
              I2cSlaveV2GasketAdapter(&amp;parent()-&gt;systemc_i2c[index()], parent()) {
        }
    };

  private:
    scl::simics2tlm::IoMemory     systemc_io[2];
    scl::simics2tlm::I2cSlaveV2   systemc_i2c[2];
    scl::tlm2simics::I2cMasterV2  simics_i2c[2];
    std::array&lt;scl::Device&lt;I2cSlave&gt;, 2&gt; i2c_slave_devs {{
                    {this, "i2c_dev0"},
                    {this, "i2c_dev1"}}};
};  

[...]

 auto port = simics::make_class&lt;SlaveAdapter::Port&gt;(
            "sample_tlm2_i2c_slave.port", "i2C port", "I2C port");
    port-&gt;add(scl::iface::createAdapter&lt;
              scl::iface::IoMemorySimicsAdapter&lt;SlaveAdapter::Port&gt;&gt;());
    port-&gt;add(scl::iface::createAdapter&lt;
              scl::iface::I2cSlaveV2SimicsAdapter&lt;SlaveAdapter::Port&gt;&gt;());
    cls-&gt;add(port, "port.I2C[2]");
    

[...]

 extern "C" void init_local_slave(void) {
    simics::make_class&lt;SlaveAdapter&gt;(
        DEVICE_CLASS,
        "sample OSCI TLM2 I2C slave",
        "The &lt;class&gt;" DEVICE_CLASS "&lt;/class&gt; is a Simics module"
        " encapsulating a SystemC TLM2-based I2C slave to demonstrate"
        " the use of Simics SystemC Library.");
}  
</code></pre>
<p>A new <code>Port</code> class is defined and derived from <code>simics::Port&lt;SlaveAdapter&gt;</code> and two <em>gasket-adapter</em> classes. These two <em>gasket-adapter</em>classes expose <code>io_memory</code> and <code>i2c_slave_v2</code> interfaces on the port object instance. They are initialized like the other <em>gasket-adapter</em> class except the first constructor parameter is bind to the gasket defined in the parent class. The <code>index</code> function returns the array index of the port object if it is given an array-like name. It is used to bind to the right gasket.</p>
<p>The new <code>Port</code> class is registered like the normal Simics class. Also the same for the Simics adapter registration. When registering the port class to the device class, a name for the port is provided as a function parameter. If an array-like name is provided, a port array is registered. In the above example, the two port objects are named like <code>port.I2C[0]</code> and <code>port.I2C[1]</code>.</p>
<p>Sometimes there are many gaskets with the same type, but for some reason cannot use the port array. An example of this is shown here.</p>
<pre><code> class Port : public simics::Port&lt;test_sc_gasket_port_adapter&gt;,
                 public simics::systemc::simics2systemc::SignalGasketAdapter {
      public:
        explicit Port(simics::ConfObjectRef o)
            : simics::Port&lt;test_sc_gasket_port_adapter&gt;(o),
              SignalGasketAdapter(&amp;(parent()-&gt;*port_gasket[name()]), parent()) {
        }

        static std::map&lt;std::string,
                        simics::systemc::simics2systemc::Signal
                        test_sc_gasket_port_adapter::*&gt; port_gasket;
    };

  private:
    simics::systemc::simics2systemc::Signal systemc_first_in_;
    simics::systemc::simics2systemc::Signal systemc_second_in_;
    simics::systemc::simics2systemc::Signal systemc_third_in_;
    simics::systemc::Device&lt;test_sc_gasket_port_module&gt; dut_;
};

std::map&lt;std::string,
         simics::systemc::simics2systemc::Signal
         test_sc_gasket_port_adapter::*&gt;
test_sc_gasket_port_adapter::Port::port_gasket {
    {"port.first", &amp;test_sc_gasket_port_adapter::systemc_first_in_},
    {"port.second", &amp;test_sc_gasket_port_adapter::systemc_second_in_},
    {"port.third", &amp;test_sc_gasket_port_adapter::systemc_third_in_},
};
</code></pre>
<p>The port class here acts like a trampoline by defining a map between the port name and the bind gasket. Thus no need to create a port class to bind to each individual gasket.</p>
<h2 id="connecting-systemc-and-simics-models.html:gasket-objects"><a href="#connecting-systemc-and-simics-models.html:gasket-objects">4.8 Gasket Objects</a></h2>
<p>Section <a class="reference" href="#connecting-systemc-and-simics-models.html:dma-example">4.1</a> shows how gaskets are added to the configuration as part of the adapter's source code. The current section shows a different approach, where the gaskets are created and configured as pre-conf objects before they are added to the configuration by invoking <code>SIM_add_configuration()</code>. In such a configuration the adapter only need to setup the SystemC model but not any gaskets. The gaskets are connected as part of finalizing the Simics configuration.</p>
<p>Therefore, when gasket objects are used, one can use the same adapter template class for all kinds of SystemC models:</p>
<pre><code>template&lt;class TModel&gt;
class Adapter : public simics::systemc::Adapter {
 public:
    explicit Adapter(simics::ConfObjectRef o)
        : simics::systemc::Adapter(o)
        , top_("top") {}

 private:
    TModel top_;
};

</code></pre>
<p>In the following example, <code>Top</code> is used as SystemC model and template parameter for the <code>Adapter</code> class. The model is just a dummy that creates two sockets to show how they are connected to the gasket objects further below.</p>
<pre><code> class Top : public sc_core::sc_module {
  public:
    SC_CTOR(Top)
        : target_socket_("target_socket")
        , initiator_socket_("initiator_socket") {
        target_socket_.register_b_transport(this, &amp;Top::b_transport);
    }

  private:
    tlm_utils::simple_target_socket&lt;Top&gt; target_socket_;
    tlm_utils::simple_initiator_socket&lt;Top&gt; initiator_socket_;

    void b_transport(tlm::tlm_generic_payload &amp;trans,  // NOLINT: SystemC API
                     sc_core::sc_time &amp;local_time) {
        initiator_socket_-&gt;b_transport(trans, local_time);
    }
};

</code></pre>
<p>The binding between the gaskets and the TLM2 sockets is based on the hierarchical names of the sockets. The following example shows how this can be done from CLI, but typically this is done in a component or from a python test.</p>
<pre><code class="language-simics">simics&gt; <strong>@adapter = pre_conf_object('adapter', 'sample_tlm2_gasket_device_doc_example')</strong>
simics&gt; <strong></strong>
simics&gt; <strong>@io_gasket = pre_conf_object('io_gasket', 'sample_tlm2_gasket_device_gasket_simics2tlm_IoMemory')</strong>
simics&gt; <strong>@io_gasket.target = 'top.target_socket'</strong>
simics&gt; <strong>@io_gasket.simulation = adapter</strong>
simics&gt; <strong></strong>
simics&gt; <strong>@ms = pre_conf_object('ms', 'memory-space')</strong>
simics&gt; <strong>@ms_gasket = pre_conf_object('ms_gasket', 'sample_tlm2_gasket_device_gasket_tlm2simics_MemorySpace')</strong>
simics&gt; <strong>@ms_gasket.initiator = 'top.initiator_socket'</strong>
simics&gt; <strong>@ms_gasket.simulation = adapter</strong>
simics&gt; <strong>@ms_gasket.object = ms</strong>
simics&gt; <strong></strong>
simics&gt; <strong>@adapter.gasket_list = [io_gasket, ms_gasket]</strong>
simics&gt; <strong></strong>
simics&gt; <strong>@SIM_add_configuration([adapter, io_gasket, ms_gasket, ms], None)</strong>
</code></pre>
<p>All gasket objects must be listed in the adapter's <code>gasket_list</code> attribute. The order in which the gasket objects are finalized is controlled in such a way that the adapter first creates the SystemC world and then each gasket object binds the sockets according to their attributes.</p>
<p>There are different types of gasket objects and they require different attributes to be set at configuration. All gaskets require the attribute <code>simulation</code> to be set. The <code>simulation</code> attribute couples the gasket to the adapter. In addition, gaskets translating Simics interface calls to TLM2 transactions, i.e. simics2tlm gaskets, require that the <code>target</code> attribute is set. The <code>target</code> attribute binds the initiator socket within the gasket to the target socket in the SystemC model. Gaskets translating TLM2 transactions to Simics interface calls, i.e. tlm2simics gaskets, require that the <code>initiator</code> attribute is set. The <code>initiator</code> attribute binds the target socket within the gasket to the initiator socket in the SystemC model. The tlm2simics gaskets has one additional attribute named <code>object</code>. This should point to a Simics object implementing the corresponding interface of the gasket, and can be left unset.</p>
<p>The third type of gasket objects is the composite PCI gasket. Required attributes are <code>device</code>, <code>pci_bus</code> and <code>simulation</code>. For more details see the sample-tlm2-pci-device source code.</p>
<div class="note">
<p>To prevent problems caused by incompatible toolchains it is not possible to set the <code>simulation</code> attribute of the gasket object to an adapter built from a different module than the gasket.</p>
</div>
<p>Each module builds its own set of gasket objects. Therefore the conf-class names used for these gasket objects are prefixed with the module's name. The following gasket objects are currently supported:</p>
<ul>
<li>&lt;module prefix&gt;_gasket_simics2tlm_[EthernetCommon, Packet, I2cSlaveV2, IoMemory, PciDevice, PciExpress, SerialDevice]</li>
<li>&lt;module prefix&gt;_gasket_tlm2simics_[EthernetCommon, Packet, I2cMasterV2, MemorySpace, PciBus, SerialDevice]</li>
<li>&lt;module prefix&gt;_gasket_simics2systemc_Signal</li>
<li>&lt;module prefix&gt;_gasket_systemc2simics_Signal</li>
<li>&lt;module prefix&gt;_gasket_composite_[Pci, Pcie]</li>
</ul>
<p>Besides the flexibility of binding, gasket objects can be used to reduce the code size and increase the code readability. For example, if a SystemC module exposes hundreds of signals, the traditional way of adding gaskets to the Adapter quickly explodes as each new interface of the same type requires four lines of code. Using gasket objects could replace these four hundred lines of code with just a few lines.</p>
<p>In the following example, <code>TopVector</code> is used as SystemC model and template parameter for the <code>Adapter</code> class. The model has 100 signal input and 100 signal output. The example shows how easy the signals can be connected to the gasket object further below.</p>
<pre><code> class TopVector : public sc_core::sc_module {
  public:
    SC_CTOR(TopVector)
        : sc_in_vec_("sc_in_vec", VECTOR_SIZE)
        , sc_out_vec_("sc_out_vec", VECTOR_SIZE) {}

    static const int VECTOR_SIZE = 100;

  private:
    sc_core::sc_vector&lt;sc_core::sc_in&lt;bool&gt;&gt; sc_in_vec_;
    sc_core::sc_vector&lt;sc_core::sc_out&lt;bool&gt;&gt; sc_out_vec_;
};

</code></pre>
<p>The following example shows how this can be done from a python script.</p>
<pre><code>import dev_util as du
import simics

adapter = simics.pre_conf_object('adapter', 'sample_tlm2_gasket_device_doc_vector_example')

VECTOR_SIZE = 100
vector_in = [None] * VECTOR_SIZE
for idx in range(VECTOR_SIZE):
    vector_in[idx] = simics.pre_conf_object('vector_in_%d' % idx,
                                            'sample_tlm2_gasket_device_gasket_simics2systemc_Signal')
    vector_in[idx].signal = 'top.sc_in_vec_%d' % idx
    vector_in[idx].simulation = adapter

signal_object_vect = [du.Dev([du.Signal]) for _ in range(VECTOR_SIZE)]
vector_out = [None] * VECTOR_SIZE
for idx in range(VECTOR_SIZE):
    vector_out[idx] = simics.pre_conf_object('vector_out_%d_' % idx,
                                             'sample_tlm2_gasket_device_gasket_systemc2simics_Signal')
    vector_out[idx].signal = 'top.sc_out_vec_%d' % idx
    vector_out[idx].object = signal_object_vect[idx].obj
    vector_out[idx].simulation = adapter

adapter.gasket_list = vector_in + vector_out

simics.SIM_add_configuration([adapter] + vector_in + vector_out, None)
</code></pre>
<h2 id="connecting-systemc-and-simics-models.html:gaskets"><a href="#connecting-systemc-and-simics-models.html:gaskets">4.9 Gaskets</a></h2>
<h3 id="connecting-systemc-and-simics-models.html:transaction-gasket"><a href="#connecting-systemc-and-simics-models.html:transaction-gasket">4.9.1 Transaction Gasket</a></h3>
<p>The <code>transaction</code> interface is preferred over the <code>io_memory</code> interface to perform memory/IO transaction. The <code>transaction_t</code> data type used in the interface is more flexible and supports more features than the old <code>generic_transaction_t</code> data type. For information about transaction atoms, <code>transaction_t</code> data type and transaction API, please refer to the chapter <em>Transactions</em> of <em>Model Builder User's Guide</em> for more details.</p>
<p>The <code>Transaction</code> gasket bridges between the Simics <code>transaction</code> interface and the TLM blocking transport interface.</p>
<p>The Simics <code>transaction</code> interface looks as follows:</p>
<pre><code>class TransactionInterface {
  public:
    virtual exception_type_t issue(transaction_t *t, uint64 addr) = 0;
    virtual ~TransactionInterface() {}
};
</code></pre>
<p>The single method <code>issue</code> takes two arguments. The first argument is the <code>transaction_t</code> holding all the information about the transaction and it's payload. The second argument is the address to which the transaction was issued. It is a local offset into the mapped device.</p>
<p>The TLM blocking transport interface looks as follows:</p>
<pre><code>  void b_transport(tlm::tlm_generic_payload &amp;trans, sc_core::sc_time &amp;t);
</code></pre>
<h4 id="connecting-systemc-and-simics-models.html:simics2tlm-transaction-gasket"><a href="#connecting-systemc-and-simics-models.html:simics2tlm-transaction-gasket">4.9.1.1 Simics2TLM Transaction gasket</a></h4>
<p>To perform memory transactions from Simics to the SystemC model, SystemC Library provides the Simics-to-TLM <code>simics2tlm::Transaction</code> gasket which converts the <code>transaction</code> interface calls to SystemC TLM payload:</p>
<pre><code>/**
 * Class that implements the Simics transaction interface and translates it into
 * a TLM transaction.
 *
 * The TLM2 return codes are translated to Simics like this:
 *   TLM_OK_RESPONSE =&gt; Sim_PE_No_Exception,
 *   TLM_ADDRESS_ERROR_RESPONSE =&gt; Sim_PE_IO_Not_Taken or
 *                Sim_PE_Inquiry_Outside_Memory on inquiry access,
 *   remaining TLM2 errors =&gt; Sim_PE_IO_Error or
 *                Sim_PE_Inquiry_Unhandled on inquiry access
 */
class Transaction : public simics::systemc::iface::TransactionInterface,
                    public GasketOwner {
  public:
    exception_type_t issue(transaction_t *transaction, uint64 addr);

  private:
    /*
     * Update the TLM transaction before sending it over to the SystemC side
     * By default this function does nothing since the TLM transaction has
     * been filled with the basic required information. It can used to modify
     * the filled information or add more information including customized
     * extensions.
     *
     * @param simics_transaction the transaction received from Simics side
     * @param tlm_transaction the TLM transaction to be sent over to the SystemC
     *                        side
     */
    virtual void update_transaction(const transaction_t *simics_transaction,
                                    tlm::tlm_generic_payload *tlm_transaction) {
    }

    iface::TransactionPool pool_;
};
</code></pre>
<p>The gasket converts the transaction(<code>transaction</code>) and address(<code>addr</code>) to TLM <code>trans</code>. It only supports blocking transport. The TLM2 return codes are translated to Simics like this:</p>
<ul>
<li>TLM_OK_RESPONSE =&gt; Sim_PE_No_Exception</li>
<li>On non-inquiry access, TLM_ADDRESS_ERROR_RESPONSE =&gt; Sim_PE_IO_Not_Taken</li>
<li>On inquiry access, TLM_ADDRESS_ERROR_RESPONSE =&gt; Sim_PE_Inquiry_Outside_Memory</li>
<li>On non-inquiry access, remaining TLM2 errors =&gt; Sim_PE_IO_Error</li>
<li>on inquiry access, remaining TLM2 errors =&gt; Sim_PE_Inquiry_Unhandled</li>
</ul>
<p>If the <code>b_transport</code> function calls <code>wait</code>, directly or indirectly, the transaction is completed asynchronously. Otherwise, it is completed synchronously. The gasket handles both cases automatically and no extra step is needed from the SystemC side. The deferred transaction information is buffered. Once the device is ready with the requested operation, the deferred transaction is completed by calling <code>SIM_complete_transaction</code>.</p>
<h4 id="connecting-systemc-and-simics-models.html:tlm2simics-transaction-gasket"><a href="#connecting-systemc-and-simics-models.html:tlm2simics-transaction-gasket">4.9.1.2 TLM2Simics Transaction gasket</a></h4>
<p>To perform memory transactions from the SystemC model to Simics, SystemC Library provides the TLM-to-Simics <code>tlm2simics::Transaction</code> gasket which converts the SystemC TLM payload to the <code>transaction</code> interface calls:</p>
<pre><code>/** Protocol specific transaction handler for Simics transaction interface.
 */
class Transaction : public InterfaceProvider,
                    public DmiTransactionHandler {
  public:
    Transaction();
    virtual ~Transaction();

    // DmiTransactionHandler
    void set_gasket(GasketInterface::Ptr gasketInterface) override;
  private:
    tlm::tlm_response_status simics_transaction(
            ConfObjectRef &amp;simics_obj,
            tlm::tlm_generic_payload *trans) override;
    unsigned int debug_transaction(ConfObjectRef &amp;simics_obj,
                                   tlm::tlm_generic_payload *trans) override;

    unsigned int transaction(ConfObjectRef &amp;simics_obj,  // NOLINT
                             tlm::tlm_generic_payload *trans, bool inquiry);

    /*
     * Update the Simics transaction atoms before sending it to the Simics side
     * By default, it is empty since the basic required atoms are already filled.
     * It can be used to update the existing atoms or add new customized atoms.
     *
     * @param tlm_transaction the TLM transaction received from SystemC side
     * @param atoms the atoms used in the Simics transaction sent to the Simics
     *              side. No need to add ATOM_LIST_END here.
     */
    virtual void add_custom_atoms(
            const tlm::tlm_generic_payload *tlm_transaction,
            std::vector&lt;atom_t&gt; *atoms) {}

    class UpdateTarget : public InterfaceProvider::TargetUpdateListener {
      public:
        UpdateTarget() : map_target_(NULL) {}
        virtual ~UpdateTarget() {
            if (map_target_)
                SIM_free_map_target(map_target_);
        }

        // InterfaceProvider::TargetUpdateListener
        void update_target(ConfObjectRef old_target,
                           ConfObjectRef new_target) override {
            if (map_target_) {
                SIM_free_map_target(map_target_);
                map_target_ = nullptr;
            }

            if (new_target) {
                map_target_ = SIM_new_map_target(new_target.object(),
                                                 NULL, NULL);
            }
        }

        map_target_t *map_target() {
            return map_target_;
        }

      private:
        map_target_t *map_target_;
    };

    UpdateTarget update_target_;
    // The proxy object for the target_socket used in this gasket
    conf_object_t *target_socket_proxy_obj_ {nullptr};
};
</code></pre>
<p>The gasket converts the TLM <code>trans</code> to Simics <code>transaction_t</code>. It currently only support sending transaction synchronously using TLM blocking transport interface (<code>b_transport</code>) and debug transport interface (<code>transport_dbg</code>).</p>
<p>The TLM2 return codes are translated from Simics like this:</p>
<ul>
<li>Sim_PE_No_Exception =&gt; TLM_OK_RESPONSE</li>
<li>all Sim_PE exceptions =&gt; TLM_GENERIC_ERROR_RESPONSE</li>
</ul>
<h4 id="connecting-systemc-and-simics-models.html:custom-atoms"><a href="#connecting-systemc-and-simics-models.html:custom-atoms">4.9.1.3 Custom ATOMs</a></h4>
<p>Besides the Simics defined transaction atoms, it is possible to define custom atoms. Refer to the <em>Transactions</em> of <em>Model Builder User's Guide</em> for more details about how to define custom atoms.</p>
<p>Custom gaskets are needed to handle the custom atoms. And the official transaction gaskets provide help function to make the handling with custom atoms easier. For a custom simics2tlm gasket, the logic of converting the Simics custom atoms to TLM extension should be implemented in the overloaded <code>update_transaction</code> method. The method is called before sending the transaction to the TLM blocking transaction interface. Example showing this conversion:</p>
<pre><code>// Custom Simics2Tlm Gasket that handles the custom atom
class CustomSimics2TlmTransaction : public scl::simics2tlm::Transaction {
    void update_transaction(const transaction_t *simics_transaction,
                            tlm::tlm_generic_payload *tlm_transaction) override {
        custom_atom_ext.custom_atom = ATOM_get_transaction_custom_atom(
                simics_transaction);
        tlm_transaction-&gt;set_extension(&amp;custom_atom_ext);
    }

    // We should use a pool to support multiple async transactions
    CustomExtension custom_atom_ext;
};
</code></pre>
<p>In the opposite direction, the logic of creating Simics custom atoms from TLM extensions should be implemented in the overloaded <code>add_custom_atoms</code> method. The method is called before sending it to the Simics <code>transaction</code> interface. Example showing this conversion:</p>
<pre><code>// Custom Tlm2Simics Gasket that handles the custom atom
class CustomTlm2SimicsTransaction : public scl::tlm2simics::Transaction {
    void add_custom_atoms(const tlm::tlm_generic_payload *tlm_transaction,
                          std::vector&lt;atom_t&gt; *atoms) override {
        CustomExtension *custom_atom_ext = nullptr;
        tlm_transaction-&gt;get_extension&lt;CustomExtension&gt;(custom_atom_ext);
        if (custom_atom_ext) {
            atoms-&gt;push_back(ATOM_custom_atom(custom_atom_ext-&gt;custom_atom));
        }
    }
};
</code></pre>
<h4 id="connecting-systemc-and-simics-models.html:asynchronous-completion"><a href="#connecting-systemc-and-simics-models.html:asynchronous-completion">4.9.1.4 Asynchronous Completion</a></h4>
<p>Transactions can be completed asynchronously, provided that the initiator supports it.</p>
<p>When Simics side initiates a transaction, the <code>simics2tlm::Transaction</code> sends it over to the SystemC side through the blocking transport interface(See <a class="reference" href="#connecting-systemc-and-simics-models.html:non-blocking-transport-interface">4.9.1.5</a> for how to connect it to non-blocking transport interface). The SystemC side could call <code>wait</code> to simulate the delay in returning data. For synchronous transaction calls, this blocks the Simics simulation until the data is returned. See <a class="reference" href="#execution-of-systemc-models-in-the-simics-simulator.html">6</a> for more details.</p>
<p>For transactions that can be completed asynchronously, i.e. where the initiator has issued a transaction with a completion callback, the transaction is automatically deferred by the gasket when <code>wait</code> is called from the SystemC side. This allows the gasket to return immediately back to Simics. Later when SystemC runs and the data is returned from the <code>b_transport</code> function, the gasket sends the data back to Simics by invoking the completion callback registered on the Simics initiator.</p>
<p>When SystemC side initiates a transaction into Simics it can only be deferred if the non-blocking transport has been used. The <code>nb_transport_fw</code> function sends the transaction to the Simics side. When the transaction is deferred, <code>tlm::TLM_ACCEPTED</code> is returned. The response data is later sent via the <code>nb_transport_bw</code> function defined on the SystemC initiator.</p>
<h4 id="connecting-systemc-and-simics-models.html:non-blocking-transport-interface"><a href="#connecting-systemc-and-simics-models.html:non-blocking-transport-interface">4.9.1.5 Non-blocking transport interface</a></h4>
<p>The non-blocking transport interface cannot directly connect with the Simics gaskets. A converter is needed in between to bridge a blocking transport interface to a non-blocking one. Simics does not provide such converter. User can either write own converter or use the convenience sockets from <code>tlm_utils</code>. For example, In SystemC/TLM, the <code>simple_target_socket</code> provides built-in support for converting blocking to non-blocking behavior. Please refer to the chapter <em>Convenience sockets</em> of <em>OSCI TLM-2.0 language reference manual</em> for more details.</p>
<h3 id="connecting-systemc-and-simics-models.html:pcie-gasket"><a href="#connecting-systemc-and-simics-models.html:pcie-gasket">4.9.2 PCIe Gasket</a></h3>
<p>Simics contains a model of the widely used PCIe. SystemC Library provides the <em>PCIe gasket</em> enabling users to connect PCIe endpoints or PCIe multifunction endpoints written in SystemC to the Simics PCIe. The gasket is implemented by <code>composite::PcieGasket</code> class which is defined in <code>simics/systemc/composite/pcie_gasket.h</code> file. See <a href="../pcie-in-simics/high-level-design.html">PCIe Modeling Library</a> for high-level description of how PCIe is implemented in Simics.</p>
<p>To use the gasket the <code>Adapter</code> class must be derived from the <code>composite::PcieGasket</code> class, and the gasket must be initialized with a pointer to the <code>Adapter</code> instance.</p>
<p>The main <code>connect</code> function of the <code>composite::PcieGasket</code> class, which takes the device as a parameter, binds device sockets to a set of helper gaskets used by the PCIe gasket internally. Refer to <code>sample-tlm2-pcie-device</code> module which demonstrates how the PCIe gasket is used.</p>
<p>Inside the gasket the connection is performed with the help of <code>PcieMappingInterconnect</code> class. The class is intended for snooping write accesses to configuration registers and updating Simics specific mapping of the device in PCIe memory/IO address space. The class also removes the corresponding mapping upon receiving a PCIe reset.</p>
<p>Depending on the PCIe type, different port objects are mapped in the PCIe memory space. There are in total 4 port objects for each PCIe endpoint, port.cfg, port.mem, port.io and port.msg. When being accessed, they forward the transaction to the PCIe endpoint with the corresponding PCIe type.</p>
<h4 id="connecting-systemc-and-simics-models.html:systemc-pcie-device-interfaces"><a href="#connecting-systemc-and-simics-models.html:systemc-pcie-device-interfaces">4.9.2.1 SystemC PCIe Device Interfaces</a></h4>
<p>A SystemC PCIe device, connected to the PCIe port via the PCIe gasket, must implement the following interfaces:</p>
<ul>
<li><code>PcieDeviceQueryInterface</code></li>
<li><code>PcieBaseAddressRegisterQueryInterface</code></li>
<li><code>PcieResetInterface</code></li>
</ul>
<p>The <code>PcieDeviceQueryInterface</code> interface exposes a set of sockets and is shown below:</p>
<pre><code>class PcieDeviceQueryInterface {
  public:
    virtual ~PcieDeviceQueryInterface() = default;

    // A multi-function device should pass a multi_passthrough_target_socket
    // for the config space of all functions, and that each function is
    // connected to this target socket in ascending id order.
    virtual sc_core::sc_object *getConfigTargetSocket() = 0;
    // Returns the target socket to receive PCIe message
    virtual sc_core::sc_object *getMsgTargetSocket() = 0;
    // Returns the initiator socket to send upstream transaction
    virtual sc_core::sc_object *getPcieMapInitiatorSocket() = 0;
};
</code></pre>
<p>The <code>getConfigTargetSocket</code> function must return a target socket intended to receive downstream transactions to the PCIe configuration space. The transactions are forwarded from Simics to SystemC via Simics-to-TLM <code>transaction</code> gasket used by the PCIe gasket. In case of multi-function PCIe device the function must return the multi-passthrough target socket. This socket, bound to the initiator socket(s) of the <code>transaction</code> gasket, will get transactions for all functions. Sequential IDs of the initiator sockets correspond to ordered numbers of the valid device functions. For example, functions 0, 3 and 5 of a multi-function device will get the transactions from initiator sockets 0, 1 and 2 correspondingly.</p>
<p>The <code>getMsgTargetSocket</code> function must return a target socket intended to receive downstream transactions to the PCIe message space. The transactions are forwarded from Simics to SystemC via Simics-to-TLM <code>transaction</code> gasket used by the PCIe gasket.</p>
<p>The <code>getPcieMapInitiatorSocket</code> function must return an initiator socket intended to send upstream transactions to the upstream port. In the PCIe gasket the transactions are translated to the <code>transaction</code> and <code>pcie_map</code> interface calls using the TLM-to-Simics <code>PcieTransaction</code> gasket. The device is supposed to use the <code>PcieTlmExtension</code> and <code>PcieMapExtension</code> extensions attached to the TLM payload correspondingly.</p>
<div class="note">
<p>A TLM payload sent without the <code>PcieTlmExtension</code> and <code>PcieMapExtension</code> extensions will be dropped by the PCIe gasket.</p>
</div>
<p>Upon SW writing to configuration registers that control access to device IO/memory space (BARs and Command register) or upon a PCIe reset, the PCIe gasket automatically updates or removes device mappings in Simics. This is performed via invocation of the <code>add_map</code> or <code>del_map</code> functions of the <code>pcie_map</code> interface.</p>
<p>The gasket snoops accesses to standard BARs (BAR0-5) and Expansion ROM BAR as defined by Type 0 PCIe Headers. Accesses to device specific BARs, and hence the updating or removing of the corresponding mappings in Simics, must be handled by the device. This also includes handling the PCIe reset correctly for the device specific BARs.</p>
<p>To perform reads from or writes to the Simics PCIe the device should use the TLM payload with <code>PcieTlmExtension</code> extension. Note that access type (i.e. read or write), transaction address, data and size must be encoded in the TLM payload. Refer to <code>sample-tlm2-pcie-device</code> module for an example.</p>
<p>The device exposes the memory/IO target sockets as well as the BARs data with the help of <code>PcieBaseAddressRegisterQueryInterface</code> interface shown below:</p>
<pre><code>class PcieBaseAddressRegisterQueryInterface {
  public:
</code></pre>
<pre><code>    struct PCIeBar {
        int function;  ///&lt; Function number of the device
        int offset;  ///&lt; BAR offset in Configuration Space Header
        bool is_memory;  ///&lt; If it is a Memory BAR?
        bool is_64bit;  ///&lt; For memory BAR, is it 64-bit or 32-bit?
        int size_bits;  ///&lt; Size of BAR, in number of bits
        sc_core::sc_object *target_socket;  ///&lt; Where to direct the access
    };
    </code></pre>
<pre><code>    virtual std::vector&lt;PCIeBar&gt; getBarInfo() = 0;
};
</code></pre>
<p>The <code>getBarInfo</code> function must return the <code>PCIeBar</code> configuration which includes the associated target socket for each implemented BAR.</p>
<p>The <code>PCIeResetInterface</code> interface handles different kinds of PCIe reset including warm reset, hot reset and function level reset.</p>
<h3 id="connecting-systemc-and-simics-models.html:multiple-gaskets-bind-to-one-systemc-tlm2-initiator-socket"><a href="#connecting-systemc-and-simics-models.html:multiple-gaskets-bind-to-one-systemc-tlm2-initiator-socket">4.9.3 Multiple Gaskets bind to one SystemC TLM2 initiator socket</a></h3>
<p>The SystemC to Simics gasket is used when a SystemC device is sending data over to a Simics object (See <a class="reference" href="#connecting-systemc-and-simics-models.html:systemc-to-simics">4.6.2</a>). One SystemC TLM2 initiator socket can bind to either one Simics tlm2simics gasket or multiple of them.</p>
<p>To bind one SystemC TLM2 initiator socket to multiple tlm2simics gaskets it is necessary to:</p>
<ul>
<li>Create an instance of the tlm-gasket for each interface type and bind it to the SystemC TLM2 initiator socket using the <code>tlm2simics::createMultiGasket</code> factory function.</li>
<li>Then, assign the tlm-gasket to the gasket with the help of <code>set_gasket</code> method of the gasket class as before.</li>
<li>Next, add corresponding connectors, which wrap gaskets, as members of the <code>Adapter</code> class:
<ul>
<li>The default connector should be reserved for gasket without extensions (for example, tlm2simics::Transaction) if any. Wrap the gasket with the <code>Connector</code> class.</li>
<li>Wrap the rest of the gaskets with the <code>ConnectorProxy</code> class and pass the pointer to the default connector when constructing the connectors.</li>
</ul>
</li>
<li>Finally, register only the default connector as a Simics attribute on the configuration class.</li>
</ul>
<p>An example that uses one initiator socket to send both PcieTransaction and PcieMap is shown below:</p>
<pre><code>namespace scl = simics::systemc;
class sample_one_initiator_multiple_tlm2simics_gaskets : public scl::Adapter {
  public:
    explicit sample_one_initiator_multiple_tlm2simics_gaskets(
        simics::ConfObjectRef o)
        : scl::Adapter(o),
          dut_(this, "TLM2Device") {
        simics_transaction_target_-&gt;set_gasket(
            scl::tlm2simics::createMultiGasket(&amp;dut_-&gt;init_socket_, o));
        simics_pcie_map_target_-&gt;set_gasket(
            scl::tlm2simics::createMultiGasket(&amp;dut_-&gt;init_socket_, o));
    }

    static void init_class(simics::ConfClass *cls) {
        cls-&gt;add(simics::Attribute(
                     "upstream_target", "o|n",
                     "The PCIe upstream target to connect to.",
                     ATTR_CLS_VAR(
                         sample_one_initiator_multiple_tlm2simics_gaskets,
                         simics_transaction_target_)));
    }

    scl::Connector&lt;scl::tlm2simics::PcieTransaction&gt; simics_transaction_target_;
    scl::ConnectorProxy&lt;scl::tlm2simics::PcieMap&gt; simics_pcie_map_target_ {
        &amp;simics_transaction_target_
    };
    // TLM2 device implementation by SystemC/TLM
    scl::Device&lt;TLM2Device&gt; dut_;
};
</code></pre>
<h3 id="connecting-systemc-and-simics-models.html:pcie-gasket-port"><a href="#connecting-systemc-and-simics-models.html:pcie-gasket-port">4.9.4 PCIe gasket port</a></h3>
<p>For a device that includes multiple PCIe ports, each port can be instantiated from the <code>composite::PcieGasket</code> class. The same <code>connect</code> function is utilized to link the PCIe sockets to the PCIe gasket. However, the creation of map helper objects should be postponed until the finalize phase. Please refer to the example code below.</p>
<pre><code>    class PciePort : public simics::Port&lt;test_sc_pcie_port_adapter&gt;,
                     public scl::composite::PcieGasket&lt;&gt; {
      public:
        explicit PciePort(simics::ConfObjectRef o)
            : Port(o),
              PcieGasket(parent(), o) {
            PcieGasket::connect(parent()-&gt;duts_.at(index()).pointer());
        }

        void finalize() override {
            // Delay the creation of map helper in here as it cannot be created
            // in connect() during construction
            PcieGasket::createCfgMapHelper();
        }
    };
    </code></pre>
</section><section class="page" id="overview_of_systemc_features.html"><h1 id="overview_of_systemc_features.html:overview-of-systemc-features"><a href="#overview_of_systemc_features.html:overview-of-systemc-features">5 Overview of SystemC Features</a></h1>
<p>This section outlines some of the Simics features that are available when running SystemC models in Simics.</p>
<p>In Simics the SystemC scheduler runs under the control of the Simics framework, meaning that simulation can be started and stopped using the Simics GUI or normal Simics commands such as <code>continue</code> or <code>stop</code>.</p>
<p>All SystemC objects, derived from <code>sc_object</code> class, are visible in Simics as configuration objects. This means that it is possible to interact with the objects from the Simics CLI.</p>
<p>The creation of these objects is controlled by the <code>create_proxy_objects</code> attribute of the adapter. If set to <code>false</code>, no objects are created. This is useful in very large systems that would end up consuming too much memory if all SystemC objects are exposed as Simics objects.</p>
<div class="note">
<p>If some SystemC object is not visible in Simics, check that all the following conditions apply:</p>
<ol>
<li>
<p>The name complies to the recommendation of IEEE 1666-2011 5.17 which is also a requirement for naming Simics objects. Non-compliant names are transformed and the Simics object created under Adapter.renamed using the corresponding hierarchy. Invalid characters are escaped with _0x and replaced with the ASCII value in hex. E.g: a.b.test[A] becomes renamed.a.b.test_0x5B_A_0x5D_</p>
</li>
<li>
<p>The object is not dynamic, as stated in section <a class="reference" href="#overview_of_systemc_features.html:dynamic-systemc-objects">5.3.2.1</a>;</p>
</li>
</ol>
</div>
<div class="note">
<p>Use <code>help SystemC</code> to get a list of all supported SystemC CLI commands. And use <code>help</code> on selected command to get detail information.</p>
</div>
<p>Typical operations available on SystemC objects are enabling tracing or breakpoints on sockets and signals. In addition, normal Simics commands work as expected. For example, to find all SystemC ports the command <code>list-objects</code> can be used with sc_port as the <em>type</em> argument.</p>
<pre><code class="language-simics">simics&gt; <strong>list-objects -show-port-objects iface=sc_port</strong>
┌─────────────────────────────────────────────────────┬────────────────────────────────────────────────────────────────────────────────────┐
│                       Object                        │                                       Class                                        │
├─────────────────────────────────────────────────────┼────────────────────────────────────────────────────────────────────────────────────┤
│lt.dut.m_at_and_lt_target_1.memory_socket_1_port_0   │&lt;lt_example_sc_port&gt;                                                                │
│lt.dut.m_bus.simple_initiator_socket_tagged_0        │&lt;lt_example_tlm_initiator_socket_dut_m_bus_simple_initiator_socket_tagged_0&gt;        │
│lt.dut.m_bus.simple_initiator_socket_tagged_1        │&lt;lt_example_tlm_initiator_socket_dut_m_bus_simple_initiator_socket_tagged_1&gt;        │
│lt.dut.m_bus.simple_target_socket_tagged_0_port_0    │&lt;lt_example_sc_port&gt;                                                                │
│lt.dut.m_bus.simple_target_socket_tagged_1_port_0    │&lt;lt_example_sc_port&gt;                                                                │
│lt.dut.m_initiator_1.m_initiator.initiator_socket    │&lt;lt_example_tlm_initiator_socket_dut_m_initiator_1_m_initiator_initiator_socket&gt;    │
│lt.dut.m_initiator_1.m_initiator.initiator_socket_opt│&lt;lt_example_tlm_initiator_socket_dut_m_initiator_1_m_initiator_initiator_socket_opt&gt;│
│lt.dut.m_initiator_1.m_initiator.port_0              │&lt;lt_example_sc_port&gt;                                                                │
│lt.dut.m_initiator_1.m_initiator.port_1              │&lt;lt_example_sc_port&gt;                                                                │
│lt.dut.m_initiator_1.m_traffic_gen.port_0            │&lt;lt_example_sc_port&gt;                                                                │
│lt.dut.m_initiator_1.m_traffic_gen.port_1            │&lt;lt_example_sc_port&gt;                                                                │
│lt.dut.m_initiator_1.top_initiator_socket            │&lt;lt_example_tlm_initiator_socket_dut_m_initiator_1_top_initiator_socket&gt;            │
│lt.dut.m_initiator_2.m_initiator.initiator_socket    │&lt;lt_example_tlm_initiator_socket_dut_m_initiator_2_m_initiator_initiator_socket&gt;    │
│lt.dut.m_initiator_2.m_initiator.initiator_socket_opt│&lt;lt_example_tlm_initiator_socket_dut_m_initiator_2_m_initiator_initiator_socket_opt&gt;│
│lt.dut.m_initiator_2.m_initiator.port_0              │&lt;lt_example_sc_port&gt;                                                                │
│lt.dut.m_initiator_2.m_initiator.port_1              │&lt;lt_example_sc_port&gt;                                                                │
│lt.dut.m_initiator_2.m_traffic_gen.port_0            │&lt;lt_example_sc_port&gt;                                                                │
│lt.dut.m_initiator_2.m_traffic_gen.port_1            │&lt;lt_example_sc_port&gt;                                                                │
│lt.dut.m_initiator_2.top_initiator_socket            │&lt;lt_example_tlm_initiator_socket_dut_m_initiator_2_top_initiator_socket&gt;            │
│lt.dut.m_lt_target_2.memory_socket_2_opt_port_0      │&lt;lt_example_sc_port&gt;                                                                │
│lt.dut.m_lt_target_2.memory_socket_2_port_0          │&lt;lt_example_sc_port&gt;                                                                │
└─────────────────────────────────────────────────────┴────────────────────────────────────────────────────────────────────────────────────┘
</code></pre>
<p>SystemC signals and TLM2 sockets can be traced or have breakpoints attached to them. Please refer to section <a class="reference" href="#overview_of_systemc_features.html:systemc-library-tools">5.3</a> for more information about trace and break on SystemC objects.</p>
<p>For example, a transaction break-point can be set on a target socket as shown below.</p>
<pre><code class="language-simics">simics&gt; <strong>lt.dut.m_lt_target_2.memory_socket_2.break-sc</strong>
simics&gt; <strong>c</strong>
[lt.dut.m_lt_target_2.memory_socket_2 break-b-in] write sz:4 addr:0x0 data:0xefffffff
[lt.dut.m_lt_target_2.memory_socket_2 break-b-out] write sz:4 addr:0x0 data:0xefffffff status:TLM_OK_RESPONSE
[lt.dut.m_lt_target_2.memory_socket_2 break-b-in] write sz:4 addr:0x0 data:0xefffffff
[lt.dut.m_lt_target_2.memory_socket_2 break-b-out] write sz:4 addr:0x0 data:0xefffffff status:TLM_OK_RESPONSE
simics&gt; <strong></strong>
</code></pre>
<p>In order to reduce the message length, Simics shortens common SystemC terminology. For instance, in the example above "b_in" refers to an inbound blocking transaction. The table below summarizes all the abbreviations.</p>
<table><thead><tr><th><strong>Simics</strong></th><th><strong>SystemC</strong></th></tr></thead><tbody>
<tr><td>b</td><td>blocking</td></tr>
<tr><td>nb</td><td>non-blocking</td></tr>
<tr><td>in</td><td>inbound</td></tr>
<tr><td>out</td><td>outbound</td></tr>
<tr><td>fw</td><td>forward</td></tr>
<tr><td>bw</td><td>backwards</td></tr>
</tbody></table>
<p>When a new socket type/protocol is used, it is necessary to register the type/protocol with the awareness framework. If it is not registered the commands <code>trace-sc</code> and <code>break-sc</code> will not be available for the new socket. As an example, for a socket that uses width 64 and protocol "MyProtocol", it is necessary to register the socket calling the function <code>registerSocketType&lt;64, MyProtocol&gt;()</code>.</p>
<div class="note">
<p>Tracing and breaking has certain limitations. Please refer to chapter <a class="reference" href="#limitations.html">7</a>.</p>
</div>
<h2 id="overview_of_systemc_features.html:logging"><a href="#overview_of_systemc_features.html:logging">5.1 Logging</a></h2>
<p>SystemC Library implements report handler which forwards SystemC reports to Simics according to <code>sc_report</code> actions. Since SystemC does not have the concept of objects attached to log messages, all messages will be printed on the top-level <code>Adapter</code> object in Simics. It is possible to control SystemC logging level using <code>log-level</code> command on the <code>Adapter</code> object. Also, all the normal Simics logging commands, such as <code>log-setup</code>, <code>log-type</code>, work.</p>
<p>Simics performs a mapping from SystemC log concepts such as verbosity and severity into Simics concepts. The <code>sc_report</code> actions work as defined by IEEE-1666 standard. The most important mapping is the one from the SystemC verbosity to the Simics log-level, as shown in the table below:</p>
<table><thead><tr><th><strong>Simics log-level</strong></th><th><strong>SystemC verbosity</strong></th></tr></thead><tbody>
<tr><td>1</td><td>verbosity &lt; SC_MEDIUM</td></tr>
<tr><td>2</td><td>SC_MEDIUM ≤ verbosity &lt; SC_HIGH</td></tr>
<tr><td>3</td><td>SC_HIGH ≤ verbosity &lt; SC_DEBUG</td></tr>
<tr><td>4</td><td>SC_DEBUG ≤ verbosity</td></tr>
</tbody></table>
<p>Log messages map to the <em>info</em> category in Simics, unless the severity is greater than SC_WARNING, in which case the <em>error</em> category is used. It is also possible to emit <em>unimplemented</em> and <em>spec-violation</em> log categories by ending the message type with "unimplemented" or "unimpl", or "spec-violation" or "spec-viol", respectively. However, a severity greater than SC_WARNING will always generate an <em>error</em> log.</p>
<pre><code class="language-simics">simics&gt; <strong>lt.log-level level = 3</strong>
[lt] Changing log level: 1 -&gt; 3
simics&gt; <strong>bp.log.break object = lt</strong>
simics&gt; <strong>c</strong>
[lt info] 0 s - traffic_generator_thread
      Initiator: 101 Starting Traffic @ 0 s of traffic_generator.cpp in traffic_generator.cpp:114
[lt info] 0 s - traffic_generator_thread
      Initiator: 102 Starting Traffic @ 0 s of traffic_generator.cpp in traffic_generator.cpp:114
[lt info] 0 s - initiator_thread
      Initiator: 101 b_transport(GP, 0 s) @ 0 s of lt_initiator.cpp in lt_initiator.cpp:124
[lt info] 0 s - print
      ID: 201 COMMAND: WRITE Length: 04
      Addr: 0x0000000000000000 Data: 0x00000000 @ 0 s of memory.cpp in report.cpp:189
[lt info] 0 s - b_transport
      Target: 201 returned delay of 0 s + 20 ns + 60 ns = 80 ns @ 0 s of at_target_1_phase.cpp in at_target_1_phase.cpp:111
[lt info] 0 s - initiator_thread
      Initiator: 101 b_transport returned delay = 80 ns @ 0 s of lt_initiator.cpp in lt_initiator.cpp:145
[lt info] 0 s - initiator_thread
      Initiator: 102 b_transport(GP, 0 s) @ 0 s of lt_initiator.cpp in lt_initiator.cpp:124
[lt info] 0 s - print
      ID: 201 COMMAND: WRITE Length: 04
      Addr: 0x0000000000000000 Data: 0x00000000 @ 0 s of memory.cpp in report.cpp:189
[lt info] 0 s - b_transport
      Target: 201 returned delay of 0 s + 20 ns + 60 ns = 80 ns @ 0 s of at_target_1_phase.cpp in at_target_1_phase.cpp:111
[lt info] 0 s - initiator_thread
      Initiator: 102 b_transport returned delay = 80 ns @ 0 s of lt_initiator.cpp in lt_initiator.cpp:145
[lt] Breakpoint 1: lt log message of type &lt;all&gt;
[lt] Breakpoint 1: lt log message of type &lt;all&gt;
[lt] Breakpoint 1: lt log message of type &lt;all&gt;
[lt] Breakpoint 1: lt log message of type &lt;all&gt;
[lt] Breakpoint 1: lt log message of type &lt;all&gt;
[lt] Breakpoint 1: lt log message of type &lt;all&gt;
[lt] Breakpoint 1: lt log message of type &lt;all&gt;
[lt] Breakpoint 1: lt log message of type &lt;all&gt;
simics&gt; <strong></strong>
</code></pre>
<p>SystemC Library allows breaking simulation on SystemC log messages, which is enabled by <code>bp.log.break</code> command. It should be noted that Simics does not break immediately on the first log message, but rather after several log messages have been printed. This is because a "break" in Simics corresponds to stopping virtual time. All the log messages above were printed at the same virtual time, and thus there is no way to stop until all messages have been printed and virtual time is ready to move on. To understand what is going on between the various log messages, source level debugging is required.</p>
<h3 id="overview_of_systemc_features.html:redirecting-custom-api-logs"><a href="#overview_of_systemc_features.html:redirecting-custom-api-logs">5.1.1 Redirecting Custom API Logs</a></h3>
<p>Logs using <code>sc_report</code> are automatically integrated with the Simics logging system. However, since <code>sc_report</code> has some issues of its own it is common that SystemC developers have their own logging API or resort to using plain <code>std::cout</code>. While the use of standard streams for logging is highly discouraged this sections explains how to redirect these logs to Simics.</p>
<p>If a custom log API is being used, it is often possible to enable it to support multiple front ends. One simple approach is to specialize it to work in Simics using the standard set of <code>SIM_log*</code> functions, as described in the <em>API Reference Manual</em>. If the log API works with streams Simics provides a convenience class called <code>LogStream</code> that can be used. The convenience class has the following signature:</p>
<pre><code> template&lt;log_type_t Type = Sim_Log_Info,
         unsigned Level = 1,
         int Groups = 0&gt;
class LogStream : public std::ostream {
  public:
    explicit LogStream(ConfObjectRef log_obj)

 ... 
</code></pre>
<p>It is possible to use multiple <code>LogStream</code> objects to map different types of output to different Simics log-types, log-levels, and log-groups. The streams can be used wherever the logging API outputs to a <code>std::ostream</code> object and the log will automatically be turned into a Simics log message with the appropriate type, level, and group.</p>
<p>The <code>LogStream</code> can also be used to redirect standard streams, for example <code>std::cout</code>. This is done by replacing the stream's <code>streambuf</code> with the <code>streambuf</code> of the Simics <code>LogStream</code> as is shown in the example below.</p>
<pre><code>#include &lt;simics/systemc/awareness/log.h&gt;

class CoutRedirect : public simics::ConfObject {
  public:
    explicit CoutRedirect(simics::ConfObjectRef o)
        : simics::ConfObject(o),
          simLog_(o) {
        std::cout.rdbuf(simLog_.rdbuf());
    }

    static void init_class(simics::ConfClass *cls);

  private:
    void print_a_log() const {
        std::cout &lt;&lt; "Print a simple message to std::cout" &lt;&lt; std::flush;
    }

    simics::LogStream&lt;Sim_Log_Info, 2&gt; simLog_;

};
</code></pre>
<h2 id="overview_of_systemc_features.html:systemc-signal-read-and-write"><a href="#overview_of_systemc_features.html:systemc-signal-read-and-write">5.2 SystemC Signal Read and Write</a></h2>
<p>SystemC Library has support for read and write of SystemC signals <code>sc_signal</code>, <code>sc_in</code>, <code>sc_out</code>, and <code>sc_inout</code>. A signal's value can be read by invoking the Simics interface <code>sc_signal_read</code> on the signal object.</p>
<p>There is a second Simics interface, <code>sc_signal_write</code>, which is used to write a value to the signal object. Based on the type of signal, either the <code>sc_signal_read</code>, <code>sc_signal_write</code>, or both interfaces are implemented by the object.</p>
<div class="note">
<p>When writing a value to the signal object, the value will be updated during the next SystemC cycle. From the command line, simply invoke <code>c 1</code> will update the signal object's value.</p>
</div>
<p>SystemC signals use a template parameter that specifies the underlying value-type of the signal. This allows to use arbitrary classes as value-types. The current implementation directly supports the following value-types:</p>
<ul>
<li>bool</li>
<li>int8_t</li>
<li>int16_t</li>
<li>int32_t</li>
<li>int64_t</li>
<li>uint8_t</li>
<li>uint16_t</li>
<li>uint32_t</li>
<li>uint64_t</li>
<li>sc_time</li>
</ul>
<p>To support SystemC signals with a value-type not listed above, <code>simics::systemc::ScSignalAccessTemplate</code> needs to be implemented.</p>
<p>To activate support for the additional type, the template class needs to be instantiated. This is required to register the support for the new value-type in the infrastructure. One possibility is to declare it as a member variable of the Adapter.</p>
<p>Below is an example that shows the required steps to support signals with a value-type of <code>sc_dt::sc_bigint&lt;1024&gt;</code>.</p>
<pre><code> class BigInt1024Access
    : public simics::systemc::ScSignalAccessTemplate&lt;sc_dt::sc_bigint&lt;1024&gt; &gt; {
  public:
    bool attrToValueT(const attr_value_t *attr,
                      sc_dt::sc_bigint&lt;1024&gt; *value) const {
        const char *str = NULL;
        if (!attrToValue(attr, &amp;str))
            return false;

        *value = str;
        return true;
    }

    attr_value_t valueToAttrT(const sc_dt::sc_bigint&lt;1024&gt; &amp;value) const {
        std::string str = value.to_string();
        return valueToAttr(str.c_str());
    }
};


class Adapter : public scl::Adapter
[...]
    BigInt1024Access big_int_1024_access_;
[...]
</code></pre>
<p>The function <code>attrToValueT</code> implements the transformation from a Simics <code>attr_value_t</code> to the signal's value-type. If the transformation can not be performed, <code>false</code> must be returned, otherwise <code>true</code>.</p>
<p>The template class provides <code>attrToValue</code> functions to transform from <code>attr_value_t</code> to:</p>
<ul>
<li>bool</li>
<li>int64_t</li>
<li>int32_t</li>
<li>int16_t</li>
<li>int8_t</li>
<li>long long unsigned int</li>
<li>uint64_t</li>
<li>uint32_t</li>
<li>uint16_t</li>
<li>uint8_t</li>
<li>double</li>
<li>const char *</li>
</ul>
<p>The function <code>valueToAttrT</code> is used to transform from the SystemC signal value-type to a <code>attr_value_t</code>. The template class provides transformation for the the same types as listed above.</p>
<h2 id="overview_of_systemc_features.html:systemc-library-tools"><a href="#overview_of_systemc_features.html:systemc-library-tools">5.3 SystemC Library Tools</a></h2>
<p>SystemC Library comes with a variety of tools that use the Simics instrumentation framework and interact with the SystemC objects. For generic information on how Simics instrumentation framework works please refer to the chapter in
<a href="../analyzer-user-guide/index.html">Analyzer User's Guide</a></p>
<h3 id="overview_of_systemc_features.html:supported-systemc-objects"><a href="#overview_of_systemc_features.html:supported-systemc-objects">5.3.1 Supported SystemC Objects</a></h3>
<p>The following table shows the different kinds of SystemC objects and when they interact with the SystemC Library tools:</p>
<table><thead><tr><th><strong>SystemC object</strong></th><th><strong>Event</strong></th></tr></thead><tbody>
<tr><td><code>sc_event</code></td><td>an event is notified</td></tr>
<tr><td><code>SC_METHOD</code></td><td>a method process is triggered</td></tr>
<tr><td><code>SC_THREAD</code></td><td>a thread process is triggered or resumed</td></tr>
<tr><td><code>tlm_initiator_socket</code></td><td>a TLM initiator socket method is called</td></tr>
<tr><td><code>tlm_target_socket</code></td><td>a TLM target socket method is called</td></tr>
<tr><td><code>sc_signal</code></td><td>a signal's value is changed</td></tr>
<tr><td><code>sc_in/sc_out/sc_inout</code></td><td>a port's value is changed</td></tr>
</tbody></table>
<h3 id="overview_of_systemc_features.html:using-the-tools"><a href="#overview_of_systemc_features.html:using-the-tools">5.3.2 Using the Tools</a></h3>
<p>There are two different ways to use the tools and their provided functionality. The user could use the Simics commands registered on the SystemC objects. These commands are tool-specific both in terms of functionality and usage. They automatically create an instrumentation tool for internal use by the commands. The user should avoid using this tool directly.</p>
<p>When using trace and break tools, existing DMI tables are automatically invalidated and the DMI hint is suppressed. When all tools have been removed, DMI hint is no longer suppressed - allowing the initiator to build up a new DMI table if supported.</p>
<p>In the following example, by invoking the command <code>trace-sc</code> on the SystemC target socket, an internal instrumentation tool is created and connected to the target socket. It traces the invocation of any socket method.</p>
<pre><code class="language-simics">simics&gt; <strong>simple.simple_device.target_socket.trace-sc</strong>
Created simple.internal.sc_trace_tool (connected to 1 provider)
</code></pre>
<p>For advanced instrumentation tasks, the user should use the Simics instrumentation framework directly. This makes it possible to use more tool features. It is, for example, possible to create a tool that only traces a certain event or method invocation. Other tools with different filtering options can of course be instantiated and operated in parallel.</p>
<p>The commands bound to the SystemC objects are covered in the tool specific sections below. The remainder of this section shows how the tools provided with SystemC Library can be used.</p>
<p>In the following example, a new trace tool is created that traces all supported SystemC objects. To avoid mixing different C++ ABIs, the standard SystemC tools are built together with the adapter as part of building the corresponding Simics module. The default name of the tool if not provided is prefixed with the module's name. For readability it is recommended to create the tool as a sub-object of the adapter instead, as shown by the example below, whenever that makes sense.</p>
<p>When using trace and break tools, existing DMI tables are automatically invalidated and the DMI hint is suppressed. When all tools have been removed, DMI hint is no longer suppressed - allowing the initiator to build up a new DMI table if supported.</p>
<pre><code class="language-simics">simics&gt; <strong>simple.new-sc-trace-tool -connect-all name=simple.trace_tool</strong>
[simple.gasket_simple_device_target_socket.initiator_socket trace-invalidate-dmi-in] start_addr:0x0 end_addr:0xffffffffffffffff
Created simple.trace_tool (connected to 7 providers)
</code></pre>
<p>The newly created tool can now be disabled, enabled and, if it is of no use anymore, removed. Additional SystemC objects can also be connected and disconnected. All this information is available by invoking the command <code>help</code> on the tool.</p>
<pre><code class="language-simics">simics&gt; <strong>help simple.trace_tool</strong>
</code></pre>
<p>To trace TLM sockets only, the user can instantiate a filter that only matches sockets and add it to the tool. The filter can be removed later to trace all supported objects again. There are four kinds of filters: signal, event, process and socket. All this information is available by invoking <code>help</code> on the <code>new-systemc-filter</code> command.</p>
<pre><code class="language-simics">simics&gt; <strong>new-systemc-filter socket</strong>
Created SystemC filter sc_filter0
simics&gt; <strong>simple.trace_tool.add-filter sc_filter0</strong>
simics&gt; <strong>simple.trace_tool.remove-filter sc_filter0</strong>
</code></pre>
<p>When connecting the tool to objects of socket kind the functions argument can be used to select which TLM2 functions to act on. The functions argument correspond to the methods in the <code>tlm_bw_transport_if</code> and <code>tlm_fw_transport_if</code> interfaces. For each interface method there exists a pair of pre and post functions. The pre function is used to instrument the transaction before it is sent through the socket. The post function is used to instrument the transaction after the invocation of the interface method has been performed.</p>
<p>The functions argument is optional. If omitted, all interface methods are handled by the tool. The argument is ignored and has no effect for connections to other kind of objects.</p>
<p>A summary of all tools and their supported functions can be shown by running:</p>
<pre><code class="language-simics">simics&gt; <strong>help topic = Instrumentation</strong>
</code></pre>
<h4 id="overview_of_systemc_features.html:dynamic-systemc-objects"><a href="#overview_of_systemc_features.html:dynamic-systemc-objects">5.3.2.1 Dynamic SystemC Objects</a></h4>
<p>SystemC allows to create and delete processes and events dynamically during simulation. Due to their dynamic nature, these objects do not have dedicated Simics configuration objects. Instead, they are grouped together and have one shared object for each type that can be used by the tools.</p>
<p><code>&lt;adapter&gt;.sc_event_all_dynamic</code> can be used to connect tools to all dynamic <code>sc_event</code> objects.</p>
<p><code>&lt;adapter&gt;.sc_process_all_dynamic</code> can be used to connect tools to all dynamic <code>SC_METHOD</code> or <code>SC_THREAD</code> objects.</p>
<p>The commands <code>trace-sc</code>, <code>untrace-sc</code>, <code>break-sc</code>, and <code>unbreak-sc</code> can be used on these two Simics configuration objects.</p>
<h3 id="overview_of_systemc_features.html:sc_trace_tool"><a href="#overview_of_systemc_features.html:sc_trace_tool">5.3.3 sc_trace_tool</a></h3>
<p>The <code>sc_trace_tool</code> can be used for tracing any event listed in section <a class="reference" href="#overview_of_systemc_features.html:supported-systemc-objects">5.3.1</a>.</p>
<p>To enable or disable tracing of these events, <code>trace-sc</code> or <code>untrace-sc</code> needs to be invoked on the corresponding SystemC object. See <code>help &lt;sc_provider_controller&gt;.trace-sc</code> and <code>help &lt;sc_provider_controller&gt;.untrace-sc</code> for more information about the commands. Section <a class="reference" href="#overview_of_systemc_features.html">5</a> contains an example of how to enable tracing on a TLM2 socket.</p>
<p>There is also a set of commands that makes it possible to trace and untrace on all objects of a certain kind. These commands are located in the corresponding adapter. The following commands <code>trace-sc-event-all</code>, <code>trace-sc-signal-all</code>, <code>trace-sc-process-all</code>, and <code>trace-sc-socket-all</code> are available for enabling instrumentation and the following commands <code>untrace-sc-event-all</code>, <code>untrace-sc-signal-all</code>, <code>untrace-sc-process-all</code>, and <code>untrace-sc-socket-all</code> are available for disabling instrumentation.</p>
<h3 id="overview_of_systemc_features.html:sc_break_tool"><a href="#overview_of_systemc_features.html:sc_break_tool">5.3.4 sc_break_tool</a></h3>
<p>The <code>sc_break_tool</code> is a tool that can be used to stop the simulation on any event listed in section <a class="reference" href="#overview_of_systemc_features.html:supported-systemc-objects">5.3.1</a>.</p>
<p>To enable or disable break on these events, <code>break-sc</code> or <code>unbreak-sc</code> has to be invoked on the corresponding SystemC object. See <code>help &lt;sc_provider_controller&gt;.break-sc</code> and <code>help &lt;sc_provider_controller&gt;.unbreak-sc</code> for more information about the commands. Section <a class="reference" href="#overview_of_systemc_features.html">5</a> contains an example of how to enable tracing on a TLM2 socket; the break tools works just like trace.</p>
<p>There is also a set of commands that makes it possible to break and unbreak on all objects of a certain kind. These commands are located in the corresponding adapter. The following commands <code>break-sc-event-all</code>, <code>break-sc-signal-all</code>, <code>break-sc-process-all</code>, and <code>break-sc-socket-all</code> are available for enabling instrumentation and the following commands <code>unbreak-sc-event-all</code>, <code>unbreak-sc-signal-all</code>, <code>unbreak-sc-process-all</code>, and <code>unbreak-sc-socket-all</code> are available for disabling instrumentation.</p>
<h3 id="overview_of_systemc_features.html:sc_transaction_tracker_tool"><a href="#overview_of_systemc_features.html:sc_transaction_tracker_tool">5.3.5 sc_transaction_tracker_tool</a></h3>
<p>To simplify debugging of complex SystemC models where multiple TLM transactions are sent between multiple sockets, Simics has a capability to track the path a transaction went through as well as to save the history of the transaction changes which happened when the transaction travelled along the path. This capability is provided by the <em>transaction tracker tool</em> which is based on Simics instrumentation framework.</p>
<p>To track a transaction the tool connects to TLM sockets of the SystemC model and observes all the transactions which are sent between the sockets. The tool adds special TLM extension to each transaction passed through a socket, if the transaction does not have the extension added earlier, and uses the extension to save the transaction history. A new entry, consisting of current transaction attributes and hierarchical name of the socket, is appended to the history when the transaction is passed through the socket. Currently, the only transaction attribute which is saved in the entry is transaction address.</p>
<p>To create and connect the tool to all sockets of the SystemC model one should use adapter's <code>track-transactions-all</code> command. Corresponding <code>untrack-transactions-all</code> command disconnects the tool from all the sockets. One may use <code>track-transactions</code> command of a selected socket to connect the socket to the tool, and <code>untrack-transactions</code> command to disconnect it. Also it is possible to use instrumentation tool commands, such as <code>add-instrumentation</code> or <code>remove-instrumentation</code>, to control connection of the tool to all or selected sockets. Please refer to corresponding <code>help</code> commands or the
<a href="../model-builder-user-guide/instrumentation.html#instrumentation">Instrumentation chapter</a> in the Model Builder User's Guide.</p>
<p>To view the transaction history user should enable GDB pretty printing for TLM transactions. The pretty printer output can be seen in GDB console.</p>
<h3 id="overview_of_systemc_features.html:sc_protocol_checker_tool"><a href="#overview_of_systemc_features.html:sc_protocol_checker_tool">5.3.6 sc_protocol_checker_tool</a></h3>
<p>The <code>sc_protocol_checker_tool</code> is a tool for validation of TLM2 transactions. It checks the transactions sent through sockets and detect those which are not in compliance with the "OSCI TLM-2.0 USER MANUAL".</p>
<div class="note">
<p>The checker is using the Doulos TLM-2.0 Base Protocol Checker of an older version. The checker will be upgraded to a more recent version checking against the IEEE Std 1666-2011 specification.</p>
</div>
<p>The <code>sc_protocol_checker_tool</code> supports <code>tlm_initiator_socket</code> and <code>tlm_target_socket</code> as stated in section <a class="reference" href="#overview_of_systemc_features.html:supported-systemc-objects">5.3.1</a>. This tool does not have commands registered on the SystemC objects.</p>
<p>The protocol checker keeps track of the transaction state before the transaction is sent through a socket and after it returns. It checks all TLM socket methods for possible TLM2 transaction specification violations.</p>
<p>As an example, <code>&lt;adapter&gt;.new-sc-protocol-checker-tool -connect-all</code> can be used to check all sockets in a simulation.</p>
<h3 id="overview_of_systemc_features.html:sc_vcd_trace_tool"><a href="#overview_of_systemc_features.html:sc_vcd_trace_tool">5.3.7 sc_vcd_trace_tool</a></h3>
<p>The <code>sc_vcd_trace_tool</code> generates files based on the VCD format.</p>
<p>As an example, the command <code>&lt;adapter&gt;.new-sc-vcd-trace-tool file = myfile.vcd -connect-all</code> would generate a file in VCD format containing changes for any SystemC object listed in section <a class="reference" href="#overview_of_systemc_features.html:supported-systemc-objects">5.3.1</a> with the exception of type <code>SC_THREAD</code> and <code>SC_METHOD</code>.</p>
<p>During generation, two files are created. One contains the header section with variable definitions and the second file contains the value change section. When Simics ends or the tool is deleted, these two files are merged together into a single file. If this merge can not be performed automatically, it should be sufficient to append the file with the value change section on to the header file. For instance: <code>cat myfile.vcd.tail &gt;&gt; myfile.vcd</code></p>
<h2 id="overview_of_systemc_features.html:systemc-profiling"><a href="#overview_of_systemc_features.html:systemc-profiling">5.4 SystemC Profiling</a></h2>
<p>To aid users in developing well-performing models, Simics offers two ways of profiling SystemC processes. These features encompass a process profiler, that helps users identify performance-heavy processes, and memory profiling, that compiles memory statistics of memory-intensive processes. Details on how to enable and use these features are presented below.</p>
<h3 id="overview_of_systemc_features.html:process-profiler"><a href="#overview_of_systemc_features.html:process-profiler">5.4.1 Process Profiler</a></h3>
<p>The process profiler feature measures wall clock time execution of method- and thread-processes. The feature is disabled by default, but can be enabled on adapters by using the <code>enable-process-profiler</code> command. The feature can be disabled again by using the command <code>disable-process-profiler</code>.</p>
<p>The profiling results can be obtained by using the adapter command <code>process-profiler-results</code>. This command will show the number of processes of each type and the number of calls and total time spent executing them.</p>
<p>If using the <code>status</code> command on a process, more detailed information will be shown. This information will consist of minimum time, maximum time, total time executing and number of calls to the process. For thread processes the number of calls will represent the number of times we yielded to that process.</p>
<p>The <code>clear-process-profiler-results</code> command clears accumulated profiling results. All process profiler data including the aggregated execution time is cleared.</p>
<h3 id="overview_of_systemc_features.html:memory-profiling"><a href="#overview_of_systemc_features.html:memory-profiling">5.4.2 Memory Profiling</a></h3>
<p>Memory profiling is enabled and disabled for each adapter by using the <code>enable-memory-profiler</code> and <code>disable-memory-profiler</code> commands. Memory profiling is disabled by default.</p>
<p>When memory profiling is enabled, Simics will record allocations and deallocations made in underlying processes. Please note that memory profiling has to be enabled for each adapter you wish to profile.</p>
<p>Users may inspect the current memory usage of a process by using the <code>status</code> command on the corresponding object in the awareness object hierarchy. Additionally, the collective memory usage of processes in a module may be inspected by using the <code>status</code> command on that module.</p>
<div class="note">
<p>Memory profiling has certain limitations listed in chapter <a class="reference" href="#limitations.html">7</a>.</p>
</div>
<h2 id="overview_of_systemc_features.html:trigger-systemc-processes"><a href="#overview_of_systemc_features.html:trigger-systemc-processes">5.5 Trigger SystemC Processes</a></h2>
<p>SystemC Library supports unscheduled running of SystemC thread and SystemC method process objects. Two different options are available to run the processes. The first way is to locate the event object that the processes are sensitive to and invoke <code>notify</code> on the event object. This will cause all processes that are sensitive to the event object to be run during the next SystemC cycle. The second option is to locate the SystemC thread or process and invoke <code>run</code> on the object directly. The process will be run during the next SystemC cycle. This implies that <code>SIM_continue()</code> must be invoked before the process is run. From the command line, this corresponds to invoking <code>c 1</code>.</p>
<h2 id="overview_of_systemc_features.html:tlm-injection"><a href="#overview_of_systemc_features.html:tlm-injection">5.6 TLM Injection</a></h2>
<p>Sockets, registered with the awareness framework, provide the Simics <code>sc_tlm_fw_transport</code> and <code>sc_tlm_bw_transport</code> interfaces. The interfaces correspond to the SystemC TLM2 transport interfaces and support injection. The following rules specify the mapping between the Simics interfaces and the SystemC transport interfaces.</p>
<ul>
<li>The <code>attr_value_t</code> are dictionaries with <code>string</code> as key</li>
<li>The keys are based on namespaces to address the designated target</li>
<li>The namespace used for the transaction is <strong>gp</strong></li>
<li>The namespace used for the <code>tlm_dmi</code> descriptor is <strong>dmi</strong></li>
</ul>
<p>For example, injecting a write transaction into a socket could be done as shown below.</p>
<pre><code class="language-simics">simics&gt; <strong>dut.top.simple_initiator_socket_0.trace-sc</strong>
Created dut.internal.sc_trace_tool (connected to 1 provider)
simics&gt; <strong>@socket = dut.top.simple_initiator_socket_0.iface.sc_tlm_fw_transport</strong>
simics&gt; <strong>@socket.b_transport({'gp.command' : 1, 'gp.data_ptr' : (0, 1, 2, 3)}, 0)</strong>
None
simics&gt; <strong>c 1</strong>
[dut.top.simple_initiator_socket_0 trace-b-out] write sz:4 addr:0x0 data:0x03020100
[dut.top.simple_initiator_socket_0 trace-b-in] write sz:4 addr:0x0 data:0x03020100 status:TLM_OK_RESPONSE
simics&gt; <strong></strong>
</code></pre>
<p>The transaction is injected into the socket by invoking <code>b_transport</code> of the <code>sc_tlm_fw_transport</code> interface. To avoid blocking Simics when the interface is called, the transaction is queued up and sent when simulation starts. This is only required for <code>b_transport</code>. All other functions of <code>sc_tlm_fw_transport</code> and <code>sc_tlm_bw_transport</code> execute their side-effects directly. The fields of the <code>tlm_generic_payload</code> are set by building the key prefixed with <strong>gp.</strong>, followed by the name of the setter function. The key <strong>gp.command</strong> addresses the generic payload and invokes <code>set_command</code> on the generic payload. The functions expects a <code>tlm_command</code> enum type when invoked in SystemC. For argument passing, enums are passed as <code>signed integer</code> types. The value 0 reflects a read transaction and 1 corresponds to a write transaction. This is according to the <code>tlm_command</code> enum definition in the SystemC kernel.</p>
<p>To simplify matters, <strong>gp.data_ptr</strong> invokes <code>set_data_ptr</code>, <code>set_data_length</code> and <code>set_streaming_width</code>. The following guidelines should be followed when setting the value of the key-value pair in dictionaries.</p>
<ul>
<li>Pointers to data are set via <code>attr_value_t</code> 'data'</li>
<li>The length of the data is encapsulated by the <code>attr_value_t</code> 'data', and should not be explicitly set</li>
<li>Arrays are set via <code>attr_value_t</code> 'list'</li>
<li>The length of the array is encapsulated by the <code>attr_value_t</code> 'list', and should not be explicitly set</li>
<li>Each extension is set as an attr_value_t 'dict'</li>
<li>For multiple function arguments of different types, use a 'dict'</li>
<li>For multiple function arguments of the same type, use a 'list'</li>
</ul>
<p>Injecting a read transaction into a socket could be done as shown below.</p>
<pre><code class="language-simics">simics&gt; <strong>@socket.b_transport({'gp.command' : 0, 'gp.data_ptr' : (0,) * 4}, 0)</strong>
None
simics&gt; <strong>c 1</strong>
[dut.top.simple_initiator_socket_0 trace-b-out] read sz:4 addr:0x0 data:0x00000000
[dut.top.simple_initiator_socket_0 trace-b-in] read sz:4 addr:0x0 data:0x03020100 status:TLM_OK_RESPONSE
simics&gt; <strong></strong>
</code></pre>
<p>The length of the data to be read is specified by the Python tuple. Because the transaction is sent into the socket at a later point in time, the Simics instrumentation framework is used to display the actual data returned from the <code>b_transport</code> call.</p>
<p>To add an extension to the transaction, additional key-value pairs need to be set in the dictionary associated with the transaction argument. The table below lists the mapping between each namespace and the corresponding SystemC Library extension.</p>
<table><thead><tr><th><strong>Namespace key</strong></th><th><strong>Extension</strong></th></tr></thead><tbody>
<tr><td>ethernet_common</td><td>EthernetCommonExtension</td></tr>
<tr><td>i2c_master_v2</td><td>I2cMasterV2Extension</td></tr>
<tr><td>i2c_slave_v2</td><td>I2cSlaveV2Extension</td></tr>
<tr><td>map_info</td><td>MapInfoExtension</td></tr>
<tr><td>pci_bus</td><td>PciBusExtension</td></tr>
<tr><td>pci_device</td><td>PciDeviceExtension</td></tr>
<tr><td>pci_express</td><td>PciExpressExtension</td></tr>
<tr><td>pci_upstream_operation</td><td>PciUpstreamOperationExtension</td></tr>
<tr><td>serial_device</td><td>SerialDeviceExtension</td></tr>
</tbody></table>
<p>The key-value pairs for the extensions are specific. For details about the valid pairs, please refer to the implementation of the extension injector located in <code>simics/systemc/iface/</code>. One example that demonstrates the inject of a transaction with an <code>EthernetCommonExtension</code> set is shown below.</p>
<pre><code class="language-simics">simics&gt; <strong>@data = tuple(bytearray(b'ABCDEF'))</strong>
simics&gt; <strong>@fraglist = [data[:4], data[4:]]</strong>
simics&gt; <strong>@frame = {'len' : len(data), 'fraglist' : fraglist}</strong>
simics&gt; <strong>@socket.b_transport({'ethernet_common.frame' : {'frame' : frame, 'crc_ok' : 1}}, 0)</strong>
None
simics&gt; <strong>c 1</strong>
[dut.top.simple_initiator_socket_0 trace-b-out] ignore sz:0 addr:0x0
[dut.top.simple_initiator_socket_0 trace-b-in] ignore sz:0 addr:0x0 status:TLM_OK_RESPONSE
</code></pre>
<h3 id="overview_of_systemc_features.html:writing-an-injector-for-a-custom-extension"><a href="#overview_of_systemc_features.html:writing-an-injector-for-a-custom-extension">5.6.1 Writing an Injector for a Custom Extension</a></h3>
<p>To support inject of extensions not provided by SystemC Library, <code>simics::systemc::injection::InjectBase</code> needs to be implemented.</p>
<p>To activate support for the additional injector, the template class needs to be instantiated. This is required to register the support for the new injector in the infrastructure. One possibility is to declare it as a member variable of the Adapter. Below is an example that shows the required steps to support a new extension.</p>
<pre><code> class CustomExtension : public tlm::tlm_extension&lt;CustomExtension&gt; {
  public:
    CustomExtension() : member_a_(0), member_b_(0),
                        member_d_(NULL), member_d_len_(0),
                        member_x_(0), member_y_(0) {}
    virtual tlm::tlm_extension_base *clone() const {
        return new CustomExtension(*static_cast&lt;const CustomExtension *&gt;(this));
    }
    virtual void copy_from(tlm::tlm_extension_base const &amp;extension) {
        *this = static_cast&lt;const CustomExtension &amp;&gt;(extension);
    }
    void set_member_b(uint8_t member) {
        member_b_ = member;
    }
    void set_xy(uint8_t x, int8_t y) {
        member_x_ = x;
        member_y_ = y;
    }
    virtual ~CustomExtension() {}
    uint8_t member_a_;
    uint8_t member_b_;
    std::vector&lt;uint8_t&gt; member_c_;
    const uint8_t *member_d_;
    uint64_t member_d_len_;

  private:
    uint8_t member_x_;
    int8_t member_y_;
};

#include &lt;simics/systemc/injection/inject_base.h&gt;  // NOLINT

template &lt;typename TPAYLOAD&gt;
class InjectCustomExtension
    : public simics::systemc::injection::InjectBase&lt;TPAYLOAD&gt; {
  public:
    ATTR_DICT_PARSER_NAMESPACE("custom.")

    virtual bool setValue(simics::systemc::injection::AttrDictParser *parser,
                          const std::string &amp;key, attr_value_t *attr,
                          TPAYLOAD *gp) {
        if (key == "member_a") {
            CustomExtension *extension =
                this-&gt;template get_extension&lt;CustomExtension&gt;(gp);

            if (!parser-&gt;value(&amp;extension-&gt;member_a_))
                return false;

            return true;
        }

        INJECT_SET_VALUE(set_member_b, uint8_t, CustomExtension);

        if (key == "set_xy") {
            simics::systemc::injection::AttrDictParser p = parser-&gt;init(attr);
            CustomExtension *extension =
                this-&gt;template get_extension&lt;CustomExtension&gt;(gp);
            uint8_t x = 0;
            if (!p.lookUp("x", &amp;x))
                return false;

            int8_t y = 0;
            if (!p.lookUp("y", &amp;y))
                return false;

            extension-&gt;set_xy(x, y);
            return true;
        }

        if (key == "member_c") {
            CustomExtension *extension =
                this-&gt;template get_extension&lt;CustomExtension&gt;(gp);

            if (!parser-&gt;value(&amp;extension-&gt;member_c_))
                return false;

            return true;
        }

        if (key == "member_d") {
            CustomExtension *extension =
                this-&gt;template get_extension&lt;CustomExtension&gt;(gp);

            if (!SIM_attr_is_data(*attr)) {
                parser-&gt;reportError("member_d must be data");
                return false;
            }
            extension-&gt;member_d_ = SIM_attr_data(*attr);
            extension-&gt;member_d_len_ = SIM_attr_data_size(*attr);

            return true;
        }

        return false;
    }
};

static InjectCustomExtension&lt;tlm::tlm_generic_payload&gt; injector_;
</code></pre>
<p>The example shows different ways to set the members in the <code>CustomerExtension</code>. If the member in the extension is directly accessible, it could be set as shown for <strong>member_a</strong>. Data access is usually provided by setters and getters, <code>set_member_b</code> can be called by <code>INJECT_SET_VALUE</code>. If multiple arguments are required by the extension method, the arguments should be grouped in another dictionary or list as key <strong>set_xy</strong> shows. The key <strong>member_c</strong> demonstrates how a Python list can be loaded into a <code>vector</code>. Setting a data pointer is shown by key <strong>member_d</strong>. If a member in the extension cannot be properly setup, <code>false</code> must be returned. The failing key will be reported as an error and the inject call will be aborted.</p>
<p>The corresponding calls to setup the extension from Python could be as in the following example.</p>
<pre><code class="language-simics">simics&gt; <strong>@socket.b_transport({'custom.member_a' : 1}, 0)</strong>
simics&gt; <strong>@socket.b_transport({'custom.set_member_b' : 2}, 0)</strong>
simics&gt; <strong>@socket.b_transport({'custom.set_xy' : {'x' : 3, 'y' : 4}}, 0)</strong>
simics&gt; <strong>@socket.b_transport({'custom.member_c' : [5, 6]}, 0)</strong>
simics&gt; <strong>@socket.b_transport({'custom.member_d' : (7, 8, 9)}, 0)</strong>
</code></pre>
<h2 id="overview_of_systemc_features.html:unconnected-ports"><a href="#overview_of_systemc_features.html:unconnected-ports">5.7 Unconnected Ports</a></h2>
<p>According to SystemC language standard, port instances defined by <code>sc_port</code> class cannot remain unbound at the end of elaboration, unless allowed by port policy. SystemC Library optionally permits using unbound ports. Such ports are then automatically bound to a dynamically allocated object implementing the corresponding interface. Access to an unbound port will log an unimplemented message in Simics, for example:</p>
<pre><code>[device unimpl] Access to unbound port: device.simple_initiator_socket_0 @ 0 s
of intc/unimplemented in unconnected_base.h:28
</code></pre>
<p>The feature is disabled by default and can be enabled using <em>allow_unconnected_ports</em> attribute of the SystemC adapter. The list of supported unbound ports includes specialized <code>sc_in</code>, <code>sc_out</code> and <code>sc_inout</code> ports as well as socket ports which use the standard TLM-2.0 forward and backward transport interfaces.</p>
<h2 id="overview_of_systemc_features.html:checkpointing"><a href="#overview_of_systemc_features.html:checkpointing">5.8 Checkpointing</a></h2>
<p>The SystemC Checkpoint Library offers the ability to save and restore the state of SystemC devices. By utilizing the provided checkpoint API, users can add checkpoint support to their devices.</p>
<p>This feature is disabled by default. To enable checkpointing, set <code>USE_SIMICS_CHECKPOINTING=yes</code> when building the SystemC Library and SystemC modules.</p>
<p>The checkpoint API is detailed in a separate document, which can be found at <code>[The installation path for package 1013]/doc/systemc-checkpoint.pdf</code>.</p>
</section><section class="page" id="execution-of-systemc-models-in-the-simics-simulator.html"><h1 id="execution-of-systemc-models-in-the-simics-simulator.html:execution-of-systemc-models-in-the-simics-simulator"><a href="#execution-of-systemc-models-in-the-simics-simulator.html:execution-of-systemc-models-in-the-simics-simulator">6 Execution of SystemC Models in the Simics Simulator</a></h1>
<p>When a Simics adapter is created inside Simics, the elaboration phase is run which creates the SystemC object hierarchy. SystemC simulation phase involves the execution of the SystemC scheduler and is driven by Simics. The Simics simulator has a concept of virtual time that all models refer to. This chapter covers how SystemC models are executed inside the Simics simulator.</p>
<h2 id="execution-of-systemc-models-in-the-simics-simulator.html:systemc-simulation-time"><a href="#execution-of-systemc-models-in-the-simics-simulator.html:systemc-simulation-time">6.1 SystemC simulation time</a></h2>
<p>The SystemC scheduler is event-driven and events occur at precise points in simulation time. Simulation time in SystemC is an integer multiple of the time resolution and increases monotonically during simulation. Typically, outside of Simics, the SystemC simulation time is advanced by the <code>sc_start</code> function.</p>
<p>The simulation time resolution used for SystemC in Simics is by default one picosecond. In the SystemC Library, <code>sc_start</code> is invoked by the adapter only. It must never be invoked from within a SystemC model. The adapter drives the simulation and keeps track of the current simulation time. To print the current simulation time, use the <code>print-time</code> (<code>ptime</code>) command on the adapter object with the time option:</p>
<pre><code class="language-simics">simics&gt; <strong>psel dev</strong>
simics&gt; <strong>r 1 ps</strong>
simics&gt; <strong>ptime -pico-seconds</strong>
┌─────────┬───────────┐
│Processor│Picoseconds│
├─────────┼───────────┤
│dev      │          1│
└─────────┴───────────┘
</code></pre>
<p>It returns the time in seconds as a floating-point value. When the <code>dev</code> object is selected as the command line frontend, the simulation time can be advanced using the <code>run</code> (<code>r</code>) command.</p>
<div class="note">
<p>The description of these commands can be found from
<a href="../rm-base/index.html">Simics Reference manual</a> or help command output from Simics CLI.</p>
</div>
<p>The pending SystemC events currently registered with the kernel can be listed using the <code>print-event-queue</code> (<code>peq</code>) command:</p>
<pre><code class="language-simics">simics&gt; <strong>peq -i</strong>
┌──────────┬──────────┬──────────────┐
│  Cycle   │  Object  │ Description  │
├──────────┼──────────┼──────────────┤
│4999999999│dev.engine│Internal: stop│
└──────────┴──────────┴──────────────┘

┌─────────────┬──────┬───────────────────────────────────────────────────┐
│SystemC (ps) │Object│                    Description                    │
├─────────────┼──────┼───────────────────────────────────────────────────┤
│1234000000000│dev   │test_sc_devices.dummy_1_event                      │
│1234000000000│dev   │test_sc_devices.dummy_3_event                      │
│5678000000000│dev   │test_sc_devices.event_method (static method)       │
│5678000000000│dev   │test_sc_devices.trigger_method_event               │
│5678000000000│dev   │test_sc_devices.event_thread (dynamic thread)      │
│5678000000000│dev   │test_sc_devices.trigger_thread_event               │
│9876000000000│dev   │test_sc_devices.dummy_2_event                      │
│9999999999999│dev   │test_sc_devices.event_thread_timed (dynamic thread)│
└─────────────┴──────┴───────────────────────────────────────────────────┘
</code></pre>
<div class="note">
<p>The events posted by the SystemC adapter are treated as Simics simulator internal events, thus <em>-i</em> is needed.</p>
</div>
<p>The time shown in the <code>ptime</code> command output is relative to the current simulation time. Thus, the next event will be triggered after 1234000000000 ps.</p>
<p>The simulation time depends on the context of the SystemC kernel. Each adapter has its own context of the SystemC kernel with its own simulation time and events.</p>
<pre><code class="language-simics">simics&gt; <strong>psel dev2</strong>
simics&gt; <strong>ptime -pico-seconds</strong>
┌─────────┬───────────┐
│Processor│Picoseconds│
├─────────┼───────────┤
│dev2     │          0│
└─────────┴───────────┘
simics&gt; <strong>peq -i</strong>
┌─────┬───────────┬──────────────┐
│Cycle│  Object   │ Description  │
├─────┼───────────┼──────────────┤
│    0│dev2.engine│Internal: stop│
└─────┴───────────┴──────────────┘
</code></pre>
<p>The above results show that <code>dev</code> and <code>dev2</code> have different simulation time and events.</p>
<h2 id="execution-of-systemc-models-in-the-simics-simulator.html:simics-processors-driving-the-systemc-simulation"><a href="#execution-of-systemc-models-in-the-simics-simulator.html:simics-processors-driving-the-systemc-simulation">6.2 Simics processors driving the SystemC simulation</a></h2>
<p>In the Simics simulation framework, the <strong>processor</strong> concept includes all models that actively drive the simulation forward and manage the simulation time. Each processor is event-driven and supports one or more types of event queues representing: cycles, steps and/or pico-seconds.</p>
<p>All Simics processors in the example configuration can be listed using the <code>list-processors</code> command.</p>
<p>Each adapter (SystemC subsystem) exposes two processors to the rest of the Simics simulation system.</p>
<ul>
<li>The top-level adapter (<code>dev</code> and <code>dev2</code> in the example above) represent the current time of the SystemC kernel embedded in each adapter. This time might be ahead of the rest of the Simics simulation configuration.</li>
<li>The engines, (<code>dev.engine</code> and <code>dev2.engine</code>) are used by the Simics simulation core to drive time forward.</li>
</ul>
<pre><code class="language-simics">simics&gt; <strong>list-processors -all</strong>
┌───────────┬─┬─────────────────────────┬────────┬─────────┐
│ CPU Name  │ │        CPU Class        │  Freq  │Scheduled│
├───────────┼─┼─────────────────────────┼────────┼─────────┤
│clock      │ │clock                    │1.00 THz│yes      │
│dev        │ │test_sc_devices          │1.00 THz│no       │
│dev.engine │ │co-execute               │1.00 THz│yes      │
│dev2       │*│sample_tlm2_simple_device│1.00 THz│no       │
│dev2.engine│ │co-execute               │1.00 THz│yes      │
└───────────┴─┴─────────────────────────┴────────┴─────────┘
* = selected CPU
</code></pre>
<p>Processor <code>dev</code> and <code>dev2</code> support two kinds of event queues: the cycle-based and pico-seconds-based. The frequency is hardcoded as 1000000 MHz (or equivalently, 1 THz). Thus, 1 cycle equals 1 ps. All SystemC events are posted on the SystemC clock using the ps event queue (see how to display SystemC events using <code>peq</code> above). Since the processor on <code>dev</code>/<code>dev2</code> runs on SystemC simulation time, it is referred as the <strong>SystemC clock</strong> in this document.</p>
<p>The previous example of advancing SystemC simulation time can be achieved using cycle as well:</p>
<pre><code class="language-simics">simics&gt; <strong>r 1 cycles</strong>
simics&gt; <strong># using 'echo' below to illustrate that command return is a float value</strong>
simics&gt; <strong>echo (ptime -t)</strong>
1e-12
</code></pre>
<p>Simics events can be posted on the SystemC clock using either the cycle-based or ps-based event queue. Below is an example showing how to post Simics events using the cycle-based event queue:</p>
<pre><code class="language-simics">simics&gt; <strong>bp.cycle.break 10</strong>
Breakpoint 1: dev2 will break at cycle 11
simics&gt; <strong>peq -i</strong>
┌─────┬───────────┬───────────────────────────────┐
│Cycle│  Object   │          Description          │
├─────┼───────────┼───────────────────────────────┤
│   10│bp.cycle   │Break event on dev2 at cycle 11│
│  999│dev2.engine│Internal: stop                 │
└─────┴───────────┴───────────────────────────────┘
</code></pre>
<p>As shown in the above example, besides the user breakpoint set at cycle 10, the <code>dev.engine</code> processor is also posting events on the SystemC clock (as represented by the <code>dev</code> processor). The <code>dev.engine</code> is another Simics processor like the SystemC clock. It supports both a cycle-based event queue and a ps event queue. The only difference is how they are scheduled.</p>
<figure id="execution-of-systemc-models-in-the-simics-simulator.html:simics-schedules-the-processors">
<p><img alt="" src="scheduler.png"> </p><figcaption>Figure 1. Simics schedules the processors</figcaption><p></p>
</figure>
<p>Figure <a class="reference" href="#execution-of-systemc-models-in-the-simics-simulator.html:simics-schedules-the-processors">1</a> shows how Simics schedules the target processors in a single thread in default mode. Another mode (the free running mode) is described in section <a class="reference" href="#execution-of-systemc-models-in-the-simics-simulator.html:free-running">6.4.3</a>. All blue rectangles are Simics target processors which implement the <code>execute</code> interface. The thread calling the <code>execute</code> interface is a simulation thread managed by the Simics scheduler. <code>clock</code>, <code>dev.engine</code> and <code>dev2.engine</code> are three target processors scheduled directly by the Simics scheduler in a round-robin fashion. With temporal decoupling, each target processor runs multiple simulation steps or cycles (its time quantum) before handing over to the next processor.</p>
<p>The SystemC clock (<code>dev</code> and <code>dev2</code>) is not directly scheduled by the Simics scheduler. Instead it is indirectly scheduled via the adapter’s engine object (<code>dev.engine</code>) which is referred to as the <strong>Simics clock</strong>. This scheduler decoupling enables the SystemC clock to be driven both by the Simics clock as well as by the adapter. As described in section <a class="reference" href="#execution-of-systemc-models-in-the-simics-simulator.html:systemc-simulation-time">6.1</a>, the SystemC clock drives one SystemC kernel context.</p>
<p>In most cases, these two clocks are synced. But the SystemC clock could run ahead of the Simics clock if needed. For example when a synchronous Simics interface calls into the SystemC device, invoking the <code>b_transport</code> function which in turn invokes the <code>wait</code> function. In this case, SystemC time must run forward in order for the <code>b_transport</code> to return so that the Simics interface call can return. See Figure <a class="reference" href="#execution-of-systemc-models-in-the-simics-simulator.html:the-systemc-clock-could-move-ahead-of-the-simics-clock">2</a>.</p>
<figure id="execution-of-systemc-models-in-the-simics-simulator.html:the-systemc-clock-could-move-ahead-of-the-simics-clock">
<p><img alt="" src="sc_ahead.png"> </p><figcaption>Figure 2. the SystemC clock could move ahead of the Simics clock</figcaption><p></p>
</figure>
<p>Besides the processors, from the object hierarchy, there are some other objects that handle time: <code>vtime</code>, <code>vtime.cycles</code> and <code>vtime.ps</code>. They provide the functionality used by both clocks. <code>vtime</code> is used to dispatch pending events and drive the cycle queues. <code>vtime.cycles</code> and <code>vtime.ps</code> contains the cycle-based event queue and the ps event queue respectively. These objects are considered internal and user should not interact with them.</p>
<pre><code class="language-simics">simics&gt; <strong>list-objects -show-port-objects substr = vtime -tree</strong>
┐
├ clock ┐
│       └ vtime ┐
│               ├ cycles 
│               └ ps 
├ dev ┐
│     ├ engine ┐
│     │        └ vtime ┐
│     │                ├ cycles 
│     │                └ ps 
│     └ vtime ┐
│             ├ cycles 
│             └ ps 
└ dev2 ┐
       ├ engine ┐
       │        └ vtime ┐
       │                ├ cycles 
       │                └ ps 
       └ vtime ┐
               ├ cycles 
               └ ps 
</code></pre>
<h2 id="execution-of-systemc-models-in-the-simics-simulator.html:performance-tuning"><a href="#execution-of-systemc-models-in-the-simics-simulator.html:performance-tuning">6.3 Performance tuning</a></h2>
<p>The SystemC Library has been optimized to reduce the overhead when running SystemC models inside Simics. Normally, there is no need to do performance tuning. This section is targeting some advanced usage.</p>
<h3 id="execution-of-systemc-models-in-the-simics-simulator.html:disable-dmi"><a href="#execution-of-systemc-models-in-the-simics-simulator.html:disable-dmi">6.3.1 Disable DMI</a></h3>
<p>In SystemC, using the TLM-2.0 Direct Memory Interface (DMI) offers potentially significant increases in simulation speed for simple memory accesses, since it bypasses the normal <code>b_transport</code> calls. An initiator can check the <em>DMI allowed</em> attribute of a TLM-2.0 transaction passed through the transport interface to see if the target supports it. Since an interconnect component is permitted to modify the <em>address</em> attribute and the <em>extension pointers</em>, the original transaction needs to be deep-copied for potential DMI purposes later on. This deep copy cost some performance. For a SystemC device that does not support DMI, the DMI check can be disabled to avoid this overhead.</p>
<p>For example, following command disables DMI check on the initiator implemented in the gasket:</p>
<pre><code class="language-simics">simics&gt; <strong>@conf.dev2.gasket_simple_device_target_socket.iface.sc_initiator_gasket.set_dmi(False)</strong>
None
</code></pre>
<h3 id="execution-of-systemc-models-in-the-simics-simulator.html:scaling"><a href="#execution-of-systemc-models-in-the-simics-simulator.html:scaling">6.3.2 Scaling</a></h3>
<p>The SystemC simulation can be scaled. When the SystemC simulation runs very slowly, for example, when too many SystemC events are posted, the overall Simics simulation performance is affected. By scaling down the SystemC simulation, it allows the other processors to run faster. This can be achieved by setting the <em>frequency</em> attribute of <code>dev.engine.vtime</code>.</p>
<div class="note">
<p>In the future, the <em>frequency</em> attribute can be changed directly from <code>dev.engine</code>.</p>
</div>
<pre><code class="language-simics">simics&gt; <strong>ptime -all</strong>
┌───────────┬─────┬──────┬────────┐
│ Processor │Steps│Cycles│Time (s)│
├───────────┼─────┼──────┼────────┤
│clock      │n/a  │     0│   0.000│
│dev        │n/a  │  1001│   0.000│
│dev2       │n/a  │     1│   0.000│
│dev2.engine│n/a  │     1│   0.000│
│dev.engine │n/a  │  1001│   0.000│
└───────────┴─────┴──────┴────────┘
simics&gt; <strong>dev.engine.vtime-&gt;frequency = 1e11</strong>
simics&gt; <strong>r 1000 cycles</strong>
simics&gt; <strong>ptime -all</strong>
┌───────────┬─────┬──────┬────────┐
│ Processor │Steps│Cycles│Time (s)│
├───────────┼─────┼──────┼────────┤
│clock      │n/a  │  1000│   0.000│
│dev        │n/a  │  1101│   0.000│
│dev2       │n/a  │  1001│   0.000│
│dev2.engine│n/a  │  1001│   0.000│
│dev.engine │n/a  │  1101│   0.000│
└───────────┴─────┴──────┴────────┘
</code></pre>
<p>Here the frequency does not relate to how one cycle matches to ps but determines how many cycles the processor advances in one <strong>delta_tick</strong>. By dividing it with a factor of 10, <code>dev</code> and <code>dev.engine</code> run only 1101 – 1001 = 100 cycles compared with <code>dev2</code> and <code>dev2.engine</code> who runs 1001 – 1 = 1000 cycles. This way, the rest of the simulation gets more wall clock time to run.</p>
<h2 id="execution-of-systemc-models-in-the-simics-simulator.html:performance-scaling"><a href="#execution-of-systemc-models-in-the-simics-simulator.html:performance-scaling">6.4 Performance scaling</a></h2>
<p>SystemC Library supports the general Simics performance scaling feature. The feature is described in chapter "Scaling Simics" of
<a href="../simics-user-guide/index.html">Simics User's Guide</a>. Here only the SystemC specific parts are covered.</p>
<p>Simics Accelerator has two different mechanisms that can operate alone or work together to improve performance. The first is Simics® <em>Multimachine Accelerator</em> which is based upon the cell concept. The other mechanism is <em>Multicore Accelerator</em> which can parallelize simulation even within cells.</p>
<h3 id="execution-of-systemc-models-in-the-simics-simulator.html:multimachine-accelerator-for-systemc"><a href="#execution-of-systemc-models-in-the-simics-simulator.html:multimachine-accelerator-for-systemc">6.4.1 Multimachine Accelerator for SystemC</a></h3>
<p>Every Simics simulation is split into a set of cells and every processor belongs to a cell. By default, all cells run in parallel with each other. SystemC related processors from different Simics modules can reside in different cells and utilize the power of running in parallel. But SystemC related processors from the same Simics module cannot and by default end up in the same cell. This limitation comes from the Accellera SystemC kernel which is not thread safe (it contains global static variables/pointers). There is an automatic check for this requirement whenever the current SystemC related cell configuration changes.</p>
<pre><code class="language-simics">simics&gt; <strong>dev-&gt;cell</strong>
"default_cell0"
simics&gt; <strong>dev.engine-&gt;cell</strong>
"default_cell0"
simics&gt; <strong>@cell1=SIM_create_object('cell', 'cell1')</strong>
simics&gt; <strong>dev-&gt;cell = cell1</strong>
[dev error] dev is not placed in the same cell with [dev.engine, ]. The simulation may run into errors or even segfault in multi-threading mode.
</code></pre>
<p>By default, all SystemC related processors from one Simics module reside in the same cell (<code>default_cell0</code> in the above example). If processor <code>dev</code> is moved to a different cell (<code>cell1</code>), with <code>dev.engine</code> still in <code>default_cell0</code>, an error message is printed as show in the above example. Do not ignore this error, as the simulation will likely run into hard-to-debug type of errors or even segfaults in multi-threading mode.</p>
<p>The configuration is correct again when <code>dev.engine</code> is moved to <code>cell1</code> as well. Since <code>dev</code> and <code>dev2</code> belong to different Simics modules, they can reside in different cells.</p>
<pre><code class="language-simics">simics&gt; <strong>dev.engine-&gt;cell = cell1</strong>
simics&gt; <strong>set-threading-mode serialized</strong>
simics&gt; <strong>set-threading-mode</strong>
┌─────────────┬──────────┬───┬────────────┬─────────────┬───────────┐
│    cell     │   mode   │#td│time-quantum│max-time-span│min-latency│
├─────────────┼──────────┼───┼────────────┼─────────────┼───────────┤
│default_cell0│serialized│  1│      1.0 ns│     (1.0 ns)│    10.0 ms│
│cell1        │serialized│  1│    (1.0 ns)│     (1.0 ns)│    10.0 ms│
└─────────────┴──────────┴───┴────────────┴─────────────┴───────────┘
simics&gt; <strong>list-thread-domains</strong>
┌─────────────┬──────┬─────────────┐
│    Cell     │Domain│   Objects   │
├─────────────┼──────┼─────────────┤
│default_cell0│   #0*│default_cell0│
│             │      │clock        │
│             │      │dev2         │
│             │      │dev2.engine  │
└─────────────┴──────┴─────────────┘
┌─────┬──────┬──────────┐
│Cell │Domain│ Objects  │
├─────┼──────┼──────────┤
│cell1│   #0*│cell1     │
│     │      │dev       │
│     │      │dev.engine│
└─────┴──────┴──────────┘
</code></pre>
<h3 id="execution-of-systemc-models-in-the-simics-simulator.html:multicore-accelerator-for-systemc"><a href="#execution-of-systemc-models-in-the-simics-simulator.html:multicore-accelerator-for-systemc">6.4.2 Multicore Accelerator for SystemC</a></h3>
<p>With Subsystem threading, multiple host threads can be used to simulate multiple processors within each cell concurrently provided that the processors do not share memory. SystemC Library supports this execution threading model. Just like the cell partition limitation, all SystemC processors from the same module must reside in the same thread domain. This is guaranteed by the <code>adapter</code> class in SystemC Library so the user can never break this invariant. When <strong>Multicore Accelerator</strong> is enabled, by default, all SystemC instances from same module are grouped within the same thread domain. SystemC instances from different modules can reside in different thread domains and will then benefit from parallel multi-threading.</p>
<div style="text-align:center">
<figure id="execution-of-systemc-models-in-the-simics-simulator.html:cell-and-td-partitioning">
<p><img alt="" src="cell_td.png"> </p><figcaption>Figure 3. cell and TD partitioning</figcaption><p></p>
</figure>
</div>
<p>Current thread domain partitioning can be checked with <code>list-thread-domains</code> command.</p>
<pre><code class="language-simics">simics&gt; <strong>@SIM_create_object('sample_tlm2_simple_device', 'dev3')</strong>
simics&gt; <strong>set-threading-mode subsystem</strong>
simics&gt; <strong>set-threading-mode</strong>
┌─────────────┬───────────────────┬───┬────────────┬─────────────┬───────────┐
│    cell     │       mode        │#td│time-quantum│max-time-span│min-latency│
├─────────────┼───────────────────┼───┼────────────┼─────────────┼───────────┤
│default_cell0│     subsystem     │  2│      1.0 ns│       1.0 ns│    10.0 ms│
│cell1        │multicore/subsystem│  1│    (1.0 ns)│     (1.0 ns)│    10.0 ms│
└─────────────┴───────────────────┴───┴────────────┴─────────────┴───────────┘
simics&gt; <strong>list-thread-domains</strong>
┌─────────────┬──────┬─────────────┐
│    Cell     │Domain│   Objects   │
├─────────────┼──────┼─────────────┤
│default_cell0│   #0*│default_cell0│
├─────────────┼──────┼─────────────┤
│             │    #1│clock        │
├─────────────┼──────┼─────────────┤
│             │    #2│dev2         │
│             │      │dev3         │
└─────────────┴──────┴─────────────┘
┌─────┬──────┬───────┐
│Cell │Domain│Objects│
├─────┼──────┼───────┤
│cell1│   #0*│cell1  │
│     │    #1│dev    │
└─────┴──────┴───────┘
</code></pre>
<p>In the example above, there are three Simics processors scheduled by Simics inside <code>default_cell0</code>. The <code>clock</code> resides in the cell TD #0. Since <code>dev2</code> and <code>dev3</code> use the same Simics module, <code>dev2.engine</code> and <code>dev3.engine</code> reside in TD #1. This allows objects in one cell to run in parallel using multiple threads.</p>
<h3 id="execution-of-systemc-models-in-the-simics-simulator.html:free-running"><a href="#execution-of-systemc-models-in-the-simics-simulator.html:free-running">6.4.3 Free running</a></h3>
<p>The SystemC simulation can also run in free running mode. In this mode, SystemC time synchronization is decoupled from the rest of Simics. The SystemC simulation is no longer scheduled in round robin with the other processors and clocks as show in Figure <a class="reference" href="#execution-of-systemc-models-in-the-simics-simulator.html:simics-schedules-the-processors">1</a>. This can be achieved by setting the <em>run_continuously</em> attribute of <code>dev.engine</code>.</p>
<div class="note">
<p>Free running is only supported when the threading mode is <strong>subsystem</strong> or <strong>multicore</strong>.</p>
</div>
<pre><code class="language-simics">simics&gt; <strong>ptime -all</strong>
┌──────────┬─────┬──────┬────────┐
│Processor │Steps│Cycles│Time (s)│
├──────────┼─────┼──────┼────────┤
│clock     │n/a  │     0│   0.000│
│dev       │n/a  │     0│   0.000│
│dev.engine│n/a  │     0│   0.000│
└──────────┴─────┴──────┴────────┘
simics&gt; <strong>psel dev</strong>
simics&gt; <strong>r 10001 cycles</strong>
simics&gt; <strong>ptime -all</strong>
┌──────────┬─────┬──────┬────────┐
│Processor │Steps│Cycles│Time (s)│
├──────────┼─────┼──────┼────────┤
│clock     │n/a  │ 10000│   0.000│
│dev       │n/a  │ 10001│   0.000│
│dev.engine│n/a  │ 10001│   0.000│
└──────────┴─────┴──────┴────────┘
simics&gt; <strong>set-threading-mode subsystem</strong>
simics&gt; <strong>dev.engine-&gt;run_continuously = TRUE</strong>
simics&gt; <strong>r 10000 cycles</strong>
simics&gt; <strong>ptime -all</strong>
</code></pre>
<p>In above example, the SystemC model inside the <code>dev</code> contains a heavy workload that will slow down the simulation. When it runs in the default mode, the <code>clock</code> and <code>dev</code> are coupled and advanced with same cycles. When switched to the free running mode, <code>clock</code> is decouple from <code>dev</code> and can move forward in a much faster pace. In the above example, when <code>dev</code> and <code>dev.engine</code> move 10000 cycles forward, <code>clock</code> has moved much further. The exact number of cycles for <code>clock</code> is not deterministic, following is one example of such a run.</p>
<pre><code>┌──────────┬─────┬─────────────┬────────┐
│Processor │Steps│   Cycles    │Time (s)│
├──────────┼─────┼─────────────┼────────┤
│clock     │n/a  │4294999999998│   4.295│
│dev       │n/a  │        20001│   0.000│
│dev.engine│n/a  │        20001│   0.000│
└──────────┴─────┴─────────────┴────────┘
</code></pre>
</section><section class="page" id="limitations.html"><h1 id="limitations.html:limitations"><a href="#limitations.html:limitations">7 Limitations</a></h1>
<ul>
<li>The kernel must be statically linked with the model in order to satisfy the isolation properties expected by all Simics modules</li>
<li>Awareness for sockets only supports a BUSWIDTH of 32 and 64</li>
<li>Awareness for processes does not track spawned processes at run-time</li>
<li>The memory profiling feature does not support threads instantiated using SC_CTHREAD. Allocations made by threads instantiated using SC_THREAD are supported</li>
<li>The memory profiling results include allocations made by the SystemC kernel</li>
<li>SystemC adapters from the same (Simics) module cannot be instantiated in multiple cells. This limitation comes from the SystemC kernel itself, having a global/shared sc_simcontext pointer. Simics supports multiple instances of the kernel, by allocating a new context for each instance and updating the global context at the enter/exit of each instance. To run the same SystemC model in multiple cells, the model must be wrapped in separate modules.</li>
<li>Similar with the previous limitation, SystemC adapters from the same (Simics) module does not work in multicore accelerator mode.</li>
<li>Static SystemC objects are only supported for the first instance of each <code>Adapter</code> created in Simics</li>
<li>The <code>simics2tlm::Transaction</code> gasket does not support checkpointing of asynchronous transactions</li>
<li>The TLM transaction injected to a multi passthrough initiator socket is only sent to the first bound target socket.</li>
</ul>
</section><section class="page" id="building-required-libraries.html"><h1 id="building-required-libraries.html:building-required-libraries"><a href="#building-required-libraries.html:building-required-libraries">8 Building Required Libraries</a></h1>
<p>Building a Simics SystemC module is different than building a Simics module written in other languages. When you try to build a SystemC module, it might fail because the required libraries are missing.</p>
<pre><code class="language-simics">project&gt; <strong>bin/project-setup --sc-device=my_sc_device</strong>
project&gt; <strong>make my_sc_device</strong>
=== Building module my_sc_device ===
&lt;path to Simics SystemC Library Installation&gt;/src/extensions/systemc-cci/systemc-config.mk:55: *** Unable to locate: CCI libs.  Stop.
</code></pre>
<p>This document provides information on the required libraries, how to build them, and the different build options.</p>
<h2 id="building-required-libraries.html:the-systemc-libraries"><a href="#building-required-libraries.html:the-systemc-libraries">8.1 The SystemC Libraries</a></h2>
<p>The SystemC libraries refer to a set of required static libraries (.a) to build a Simics SystemC device module. The exact set of libraries depends on the different build options. However, the minimal set of required libraries is <code>libsystemc.a</code> and <code>libsystemc-library.a</code>.</p>
<ul>
<li>The <code>libsystemc.a</code> library contains the compiled object code for the SystemC kernel. It provides the implementation of the SystemC classes and functions.</li>
<li>The <code>libsystemc-library.a</code> library contains the compiled object code for the SystemC Library. It provides the implementation of the SystemC Library classes and functions.</li>
</ul>
<p>These two libraries are required for all Simics SystemC modules. By default, <code>USE_SIMICS_CCI</code> is set to yes, thus the <code>libcciapi.a</code> library which provides the implementation of the SystemC CCI classes and functions is required as well.</p>
<p>When SystemC checkpointing is enabled by setting <code>USE_SIMICS_CHECKPOINTING</code> to yes, two additional libraries <code>libcci_serialization.a</code> and <code>libsystemc-checkpoint.a</code> are required.</p>
<p>The lack of a stable C++ ABI prevents these libraries from being shipped (as binaries) in the Simics package. Therefore, it is necessary to rebuild the libraries from source every time the <em>Simics SystemC Library</em> package is upgraded.</p>
<p>The following chapter describes how to build these SystemC libraries.</p>
<h2 id="building-required-libraries.html:build-requirement-and-boost-dependency"><a href="#building-required-libraries.html:build-requirement-and-boost-dependency">8.2 Build Requirement and Boost Dependency</a></h2>
<p>The build requirement is covered in <a class="reference" href="#systemc-library-requirements.html">2</a>. The compiler needs to support the C++14 language standard. For maximum interoperability, it is recommended to use GCC 6.3.0. On Linux, other GCC versions may work, but only GCC 6.3.0 is used in the Simics regression tests.</p>
<h3 id="building-required-libraries.html:boost-dependency"><a href="#building-required-libraries.html:boost-dependency">8.2.1 Boost Dependency</a></h3>
<p>There is no external dependency when building libraries <code>libsystemc.a</code> and <code>libsystemc-library.a</code> using the (build script)[#build-script].</p>
<p>If Simics checkpointing is enabled by <code>USE_SIMICS_CHECKPOINTING=yes</code>, there is an external dependency on Boost C++ (www.boost.org). The Simics Serialization Library is a fork of Boost version 1.65.1, so only this version will work. The Boost C++ used in Simics SystemC Serialization is header-only, so there is no need to build and link with any Boost libraries.</p>
<div class="note">
<p>If you are an Intel internal user, you may have different Boost dependencies. Please check the <em>Intel SystemC Library Programming Guide</em> for more details.</p>
</div>
<p>To let Simics know where Boost is installed, you need to define and export the <code>BOOST_INC_PATH</code> variable. This can be done by multiple ways as mentioned in <a class="reference" href="#building-required-libraries.html:build-options">8.5</a>. Here is an example shows how to set it in the config-user.mk file in your Simics project directory.</p>
<div class="note">
<p>Variables set in <code>config-user.mk</code> must also be explicitly exported:</p>
<pre><code>BOOST_INC_PATH ?= /home/packages/boost/1.65.1/include/
export BOOST_INC_PATH
</code></pre>
</div>
<div class="note">
<p>It is not an error to provide both <code>BOOST_INC_PATH</code> and <code>BOOST_PREFIX</code> variables. If both are provided, <code>BOOST_INC_PATH</code> takes precedence.</p>
</div>
<h2 id="building-required-libraries.html:library-order"><a href="#building-required-libraries.html:library-order">8.3 Library Order</a></h2>
<p>SystemC libraries have dependencies on each other and must be compiled in the right order before any SystemC devices can be built. Here is the recommended order for building the SystemC libraries:</p>
<ol>
<li><code>SystemC Kernel</code></li>
<li><code>SystemC CCI</code> (If not disabled by USE_SIMICS_CCI=no)</li>
<li><code>SystemC Serialization</code> (If enabled by USE_SIMICS_CHECKPOINTING=yes)</li>
<li><code>SystemC Checkpoint</code> (If enabled by USE_SIMICS_CHECKPOINTING=yes)</li>
<li><code>SystemC Library</code></li>
</ol>
<p>To build all the libraries in the correct order and with the same compiler flags, it is recommended to invoke the build script from a Simics project. Please refer to <a class="reference" href="#building-required-libraries.html:build-script">8.4</a> for more details.</p>
<p>Alternatively, you can build all the modules manually following the above order. Keep in mind that due to library dependencies, if one library is rebuilt with different compile flags, all the libraries that depend on it should also be rebuilt using the same compiler flags. Please refer to <a class="reference" href="#building-required-libraries.html:build-libraries-manually">8.6</a> for more details.</p>
<h2 id="building-required-libraries.html:build-script"><a href="#building-required-libraries.html:build-script">8.4 Build Script</a></h2>
<p>Simics provides a build script that simplifies the compilation of all the SystemC libraries within a Simics project. The script is located in the <code>bin</code> subdirectory of the Simics installation, and is invoked like this:</p>
<section class="not-numbered">
<h3 id="building-required-libraries.html:usage"><a href="#building-required-libraries.html:usage">Usage</a></h3>
<div class="dl">
<ul>
<li>
<p><span class="term" id="building-required-libraries.html:dt:windows"><a href="#building-required-libraries.html:dt:windows">Windows</a></span></p>
<pre><code class="language-simics">project&gt; <strong>bin\build-systemc-libraries.bat [options]</strong>
</code></pre>
</li>
<li>
<p><span class="term" id="building-required-libraries.html:dt:linux"><a href="#building-required-libraries.html:dt:linux">Linux</a></span></p>
<pre><code class="language-simics">project$ <strong>bin/build-systemc-libraries [options]</strong>
</code></pre>
</li>
</ul>
</div>
</section>
<section class="not-numbered">
<h3 id="building-required-libraries.html:options"><a href="#building-required-libraries.html:options">Options</a></h3>
<div class="dl">
<ul>
<li><span class="term" id="building-required-libraries.html:dt:h-help"><a href="#building-required-libraries.html:dt:h-help"><code>-h, --help</code></a></span>
Show help message and exit.</li>
<li><span class="term" id="building-required-libraries.html:dt:f-force"><a href="#building-required-libraries.html:dt:f-force"><code>-f, --force</code></a></span>
Force rebuild of all the libraries.</li>
<li><span class="term" id="building-required-libraries.html:dt:u-unittests"><a href="#building-required-libraries.html:dt:u-unittests"><code>-u, --unittests</code></a></span>
Build and run unit tests.</li>
<li><span class="term" id="building-required-libraries.html:dt:j-jobs"><a href="#building-required-libraries.html:dt:j-jobs"><code>-j, --jobs</code></a></span>
Run up to N build jobs in parallel.</li>
<li><span class="term" id="building-required-libraries.html:dt:m-make"><a href="#building-required-libraries.html:dt:m-make"><code>-m, --make</code></a></span>
Specify which GNU Make binary to run. Defaults to 'make'</li>
<li><span class="term" id="building-required-libraries.html:dt:v-version"><a href="#building-required-libraries.html:dt:v-version"><code>-v, --version</code></a></span>
Specify which version of SystemC kernel to use. Defaults to '2.3.3'</li>
<li><span class="term" id="building-required-libraries.html:dt:std-cxx-standard"><a href="#building-required-libraries.html:dt:std-cxx-standard"><code>-std, --cxx-standard</code></a></span>
Specify which C++ standard to use. Defaults to 17 for SystemC kernel
3.0.0, otherwise defaults to 14.</li>
<li><span class="term" id="building-required-libraries.html:dt:"><a href="#building-required-libraries.html:dt:"><code>...</code></a></span>
The rest are parsed as make options for the modules.</li>
</ul>
</div>
</section>
<p>The script copies the necessary SystemC modules to the current Simics project and builds them in the correct dependency order. The required SystemC modules depend on the chosen build options, which are explained in detail in <a class="reference" href="#building-required-libraries.html:build-options">8.5</a> section. These build options can be specified when invoking the script.</p>
<p>It is recommended to configure the Make variable CC and CXX instead of relying on the default system compiler. By default, on Linux, the build script builds the following libraries if no additional Make variables are provided:</p>
<pre><code class="language-simics">project&gt; <strong>./bin/build-systemc-libraries CC=/usr/itm/gcc/6.3.0/bin/gcc CXX=/usr/itm/gcc/6.3.0/bin/g++</strong>
Building:
systemc-kernel            |################################| 100%
systemc-cci               |################################| 100%
systemc-library           |################################| 100%

All SystemC libraries successfully built
</code></pre>
<p>Once the script has finished running, you can proceed to build other SystemC modules within the project.</p>
<pre><code class="language-simics">project&gt; <strong>make my_sc_device</strong>
=== Building module my_sc_device ===
...
CCLD    my_sc_device.so
</code></pre>
<div class="note">
<p>Users can choose which SystemC kernel version to use for building the libraries by specifying the <code>-v</code> or <code>--version</code> option when executing the build script. The supported values are '2.3.3', '2.3.4' and '3.0.0', with '2.3.3' set as the default version. When using '3.0.0', the SystemC checkpoint feature is not supported.</p>
</div>
<div class="note">
<p>Users can optionally choose which C++ language standard to use for building the libraries by specifying the <code>-std</code> or <code>--cxx-standard</code> option when executing the build script. The supported values are '14' and '17'. If not set, the default C++ language standard from the compiler is used. The SystemC kernel 3.0.0 must be built with C++17, thus selecting C++14 will raise an error.</p>
</div>
<div class="note">
<p>The script must be executed in the root directory of the Simics project associated with the Simics installation.</p>
</div>
<div class="note">
<p>Whenever the <em>Simics SystemC Library</em> package is upgraded, the script must be run again with the <code>--force</code> option.</p>
</div>
<h2 id="building-required-libraries.html:build-options"><a href="#building-required-libraries.html:build-options">8.5 Build options</a></h2>
<p>This section provides a list of Make variables related to SystemC modules that are configured by the build script. These variables are generally identical for all SystemC modules. For information on common Simics Make variables, including CC and CXX, refer to <a class="reference" href="../module-mk/index.html">x</a>.</p>
<p>The following table displays the variable names, their default values, and their usage:</p>
<table><thead><tr><th>Variable name</th><th>Default value</th><th>Usage</th></tr></thead><tbody>
<tr><td>BOOST_INC_PATH</td><td></td><td>Specifies the location of the Boost headers</td></tr>
<tr><td>INTC_EXT</td><td>1</td><td>enables or disable the Intel SystemC kernel extension</td></tr>
<tr><td>USE_SIMICS_CCI</td><td>'yes'</td><td>enables or disables the Simics CCI feature</td></tr>
<tr><td>USE_SIMICS_CHECKPOINTING</td><td>'no'</td><td>enables or disables the Simics checkpointing feature</td></tr>
<tr><td>SYSTEMC_NO_UNITTESTS</td><td>1</td><td>enables or disables the Simics libraries unittest</td></tr>
<tr><td>SYSTEMC_KERNEL_VERSION</td><td></td><td>Selects the SystemC kernel version used in the project</td></tr>
<tr><td>SYSTEMC_CXX_STANDARD</td><td></td><td>Selects the C++ language standard used in the project</td></tr>
</tbody></table>
<p>There are 3 ways to set these Make variables:</p>
<ol>
<li>The user can set and export the variables in the config-user.mk file.</li>
<li>The variables can be provided as script parameters.</li>
<li>The variables can be set as shell environment variables.</li>
</ol>
<p>For variable <code>SYSTEMC_KERNEL_VERSION</code>, if all modules in a project have the same requirements then it can be set in <code>config-user.mk</code>; but it's better to list requirements per module, i.e, setting <code>SYSTEMC_KERNEL_VERSION=&lt;version&gt;</code> in the Makefile.</p>
<div class="note">
<p>The library <code>libsystemc-library.a</code> differs when built with different values for the USE_SIMICS_CHECKPOINTING variable. During the build process, when <code>USE_SIMICS_CHECKPOINTING=yes</code>, the library is compiled with all symbols, including those related to checkpointing. However, when <code>USE_SIMICS_CHECKPOINTING=no</code>, certain checkpoint-related symbols are excluded from the library.</p>
<p>It is important to note that if <code>libsystemc-library.a</code> is built with <code>USE_SIMICS_CHECKPOINTING=yes</code>, and a module is subsequently built with <code>USE_SIMICS_CHECKPOINTING=no</code>, the linker will automatically remove any unused object files from <code>libsystemc-library.a</code> without raising any missing symbol errors. However, the opposite scenario, where <code>libsystemc-library.a</code> is built with <code>USE_SIMICS_CHECKPOINTING=no</code> and a module is built with <code>USE_SIMICS_CHECKPOINTING=yes</code>, may not work as expected.</p>
<p>Therefore, when caching the SystemC libraries (See <a class="reference" href="#building-required-libraries.html:cached-libraries">8.9</a>), it is recommended to build <code>libsystemc-library.a</code> with <code>USE_SIMICS_CHECKPOINTING=yes</code>. And the desired value for USE_SIMICS_CHECKPOINTING can be chose at the modules build process.</p>
</div>
<h2 id="building-required-libraries.html:build-libraries-manually"><a href="#building-required-libraries.html:build-libraries-manually">8.6 Build libraries manually</a></h2>
<p>This section contains build instructions for the individual SystemC libraries. The best way to build them is to run the build script. See <a class="reference" href="#building-required-libraries.html:build-script">8.4</a> for details.</p>
<p>Reduce the compilation times of SystemC libraries by setting the <code>SYSTEMC_NO_UNITTESTS</code> variable. When set, no unit tests are compiled and run for those libraries that contain them.</p>
<h3 id="building-required-libraries.html:building-systemc-kernel"><a href="#building-required-libraries.html:building-systemc-kernel">8.6.1 Building SystemC Kernel</a></h3>
<p>In order to run SystemC models in Simics, the Simics SystemC Kernel must be used.</p>
<div class="note">
<p>SystemC Kernel is distributed as source, and must be built along with the other components including the device modules using the same toolchain.</p>
</div>
<div class="note">
<p>Building the kernel using a different GCC toolchain than the one used by Simics, usually also requires building the rest of the Simics SystemC components using the same toolchain. See <a class="reference" href="#building-required-libraries.html:build-script">8.4</a> for more details.</p>
</div>
<h4 id="building-required-libraries.html:how-to-build-systemc-kernel"><a href="#building-required-libraries.html:how-to-build-systemc-kernel">8.6.1.1 How To Build SystemC Kernel</a></h4>
<p>SystemC Kernel is built from a Simics Project. When building on Microsoft* Windows*, Microsoft Visual Studio 2015 is also required. These are the steps to build SystemC Kernel from a Simics Project:</p>
<h5 id="building-required-libraries.html:building-on-linux"><a href="#building-required-libraries.html:building-on-linux">8.6.1.1.1 Building On Linux</a></h5>
<pre><code class="language-simics">project&gt; <strong>bin/project-setup --copy-module=systemc-kernel</strong>
</code></pre>
<pre><code class="language-simics">project&gt; <strong>make systemc-kernel</strong>
</code></pre>
<h5 id="building-required-libraries.html:building-on-microsoft-windows"><a href="#building-required-libraries.html:building-on-microsoft-windows">8.6.1.1.2 Building On Microsoft Windows</a></h5>
<p>Start a Visual Studio command prompt and change directory to the project.</p>
<pre><code class="language-simics">project&gt; <strong>bin\project-setup --copy-module=systemc-kernel</strong>
</code></pre>
<pre><code class="language-simics">project&gt; <strong>bin\make systemc-kernel</strong>
</code></pre>
<p>You will need to set the CC to point to the Visual C++ compiler. See <a class="reference" href="#building-required-libraries.html:building-on-windows">8.7</a> for more details.</p>
<h3 id="building-required-libraries.html:building-the-simics-serialization-library"><a href="#building-required-libraries.html:building-the-simics-serialization-library">8.6.2 Building the Simics Serialization Library</a></h3>
<p>Simics Serialization Library is a fork of Boost Serialization, which provides extended serialization support to be used with SystemC Checkpoint Library.</p>
<p>To build Simics Serialization Library from source:</p>
<pre><code class="language-simics">project&gt; <strong>bin/project-setup --copy-module=systemc-serialization</strong>
</code></pre>
<pre><code class="language-simics">project&gt; <strong>make systemc-serialization</strong>
</code></pre>
<p>Simics Serialization Library requires Boost; see <a class="reference" href="#building-required-libraries.html:boost-dependency">8.2.1</a> for more details.</p>
<h3 id="building-required-libraries.html:building-systemc-checkpoint-library"><a href="#building-required-libraries.html:building-systemc-checkpoint-library">8.6.3 Building SystemC Checkpoint Library</a></h3>
<p>SystemC Checkpoint Library depends on Simics Serialization Library and SystemC Kernel. Please see <a class="reference" href="#building-required-libraries.html:building-the-simics-serialization-library">8.6.2</a> and <a class="reference" href="#building-required-libraries.html:building-systemc-kernel">8.6.1</a> for more details. SystemC Checkpoint Library is used by SystemC Library to provide checkpointing support, but it can also be used on its own. See the SystemC Checkpoint Library Programming Guide for more details.</p>
<p>To build Checkpoint Library from source:</p>
<pre><code class="language-simics">project&gt; <strong>bin/project-setup --copy-module=systemc-checkpoint</strong>
</code></pre>
<pre><code class="language-simics">project&gt; <strong>make systemc-checkpoint</strong>
</code></pre>
<p>See <a class="reference" href="#building-required-libraries.html:building-systemc-library">8.6.4</a> for using a different compiler, and <a class="reference" href="#building-required-libraries.html:building-on-windows">8.7</a> for building on Windows.</p>
<p>SystemC Checkpoint Library requires Boost, see <a class="reference" href="#building-required-libraries.html:boost-dependency">8.2.1</a> for more details.</p>
<div class="note">
<p>The SystemC libraries must be compiled in a particular order. Please advise <a class="reference" href="#building-required-libraries.html:library-order">8.3</a> for more details.</p>
</div>
<h3 id="building-required-libraries.html:building-systemc-library"><a href="#building-required-libraries.html:building-systemc-library">8.6.4 Building SystemC Library</a></h3>
<p>SystemC Library is distributed as source code, and must be compiled together with the other SystemC components including the device modules using the same toolchain.</p>
<p>To build Simics SystemC Library from source:</p>
<pre><code class="language-simics">project&gt; <strong>bin/project-setup --copy-module=systemc-library</strong>
</code></pre>
<pre><code class="language-simics">project&gt; <strong>make systemc-library</strong>
</code></pre>
<p>This will use the default compiler of the system. To use a different compiler, set the CC and CXX flags:</p>
<pre><code class="language-simics">project&gt; <strong>CC=/usr/itm/gcc/6.3.0/bin/gcc CXX=/usr/itm/gcc/6.3.0/bin/g++ make systemc-library</strong>
</code></pre>
<p>It is also possible to set the CC and CXX flags in the config-user.mk file, like this:</p>
<pre><code>CC = /usr/itm/gcc/6.3.0/bin/gcc
CXX = /usr/itm/gcc/6.3.0/bin/g++
</code></pre>
<p>The SystemC Library unit tests require Boost. See <a class="reference" href="#building-required-libraries.html:boost-dependency">8.2.1</a> for more details.</p>
<div class="note">
<p>The default GCC used by Simics SystemC Library is 6.3.0. For maximum interoperability, it is recommended to use this compiler version.</p>
</div>
<div class="note">
<p>Using a different toolchain requires rebuilding all other archives using the same toolchain. Please use the build script described in <a class="reference" href="#building-required-libraries.html:build-script">8.4</a> to do that.</p>
</div>
<div class="note">
<p>The SystemC libraries must be compiled in a particular order. Please advise <a class="reference" href="#building-required-libraries.html:library-order">8.3</a> for more details.</p>
</div>
<h2 id="building-required-libraries.html:building-on-windows"><a href="#building-required-libraries.html:building-on-windows">8.7 Building on Windows</a></h2>
<p>On Windows, SystemC modules can only be built using Visual C++ (provided with Visual Studio). In order to build SystemC modules using Visual C++, launch the Visual Studio Command Prompt (x64 version), configure the CC environment variable to use Visual C++ ('cl'), and build your modules using bin\make.bat.</p>
<pre><code class="language-simics">project&gt; <strong>"&lt;path to Visual Studio's vcvars64.bat"</strong>
project&gt; <strong>set CC=cl</strong>
project&gt; <strong>bin\make.bat</strong>
</code></pre>
<p>The module's makefile will try to detect which Visual C++ version to use by inspecting the environment variables, set up by the corresponding Visual Studio Command Prompt. The version can be forced by setting MSVC_VERSION:</p>
<pre><code class="language-simics">project&gt; <strong>set MSVC_VERSION=msvc140</strong>
-- or --
project&gt; <strong>set MSVC_VERSION=msvc170  </strong>
</code></pre>
<div class="note">
<p>Use of Visual Studio 2010 or 2013 is no longer supported, due to their lack of C++14 support.</p>
</div>
<div class="note">
<p>Use of Visual Studio 2017 and 2019 is currently not supported, but it should be possible to manually convert the solution files and make it work; as it does work for Visual Studio 2022.</p>
</div>
<div class="note">
<p>DML and C modules must use GCC/MinGW, so if there is a mix of DML/C and C++/SystemC models in the project, then it is necessary to build the targets separately.</p>
</div>
<div class="note">
<p>Currently the host requires the "8.3 short filename"-support to be enabled in order for the GNU Make logic to work. See 'fsutil 8dot3name' on <a href="https://docs.microsoft.com" rel="noopener noreferrer" target="_top">https://docs.microsoft.com</a> for more details on how to query and enable this.</p>
</div>
<h2 id="building-required-libraries.html:errors-when-building-the-systemc-libraries"><a href="#building-required-libraries.html:errors-when-building-the-systemc-libraries">8.8 Errors When Building the SystemC Libraries</a></h2>
<p>Many errors when building the SystemC libraries are caused by unresolved dependencies like Boost (see <a class="reference" href="#building-required-libraries.html:boost-dependency">8.2.1</a>), or not following the particular order (see <a class="reference" href="#building-required-libraries.html:library-order">8.3</a>) to build the SystemC libraries. The best way to build all binaries in the correct order, is to invoke the build script from a Simics project. See <a class="reference" href="#building-required-libraries.html:build-script">8.4</a> for more details.</p>
<p>The script must be run once again with --force option every time the <em>Simics SystemC Library</em> package is upgraded. If you failed to do this, you will probably see an undefined symbol error like this when loading your SystemC device module:</p>
<pre><code>Undefined symbol: _ZN6simics7systemc16SCL_VERSION_5108C1Ev
</code></pre>
<div class="note">
<p>The number 5108 shown in the error message depends on the SystemC Library version which may differ in real cases.</p>
</div>
<p>There are also compile-time checks that will take effect when compiling the Simics modules using the SystemC libraries. These checks verify that the libraries have been build with the same compiler as is used to build the Simics module.</p>
<h2 id="building-required-libraries.html:cached-libraries"><a href="#building-required-libraries.html:cached-libraries">8.9 Cached libraries</a></h2>
<p>In order to save time when working in multiple Simics projects, building the libraries in each project can be avoided by using a cache. The build system supports this through the following scheme:</p>
<ol>
<li>Build the libraries by running the build script in a project</li>
<li>Copy the libraries and the generated headers for the compile-time checks, i.e. everything under <code>&lt;host&gt;/lib/systemc</code>, to a shared location</li>
<li>Add the following to config-user.mk:<br>
<code>export   SYSTEMC_DEPS_CACHE=&lt;path to cache&gt;</code></li>
<li>Build SystemC Simics modules using GNU Make as normal</li>
</ol>
</section><section class="page" id="migration-guide-simics-5-to-simics-6.html"><h1 id="migration-guide-simics-5-to-simics-6.html:migration-guide-simics-5-to-simics-6"><a href="#migration-guide-simics-5-to-simics-6.html:migration-guide-simics-5-to-simics-6">9 Migration Guide Simics 5 to Simics 6</a></h1>
<p>SystemC Library has been upgraded between Simics 5 and Simics 6 to support new features and make the product more robust and future proof. See the release notes for a list of all new features.</p>
<p>Most changes are internal and do not affect the end-user. In addition the deprecated API has been kept, whenever possible, to maintain backwards compatibility.</p>
<p>One major change that affects the end-user is how the SystemC scheduler is integrated with Simics. In Simics 5 the SystemC time was forwarded by events posted on an external clock, therefore creating and connecting this clock was a required step. In Simics 6 the adapter is directly scheduled by Simics and so no external clock is required. This affects the configuration, and some migration is required as described below.</p>
<p>Here is the list of things one has to do when migrating from 5 to 6:</p>
<ul>
<li>Adapter <em>always</em> creates an internal clock, so any explicitly created external clocks in components or test benches should be removed.</li>
<li>For the same reason, the adapter's <code>queue</code> attribute must not be set explicitly by components or test benches. If set, it will result in an error with the following message: <em>"VT_set_object_clock() called twice for the object &lt;object name&gt;. The function may only be called once for each configuration object."</em>.</li>
<li>In a configuration with other clocks, aside from the one now provided by the adapter, extra care must be taken to make sure the adapter ends up in the correct cell. Please run <code>check-cell-partitioning</code> to validate the configuration.</li>
<li>Test-benches that run Simics for a specified amount of cycles based on the frequency of the external clock, must be updated to run the corresponding time in picoseconds instead.</li>
<li>Custom gaskets must be updated: <code>CatchUp</code> class has been removed, and must be removed from the gasket to avoid compilation error.</li>
<li>Custom adapters calling SimulationInterface directly must be updated to avoid compilation error.</li>
<li>All conf-classes provided by SystemC Library and Tools now use underscore instead of deprecated hyphens. Updates may be required depending on use-case.</li>
<li><code>time_quantum</code> attribute removed from Adapter. Updates may be required depending on use-case.</li>
<li>SystemC tools have moved inside SystemC Library and are built as part of the Simics module, with tool classes prefixed with the module's name. This in order to improve isolation between different Simics modules to avoid problems with incompatible C++ ABIs. Updates may be required depending on use-case.</li>
<li>The default tools created by the <code>[trace,break]-sc</code> commands have been moved into the internal namespace of the adapter. Please don't use this tool directly.</li>
<li>The <code>systemc2simics::Signal</code> gasket can no longer be bound directly to the SystemC sc_out via operator overloading. Instead, calling the <code>set_pin</code> method is required. This makes the Signal gasket consistent with the other gaskets.</li>
</ul>
<p>Please also consider the following optional changes:</p>
<ul>
<li>Remove calls to <code>ExtensionSender::set_payload()</code> if not required. This is only required when the payload is modified before calling methods of the interface-specific <code>Extension</code> class</li>
<li>Remove calls to <code>Extension::init(sender, payload)</code> with calls to <code>Extension::init(sender)</code>.</li>
<li>In simics2tlm gaskets, replace calls to <code>Gasket::payload()</code> with <code>TransactionPool::acquire()</code> and calls to <code>Gasket::trigger_transaction()</code> with <code>Gasket::trigger(Transaction*)</code>. This will make the gasket re-entry safe. See any of the standard gaskets for reference.</li>
<li>In simics2tlm gaskets, replace calls to <code>Gasket::set_inquiry(bool)</code> with <code>TransactionExtension::set_transport_debug(bool)</code>. See <code>IoMemory</code> gasket for reference.</li>
<li>Remember to change SIMICS_API from 5 to 6 in the module's Makefile.</li>
</ul>
</section><section class="page" id="migration-guide-systemc.html"><h1 id="migration-guide-systemc.html:migration-guide-systemc"><a href="#migration-guide-systemc.html:migration-guide-systemc">10 Migration Guide SystemC</a></h1>
<h2 id="migration-guide-systemc.html:migrate-from-2-3-1-to-2-3-3"><a href="#migration-guide-systemc.html:migrate-from-2-3-1-to-2-3-3">10.1 Migrate from 2.3.1 to 2.3.3</a></h2>
<p>From a device model's point of view there are only a few incompatible changes between SystemC 2.3.1 and 2.3.3 to consider. Migration should thus be straight forward and trivial. If the model has dependencies on 3rd party IP, additional changes may be required. Please contact the IP provider for details.</p>
<p>Here is the list of known changes that can cause problems when migrating from 2.3.1 to 2.3.3. See the Accellera kernel <code>RELEASENOTES</code> for more details and full list of changes:</p>
<ul>
<li>The non-standard functions `interface_count` and `if_typename` in sc_port_base have been marked as private.</li>
<li>The non-standard, 32-bit implementation of sc_(u)int has been removed.</li>
<li>The non-standard macros WAIT, WAITN and WAIT_UNTIL have been renamed to SC_WAIT, SC_WAITN, SC_WAIT_UNTIL.</li>
<li>The non-standard macros SCAST, CCAST, RCAST have been removed.</li>
<li>The implicit inclusions of the system-headers "cstring" and "sstream" have been removed.</li>
<li>Detection and assert of invalid instantiation of an sc_export outside of an sc_module.</li>
<li>Detection and assert of invalid immediate notification of events during elaboration.</li>
<li>Wait on empty event list not allowed. Add an explicit check before invoking <code>wait()</code> or <code>next_trigger()</code>.</li>
</ul>
<h2 id="migration-guide-systemc.html:migrate-from-2-3-3-to-2-3-4"><a href="#migration-guide-systemc.html:migrate-from-2-3-3-to-2-3-4">10.2 Migrate from 2.3.3 to 2.3.4</a></h2>
<p>In addition to the changes listed in the Accellera kernel <code>RELEASENOTES</code>, there is an incompatible change in the <code>tlm::tlm_base_socket_if</code> interface. In SystemC 2.3.3, the interface is defined as follows:</p>
<pre><code>class tlm_base_socket_if {
 public:
  virtual sc_core::sc_port_base &amp;         get_port_base() = 0;
  virtual sc_core::sc_port_base const &amp;   get_port_base() const = 0;
  virtual sc_core::sc_export_base &amp;       get_export_base() = 0;
  virtual sc_core::sc_export_base const &amp; get_export_base() const = 0;
  ...
};
</code></pre>
<p>In SystemC 2.3.4, these methods have been renamed:</p>
<pre><code>class tlm_base_socket_if {
 public:
  virtual sc_core::sc_port_base &amp;         get_base_port() = 0;
  virtual sc_core::sc_port_base const &amp;   get_base_port() const = 0;
  virtual sc_core::sc_export_base &amp;       get_base_export() = 0;
  virtual sc_core::sc_export_base const &amp; get_base_export() const = 0;
  ...
};
</code></pre>
<p>If your integrated SystemC IP explicitly uses these methods from <code>tlm::tlm_base_socket_if</code>, you will need to update the method names accordingly.</p>
<h2 id="migration-guide-systemc.html:migrate-from-2-3-4-to-3-0-0"><a href="#migration-guide-systemc.html:migrate-from-2-3-4-to-3-0-0">10.3 Migrate from 2.3.4 to 3.0.0</a></h2>
<p>SystemC 3.0.0 introduces new features and API changes to align with IEEE Std. 1666-2023. For detailed information, refer to Chapter 3 "New Features" in the Accellera kernel <code>RELEASENOTES.md</code>.</p>
<p>IEEE Std. 1666-2023 mandates C++17 as the baseline for SystemC implementations. Ensure that your SystemC IP is compatible with a compiler that supports the C++17 language standard.</p>
<p>Below is a list of known changes that may cause issues when migrating from 2.3.4 to 3.0.0:</p>
<ul>
<li>The macro <code>SC_HAS_PROCESS</code> is not required anymore and has been deprecated</li>
<li>The constructor <code>sc_time(double, bool)</code> has been deprecated</li>
<li>The constructor <code>sc_time(uint64, bool)</code> has been deprecated</li>
<li>The function <code>sc_set_default_time_unit</code> has been deprecated</li>
<li>The function <code>sc_get_default_time_unit</code> has been deprecated</li>
</ul>
</section><section class="page" id="migration-guide-simics-6-0-129-to-simics-6-0-130.html"><h1 id="migration-guide-simics-6-0-129-to-simics-6-0-130.html:migration-guide-simics-6-0-129-to-simics-6-0-130"><a href="#migration-guide-simics-6-0-129-to-simics-6-0-130.html:migration-guide-simics-6-0-129-to-simics-6-0-130">11 Migration Guide Simics 6.0.129 to Simics 6.0.130</a></h1>
<p>Simics SystemC Library has been upgraded to use Simics C++ API v2. Most changes are covered already in the <code>Migration Guide</code> chapter of the
<a href="../cc-device-api/index.html">Simics C++ Device API v2</a> documentation. Only the additional changes are listed here.</p>
<ul>
<li>The simics2tlm and simics2systemc Simics adapter is registered on <code>ConfClass</code> instead of <code>ClassDef</code>.</li>
</ul>
</section>