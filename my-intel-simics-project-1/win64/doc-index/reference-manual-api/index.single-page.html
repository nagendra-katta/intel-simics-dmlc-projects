<!doctype html>
<meta charset=utf8>
<link rel=stylesheet href="../simics.css">
<title>API Reference Manual</title>

<section class="page" id="index.html"><h1>API Reference Manual</h1>

    
    
    
<p>
    
    
</p><p>
    
    
    
</p><p>
    
    
    </p><p>
    
    </p><p>
    
</p><p>
    
    </p><p>
    
    
</p><p>
    
</p></section><section class="page" id="introduction.html"><h1 class="jdocu"><a id="introduction.html:Introduction">1 Introduction</a></h1>
<p>

</p><p>
This manual contains the reference documentation for most Simics
APIs. It describes the Device API, as well as the interfaces and haps
that are available for developing models. The manual also describes
the Simulator API and its interfaces, for use when developing
extensions to Simics. Furthermore, the manual details the Link Library
API - that's used to create link models to connect devices in
different cells. The Processor API is used to create models of
processors for use in Simics; the reference documentation for the
Processor API is also present in this manual. The manual is concluded
with the reference documentation of the Python API.
</p><p>
This manual is primarily meant to be used as reference documentation, but it
also describes some concepts of central importance closely related
to the API. Refer to the other Simics manuals, listed in the
<em>Documentation Contents</em> document, for more details
about other things.
</p><p>

    
    
    
    
</p></section><section class="page" id="programming-concepts.html"><h1 class="jdocu"><a id="programming-concepts.html:Programming-Concepts">1.1 Programming Concepts</a></h1>
<p>

</p><p>
This chapter describes the major programming concepts in Simics. It is
intended for anyone who wants to write extensions or modules for Simics.
</p><p>
A Simics module is just some executable code loaded dynamically into the
simulator, so it could perform virtually any operation. To be of any practical
use however, a module has to interact with Simics, other modules, or the
user. Simics provides a set of functions (the Simics API) for the modules to
work within the simulator framework. The API defines a number of concepts like
classes, objects, interfaces, haps, and events, which will
be presented below.
</p><p>
Simics modules can be written using different programming languages:
</p><p>
</p><dl><dt id="programming-concepts.html:dt:dml"><a href="#programming-concepts.html:dt:dml"><b>DML</b></a></dt><dd>Device Modeling Language (DML) has been designed to make writing new device model as simple
as possible. It integrates in the language many of the concepts
defined by the Simics API so that the user can focus on the model
rather than on the interaction with Simics. <em>This is by far the
best language for writing device models</em>. Note that although it
was designed with device models in mind, DML can be used to develop
other types of modules.</dd><dt id="programming-concepts.html:dt:python"><a href="#programming-concepts.html:dt:python"><b>Python</b></a></dt><dd>Python can be used to quickly write a new Simics module. It
is well suited for Simics extensions that are not called very often, like some
types of statistics gathering, or BIOS emulation. It can also be used for fast
prototyping of more complex extensions that later on will be rewritten in a
compiled language like DML or C. Note that in all cases, DML is easier to use
than Python to write a device model.</dd><dt id="programming-concepts.html:dt:c-c"><a href="#programming-concepts.html:dt:c-c"><b>C/C++</b></a></dt><dd>C and C++ can be used for writing any type of Simics
module. Writing in C or C++ exposes all interactions with Simics, which can be
sometimes cumbersome. C or C++ development is only recommended for specialized
cases when DML or Python do not provide the functionality needed. A few
specialized functions in the API are only available to C and C++ modules.</dd><dt id="programming-concepts.html:dt:systemc"><a href="#programming-concepts.html:dt:systemc"><b>SystemC</b></a></dt><dd>Integrating existing SystemC device models into Simics
simulations is supported by the <em>SystemC Library</em>.  The library provides
a set of gaskets that bridge from TLM-2.0 interface to Simics interfaces and
from Simics interfaces to TLM-2.0 interface. See the <em>SystemC Library
Programming Guide</em> for details. For new device modeling, DML is
recommended since it is more efficient to model in and automatically supports
all Simics features.</dd></dl><p>This chapter will cover the concepts that the Simics API defines. It will also
present how to use them, first in DML, then in Python and C/C++.
</p><p>
</p><h2 class="jdocu"><a id="programming-concepts.html:classes-modules-and-objects">1.1.1 Classes and Objects</a></h2>
<p>

</p><p>
Each device is represented by an <a id="programming-concepts.html:object">object</a> whose attributes
<a id="programming-concepts.html:attribute"></a> correspond to the state of the device.
</p><p>
Most Simics modules <a id="programming-concepts.html:module"></a> work the same way: they define <em>classes</em>
<a id="programming-concepts.html:class"></a> describing the properties of an object. This includes its
<em>attributes</em>, <em>interfaces</em> and the class name. The objects are
created by <em>instantiating</em> a class and setting the required attributes.
</p><p>
Note that <em>modules</em> and <em>classes</em> are not the same thing. A
module can define two or more classes, or none at all. But many modules define
a single class with the same name as the module.
</p><p>

</p><h2 class="jdocu"><a id="programming-concepts.html:Type">1.1.2 Type</a></h2>
<p>

</p><p>
When registering an attribute, a type definition should be provided for Simics
to check that the attribute is always set properly. This type definition is a
string that is defined according to the following rules:
</p><p>
</p><ul>

<li>A simple type is represented by a single letter: <code>i</code> (integer),
<code>f</code> (floating), <code>s</code> (string), <code>b</code> (boolean), <code>d</code>
(data), <code>o</code> (object), <code>D</code> (dictionary), <code>n</code> (nil) or
<code>a</code> (all).</li>

<li>You can match several types by using the operator <code>|</code> like in
<code>s|o</code> (string OR object).</li>

<li>Lists are defined by square brackets: <code>[</code> and <code>]</code>. Lists can
be specified in three ways:
<p>
   </p><ul>

   <li>Lists with a fixed elements: <code>[iffsb]</code> matches a list of five
   elements; an integer, two floating-point values, a string and a boolean
   value.</li>

   <li>lists of an arbitrary number of elements: <code>[i*]</code> and
   <code>[i+]</code> both match any list containing only integers, with
   the difference that <code>[i*]</code> will match an empty list, while
   <code>[i+]</code> requires at least one list element.</li>

   <li>lists with a size specifier: <code>[i{1:4}]</code> matches lists of
   integers with 1 to 4 elements. <code>[i{4}]</code> is the same as
   <code>[i{4:4}]</code> or <code>[iiii]</code>, i.e., a list of four integers.</li>

   </ul>
<p>
</p></li>

<li>The <code>|</code> operator has higher precedence than juxtaposition in the
list type definitions, which means that <code>[i|si|s]</code> matches any
two-elements list with integer or string elements. For clarity you can use a
comma anywhere in the type definition, it will be ignored.  The example could
be written as <code>[i|s,i|s]</code></li>

</ul>
<p>
As an example, the <code>"[s*]|s"</code> string defines an attribute
that can hold either a string or a (possibly empty) list of strings.
</p><p>
When writing complex attributes, you may notice that the type description
strings do not cover all the possibilities offered by the attribute structure
definition. If you need to register attributes that cannot be described in a
type string (like complex variable size lists), you will need to use the
<code>a</code> type and perform the type checking by yourself in the
<b><i>set()</i></b> function. You may also want to review your attribute and
change its definition to match a possible type description, or divide your
attribute into several simpler attributes.
</p><p>
For example, an attribute accepting a list composed of one object and one or
more integers can not be described in a type string (list definition with
variable size can only have one element). You may want to rewrite your
attribute to use a sub-list for the integers: <code>[o[i+]]</code>, or you can
perform type checking yourself.
</p><p>

</p><h2 class="jdocu"><a id="programming-concepts.html:Interfaces">1.1.3 Interfaces</a></h2>
<p>

</p><p>
Interfaces allow objects to interact with each other. An interface defines a
number of functions. Every class that implements an interface (by registering
it) must define those functions. In some cases, it is sufficient to implement
just a subset of the functions.
An object A may then ask for an interface
registered by an object B, and thus use the interface's functions to
communicate with B. Simics comes with many predefined interfaces but it is
also possible to define new interfaces.
</p><p>
One of the most important interfaces for a device class is probably the
<code>io_memory</code> interface. Implementing the <code>io_memory</code>
interface enables a class to be mapped into a memory space and be accessed by
the simulated machine. In C or DML, it is defined as:
</p><p>
</p><pre class="jdocu_small">typedef struct io_memory_interface {
        int (*_deprecated_map)(conf_object_t *NOTNULL obj,
                               addr_space_t memory_or_io,
                               map_info_t map_info);
        exception_type_t (*operation)(conf_object_t *NOTNULL obj,
                                      generic_transaction_t *NOTNULL mem_op,
                                      map_info_t map_info);
      } io_memory_interface_t;
</pre><p>
</p><p>
Other interfaces can be
used for things like raising processor interrupts or implementing PCI device
functionality.
</p><p>
Interfaces are either implemented by the device class itself, or by one of its
<em>ports</em>. This way, a device can have several ports implementing the
same interface, for example interrupt controllers with several sources or
memory mapped devices with separate banks of registers.
</p><p>

</p><h2 class="jdocu"><a id="programming-concepts.html:Logging">1.1.4 Logging</a></h2>
<p>

</p><p>
A device model should log its activities so that it is possible to see what
happens. It is useful both while developing the model and while developing
target software, or to help finding problems in the system. Logging should not
be used in attribute accessor functions or in CLI commands where there are
other ways to report errors. The Simics API provides logging facilities that
classifies log messages based on the following criteria:
</p><p>
</p><dl><a id="programming-concepts.html:loggingloglevel"></a>
<dt id="programming-concepts.html:dt:level"><a href="#programming-concepts.html:dt:level"><b><em>level</em></b></a></dt><dd>The verbosity level ranging from 1 through 4 in
decreasing importance order. The term 'high' and 'low' for log-level is based on
its priority, thus 1 is the highest log-level.</dd><a id="programming-concepts.html:logginglogtype"></a> 
<dt id="programming-concepts.html:dt:type"><a href="#programming-concepts.html:dt:type"><b><em>type</em></b></a></dt><dd>Each log message belongs to a specific category:
<p>
</p><dl><dt id="programming-concepts.html:dt:info"><a href="#programming-concepts.html:dt:info"><b><code>info</code></b></a></dt><dd>Info or debug message without any consequence on the
simulation.</dd><dt id="programming-concepts.html:dt:warning"><a href="#programming-concepts.html:dt:warning"><b><code>warning</code></b></a></dt><dd>Warning message about a problem in the
simulation, which however still allows the simulation to
continue.</dd><dt id="programming-concepts.html:dt:error"><a href="#programming-concepts.html:dt:error"><b><code>error</code></b></a></dt><dd>An error occurred that prevents the simulation (or
part of the simulation) from running properly. Note that error messages do not
have any logging level and are always printed. If the
<i>sim-&gt;fail_on_warnings</i> attribute is set to true, for example if
Simics was started with the <code>-werror</code> command line flag, then Simics
will exit with an error code when a log message of the <em>error</em> type is
generated.</dd><dt id="programming-concepts.html:dt:critical"><a href="#programming-concepts.html:dt:critical"><b><code>critical</code></b></a></dt><dd>Used to signal serious errors that the model may
not be able to resume from. Simics will stop the simulation as soon as a
critical error is logged.</dd><dt id="programming-concepts.html:dt:unimplemented"><a href="#programming-concepts.html:dt:unimplemented"><b><code>unimplemented</code></b></a></dt><dd>A model does not implement a specific
functionality, bit or register.</dd><dt id="programming-concepts.html:dt:spec_violation"><a href="#programming-concepts.html:dt:spec_violation"><b><code>spec_violation</code></b></a></dt><dd>A model received commands from the target
program that violates the device specification.</dd></dl><p></p></dd><a id="programming-concepts.html:loggingloggroup"></a> 

<dt id="programming-concepts.html:dt:group"><a href="#programming-concepts.html:dt:group"><b><em>group</em></b></a></dt><dd>A bit-field, defined and registered by the module,
used to separate different part of the device, for example to separate between
the configuration of a device and using the device's services, or the PCI
interface and the Ethernet interface, etc.</dd></dl><p>
</p><h2 class="jdocu"><a id="programming-concepts.html:Events">1.1.5 Events</a></h2>
<p>

</p><p>
When a device model wants some action to be taken at a later time, it posts an
<em>event</em> and returns control to the simulation engine. This will cause a
callback to be called after the requested simulated time has passed.
</p><p>
For example, a device that wants to raise a time interrupt every <nobr>10
ms</nobr> would post an event with a callback that raises the interrupt and
then reposts the event with a <nobr>10 ms</nobr> delay.
</p><p>
The events are posted on a clock, which is usually one of the processor cores
in the system. Typically, each device is associated with one clock on which it
posts all its events, but it is possible to choose which clock to post on, as
long as it is in the same simulation cell as the device.
</p><p>
</p><div class="note">
<b>Note:</b>
Some clocks, in particular the processor cores, also allow posting events
on a <em>step queue</em> which doesn't count time, but CPU <em>steps</em>. This
is usually not used by device models, but can be used for profiling extensions
etc.</div>You can print out the current event queue by using the
<b>print-event-queue</b> command (or <b>peq</b> for short).
<p>

</p><h2 class="jdocu"><a id="programming-concepts.html:Haps">1.1.6 Haps</a></h2>
<p>

</p><p>
Another way that models may react to Simics events is to use
<em>haps</em>. (The term was chosen because happenstance was considered too
long.) To react to a hap, a module can register a callback function to the
hap. This callback function will then be called every time the hap occurs. A
complete list of all haps, descriptions of what parameters the callback
functions should take and all functions used to register callbacks and
manipulate haps can be found in chapter <a class="reference" href="#haps-chapter.html">12</a>.
</p><p>
In general, haps are slower than notifiers, and therefore less
suitable for communication between models. However, haps allow sending
additional parameters to the callback function.

</p><h2 class="jdocu"><a id="programming-concepts.html:Commands">1.1.7 Commands</a></h2>
<p>

</p><p>
A user interface for a module can be created by adding new commands
to the Simics command line interface. Commands can be bound
to a specific namespace (i.e., a class or an interface) or to the global
namespace. 
</p><p>
</p><ul>

<li>Commands that are bound to <em>classes</em> can be used to manipulate
individual instances of that class. For example, all devices should
have an <b>info</b> command that prints static information about the
device and a <b>status</b> command that prints the state of the
device.</li>

<li>Commands that are bound to <em>interfaces</em> can be used on all
objects implementing that interface.</li>

<li>Global commands can be used for actions that do not pertain to a specific
object. This is the case of commands like <b>output-radix</b> or
<b>print</b>.</li>

</ul>
<p>

</p><p>
</p></section><section class="page" id="simics-api-information.html"><h1 class="jdocu"><a id="simics-api-information.html:Simics-API-Information">1.2 Simics API Information</a></h1>
<p>

</p><p>
This chapter describes the organization of the Simics API,
and how to use it. It also shows how it interacts with
system, Device, Simulator, Processor, and Link Library APIs.
</p><p>
</p><h2 class="jdocu"><a id="simics-api-information.html:spc-api-parts">1.2.1 The Simics API</a></h2>
<p>

<a id="simics-api-information.html:Simics-API"></a><a id="simics-api-information.html:APISimics"></a>Simics provides a number of unique
APIs designed to allow the integration of new modules with the Simics family of
products.
</p><p>
The Simics API is partitioned into three major parts, and an additional three
groups of interfaces. There is one header file to include for each part of the
Simics API, while the interfaces are split over several independent header
files.
</p><p>
With a partitioned API the part needed by models can be kept as small and
simple as possible, and the boundary between models and the simulator
infrastructure is more clearly defined. A small Device API makes device
modeling easier and reduces the risk of writing code with the
potential to break determinism or multi-threading.
</p><p>
For a model representing a piece of hardware, you should
only need to use the <em>Device API</em> together with the
necessary <em>model-to-model</em> and <em>model-to-simulator</em> interfaces.
</p><p>
To find out how to get access to a particular API function or data type, you
can use the <b><a id="simics-api-information.html:api-help">api-help</a></b> CLI command. This will tell you
which header file, if any, to include (in either DML or C/C++).
</p><p>
</p><h3 class="jdocu"><a id="simics-api-information.html:Device-API">1.2.1.1 Device API</a></h3>
<p>

The basic functionality of the Simics API and the only part available to device
models.
<br>The Device API is always accessible from DML; from C/C++ it is available
using:
</p><pre class="jdocu_small">C:   #include &lt;simics/device-api.h&gt;
C++: #include &lt;simics/cc-api.h&gt;
</pre><p>

</p><h3 class="jdocu"><a id="simics-api-information.html:Model-to-Model-Interfaces">1.2.1.2 Model-to-Model Interfaces</a></h3>
<p>

Interfaces between models typically represent standard hardware
interfaces such as PCI, IC, Ethernet and interrupt
lines. These interfaces are included in the Device API.
</p><p>
<br>Accessible from DML and C/C++ using:
</p><pre class="jdocu_small">DML:   import "simics/devs/<em>interface</em>.dml";
C:     #include &lt;simics/devs/<em>interface</em>.h&gt;
C++:   #include &lt;simics/c++/devs/<em>interface</em>.h&gt;
</pre><p>
where <em>interface</em> should be replaced with the actual header file name.
</p><p>
To find out which header file the <code>foo</code> interface is defined in, you can
use the Simics CLI command <b>api-help <em>foo</em>_interface_t</b>.

</p><h3 class="jdocu"><a id="simics-api-information.html:Model-to-Simulator-Interfaces">1.2.1.3 Model-to-Simulator Interfaces</a></h3>
<p>

These interfaces fall into two categories:
</p><ul>
  <li>Interfaces that models may implement, which are called by the
  Simics framework.</li>
  <li>Interfaces implemented by the Simics framework or by Simics simulator
  objects, which may be called by simulation models.</li>
</ul>
Interfaces included in this list are part of the Device API.
<p>
<br>They are accessed from DML and C/C++ using:
</p><pre class="jdocu_small">DML:   import "simics/model-iface/<em>interface</em>.dml";
C:     #include &lt;simics/model-iface/<em>interface</em>.h&gt;
C++:   #include &lt;simics/c++/model-iface/<em>interface</em>.h&gt;
</pre><p>
where <em>interface</em> should be replaced with the actual header file name.
</p><p>
To find out which header file the <code>foo</code> interface is defined in, you can
use the Simics CLI command <b>api-help <em>foo</em>_interface_t</b>.

</p><h3 class="jdocu"><a id="simics-api-information.html:Simulator-API">1.2.1.4 Simulator API</a></h3>
<p>

The Simulator API contains the complete Simics API, including parts that are
not available to models. This API may be used by simulator extensions.
</p><p>
<br>Accessible from DML and C/C++ using:
</p><pre class="jdocu_small">DML:   import "simics/simulator-api.dml";
C/C++: #include &lt;simics/simulator-api.h&gt;
</pre><p>

</p><h3 class="jdocu"><a id="simics-api-information.html:Simulator-to-Simulator-Interfaces">1.2.1.5 Simulator-to-Simulator Interfaces</a></h3>
<p>

Interfaces that are only used between simulator extensions and that
should not be used by any model are collected into this group. These
interfaces are part of the Simulator API.
</p><p>
<br>Accessible from DML and C/C++ using:
</p><pre class="jdocu_small">DML:   import "simics/simulator-iface/<em>interface</em>.dml";
C:     #include &lt;simics/simulator-iface/<em>interface</em>.h&gt;
C++:   #include &lt;simics/c++/simulator-iface/<em>interface</em>.h&gt;
</pre><p>
where <em>interface</em> should be replaced with the actual header file name.
</p><p>
To find out which header file the <code>foo</code> interface is defined in, you can
use the Simics CLI command <b>api-help <em>foo</em>_interface_t</b>.

</p><h3 class="jdocu"><a id="simics-api-information.html:Processor-API">1.2.1.6 Processor API</a></h3>
<p>

The Processor API extends the Device API with functions needed when modeling
processors in Simics.
<br>Accessible from DML and C/C++ using:
</p><pre class="jdocu_small">DML:   import "simics/processor-api.dml";
C/C++: #include &lt;simics/processor-api.h&gt;
</pre><p>

</p><h3 class="jdocu"><a id="simics-api-information.html:Link-Library-API">1.2.1.7 Link Library API</a></h3>
<p>

The Link Library API extends device modeling capabilities with Simics by
allowing users to write Simics link models.
<br>Accessible from DML and C/C++ using:
</p><pre class="jdocu_small">DML:   import "simics/devs/liblink.dml";
C/C++: #include &lt;simics/devs/liblink.h&gt;
</pre><p>
</p><p>

</p><h3 class="jdocu"><a id="simics-api-information.html:Python-API">1.2.1.8 Python API</a></h3>
<p>

Simics users may utilize Python to interact with the Simics API.  For
example, Python can be used to write or run Simics commands.
Python may also be used to write components and modules for Simics.
</p><p>
The API is accessible from Python by importing the respective
modules listed in chapter
<a class="reference" href="#python-api.html">10</a>.
</p><p>
Python can also be used directly from the Simics command line and
in set-up scripts.


</p><h2 class="jdocu"><a id="simics-api-information.html:API-Version">1.2.2 API Version</a></h2>
<p>

Device makefiles have a variable called <code><a id="simics-api-information.html:SIMICS_API">SIMICS_API</a></code>, which
specifies which version of the Simics API the model uses.
It is a good idea to set <code><a id="simics-api-information.html:SIMICS_API2">SIMICS_API</a></code> to the current
Simics API. This will cause compile errors for uses of deprecated features. 
</p><pre class="jdocu_small">SIMICS_API := 6
</pre><p>
Python modules do not have a SIMICS_API flag to force compiler
checking and thus need to be checked manually. Command line options can be
passed to Simics to ensure any runtime usage of deprecated features trigger
errors.

</p><h2 class="jdocu"><a id="simics-api-information.html:System-Calls-and-Signals">1.2.3 System Calls and Signals</a></h2>
<p>

<a id="simics-api-information.html:modulesignals"></a>
</p><p>
<a id="simics-api-information.html:system-callsrestartable"></a> On Linux,
Simics will register its built-in <a id="simics-api-information.html:signal-handlers">signal handlers</a> to make
system calls restartable after the signal has been handled (cf. the
<code><a id="simics-api-information.html:SA_RESTART">SA_RESTART</a></code> flag in the
<code><a id="simics-api-information.html:sigaction">sigaction</a>(2)</code> man page).
</p><p>
However, only some system calls are restartable, so when writing
modules for Simics, you have to make sure that you restart the other
system calls yourself:<a id="simics-api-information.html:EINTR"></a>
</p><p>
</p><pre class="jdocu_small">do {
        res = accept(sock, &amp;saddr, &amp;slen);
} while (res == -1 &amp;&amp; errno == EINTR);
</pre><p>

</p><h2 class="jdocu"><a id="simics-api-information.html:Text-Output">1.2.4 Text Output</a></h2>
<p>

</p><p>
Simics has its own text output routines that use the command-line
window for display and also allow output to be directed elsewhere. To
maintain this functionality these output routines
should be used instead of the standard C library output routines: Use
<b><i><a id="simics-api-information.html:SIM_printf">SIM_printf</a></i></b> instead of
<b><i><a id="simics-api-information.html:printf">printf</a></i></b>, <b><i><a id="simics-api-information.html:SIM_putchar">SIM_putchar</a></i></b>
instead of <b><i>putchar</i></b>, and so on.
</p><p>
The Simics output functions (<b><i>SIM_write</i></b>,
<b><i>SIM_printf</i></b>, etc.) also send the resulting text to handlers
registered using <b><i><a id="simics-api-information.html:SIM_add_output_handler">SIM_add_output_handler</a></i></b>.
</p><p>
Here is an example showing how a module could get Simics to write a
copy of all its text output to a log file:
</p><p>
</p><pre class="jdocu_small">static void
output_handler(void *file, const void *buf, size_t count)
{
    fwrite(buf, 1, count, (FILE *)file);
}

static void
init_local(void)
{
    SIM_add_output_handler(output_handler,
                           (void *)fopen("my.log", "a"));
}
</pre><p>
</p><p>

</p><h2 class="jdocu"><a id="simics-api-information.html:Using-Threads-in-Simics-Modules">1.2.5 Using Threads in Simics Modules</a></h2>
<p>

</p><p>
It is possible to write modules for Simics that use
POSIX <a id="simics-api-information.html:threads">threads</a>, but only a restrictive part of the
Simics API can be used directly from such threads.
It is possible, however, to post callbacks that have
access to the entire API. One way to do that is through the
<b><i>SIM_thread_safe_callback</i></b> API function. It is also possible
to enter a context where a larger part of the Simics API is available.
This, and the threading model in general, is discussed in some
detail in chapter <a class="reference" href="#rmapi-threading-model.html">2</a>.
</p><p>

</p><h2 class="jdocu"><a id="simics-api-information.html:Header-Inclusion-Order">1.2.6 Header Inclusion Order</a></h2>
<p>

<a id="simics-api-information.html:include-filesorder"></a>
<a id="simics-api-information.html:header-filesorder"></a>
<a id="simics-api-information.html:order-of-inclusion"></a>
</p><p>
For modules written in C or C++, the general order of header file inclusion
should be from most to least general:
</p><p>
<table>

 <tbody><tr>
  <td class="jdocu_noborder">Language</td>
  <td class="jdocu_noborder">e.g., <code>&lt;stdio.h&gt;</code> (C), <code>&lt;map&gt;</code> (C++)</td>
 </tr>

 <tr>
  <td class="jdocu_noborder">Operating system</td>
  <td class="jdocu_noborder">e.g., <code>&lt;unistd.h&gt;</code> (Linux),
      <code>&lt;windows.h&gt;</code> (Windows)</td>
 </tr>

 <tr>
  <td class="jdocu_noborder">Simics</td>
  <td class="jdocu_noborder">e.g., <code>&lt;simics/device-api.h&gt;</code></td>
 </tr>

 <tr>
  <td class="jdocu_noborder">Application</td>
  <td class="jdocu_noborder">specific to your module</td>
 </tr>

</tbody></table>
</p><p>
When this order is observed problems related to interference between
include files should be minimized. In particular, Simics may redefine
some standard functions with preprocessor macros and this can cause
problems unless the standard headers are included first.
</p><p>

</p><p>
</p></section><section class="page" id="api-usage-rules.html"><h1 class="jdocu"><a id="api-usage-rules.html:API-usage-rules">1.3 API usage rules</a></h1>
<p>
  
  </p><h2 class="jdocu"><a id="api-usage-rules.html:Simics-API-value-ownership-rules">1.3.1 Simics API value ownership rules</a></h2>
<p>
  
  <a id="api-usage-rules.html:ownership"></a><a id="api-usage-rules.html:deallocation"></a>
</p><p>
  The <em>owner</em> of a value in memory is the code or object
  responsible for freeing the value when it is no longer needed.
  Failure to do so may cause excessive memory consumption
  (a <em><a id="api-usage-rules.html:memory-leak">memory leak</a></em>). Deallocation of objects that
  are not owned, or use of objects after they have been freed, will
  likely result in a crash.
  </p><p>
  The ownership rules only apply to code written in C, C++ and DML.
  In <a id="api-usage-rules.html:Python">Python</a>, <a id="api-usage-rules.html:memory-management">memory management</a> is entirely
  automatic.
  </p><p>
  The general rules in Simics are:
</p><p>
  </p><ul>
    <li>
      <em>The caller of a function retains ownership of the arguments
      it passes to that function.</em> Called functions do not assume
      ownership of the arguments they receive.
    </li>
    <li>
      <em>The caller of a function receives ownership of the value
      returned from that function.</em> Called functions must relinquish
      ownership of values they return.
    </li>
    <li>
      A return type <code>const T *</code>, for some
      type <code>T</code>, is taken to mean that ownership of the
      returned value is <em>not</em> transferred to the caller,
      overriding the previous rule.
    </li>
  </ul>
      <p>
  Exceptions to the rules above are documented for each interface or
  API call.
</p><p>
  Each data type has its own way of deallocation. It is generally
  documented where objects of that type are created; see below for
  some specific examples.
  </p><p>
  </p><dl><dt id="api-usage-rules.html:dt:strings"><a href="#api-usage-rules.html:dt:strings"><b>Strings</b></a></dt><dd>Null-terminated <a id="api-usage-rules.html:strings">strings</a> are freed using
      <b><i><a id="api-usage-rules.html:MM_FREE">MM_FREE</a></i></b> in C/C++,
      <code><a id="api-usage-rules.html:delete">delete</a></code> in DML. They are created using
      <b><i><a id="api-usage-rules.html:MM_MALLOC">MM_MALLOC</a></i></b>, <b><i><a id="api-usage-rules.html:MM_STRDUP">MM_STRDUP</a></i></b>
      or other functions that create heap-allocated strings.
      (The standard C library functions <b><i><a id="api-usage-rules.html:malloc">malloc</a></i></b>,
      <b><i><a id="api-usage-rules.html:free">free</a></i></b> etc should <em>not</em> be used.)
<p>
      The pointer-to-<code>const</code> rule applies: a string
      returned as <code><a id="api-usage-rules.html:char-">char *</a></code> becomes owned by the
      caller, but not one returned as
      <code><a id="api-usage-rules.html:const-char-">const char *</a></code>.
    </p></dd><dt id="api-usage-rules.html:dt:attribute-values"><a href="#api-usage-rules.html:dt:attribute-values"><b>Attribute values</b></a></dt><dd>Values of type <code><a id="api-usage-rules.html:attr_value_t">attr_value_t</a></code> are freed
      using <b><i><a id="api-usage-rules.html:SIM_attr_free">SIM_attr_free</a></i></b>.
<p>
      Since the values may refer to heap-allocated data, they cannot
      be copied by simple (shallow) assignment. To create a (deep)
      copy of an <code>attr_value_t</code> that is safe to access
      after the original has been freed,
      use <b><i><a id="api-usage-rules.html:SIM_attr_copy">SIM_attr_copy</a></i></b>.
</p><p>
      The <code>attr_value_t</code> accessor functions return values
      that borrow references to parts of the argument. Therefore, the
      returned values cannot be altered, and cannot be used beyond
      the life-time of the argument. (This obviously does not apply
      to non-allocated values such as numbers or booleans.)
    </p></dd><dt id="api-usage-rules.html:dt:simics-managed-types"><a href="#api-usage-rules.html:dt:simics-managed-types"><b>Simics-managed types</b></a></dt><dd>Values of some types are always owned and managed by Simics
      itself and should never be freed by the user. Examples are
      <code><a id="api-usage-rules.html:conf_object_t">conf_object_t</a></code>
      and <code><a id="api-usage-rules.html:conf_class_t">conf_class_t</a></code>.
    </dd></dl><p>
  </p><h2 class="jdocu"><a id="api-usage-rules.html:api-execution-contexts">1.3.2 API Execution Contexts</a></h2>
<p>
  
  </p><p>
  The set of Simics API functions and interface methods that can be
  called at a given point depends on the state of the execution thread
  at the time of the call. The thread states are classified into
  <em><a id="api-usage-rules.html:API-execution-contexts">API execution contexts</a></em>. Three distinct execution
  contexts are defined, and they are inclusive, as illustrated in
  the figure below:
</p><p>
  </p><div class="figure">

    <div style="text-align: center">
      <img alt="" src="execution-context.png">
      <div class="caption">The execution context defines the part of the Simics API that
	may be used</div>
    </div>
  </div>

<p>
  <br>Below is a description of the defined execution contexts:
  </p><dl><dt id="api-usage-rules.html:dt:global-context"><a href="#api-usage-rules.html:dt:global-context"><b></b></a><b><a id="api-usage-rules.html:Global-Context">Global Context</a></b></dt><dd>Previously, this context was known as Outside Execution Context (OEC).
<p>
      The most permissive context. A thread running in
      Global Context has exclusive access to all objects in the simulation.
      </p><p>
      In Global Context, either the simulation is not running or
      all simulation activity
      has temporarily been suspended. The front-end runs in this
      context, as do the callbacks from <b><i><a id="api-usage-rules.html:SIM_run_alone">SIM_run_alone</a></i></b>,
      <b><i><a id="api-usage-rules.html:SIM_thread_safe_callback">SIM_thread_safe_callback</a></i></b> and
      <b><i><a id="api-usage-rules.html:SIM_notify_on_socket">SIM_notify_on_socket</a></i></b> with the
      <i>run_in_thread</i> argument set to 0. Module initialisation,
      object creation and object destruction are also performed in
      this context.
  </p><p>
      The full API is available, including functions
      and methods documented as callable in other contexts.
    </p></dd><dt id="api-usage-rules.html:dt:cell-context-ec-ic"><a href="#api-usage-rules.html:dt:cell-context-ec-ic"><b></b></a><b><a id="api-usage-rules.html:Cell-Context">Cell Context</a> (<a id="api-usage-rules.html:ECIC">EC/IC</a>)</b></dt><dd>This is a single context which was introduced in Simics 6 instead
      of Execution Context (EC) and Instruction Context (IC) that were
      around before.
<p>
      The context used for most device simulation. Typically used
      when the simulation is running.
</p><p>
      Only functions and methods documented as callable in
      Cell Context or Threaded Context are available in this context.
</p><p>
      Other objects in the simulation may be accessed or referenced,
      but only objects belonging to the same <em>simulation cell</em>.
      The cell concept is discussed in some detail in section
      <a class="reference" href="#multithreading-simulation-cells.html">2.3</a>, but basically
      it is a partitioning of the simulation into groups of objects.
      Cell Context is always tied to a specific cell.
      </p><p>
      Most device code run in this context, for instance when
      a CPU accesses a device register, as do event callbacks
      and many hap handlers.
    </p></dd><dt id="api-usage-rules.html:dt:threaded-context"><a href="#api-usage-rules.html:dt:threaded-context"><b></b></a><b><a id="api-usage-rules.html:Threaded-Context">Threaded Context</a></b></dt><dd>Previously, this context was known as Foreign Thread Context (FTC).
<p>
      The most restrictive context, denoting a thread which is 
      in neither Cell Context nor Global Context.
</p><p>
      Manually created threads and <b><i>SIM_run_in_thread</i></b> callbacks
      are examples where this context is applicable.
      Thread-aware models, like a CPU with support for multicore threading,
      also perform most of its simulation in Threaded Context.
      </p><p>
      The available API is limited to functions explicitly
      declared as being available in Threaded Context, but
      a more permissive context can be entered when needed. For example,
      <b><i><a id="api-usage-rules.html:SIM_thread_safe_callback2">SIM_thread_safe_callback</a></i></b> posts a
      callback which is invoked in Global Context, and
      Cell Context can be reached with
      the <b><i>SIM_ACQUIRE_CELL</i></b> primitive.
</p><p>
      While objects can be accessed in this context, it is only permitted
      after special primitives are used to ensure single-threaded access.
      This usually amounts to entering Cell Context, but
      thread-aware models can actually access their own object
      state directly from Threaded Context. This is discussed in
      chapter <a class="reference" href="#rmapi-threading-model.html">2</a>.
    </p></dd></dl><p>The reference manuals detail the permitted API execution context for
  each API function and interface method. Calls are allowed in the
  specified and more permissive contexts.
  </p><p>
  Violations of the API execution context rules have undefined
  consequences. They may result in warnings or error messages, but this
  is not guaranteed. In particular, a class implementing an interface
  method is under no obligation to perform any such checks.

</p></section><section class="page" id="simics-api-syntax.html"><h1 class="jdocu"><a id="simics-api-syntax.html:Simics-API-Syntax">1.4 Simics API Syntax</a></h1>
<p>

    Most of the information in this chapter uses C syntax, extended with two
    additional keywords:
    </p><dl><dt id="simics-api-syntax.html:dt:notnull"><a href="#simics-api-syntax.html:dt:notnull"><b><code></code></b></a><b><code><a id="simics-api-syntax.html:NOTNULL">NOTNULL</a></code></b></dt><dd>The <code>NOTNULL</code> keyword means that this function argument must not
    be a null pointer. In Python, where <code>None</code> is used as the null
    pointer value, there will be an exception thrown if such a function is
    called with a <code>None</code> value.</dd><dt id="simics-api-syntax.html:dt:python_method"><a href="#simics-api-syntax.html:dt:python_method"><b><code></code></b></a><b><code><a id="simics-api-syntax.html:PYTHON_METHOD">PYTHON_METHOD</a></code></b></dt><dd>Most interfaces are in <em>canonical</em><a id="simics-api-syntax.html:canonical----interfaces"></a> form; i.e., they only contain function pointers, and the
    first argument is always the object whose interface is called.
<p>
    For non-canonical interfaces, the keyword <code>PYTHON_METHOD</code> is used to
    mark regular methods. These should be called <em>without</em> their first
    argument when used from Python.
</p><p>
    Note that there is no special mark-up for canonical interfaces.</p></dd></dl><p></p></section><section class="page" id="rmapi-threading-model.html"><h1 class="jdocu"><a id="rmapi-threading-model.html:rmapi-threading-model">2 Threading Model</a></h1>
<p>

</p><p>
This chapter describes the Simics threading model from a device
model perspective. Important concepts as <em>cells</em>,
<em>thread domains</em> and <em>execution context</em> are explained
in some detail. The <em>Standard Device Model</em> and the
<em>Threaded Device Model</em> are also defined.
</p><p>









</p></section><section class="page" id="multithreading-overview.html"><h1 class="jdocu"><a id="multithreading-overview.html:multithreading-overview">2.1 Overview</a></h1>
<p>

</p><p>
At the highest level, a Simics configuration is partitioned
into one or multiple <em>simulation cells</em>. Each cell can be
simulated in parallel with the other cells, with maintained determinism.
</p><p>
</p><div class="figure" id="multithreading-overview.html:cell_partitioning">

<div style="text-align: center">
<img alt="" src="cell.png">
<div class="caption">Figure 1. Configuration is partitioned into cells.
  Cell membership is
  determined
  <br>by following <i>queue</i> and <i>cell</i>
  attributes to an actual cell object.</div>
</div>
</div>

<p>
Distinct cells are <em>loosely coupled</em>. A typical example is a
multi-machine configuration, where each machine consists of a single cell,
and where the machines are connected with a simulated Ethernet network.
Communication between cells occurs through special objects called
<em>links</em> that forward messages between cells.
</p><p>
A device model should not access objects belonging to a different
cell directly.
</p><p>
Each cell is partitioned into one or more
<em>thread domains</em>. Models belonging to different thread domains
can be simulated in parallel. However, objects within a single thread domain
can only be accessed by a single thread at a time, namely by the
<em>thread currently holding the domain</em>.
A thread domain should be thought of as a high-level locking construct
ensuring single-threaded access to the objects it contains.
</p><p>
</p><div class="figure" id="multithreading-overview.html:td_partitioning">

<div style="text-align: center">
  <img alt="" src="thread-domains.png">
<div class="caption">Figure 2. Each cell is partitioned into thread domains.</div>
</div>
</div>

<p>
Unlike the cell partitioning, which is static and given by the configuration,
the partitioning of a cell into thread domains is performed by Simics as a
function of the selected simulation mode, model capabilities, and
any declared thread domain constraints.
</p><p>
The thread domains in a cell are not all equal. The thread domain which
contains the cell object itself is special and is called the <b>cell thread
domain</b> (cell TD). Objects residing in this domain use a very permissive
device model, the <b>Standard Device Model</b>, described in
section <a class="reference" href="#multithreading-standard-device-model.html">2.6</a>. Among other
things, such models do not need to worry about thread domain boundary
crossings or threading issues. Most models use this device model.
</p><p>
Models located in thread domains other than the cell TD are called
thread-aware, and use the more restrictive <b>Threaded Device Model</b>,
which is described in section <a class="reference" href="#multithreading-threaded-cpu.html">2.7</a>.
</p><p>
The threads used to actually simulate the models are usually created by
Simics, but models can also create their own threads. The Simics scheduler is
briefly discussed in section <a class="reference" href="#multithreading-scheduler.html">2.9</a>.
</p></section><section class="page" id="basic-module-requirements.html"><h1 class="jdocu"><a id="basic-module-requirements.html:Basic-Module-Requirements">2.2 Basic Module Requirements</a></h1>
<p>

</p><p>
To use multi-threading in Simics, all modules used in the
simulation must be thread safe. This section describes what it means
for a module to be thread safe, and what conditions must be fulfilled.
</p><p>
</p><div class="note">
<b>Note:</b>
In this section, thread safe is used in the sense that models
  instantiated in different cells can be simulated
  concurrently without issues. This is a weaker definition than normally used.
</div>Simics checks each module it loads to see if it has been marked as
safe. A module is thread safe if it fulfills the following conditions:
<p>
</p><ul>
  <li>It must run without execution context violations.</li>
  <li>The module makefile variable <i>THREAD_SAFE</i> must be set to
    <code>yes</code> when compiling the module.</li>
</ul>
<p>
Below is an example makefile for a module marked as thread safe.
It can be found in the
<code></code><em>[project]</em><code>/modules/sample-user-decoder</code> directory
if the <b>sample-user-decoder</b> has been copied to the
project.
</p><p>
</p><pre class="jdocu_small">MODULE_CLASSES = sample-user-decoder

SRC_FILES = sample-user-decoder.c

SIMICS_API := 6
THREAD_SAFE = yes

include $(MODULE_MAKEFILE)
</pre><p>
</p><p>
To make a module thread safe, global state should be avoided, both in
the form of global variables and in the form of local static
variables in C. Having constant global variables are fine. Modules written
in pure DML do not have this problem since the DML compiler
does not emit any non-constant global state.
</p><p>
Simics checks for some execution context violations during
run-time and emits warnings if they occur. When running
with multi-threading disabled, violations result in warnings that can
optionally be turned off. With multi-threading enabled,
violations cause hard errors.
</p><p>
If a module that is not marked with <code>THREAD_SAFE=yes</code> is
loaded, multi-threading will be turned off automatically and a warning
will be shown. The <b>list-modules</b> command will show whether a
module is marked thread safe or not.
</p></section><section class="page" id="multithreading-simulation-cells.html"><h1 class="jdocu"><a id="multithreading-simulation-cells.html:multithreading-simulation-cells">2.3 Simulation Cells</a></h1>
<p>

<a id="multithreading-simulation-cells.html:cell"></a>
</p><p>
A cell is a group of configuration objects which may interact with
each other through direct function calls.  If a model needs to
communicate with objects in other cells during the simulation, it
needs to do this through links (see section <a class="reference" href="#multithreading-simulation-cells.html:Link-Objects">2.3.4</a> or the <em>Link Library Programming Guide</em>). A link
introduces a delay in the communication
(unless <i>immediate_delivery</i> is set), which means that
messages cannot be sent and received in the same cycle.
</p><p>
In a configuration, a cell is represented by a configuration object of
class <b>cell</b>. All objects that implement the <code>cycle</code>
interface (referred to as clocks) automatically have a <i>cell</i>
attribute that will point to the cell they belong to. Since all Simics objects
have a <i>queue</i> attribute pointing at a clock object, they will by
extension belong to the cell of their clock object. This is illustrated
in the figure below:
</p><div class="figure" id="multithreading-simulation-cells.html:cell_partitioning">

<div style="text-align: center">
<img alt="" src="cell.png">
<div class="caption">Figure 3. Configuration is partitioned into cells</div>
</div>
</div>

<br>Another example is the following configuration:
<pre class="jdocu_small">OBJECT cell0 TYPE cell {
}
OBJECT cell1 TYPE cell {
}
OBJECT cpu0 TYPE cpu {
       cell: cell0
}
OBJECT cpu1 TYPE cpu {
       cell: cell0
}
OBJECT cpu2 TYPE cpu {
       cell: cell1
}
OBJECT device0 TYPE device {
       queue = cpu0
}
OBJECT device1 TYPE device {
       queue = cpu0
}
OBJECT device2 TYPE device {
       queue = cpu2
}
</pre><p>
</p><p>
In this example, <b>device0</b> has <b>cpu0</b> as a queue, and thus
belongs to <b>cell0</b>, while <b>device2</b>
has <b>cpu2</b> as a queue, and thus belongs to <b>cell1</b>.
</p><p>
</p><h2 class="jdocu"><a id="multithreading-simulation-cells.html:Cells-and-Components">2.3.1 Cells and Components</a></h2>
<p>

</p><p>
Simics provides an
automatic cell partitioning based on top-level components. Each
component object implements a <b><i><a id="multithreading-simulation-cells.html:create_cell">create_cell</a>()</i></b>
method that can
return <code>True</code> or <code>False</code> to the question:
should a simulation cell be created to contain this component and all
its sub-components? By default, top-level components return 
<code>True</code> and all other components return <code>False</code>. 
By overriding this method, it is possible to 
automatically create cells at lower levels in the component hierarchy,
or to disable cell creation altogether. In the latter case, the
<b><i>create_cell()</i></b> should return <code>False</code> and the 
components should define cell objects themselves and assign clocks to
them as appropriate, just as normal configuration objects.
</p><p>
The code snippets below show how to overload
the <b><i>create_cell()</i></b> function for both old-style and hierarchical
way of writing components.
</p><p>
</p><pre class="jdocu_small">class mycomp(component_object):
    ...
    def create_cell(self):
        return False

class mycomp(StandardConnectorComponent): # or StandardComponent
    ....
    class component(comp.StandardComponent.component):
        def create_cell(self):
            return False
</pre><p>
</p><p>
Cells can also be created independently of components, by
creating <b>cell</b> objects and setting the <i>cell</i>
attribute of the clock objects which should belong to the cell.
</p><p>

</p><h2 class="jdocu"><a id="multithreading-simulation-cells.html:Compatibility">2.3.2 Compatibility</a></h2>
<p>

</p><p>
If clock objects are created that do not point to a cell, then
a <b>default_cell</b> object will be created, unless it exists already,
to make sure these clock objects are scheduled as intended.
This is a simple compatibility mechanism for use with older scripts.
If you are building your configurations in several steps, but without
using components, you will have to introduce your own cells and configure them.
</p><p>

</p><h2 class="jdocu"><a id="multithreading-simulation-cells.html:Verifying-the-Cell-Partitioning">2.3.3 Verifying the Cell Partitioning</a></h2>
<p>

</p><p>
The <b>check-cell-partitioning</b> command checks
either a checkpoint or the currently loaded configuration for
violations of the cell partitioning rulesnamely, that
objects belonging to one cell do not have any references to
objects in another cell. Such references will be shown
in the form of a chain of attributes connecting the cells.
</p><p>
An object is considered to belong to a cell if either it is a cell
object, or if it refers to or is referred to by an object belonging to
that cell. Object references are object values in (checkpointed)
attributes.
</p><p>
False positives can be suppressed by defining the attribute
<i>outside_cell</i> and setting it to true for objects
that should not be considered part of any cell but still refer
to other objects in cells. This can be necessary for objects
that only use these references in safe ways, e.g., in Global Context.
</p><p>

</p><h2 class="jdocu"><a id="multithreading-simulation-cells.html:Link-Objects">2.3.4 Links</a></h2>
<p>

</p><p>
Links are the only Simics objects that should connect different cells
together. In other words, link components are allowed to connect to
device components
belonging to different cells without breaking the cell isolation rules. This
works because all communication over the links are asynchronous with a delay
that is constrained by the synchronization parameters so that the information
exchange never becomes indeterministic.
</p><p>
</p><div class="note">
<b>Note:</b>
While it is possible to perform cross-cell calls if special
  precautions are taken, it should be avoided since it likely prevents the
  simulation from being deterministic even when the simulation is
  running in the "serial" threading mode.
</div>
<h2 class="jdocu"><a id="multithreading-simulation-cells.html:Synchronization-domains">2.3.5 Synchronization domains</a></h2>
<p>

</p><p>
All cells are connected to a <em><a id="multithreading-simulation-cells.html:synchronization-domain">synchronization domain</a></em> that
controls the execution in the cells to ensure that they do not run too
far apart in virtual time. The domain has a <i>min_latency</i>
parameter that limits the allowed difference in time between clocks in
all the cells connected to it. This works as a lower limit for the
latency that link objects can use when communicating between cells.
</p><p>

</p></section><section class="page" id="multithreading-thread-domains.html"><h1 class="jdocu"><a id="multithreading-thread-domains.html:multithreading-thread-domains">2.4 Thread Domains</a></h1>
<p>

Each object in the simulation has a thread domain associated with it. The same
thread domain can be associated with multiple objects.
</p><p>
The basic rule is that before the state of an object is accessed, the
corresponding thread domain needs to be held by the thread performing the
access. This ensures that an object is never accessed concurrently
by two different threads.
</p><p>
The thread domain containing the cell object, the <b>cell thread domain
(cell TD)</b>, has some special properties. Sometimes it is referred to as just
the "cell" for brevity, as in "acquiring the cell", and "holding the cell",
which should be read as "acquiring the cell thread domain", and
"holding the cell thread domain" respectively.
</p><p>
</p><div class="figure">

<div style="text-align: center">
  <img alt="" src="thread-domains.png">
<div class="caption">Division of a cell into thread domains</div>
</div>
</div>

<p>
The cell TD should be thought of as a single-threaded domain.
To a model in the cell TD, everything in the entire cell appears to be
simulated from a single thread, even if this is not the case.
</p><p>
</p><div class="note">
<b>Note:</b>
In most cases, the appropriate thread domain is already held, and no
  special action needs to be taken. This is for instance the case for normal
  device models, which run in Cell Context, or for code running in
  Global Context.
<p>
  Only models which use custom threads or use the Threaded Device Model
  need to acquire thread domains explicitly.
</p></div><h2 class="jdocu"><a id="multithreading-thread-domains.html:multithreading-execution-context">2.4.1 Relationship with API Execution Context</a></h2>
<p>The relationship between the API execution context, defined in
section <a class="reference" href="#api-usage-rules.html:api-execution-contexts">1.3.2</a>, and thread domains
is as follows:
</p><dl><dt id="multithreading-thread-domains.html:dt:global-context"><a href="#multithreading-thread-domains.html:dt:global-context"><b>Global Context</b></a></dt><dd><b>All</b> thread domains (and by implication, all cells) in
    the simulation are held by the thread.
    The thread has exclusive access to all objects. CLI scripts,
    Python scripts, CLI commands, script-branches, and
    object initialization code, all run in Global Context.
<p>
  </p></dd><dt id="multithreading-thread-domains.html:dt:cell-context"><a href="#multithreading-thread-domains.html:dt:cell-context"><b>Cell Context</b></a></dt><dd>The <b>cell TD</b> is held by the thread. The thread can freely
    access all other objects in the cell. Normal device models (i.e. models
    which are not thread-aware) can assume that they are invoked in this
    context.
<p>
  </p></dd><dt id="multithreading-thread-domains.html:dt:threaded-context"><a href="#multithreading-thread-domains.html:dt:threaded-context"><b>Threaded Context</b></a></dt><dd>No thread domains are required to be held, but thread-aware models
    often hold <b>their own</b> thread domain.
  </dd></dl><p></p><div class="note">
<b>Note:</b>
The locking model in Simics is <em>asymmetrical</em>. Models running in
  Cell Context can call interface functions on any object in the cell
  without taking any special measures, and this includes interfaces on
  objects belonging to a different TD. This is possible since thread-aware
  models are required to guard model entry points by acquiring
  their own domains. Conversely, thread-aware models are required to enter
  Cell Context explicitly, by using a special API call, before
  calling interface functions on objects in the cell TD.
</div>
<h2 class="jdocu"><a id="multithreading-thread-domains.html:thread-domains-primitive">2.4.2 Lock Semantics</a></h2>
<p>

A thread domain has the following basic properties:
</p><ul>
  <li><b>Exclusive</b> - a thread domain can only be held by a single thread at
    a time</li>
  <li><b>Recursive</b> - a thread domain can be acquired multiple times
    by the same thread</li>
  <li><b>Extendable</b> - multiple thread domains can be held simultaneously
    by a thread, and the thread may access any object whose thread domain is
    held.</li>
</ul>
The following macros are used to acquire thread domains. 
<p>
</p><dl><dt id="multithreading-thread-domains.html:dt:sim_acquire_object"><a href="#multithreading-thread-domains.html:dt:sim_acquire_object"><b>SIM_ACQUIRE_OBJECT</b></a></dt><dd>Acquires the thread domain associated with the object.
<p>
    This function is intended to be used by thread-aware objects
    to obtain its own thread domain before modifying internal state
    protected by the domain.
</p><p>
    This primitive does <b>not</b> enter Cell Context, even if the
    cell TD is acquired. The reason is that the <em>retention</em> mechanism
    is not activated (see below).
  </p></dd><dt id="multithreading-thread-domains.html:dt:sim_acquire_target"><a href="#multithreading-thread-domains.html:dt:sim_acquire_target"><b>SIM_ACQUIRE_TARGET</b></a></dt><dd>Enters Cell Context if the specified object belongs
    to the cell TD. As part of entering Cell Context,
    the cell TD is acquired.
<p>
    This primitive does nothing if the object does not belong to
    the cell TD. In other words, it is a no-op if the specified
    object is thread-aware.
    </p><p>
    Thread-aware code, which is not running in Cell Context, uses this
    function before invoking an interface method on an external object.
  </p></dd><dt id="multithreading-thread-domains.html:dt:sim_acquire_cell"><a href="#multithreading-thread-domains.html:dt:sim_acquire_cell"><b>SIM_ACQUIRE_CELL</b></a></dt><dd>Enters Cell Context unconditionally. The specified object
    is associated with a cell whose TD is acquired as part of entering
    Cell Context.
<p>
    The function should be used before calling an API function, or callback,
    requiring Cell Context.
  </p></dd></dl><p>Each primitive above
should be used together with the corresponding release function.
Macros are used in order to allow lock statistics to be collected
with information about where the lock was acquired. There are also
corresponding SIM-functions available.
</p><p>
</p><div class="note">
<b>Note:</b>
If multiple thread domains are acquired, then they must be released
  in strict reverse order. Failure to do so will result in a hard error
  and a complaint about locks being released in an incorrect order.
</div><div class="note">
<b>Note:</b>
The difference between <b>SIM_ACQUIRE_CELL</b> and
  <b>SIM_ACQUIRE_TARGET</b> is really that the former <b>always</b> acquires the
  cell thread domain and enters Cell Context, whereas the latter is a
  no-op when a thread-aware object is specified.
<p>
  The reason for the distinction is that thread-aware objects
  are required to protect incoming as needed; this self-protection
  usually involves a call to <b>SIM_ACQUIRE_OBJECT</b>, but
  models are free to use alternate locking schemes.
</p></div>
<h2 class="jdocu"><a id="multithreading-thread-domains.html:thread-domains-contention">2.4.3 Contention</a></h2>
<p>

</p><div class="note">
<b>Note:</b>
This section describes how Simics handles thread domain contention,
  and it is mostly provided to allow for a deeper understanding of the
  Simics threading model.</div>When a thread tries to acquire a thread domain which is already held or
requested by another thread, then the following happens:
<ul>
  <li>The thread is assigned a priority, using the table below.</li>
  <li>All domains held by the thread are released and marked as contended</li>
  <li>The current holder of the requested domain is notified that a thread
    is waiting for the domain, and the domain is marked as contended.</li>
  <li>The thread is blocked until all needed domains are available and can
    be assigned to the thread. Among all threads waiting for a domain,
    the domain can only be assigned to the thread with the highest priority.
  </li>
</ul>
<p>
The priority is assigned as follows:
</p><dl><dt id="multithreading-thread-domains.html:dt:"><a href="#multithreading-thread-domains.html:dt:"><b>&nbsp;</b></a></dt><dd><table>

<tbody><tr><td class="jdocu_border">Priority</td>  <td class="jdocu_border">Name &nbsp;&nbsp;</td> <td class="jdocu_border">Situation</td></tr>

<tr><td class="jdocu_border">1</td><td class="jdocu_border">Execute</td><td class="jdocu_border">
    TD acquired for instruction execution (lowest priority)
</td></tr>

<tr><td class="jdocu_border">2</td><td class="jdocu_border">Yield</td><td class="jdocu_border">
    domains reacquired after explicit yield
</td></tr>

<tr><td class="jdocu_border">3</td><td class="jdocu_border">Entry</td><td class="jdocu_border">
    TD acquired, no other domains held
</td></tr>

<tr><td class="jdocu_border">4</td><td class="jdocu_border">Entry 2</td><td class="jdocu_border">
    TD acquired, other TDs already held
</td></tr>

<tr><td class="jdocu_border">5</td><td class="jdocu_border">Cell Entry</td><td class="jdocu_border">
    cell acquired with
    <b><i>SIM_ACQUIRE_CELL/TARGET</i></b>
</td></tr>

<tr><td class="jdocu_border">6</td><td class="jdocu_border">Elevated</td><td class="jdocu_border">
    TD acquired in Cell Context
</td></tr>

<tr><td class="jdocu_border">7</td><td class="jdocu_border">Message</td><td class="jdocu_border">
    TD acquired for delivery of direct memory message
</td></tr>

</tbody></table></dd></dl><p>In the table above, TD stands for a thread domain which is not the cell TD.
</p><p>
A contended thread domain is always assigned to the waiting thread with
the highest priority. The domain is never released to a thread with lower
priority, even if the domain is unused and the highest priority thread is
waiting upon some other domain.
</p><p>
The priority scheme serves two purposes:
</p><ul>
  <li>It ensure that a deadlock situation cannot occur.</li>
  <li>It ensures that a thread in Cell Context is not preempted
    by other threads when there is lock contention.
  </li>
</ul>
<div class="note">
<b>Note:</b>
For performance reasons, a thread waiting for a thread domain will typically
  spin for a certain amount of time before falling back to sleeping on some
  condition variable.
</div>
<h2 class="jdocu"><a id="multithreading-thread-domains.html:thread-domains-retention">2.4.4 Domain Retention</a></h2>
<p>

In Cell Context, a special mechanism is used when
additionally acquired thread domains are released:
</p><dl><dt id="multithreading-thread-domains.html:dt:domain-retention-mechanism"><a href="#multithreading-thread-domains.html:dt:domain-retention-mechanism"><b>Domain retention mechanism</b></a></dt><dd>The release of additionally acquired domains is deferred until
    Cell Context is exited, or in other words, until the cell TD
    is released.
</dd></dl><p>As an example, consider a thread doing the following, with CPU1 belonging
to thread domain TD_cpu1, CPU2 to TD_cpu2, and device DEV to TD_cell,
respectively:
</p><ol>
  <li>CPU1 is simulated while holding TD_cpu1</li>
  <li>EC is entered before the model calls an interface on DEV.
    TD_cell is acquired when EC is entered.</li>
  <li>device DEV queries CPU2 for its cycle count. The TD_cpu2 domain is
    acquired and released during this operation, but the actual release
    of TD_cpu2 is deferred by the retention mechanism</li>
  <li>device DEV posts an event on CPU2, again taking and releasing TD_cpu2</li>
  <li>TD_cell is released when the DEV interface call returns, and
    the thread leaves Cell Context. The retention mechanism causes TD_cpu2
    to be released for real at this point</li>
</ol>
The retention mechanism ensures that TD_cpu2, in the example above, is
held until the device access is complete. Between point 3 and point 5,
CPU2 will not be simulated, and its state will be stable.
<div class="note">
<b>Note:</b>
The retention mechanism ensures that a device model sees
  a stable state for all objects it interacts with. The mechanism allows
  CPUs to run concurrently with device models, but when a
  device model interacts with a CPU, it is stopped until the device
  operation is complete.
</div>
</section><section class="page" id="multithreading-concurrency-modes.html"><h1 class="jdocu"><a id="multithreading-concurrency-modes.html:multithreading-concurrency-modes">2.5 Concurrency Modes</a></h1>
<p>

A device model can run in one of three concurrency modes. The modes are as
follows:
</p><dl><dt id="multithreading-concurrency-modes.html:dt:sim_concurrency_mode_serialized"><a href="#multithreading-concurrency-modes.html:dt:sim_concurrency_mode_serialized"><b><code>Sim_Concurrency_Mode_Serialized</code></b></a></dt><dd>The model can assume Cell Context.
<p>
    The model is put in the cell thread domain.
</p><p>
    The device may interact with all
    objects in the cell without having to acquire any thread domains or take
    threading into account.
   </p><p>
    Objects in the same cell, including objects belonging in other
    thread domains, always have a stable state when queried.
</p><p>
  </p></dd><dt id="multithreading-concurrency-modes.html:dt:sim_concurrency_mode_serialized_memory"><a href="#multithreading-concurrency-modes.html:dt:sim_concurrency_mode_serialized_memory"><b><code>Sim_Concurrency_Mode_Serialized_Memory</code></b></a></dt><dd>The model runs in Threaded Context.
<p>
    The model is put in a separate thread domain.
</p><p>
    The model is required to handle locking explicitly for both incoming and
    outgoing interface calls.
</p><p>
    Whenever the model crosses a thread domain boundary, or enters
    Cell Context, all devices
    in the cell can potentially undergo state transitions.
</p><p>
    Models that share memory must be grouped together (see the section on
	Thread Domain Groups below).
  </p></dd><dt id="multithreading-concurrency-modes.html:dt:sim_concurrency_mode_full"><a href="#multithreading-concurrency-modes.html:dt:sim_concurrency_mode_full"><b><code>Sim_Concurrency_Mode_Full</code></b></a></dt><dd>The model runs in Threaded Context.
<p>
    The model is put in a separate thread domain.
</p><p>
    The model is required to handle locking explicitly for both incoming and
    outgoing interface calls.
</p><p>
    Whenever the model crosses a thread domain boundary, or enters
    Cell Context, all devices
    in the cell can potentially undergo state transitions.
</p><p>
    The model cannot assume that pages granted through the direct-memory
    subsystem are not accessed concurrently from a different thread, unless
    exclusive access have been requested explicitly.
  </p></dd></dl><p></p><div class="note">
<b>Note:</b>
The concurrency mode basically only affects whether the model is put in the cell
  thread domain or not. Simics cannot automatically detect needed grouping of models,
  therefore it is the responsibility of the platform developer to assure that models
  are grouped in a correct way.
</div><h2 class="jdocu"><a id="multithreading-concurrency-modes.html:Mode-Selection">2.5.1 Mode Selection</a></h2>
<p>A model advertises its supported concurrency modes through the
<code>concurrency_mode</code> interface. If the interface is omitted,
and the object is not grouped with an object implementing the
<code>concurrency_mode</code> interface (see the next section), then the
model is assumed to only support
<code>Sim_Concurrency_Mode_Serialized</code>.
</p><p>
If the model supports multiple modes, the interface is also used by
Simics to select the concurrency mode the model should use. The mode
is derived from the simulation mode set through the
<b>set-threading-mode</b> command.
</p><p>
Device models normally run in the serialized concurrency mode, whereas
CPU models preferably should support all the modes.
</p><p>
</p><div class="note">
<b>Note:</b>
The <b>set-threading-mode</b> command is used by the user to set
  the threading mode of the simulation.
<p>
  The <em>"serialized"</em> mode puts models in the <b>serialized</b>
  concurrency mode.
  </p><p>
  The <em>"subsystem"</em> mode configures models to use the <b>serialized
    memory</b> concurrency mode, if supported, and <b>serialized</b> mode
  otherwise.
</p><p>
  The <em>"multicore"</em> mode configures models to use the <b>full</b>
  concurrency mode, if supported, and <b>serialized memory</b> or
  just <b>serialized</b> mode otherwise.
</p></div>
<h2 class="jdocu"><a id="multithreading-concurrency-modes.html:Thread-Domain-Groups">2.5.2 Thread Domain Groups</a></h2>
<p>
  
Objects that are part of a thread domain group will be put in the same
thread domain. There can be different reasons for models to be part of the
same thread domain. To keep memory accesses serialized when subsystem threading
is used all models that share memory should be put in the same group.
Even when running in multithreading mode there are objects that should reside
in the same thread domain.
Examples include:
</p><ul>
  <li>a CPU and an object representing its TLB</li>
  <li>a CPU and a CPU-specific timer</li>
  <li>two hyper threads which share a substantial amount of registers
    and whose implementation is not thread safe</li>
</ul>
When forming thread domain groups, Simics queries all objects implementing
the <code>concurrency_group</code> interface. The interface returns
constraints of the type "these objects should be put in the same thread domain",
and they are of two kinds:
<ol>
  <li>constraints that are used in <b>all</b> concurrency modes</li>
  <li>constraints that are only used in the <b>serialized memory</b> mode.
  </li>
</ol>
<p>
A <em>port object</em> is always placed in the same thread domain as
its parent, unless it implements the <em>concurrency_mode</em> interface
or is grouped explicitly with such an object.
</p><p>
For CPU models, the following is recommended:
</p><dl><dt id="multithreading-concurrency-modes.html:dt:sim_concurrency_mode_serialized_memory-2"><a href="#multithreading-concurrency-modes.html:dt:sim_concurrency_mode_serialized_memory-2"><b><code>Sim_Concurrency_Mode_Serialized_Memory</code></b></a></dt><dd>Tightly connected CPUs are grouped together.
<p>
    In this context, tightly connected really means CPUs that run
    the same OS instance. CPUs which run distinct OS instances,
    but share memory, or devices, through
    some fabric, do not need to be placed in the same group.
  </p></dd><dt id="multithreading-concurrency-modes.html:dt:sim_concurrency_mode_full-2"><a href="#multithreading-concurrency-modes.html:dt:sim_concurrency_mode_full-2"><b><code>Sim_Concurrency_Mode_Full</code></b></a></dt><dd>All CPU cores are placed in separate thread domains.
  </dd></dl><p>The above allows groups of tightly coupled CPUs
to be simulated in parallel when the simulation is configured
to use <b>subsystem</b> threading, while allowing all the CPUs to
run in parallel in <b>multicore</b> mode.

</p></section><section class="page" id="multithreading-standard-device-model.html"><h1 class="jdocu"><a id="multithreading-standard-device-model.html:multithreading-standard-device-model">2.6 Standard Device Model</a></h1>
<p>

By default, devices in Simics use the Standard Device Model. Such
models run in the <code>Sim_Concurrency_Mode_Serial</code>
concurrency mode.
</p><p>
Using the Standard Device Model amounts to being able to assume at
least Cell Context when interface methods are invoked. Certain things,
like object initialization, run in Global Context, which is
the most permissive context.
</p><p>
</p><h2 class="jdocu"><a id="multithreading-standard-device-model.html:multithreading-standard-device-model-properties">2.6.1 Properties</a></h2>
<p>

Cell Context has the following properties:
</p><ul>
  <li>Any object belonging to the same cell may be accessed or referenced.
    Interfaces marked as available in Cell Context can be
    called directly without any additional steps.</li>
  <li>Accessed objects always have a stable state.</li>
  <li>The cell thread domain is held.</li>
  <li>The direct memory subsystem ensures that there is no observable
    concurrency with respect to simulated RAM.</li>
</ul>
In Cell Context, everything within the cell appears
to be completely serialized. Under to hood, this may not be the case, and
CPUs might be running concurrently. But when a CPU is accessed from a
device, it is stopped until the device access is complete. For instance,
a device will always see a stable cycle count when it repeatedly
queries its associated clock during a register access.
 
</section><section class="page" id="multithreading-threaded-cpu.html"><h1 class="jdocu"><a id="multithreading-threaded-cpu.html:multithreading-threaded-cpu">2.7 Threaded Device Model</a></h1>
<p>

An object using one of the concurrency modes
<code>Sim_Concurrency_Mode_Serialized_Memory</code> or 
<code>Sim_Concurrency_Mode_Full</code> is called a <em>thread-aware</em>
model. The Threaded Device Model must be followed by such objects.
</p><p>
Thread-aware models run mostly in Threaded Context.
</p><p>
This section primarily discusses thread-aware models, but much of the
contents also applies to code invoked directly from a "foreign" thread.
</p><p>
</p><div class="note">
<b>Note:</b>
A CPU is the typical example of a thread-aware model. Most devices should
  rather use the Standard Device Model.
</div><h2 class="jdocu"><a id="multithreading-threaded-cpu.html:Programming-Model">2.7.1 Programming Model</a></h2>
<p>Thread-aware models need to take the following into account:
</p><dl><dt id="multithreading-threaded-cpu.html:dt:incoming-interface-calls"><a href="#multithreading-threaded-cpu.html:dt:incoming-interface-calls"><b>Incoming Interface Calls</b></a></dt><dd>Interfaces implemented by thread-aware models can be invoked in
    Threaded Context rather than Cell Context, and the thread
    domain associated with the object cannot be assumed to be held on entry.
    <p>
    It is the responsibility of the model to ensure that its state is
    protected, usually by calling <b><i>SIM_ACQUIRE_OBJECT</i></b>
    from its interface methods, as in the following example:
    </p><pre class="jdocu_small">      static void
      some_interface_method(conf_object *obj)
      {
          domain_lock_t *lock;
          SIM_ACQUIRE_OBJECT(obj, &amp;lock);
          /* ... internal state is protected by the TD ... */
          SIM_RELEASE_OBJECT(obj, &amp;lock);
      }
    </pre><p>
    No extra protection is needed for interfaces which are only available
    in OEC. All thread domains are already held on entry.
    </p><p>
    </p><div class="note">
<b>Note:</b>
There are a few situations when the model is invoked with
      its thread domain already held:
      <ul>
	<li>
	  The <b><i>run</i></b> method of the <code>execute</code>
	  interface is invoked with the object's thread domain held.
	  The model should not acquire the domain again, since this
	  would block the signaling mechanism used to notify the model
	  when another thread tries to acquire the domain.
	</li>
	<li>
	  The methods in the the <code>direct_memory_update</code>
	  interface are always invoked with the thread domain held.
	</li>
      </ul>
    </div></dd><dt id="multithreading-threaded-cpu.html:dt:outgoing-interface-calls"><a href="#multithreading-threaded-cpu.html:dt:outgoing-interface-calls"><b>Outgoing Interface Calls</b></a></dt><dd>When a thread-aware model invokes an interface method on an
    object which is not known to reside in the same thread domain,
    then the call must be protected with <b><i>SIM_ACQUIRE_TARGET</i></b>,
    with the interface object provided as an argument.
    This ensures that Cell Context is entered, when necessary.
<p>
    Example of an "outgoing" interface call:
    </p><pre class="jdocu_small">      domain_lock_t *lock;
      /* incoming interface calls may occur here */
      SIM_ACQUIRE_TARGET(target_obj, &amp;lock);
      some_interface-&gt;some_method(target_obj, ...);
      SIM_RELEASE_TARGET(target_obj, &amp;lock);
    </pre><p>
</p><p>
    </p><div class="note">
<b>Note:</b>
If the target object is thread-aware, then
      <b><i>SIM_ACQUIRE_TARGET</i></b> will actually be a no-op.</div><div class="note">
<b>Note:</b>
If the cell TD is busy when <b><i>SIM_ACQUIRE_TARGET</i></b> is executed,
      then the model may see incoming interface calls while waiting for the
      domain, since all held domains are temporarily released while
      waiting.
    </div></dd><dt id="multithreading-threaded-cpu.html:dt:api-calls"><a href="#multithreading-threaded-cpu.html:dt:api-calls"><b>API Calls</b></a></dt><dd>Cell Context must be entered before any API function can be called
    which requires this context. The context is entered with
    the <b><i>SIM_ACQUIRE_CELL</i></b> primitive, as in this example:
    <pre class="jdocu_small">      domain_lock_t *lock;
      /* incoming interface calls may occur here */
      SIM_ACQUIRE_CELL(obj, &amp;lock);
      /* this code runs in Cell Context */
      breakpoint_id = SIM_breakpoint(...);
      SIM_RELEASE_CELL(obj, &amp;lock);
    </pre><p>
    Some functions that need this protection:
    </p><ul>
      <li>HAP functions (<b><i>SIM_hap_add_callback</i></b>, ...)</li>
      <li><b><i>SIM_breakpoint</i></b>, <b><i>SIM_delete_breakpoint</i></b></li>
      <li><b><i>SIM_issue_transaction</i></b></li>
    </ul>
<p>
    There are, however, many functions that can be called directly
    in Threaded Context, e.g.
    </p><ul>
      <li>functions performing logging (<b><i>SIM_log_info</i></b>, ...)</li>
      <li>functions returning constant object properties
	(<b><i>SIM_object_name</i></b>, <b><i>SIM_get_interface</i></b>, ...)</li>
      <li>allocations (<b><i>MM_MALLOC</i></b>,
	<b><i>SIM_alloc_attr_list</i></b>, ...)</li>
      <li>accessors (<b><i>SIM_attr_integer</i></b>,
	<b><i>SIM_transaction_is_read</i></b>, ...)</li>
      <li>dbuffer API (but the dbuffer itself is <b>not</b> thread safe)</li>
      <li><b><i>SIM_run_unrestricted</i></b>, <b><i>SIM_run_alone</i></b></li>
    </ul>
    Some API functions can be called directly, as long as the TD has
    been acquired for the object in question:
    <ul>
      <li>event related functions (<b><i>SIM_event_post_cycle</i></b>, ...)</li>
      <li>time related functions (<b><i>SIM_time</i></b>,
	<b><i>SIM_cycle_count</i></b>, ...)</li>
    </ul>
  </dd><dt id="multithreading-threaded-cpu.html:dt:callbacks"><a href="#multithreading-threaded-cpu.html:dt:callbacks"><b>Callbacks</b></a></dt><dd>Callbacks triggered by the model are often expected to
    be dispatched in Cell Context. The model must
    enter Cell Context using <b><i>SIM_ACQUIRE_CELL</i></b>
    before dispatching such callbacks.
<p>
    </p><div class="note">
<b>Note:</b>
Events registered with the <code>Sim_Event_No_Serialize</code> flag
      and callbacks used by the CPU instrumentation framework do not need to be
      protected. For these callbacks, it is the callee's responsibility to be
      aware that the context can be more limited than Cell Context.
      This is a performance optimization to allow fast callbacks with
      minimal overhead.
    </div></dd><dt id="multithreading-threaded-cpu.html:dt:attributes"><a href="#multithreading-threaded-cpu.html:dt:attributes"><b>Attributes</b></a></dt><dd>Registered attribute setters and getters are automatically protected;
    an object's thread domain is always held when attribute setters and getters
    are invoked.
<p>
    </p><div class="note">
<b>Note:</b>
Attributes should be used for configuration and to hold
      state. Attributes should <b>never</b> be used for communication between
      objects during simulation.
    </div></dd></dl><p>
</p><h2 class="jdocu"><a id="multithreading-threaded-cpu.html:Domain-Boundary-Crossings">2.7.2 Domain Boundary Crossings</a></h2>
<p>

Whenever a thread-domain boundary is crossed, already held
domains may temporarily be released to avoid deadlock situations.
This allows unrelated, incoming, interface calls to occur at such points.
</p><p>
A thread-aware model must ensure that potential state changes caused
by incoming interface calls are taken into account. This is one of the
challenging points when writing a thread-aware model.
</p><p>
In Cell Context, boundary crossings are not an issue, since this
context is prioritized exactly to avoid unexpected
interface calls. Thread-aware models, running in Threaded Context,
are not as fortunate and need to be aware of the possibility.
</p><p>
It is recommended that incoming interface calls are kept as
simple as possible for thread-aware models. If possible,
the interface action should be deferred and handled from an
inner loop, especially for CPUs. For instance, a RESET interface
should not perform the reset immediately, but instead set a flag that
a reset should be performed before dispatching the next instruction.

</p><h2 class="jdocu"><a id="multithreading-threaded-cpu.html:Mixing-Thread-Domains-and-Mutexes">2.7.3 Mixing Thread Domains and Mutexes</a></h2>
<p>

It is easy to run into problems when different locking schemes
are combined. This is also the case when mixing <em>mutexes</em>
and <em>thread domains</em>. The following examples illustrate some
pitfalls:
</p><p>
</p><dl><dt id="multithreading-threaded-cpu.html:dt:example-1"><a href="#multithreading-threaded-cpu.html:dt:example-1"><b>Example 1</b></a></dt><dd>Acquiring a thread domain while holding a lock:
    <pre class="jdocu_small">      Thread 1                  Thread 2
      Locks Mutex1              Acquires TD1
      Acquires TD1 (blocks)     Locks Mutex1 (blocks)
    </pre><p>
    Thread 1 will never be able to acquire TD1 since this domain is held by
    thread 2 which blocks on Mutex1.
</p><p>
    Note that the above example will also cause a deadlock if two mutexes
    are used rather than one mutex and one thread domain:
    </p><pre class="jdocu_small">      Thread 1                  Thread 2
      Locks Mutex1              Locks Mutex2
      Locks Mutex2 (blocks)     Locks Mutex1 (blocks)
    </pre><p>
</p><p>
    Whereas no deadlock occurs with two thread domains:
    </p><pre class="jdocu_small">      Thread 1                  Thread 2
      Acquires TD2              Acquires TD1
      Acquires TD1*             Acquires TD2*
       *Not a deadlock - Simics detects and resolves this situation
    </pre><p>
  </p></dd><dt id="multithreading-threaded-cpu.html:dt:example-2"><a href="#multithreading-threaded-cpu.html:dt:example-2"><b>Example 2</b></a></dt><dd>Waiting for a condition variable while holding a thread domain:
    <pre class="jdocu_small">      Thread 1               Thread 2
      Acquires TD1           .
      Waits for COND1	     Acquires TD1 (blocks)
                             Releases TD1 (not reached)
	                     .
                             Signals COND1 (not reached)
    </pre><p>
    Sleeping on a condition while holding a thread domain easily
    leads to deadlocks. Threads requiring the thread domain
    will get stuck and potentially prevent the condition from being
    signaled.
  </p></dd></dl><p>In practice, code can seldom make assumptions about which thread domains
are held. For instance, an interface function can be invoked with an
unknown set of thread domains already acquired. The domain retention mechanism
also makes the picture more complex.
</p><p>
To avoid deadlocks, the following general principles are encouraged:
</p><ul>
  <li>Do not acquire a thread domain while holding a lock</li>
  <li>Do not sleep while holding a thread domain</li>
  <li>Use thread domains to prevent concurrent simulation</li>
  <li>Use mutexes to protect specific data structures</li>
</ul>
When needed, it is possible to drop all thread domains,
which is illustrated in the following example:
<pre class="jdocu_small">  domain_lock_t *lock;
  SIM_DROP_THREAD_DOMAINS(&amp;lock);
  /* no thread domains are held here... */
  SIM_REACQUIRE_THREAD_DOMAINS(&amp;lock);
</pre><p>
</p><div class="note">
<b>Note:</b>
Avoid empty drop/reacquire pairs. If the intention is allowing
  other objects to access held domains, then
  <b><i>SIM_yield_thread_domains</i></b> should be used instead. The yield
  function, besides being faster, guarantees that all waiting
  threads are given an opportunity to acquire the held domains.
</div>
<h2 class="jdocu"><a id="multithreading-threaded-cpu.html:Thread-Aware-CPUs">2.7.4 Thread-Aware CPUs</a></h2>
<p>

Thread-aware CPUs have a few extra things to consider.
</p><dl><dt id="multithreading-threaded-cpu.html:dt:execution"><a href="#multithreading-threaded-cpu.html:dt:execution"><b>Execution</b></a></dt><dd>CPU models are driven from the <b><i>run</i></b> method
    of the <code>execute</code> interface. The method
    is invoked in Threaded Context, with the CPU thread
    domain already held.
<p>
    The thread calling <b><i>run</i></b> is a simulation thread 
    managed by the Simics scheduler. It is possible that this thread
    is used to simulate more than one model.
</p><p>
    The model is not guaranteed that the <b><i>run</i></b> function is always
    invoked by the same thread.
  </p></dd><dt id="multithreading-threaded-cpu.html:dt:signaling"><a href="#multithreading-threaded-cpu.html:dt:signaling"><b>Signaling</b></a></dt><dd>Whenever another CPU, or a device model, tries to acquire the
    CPU domain, the CPU is notified through the <code>execute_control</code>
    interface.
<p>
    When a CPU is signaled in this way, it should <b>as soon as possible</b>
    call <b><i>SIM_yield_thread_domains</i></b>. The yield function ensures
    that pending direct memory update messages are delivered and allows
    other threads to invoke interfaces on the CPU object.
</p><p>
    The signaling methods are invoked asynchronously, and the implementation
    must not acquire any thread domains or call API functions.
</p><p>
    The signaling only occurs when the CPU's thread domain is the only
    domain held. Acquiring an additional domain, even the already held domain,
    temporarily blocks the signaling mechanism. Due to this, it is
    important that the CPU thread domain is <b>not</b> acquired in the
    <code>run</code> method, since it is already held on entry.
</p><p>
    </p><div class="note">
<b>Note:</b>
To minimize the waiting time for other threads, it is important
      that the signaling is detected quickly.
    </div></dd><dt id="multithreading-threaded-cpu.html:dt:direct-memory"><a href="#multithreading-threaded-cpu.html:dt:direct-memory"><b>Direct Memory</b></a></dt><dd>The methods of the <code>direct_memory_update</code> interface
    are invoked with the CPU thread domain already acquired.
    The model should service requests quickly and without
    acquiring additional thread domains.
  </dd></dl><p>
</p><h2 class="jdocu"><a id="multithreading-threaded-cpu.html:Thread-Domain-Contention">2.7.5 Thread Domain Contention</a></h2>
<p>

Statistics about thread-domain acquisition can be collected with the
<b>enable-object-lock-stats</b> command. This functionality is useful
when a model is optimized to avoid unnecessary thread-domain
crossings or to investigate thread-domain contention.
</p><p>
There is a definite overhead associated with collecting the
statistics; it should not be turned on by default.
</p><p>
The collected statistics can be shown with the
<b>print-object-lock-stats</b> command:
</p><pre class="jdocu_small">
CountAvg(us)           Function                         File              

  396   1.94 get_cycles                  core/clock/clock.c:172           
  369   1.91 post                        core/clock/clock.c:254           
   27   2.00Chandle_event                core/clock/clock-src.c:211       
   12   2.33 pb_lookup                   core/common/image.c:3965         
    7   2.86Ccpu_access                  cpu/cpu-common/memory.c:508      
    8   2.38Cperform_io                  cpu/x86/x86-io.c:128             
    6   1.83 dml_lookup                  core/common/memory-page.c:431    
    3   3.00Ccall_hap_functions_serializecore/common/hap.c:1410           
    3   2.33 cancel                      core/clock/clock.c:280           

</pre><p>
The command basically displays the location in the source where thread
domains have been acquired, and how quickly the domains were acquired.
The 'C' indicates that Cell Context was entered.

</p></section><section class="page" id="multithreading-threads.html"><h1 class="jdocu"><a id="multithreading-threads.html:multithreading-threads">2.8 Foreign Threads</a></h1>
<p>

Threads created explicitly by models are called <em>foreign threads</em>.
Such threads run in Threaded Context. There are also
various API functions that registers callbacks that are called in FTC, like
<b><i>SIM_run_in_thread</i></b> and <b><i>SIM_notify_on_socket</i></b> with
the <i>run_in_thread</i> argument set to 1.
</p><p>
Many of the things stated in the preceding section is also relevant to foreign
threads. One difference, however, is that foreign threads can be created by
models using the Standard Device Model.
</p><p>
</p><h2 class="jdocu"><a id="multithreading-threads.html:multithreading-threads-operations">2.8.1 Device Interactions</a></h2>
<p>

The following outlines how a foreign thread can interact with the
rest of the simulation:
</p><dl><dt id="multithreading-threads.html:dt:accessing-a-device-object"><a href="#multithreading-threads.html:dt:accessing-a-device-object"><b>Accessing a Device Object</b></a></dt><dd>A foreign thread can enter Cell Context using the
    <b><i>SIM_ACQUIRE_CELL</i></b> function. Once in Cell Context, the thread
    can interact with the object just like a normal device would do,
    and without needing any additional locking.
    <pre class="jdocu_small">      /* foreign thread */
      SIM_ACQUIRE_CELL(obj, &amp;lock);
      /* safe to access the device */
      SIM_RELEASE_CELL(obj, &amp;lock);
    </pre><p>
  </p></dd><dt id="multithreading-threads.html:dt:entering-global-context"><a href="#multithreading-threads.html:dt:entering-global-context"><b>Entering Global Context</b></a></dt><dd>A foreign thread can post callbacks that are run
    in Global Context, and hence
    allowed to access everything in the simulation. This
    is done using <b><i>SIM_thread_safe_callback</i></b>
    <pre class="jdocu_small">      static void
      global_context_callback(void *data)
      {
          /* this code runs in Global Context */
      }

      {
          /* ... Threaded Context ... */
          SIM_thread_safe_callback(global_context_callback, data);
      }
    </pre><p>
    It should be noted that the function posting the callback returns
    immediately, usually before the callback has started executing. Also,
    posting a Global Context callback is a relatively expensive operation
    since it involves stopping all running CPUs.
  </p></dd></dl><p>
</p><p>
</p></section><section class="page" id="multithreading-scheduler.html"><h1 class="jdocu"><a id="multithreading-scheduler.html:multithreading-scheduler">2.9 Simics Scheduler</a></h1>
<p>

The Simics scheduler is responsible for ensuring that models implementing the
<code>execute</code> interface are scheduled. It is also
responsible for mapping actual threads to the simulation workload and
for keeping distinct CPUs synchronized in virtual time.
</p><p>
</p><h2 class="jdocu"><a id="multithreading-scheduler.html:multithreading-scheduler-basic">2.9.1 Basic Operation</a></h2>
<p>

The Simics Scheduler compiles a list of simulation tasks that can be
run in parallel. Each task consists of a thread domain with
one or more models implementing the <code>execute</code> interface.
</p><p>
The number of tasks that can be simulated in parallel depends on the
thread domain partitioning, which in turn depends on the selected
simulation mode. The simulation mode is configurable with the
<b>set-threading-mode</b> command.
</p><p>
The available tasks are mapped to a set of execution threads
managed by the scheduler. The number of threads used
depends on the host hardware and any limit imposed by the user.
The latter is settable with the <b>set-thread-limit</b> command.
</p><p>
A particular simulation task is usually simulated from a specific
simulation thread in order to maximize cache locality. However, a task can be
migrated to another thread when this is needed for load-balancing reasons.
Thus, a model should not make any assumptions about the thread it is simulated
from.

</p><h2 class="jdocu"><a id="multithreading-scheduler.html:multithreading-scheduler-sync">2.9.2 Virtual Time Synchronization</a></h2>
<p>

</p><p>
The scheduler ensures that all CPUs (and clocks) are kept synchronized
in virtual time. More specifically, the virtual time for
a pair of CPUs are not allowed to differ more than a fixed amount.
A simulation task becomes blocked when it is about to break this
invariant.
</p><p>
If a single thread domain contains more than one object implementing the
<code>execute</code> interface, then the scheduler switches between
them in a round-robin fashion. Each executor is simulated until the
virtual time has advanced one <em>time-quantum</em>. The interval
is settable with the <b>set-time-quantum</b> command.
</p><p>
The time difference for CPUs in the same cell, but in distinct
thread domains, is not allowed to exceed the <em>max-time-span</em>
limit. The limit is settable with the <b>set-max-time-span</b>
command and is usually of the same order of magnitude as the time quantum.
</p><p>
The time difference between CPUs in distinct cells is kept below
the <em>min-latency</em> limit. This limit is set with
the <b>set-min-latency</b> command. The min-latency is often allowed
to be a bit higher than the other limits.

</p></section><section class="page" id="device-api.html"><h1 class="jdocu"><a id="device-api.html:Device-API">3 Device API</a></h1>
<p>
    
</p><p>
    The Simics Device API is a set of types and functions that provide access
    to Simics functionality from device models, usually written in DML or
    C/C++. The Device API is the same in all languages but the syntax of the
    types and functions declarations will of course differ.
</p><p>
    
    
    
    
</p></section><section class="page" id="frontend-exceptions.html"><h1 class="jdocu"><a id="frontend-exceptions.html:Frontend-Exceptions">3.1 Frontend Exceptions</a></h1>
<p>
    
</p><p>
    Whenever an error occurs in a Simics API function, that function will raise
    an <i>exception</i>. An exception consists of an <i>exception type</i> and
    an error message.
</p><p>
    The following exception types are defined in the Simics API:
</p><p>
    <a id="frontend-exceptions.html:sim_exception_t"></a>
   
</p><pre class="jdocu_small">typedef enum sim_exception {
        SimExc_No_Exception,
        SimExc_General,
        SimExc_Lookup,
        SimExc_Attribute,
        SimExc_IOError,
        SimExc_Index,
        SimExc_Memory,
        SimExc_InquiryOutsideMemory,
        SimExc_InquiryUnhandled,
        SimExc_Type,
        SimExc_Break,
        SimExc_PythonTranslation,
        SimExc_License,
        SimExc_IllegalValue,
        SimExc_InterfaceNotFound,
        SimExc_AttrNotFound,
        SimExc_AttrNotReadable,
        SimExc_AttrNotWritable
} sim_exception_t;</pre><p>

</p><p>
    Note that API users writing in C must use <b><i>SIM_clear_exception()</i></b>
    and <b><i>SIM_last_error()</i></b> since C does not support exceptions. In
    Python, the Simics API exceptions will trigger actual Python exceptions,
    which you can capture using <code>try ... except</code>.
</p><p>
</p></section><section class="page" id="device-api-data-types.html"><h1 class="jdocu"><a id="device-api-data-types.html:Device-API-Data-Types">3.2 Device API Data Types</a></h1>
<p>

    
    </p><h2 class="jdocu"><a id="device-api-data-types.html:Generic-Data-Types">3.2.1 Generic Data Types</a></h2>
<p></p><h3 class="jdocu"><a class="not-numbered" id="device-api-data-types.html:attr_value_t">attr_value_t</a></h3>
<p>
   
   
   
   <a id="device-api-data-types.html:attr_value_t2"></a>
   </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-data-types.html:__jdocu_seealso_attr_value_t"></a>attr_value_t</dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The <code>attr_value_t</code> is the type used for all values in the
   configuration system. It is a tagged union.
<p>
   The following table shows the different types of values, the type of their
   payload in C, and the corresponding Python types:
</p><p>
   </p><div style="text-align: center">
   <table>

   <tbody><tr>
     <td class="jdocu_border"><b>Kind</b></td> <td class="jdocu_border"><b>C payload</b></td> <td class="jdocu_border"><b>Python type</b></td>
   </tr>

   <tr><td class="jdocu_border">Invalid</td> <td class="jdocu_border">-</td> <td class="jdocu_border">raises exception</td></tr>

   <tr><td class="jdocu_border">String</td><td class="jdocu_border">const char *</td> <td class="jdocu_border">str or unicode</td></tr>

   <tr><td class="jdocu_border">Integer</td> <td class="jdocu_border">int64 or uint64</td> <td class="jdocu_border">int or long</td></tr>

   <tr><td class="jdocu_border">Boolean</td> <td class="jdocu_border">bool</td> <td class="jdocu_border">bool</td></tr>

   <tr><td class="jdocu_border">Floating</td><td class="jdocu_border">double</td> <td class="jdocu_border">float</td></tr>

   <tr><td class="jdocu_border">Object</td>
       <td class="jdocu_border">conf_object_t *</td> <td class="jdocu_border">simics.conf_object_t</td></tr>

   <tr><td class="jdocu_border">List</td>
       <td class="jdocu_border">array of attr_value_t</td> <td class="jdocu_border">list</td></tr>

   <tr><td class="jdocu_border">Dict</td>
       <td class="jdocu_border">array of pairs of attr_value_t</td> <td class="jdocu_border">dict</td></tr>

   <tr><td class="jdocu_border">Data</td>
       <td class="jdocu_border">array of bytes</td> <td class="jdocu_border">tuple of small integers</td></tr>

   <tr><td class="jdocu_border">Nil</td>     <td class="jdocu_border">-</td>           <td class="jdocu_border">None</td></tr>

   </tbody></table>
   </div>
<p>
   The members inside <code>attr_value_t</code> should not be accessed
   directly. Instead, use the corresponding functions for each type:
</p><p>
   <table>

    <tbody><tr>
      <td class="jdocu_noborder">Constructor</td> <td class="jdocu_noborder"><b><i>SIM_make_attr_<i>TYPE</i></i></b></td>
    </tr>

    <tr><td class="jdocu_noborder">Destructor</td><td class="jdocu_noborder"><b><i>SIM_attr_free</i></b></td></tr>

    <tr>
      <td class="jdocu_noborder">Type predicate</td> <td class="jdocu_noborder"><b><i>SIM_attr_is_<i>TYPE</i></i></b></td>
    </tr>

    <tr><td class="jdocu_noborder">Access</td><td class="jdocu_noborder"><b><i>SIM_attr_<i>TYPE</i></i></b></td></tr>

   </tbody></table>
</p><p>
   Values of type List and Dict can be modified using
   <b><i>SIM_attr_<i>TYPE</i>_set_item</i></b> and
   <b><i>SIM_attr_<i>TYPE</i>_resize</i></b>.
</p><p>
   None of these functions are available or needed in Python. The
   <code>attr_value_t</code> values are translated to the ordinary Python
   values as shown in the table above.
</p><p>
   Some values may have data in separate heap allocations. These are normally
   managed by the respective constructor and destructor methods, but careless
   copying of values may introduce aliasing errors. Use
   <b><i>SIM_attr_copy</i></b> to duplicate values. Again, this is of no concern
   in Python.
</p><p>
   </p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
     </a><b><i>SIM_make_attr_int64</i></b>, <b><i>SIM_attr_is_integer</i></b>,
     <b><i>SIM_attr_integer</i></b>, <b><i>SIM_attr_free</i></b>,
     <b><i>SIM_attr_list_resize</i></b>, <b><i>SIM_attr_list_set_item</i></b>,
     <b><i>SIM_attr_dict_resize</i></b>, <b><i>SIM_attr_dict_set_item</i></b>,
     <b><i>SIM_attr_copy</i></b>
   </dd>
</dl><p>
   </p><h3 class="jdocu"><a class="not-numbered" id="device-api-data-types.html:buffer_t">buffer_t</a></h3>
<p>
   
   
     <a id="device-api-data-types.html:buffer_t2"></a>
     
     </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-data-types.html:__jdocu_seealso_buffer_t"></a>buffer_t</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">typedef struct {
        uint8 *data;
        size_t len;
} buffer_t;</pre><p>

       </p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
A reference to a (mutable) buffer. When used as a function parameter,
         the callee is permitted to write up to <code>len</code> bytes into
         the buffer pointed to by <code>data</code>.
<p>
         Returning values of this type from interface methods should be
         avoided. If this is the case the scope of the returned object should be
         documented.
</p><p>
         The corresponding Python type is called <code>buffer_t</code>,
         and behaves like a fixed-size mutable byte vector. The constructor
         takes as argument either a string, providing the initial value,
         or an integer, specifying the buffer size.
       </p></dd>
</dl><p>
   </p><h3 class="jdocu"><a class="not-numbered" id="device-api-data-types.html:bytes_t">bytes_t</a></h3>
<p>
   
   
     <a id="device-api-data-types.html:bytes_t2"></a>
     
     </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-data-types.html:__jdocu_seealso_bytes_t"></a>bytes_t</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">typedef struct {
        const uint8 *data;
        size_t len;
} bytes_t;</pre><p>

       </p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
An immutable sequence of bytes. When used as a function parameter,
         the callee should treat the data as read-only.
<p>
         When used as a return value, the <code>data</code> member must point to a
         heap-allocated memory block whose ownership is transferred to the
         caller. The caller is then responsible for freeing the block.
    </p><p>
         The corresponding Python type is Python's built-in class 'bytes'. Here
         are a few code examples that create 'bytes' objects in Python:
         b'abcd', b'\xf0\xf1\xf2\xf3', bytes([0xf0, 0xf1, 0xf2, 0xf3]),
         0xf3f2f1f0.to_bytes(length=4, byteorder='little'),
         bytes.fromhex('f0f1f2f3').
       </p></dd>
</dl><p>
   </p><h3 class="jdocu"><a class="not-numbered" id="device-api-data-types.html:cbdata_t-cbdata_call_t-cbdata_register_t-cbdata_type_t">cbdata_t, cbdata_call_t, cbdata_register_t, cbdata_type_t</a></h3>
<p>
   
   
   <a id="device-api-data-types.html:cbdata_t"></a>
   <a id="device-api-data-types.html:cbdata_call_t"></a>
   <a id="device-api-data-types.html:cbdata_register_t"></a>
   <a id="device-api-data-types.html:cbdata_type_t"></a>
   
   </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-data-types.html:__jdocu_seealso_cbdata_t"></a>cbdata_t, cbdata_call_t, cbdata_register_t,
   cbdata_type_t</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">typedef struct {
        const char *name;
        void (*dealloc)(void *data);
} cbdata_type_t;</pre><p>

   
</p><pre class="jdocu_small">typedef struct cbdata cbdata_t;</pre><p>

   
</p><pre class="jdocu_small">typedef cbdata_t cbdata_register_t, cbdata_call_t;</pre><p>

   </p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
These data types are used by API functions and interface methods that
   provide callbacks with callback data. By using these data types instead of a
   simple <code>void *</code>, the callback data can be freed correctly when
   not needed anymore.
<p>
   The types <code>cbdata_register_t</code> and <code>cbdata_call_t</code> are
   only aliases for <code>cbdata_t</code>, used to annotate whether the object
   is passed to a registration function or a callback function. This is used by
   the automatic Python wrapping to ensure that the callback data is freed
   correctly.
</p><p>
   Objects of this type can be created by using either
   <b><i>SIM_make_cbdata</i></b> or <b><i>SIM_make_simple_cbdata</i></b>. The latter
   creates an untyped objects with no deallocation function, while the former
   takes a <code>cbdata_type_t</code> argument, specifying a type name and a
   deallocation function.
</p><p>
   The following example shows how an API function could be defined using these
   data types:
</p><p>
   </p><pre class="jdocu_small">   void for_all_ids(void (*callback)(const char *id,
                                     cbdata_call_t data),
                    cbdata_register_t data);
   </pre><p>
</p><p>
   Note how the two flavors of <code>cbdata_t</code> are used.
   <code>cbdata_register_t</code> is used to pass some data to
   <b><i>for_all_ids</i></b> which passes the same data unmodified to
   <b><i>callback</i></b>. Here is an example of how this function could be
   called; from C:
</p><p>
   </p><pre class="jdocu_small">   static void callback(const char *id, cbdata_call_t data)
   {
       const char *prefix = SIM_cbdata_data(&amp;data);
       printf("%s %s\n", prefix, id);
   }
         :
       for_all_ids(callback, SIM_make_simple_cbdata("Testing"));
   </pre><p>
</p><p>
   and from Python:
</p><p>
   </p><pre class="jdocu_small">   def callback(id, prefix):
       print("%s %s" % (prefix, id))

   for_all_ids(callback, "Testing")
   </pre><p>
</p><p>
   Note in particular that the Python code does not mention "cbdata" anywhere;
   it is all automatically handled by the Python wrapping code.
</p><p>
   The C version of the previous example used
   <b><i>SIM_make_simple_cbdata</i></b>, as the constant string <code>"Testing"</code>
   does not need any deallocation function. For dynamically allocated data, you
   must use <b><i>SIM_make_cbdata</i></b> instead:
</p><p>
   </p><pre class="jdocu_small">   static const cbdata_type_t malloced_int_type = {
       "integer",       // name
       free             // dealloc
   };

   static void callback(const char *id, cbdata_call_t data)
   {
       int *count = SIM_cbdata_data(&amp;data);
       printf("%d %s\n", *count, id);
       ++*count;
   }
         :
       int *counter = malloc(sizeof *counter);
       *counter = 1;
       for_all_ids(callback, SIM_make_cbdata(malloced_int_type, counter));
   </pre><p>
</p><p>
   In this example, <b><i>for_all_ids</i></b> is responsible for calling the
   deallocation function for the callback data after it has completed all calls
   to <b><i>callback</i></b>. It does this by calling <b><i>SIM_free_cbdata</i></b>,
   which in turn will call <i>malloced_int_type.dealloc</i>; i.e.,
   <b><i>free</i></b>.
</p><p>
   The same example in Python; we still do not have to call any cbdata function
   manually, but we do have to pass the counter in a one-element list since
   integers are immutable in Python:
</p><p>
   </p><pre class="jdocu_small">   def callback(id, count):
       print("%s %s" % (prefix, count[0]))
       count[0] += 1

   for_all_ids(callback, [1])
   </pre><p>
</p><p>
   While the use of <code>cbdata_t</code> over a simple <code>void *</code> in
   these examples seems redundant, they are needed if <b><i>for_all_ids</i></b>
   does not call <b><i>callback</i></b> before returning, but asynchronously at
   some later point in time. The use of <code>cbdata_t</code> also ensures that
   the data is freed correctly even when any of the involved functions is
   implemented in Python. This case often arises in conjunction with Simics
   interfaces.
</p><p>
   See the Callback Functions in Interfaces section in the
   <em>Simics Model Builder User's Guide</em> for more information on how
   to use the <code>cbdata_t</code> types.
</p><p>
   </p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
     </a><code>lang_void</code>, <b><i>SIM_make_cbdata</i></b>,
     <b><i>SIM_make_simple_cbdata</i></b>, <b><i>SIM_free_cbdata</i></b>,
     <b><i>SIM_cbdata_data</i></b>, <b><i>SIM_cbdata_type</i></b>
   </dd>
</dl><p>
   </p><h3 class="jdocu"><a class="not-numbered" id="device-api-data-types.html:class_data_t">class_data_t</a></h3>
<p>
   
   
   
   <a id="device-api-data-types.html:class_data_t2"></a>
</p><p>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-data-types.html:__jdocu_seealso_class_data_t"></a>class_data_t, class_kind_t</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<span class="jdocu_smaller">
  
   
<pre class="jdocu_small">typedef struct class_data {
        conf_object_t *(*alloc_object)(lang_void *data);
        lang_void *(*init_object)(conf_object_t *obj, lang_void *data);
        void (*finalize_instance)(conf_object_t *obj);

        void (*pre_delete_instance)(conf_object_t *obj);
        int (*delete_instance)(conf_object_t *obj);

        const char           *description;
        const char           *class_desc;
        class_kind_t          kind;
} class_data_t;</pre><p>

  </p></span></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The <code>class_data_t</code> type is used when a new class is registered.
  Uninitialized fields should be set to zero before the structure is passed to
  <b><i>SIM_register_class</i></b>.
<p>
  When a new object is created, memory for the <code>conf_object_t</code> is
  allocated by Simics unless <i>alloc_object</i> has been provided by the
  class. Classes written in C may implement <i>alloc_object</i> to have a
  single allocation and must then place <code>conf_object_t</code> first in the
  object data structure. This has the advantage of allowing casts directly from
  a <code>conf_object_t *</code> to a pointer to the user structure instead of
  using <i>SIM_object_data</i>.
</p><p>
  When the <code>conf_object_t</code> has been allocated, the
  <i>init_object</i> function is called. If the object instance needs
  additional storage, it may allocate its own memory and return a pointer to
  it from <i>init_object</i>. This pointer can later be obtained using
  <b><i>SIM_object_data</i></b>. The return value from <i>init_object</i>
  has to be non-null to signal a successful object initialization. If a null
  value is returned, no configuration object will be created and an error will
  be reported. For classes that implement their own <i>alloc_object</i>,
  there is no need to allocate additional storage in the <i>init_object</i>
  function and they can simply return the <code>conf_object_t</code> pointer
  from <i>init_object</i>.
</p><p>
  <i>alloc_object</i> and <i>init_object</i> both receive a
  <i>data</i> parameter; they are currently not used, and should be
  ignored.
</p><p>
  The optional <i>finalize_instance</i> function is called when all
  attributes have been initialized in the object, and in all other objects
  that are created at the same time.
</p><p>
  The <i>pre_delete_instance</i> and <i>delete_instance</i> fields can
  be set to let the objects of this class support deletion:
</p><p>
  </p><ul>
    <li>
      <i>pre_delete_instance</i> will be called in the first phase of the
      object deletion, during which objects are expected to clean-up their
      external links to other objects (breakpoints, hap
      callbacks, file or network resources, ...). They may also trigger the
      deletion of other objects. <i>pre_delete_instance</i> is only called
      for objects that have reached at least <i>finalize_instance</i>
      during initialization.
    </li>

    <li>
      <i>delete_instance</i> will be called in the second phase of the
      object deletion: objects are expected to deallocate the memory they use
      including the object data structure. They may not communicate with other
      objects as these may already have been destroyed. The return value from
      <i>delete_instance</i> is ignored for compatibility.
      <i>delete_instance</i> is always called unless
      <i>alloc_object</i> is not defined, or if it returned NULL.
    </li>
   </ul>
<p>
   The delete functions may be called by Simics before an object is fully
   configured. That is, without any call to <i>finalize_instance</i> and
   possibly before all the attribute set methods have been called. This may
   happen when the object is part of a configuration that fails to load. The
   <b><i>SIM_object_is_configured</i></b> function can be used to determine if
   <i>finalize_instance</i> has run or not.
</p><p>
   The <i>description</i> string is used to describe the class in several
   sentences. It is used in the help commands and reference manuals. The
   <i>class_desc</i> string is a short class description beginning with
   lower case, without any trailing dot, and at most 50 characters long. It is
   used in help commands and for example in the GUI.
</p><p>
   </p><div class="note">
<b>Note:</b>
The old class functions are legacy. New code should use
   <code>class_info_t</code> and <b><i>SIM_create_class</i></b>.</div>.
<p>
   </p></dd>
</dl><p>
   </p><h3 class="jdocu"><a class="not-numbered" id="device-api-data-types.html:class_info_t">class_info_t</a></h3>
<p>
   
   
   
   <a id="device-api-data-types.html:class_info_t2"></a><a id="device-api-data-types.html:class_kind_t"></a>
</p><p>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-data-types.html:__jdocu_seealso_class_info_t"></a>class_info_t, class_kind_t</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<span class="jdocu_smaller">
  
   
<pre class="jdocu_small">typedef enum {
        Sim_Class_Kind_Vanilla = 0, /* object is saved at checkpoints */
        Sim_Class_Kind_Session = 1, /* object is saved as part of a
                                     * session only */
        Sim_Class_Kind_Pseudo = 2,  /* object is never saved */

        Sim_Class_Kind_Extension = 3, /* extension class
                                         (see SIM_extend_class) */
} class_kind_t;</pre><p>

   
</p><pre class="jdocu_small">typedef struct class_info {
        conf_object_t *(*alloc)(conf_class_t *cls);
        lang_void *(*init)(conf_object_t *obj);
        void (*finalize)(conf_object_t *obj);
        void (*objects_finalized)(conf_object_t *obj);

        void (*deinit)(conf_object_t *obj);
        void (*dealloc)(conf_object_t *obj);

        const char           *description;
        const char           *short_desc;
        class_kind_t          kind;
} class_info_t;</pre><p>

  </p></span></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The <code>class_info_t</code> type is used when a new class is registered.
  Uninitialized fields should be set to zero before the structure is passed to
  <b><i>SIM_create_class</i></b>.
<p>
  The <i>alloc</i> method is responsible for allocating memory for the
  object itself, i.e. the <code>conf_object_t</code> structure. If no
  <i>alloc</i> method is provided, Simics will use a default one, which
  uses <b><i>MM_MALLOC</i></b>. Classes written in C may implement
  <i>alloc</i> to have a single allocation and must then place
  <code>conf_object_t</code> first in the object data structure. This has the
  advantage of allowing casts directly from a <code>conf_object_t *</code> to a
  pointer to the user structure instead of using
  <i>SIM_object_data</i>. The <i>alloc</i> method can fail, e.g. if
  memory allocation fails, and signals this by returning NULL.
</p><p>
  After <i>alloc</i> has run on all objects being created, the
  <i>init</i> function is called, if defined. This method should do any
  class specific initialization, such as initializing internal data
  structures. The <i>init</i> method may also use <b><i>SIM_get_object</i></b>
  to obtain pointers to other objects, and it can use
  <b><i>SIM_set_attribute_default</i></b> on its descendants, but it may not call
  interfaces on other objects, or post events. If the object instance needs
  additional storage, it may allocate its own memory and return a pointer to it
  from <i>init</i>. This pointer can later be obtained using
  <b><i>SIM_object_data</i></b>. However, for classes that implement their own
  <i>alloc</i>, there is no need for that, since it can be done by
  co-allocating the <code>conf_object_t</code> struct in a larger data
  structure, and simply return the <code>conf_object_t</code> pointer from
  <i>init</i>. The <i>init</i> method is allowed to fail, and it
  signals this by returning NULL.
</p><p>
  The <i>finalize</i> method, if defined, is called when all attributes
  have been initialized in the object, and in all other objects that are
  created at the same time. This method is supposed to do any
  object initialization that require attribute values. Communication with other
  objects, e.g. via interfaces, should ideally be deferred until the
  <i>objects_finalized</i> method, but is permitted if
  <b><i>SIM_require_object</i></b> is first called.
</p><p>
  The <i>objects_finalized</i> method, if defined, is called after
  <i>finalize</i> has been called on all objects, so in this method the
  configuration is ready, and communication with other objects is permitted
  without restrictions.
</p><p>
  The <i>deinit</i> and <i>dealloc</i> methods are called during object
  destruction. The <i>deinit</i> method, if defined, is called first on all
  objects being deleted, and is supposed to do the inverse of the
  <i>init</i> method. The <i>dealloc</i> method is supposed to free the
  <code>conf_object_t</code> itself, i.e. it should be the inverse of
  <i>alloc</i>. It is not defined, a default dealloc method is used, which
  uses <b><i>MM_FREE</i></b>.
</p><p>
  The delete functions may be called by Simics before an object is fully
  configured. That is, without any call to <i>finalize</i> and possibly
  before all the attribute set methods have been called. This may happen when
  the object is part of a configuration that fails to load. The
  <b><i>SIM_object_is_configured</i></b> function can be used to determine if
  <i>finalize</i> has run or not.
</p><p>
  All functions are called in hierarchical order, starting from the root, so
  each object can assume that in each case, a function has already been called
  on all its ancestors. This can be used to e.g. set attribute default values
  on descendants in the <i>init</i> method.
</p><p>
  If the initialization fails, i.e. if <i>init</i> fails, or if any
  attribute setter fails, then the configuration creation is rolled back. For
  those objects where init succeeded (or no init was defined), the
  <i>deinit</i> function will be called, and on all created objects
  (i.e. not ones where <i>alloc</i> failed) the <i>dealloc</i> method
  is called.
</p><p>
  The <i>description</i> string is used to describe the class in several
  sentences. It is used in the help commands and reference manuals. The
  <i>short_desc</i> string is a short class description beginning with
  lower case, without any trailing dot, and at most 50 characters long. It is
  used in help commands and for example in the GUI.
</p><p>
 </p></dd>
</dl><p>
   </p><h3 class="jdocu"><a class="not-numbered" id="device-api-data-types.html:conf_object_t">conf_object_t</a></h3>
<p>
   
   
   <a id="device-api-data-types.html:conf_object_t2"></a>
   
   </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-data-types.html:__jdocu_seealso_conf_object_t"></a>conf_object_t</dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
All objects in the Simics simulator have an associated 
   <code>conf_object_t</code> struct.
   Pointers to <code>conf_object_t</code> are used
   in the Simics simulator API to refer to a
   specific object in the current Simics session.
   <code>conf_object_t</code> is an opaque data structure whose members
   should only be accessed using the Simics API.
   </dd>
</dl><p>
   </p><h3 class="jdocu"><a class="not-numbered" id="device-api-data-types.html:data_or_instr_t">data_or_instr_t</a></h3>
<p>
   
   
   <a id="device-api-data-types.html:data_or_instr_t2"></a>
   </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-data-types.html:__jdocu_seealso_data_or_instr_t"></a>data_or_instr_t</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<span class="jdocu_smaller">
   
   
<pre class="jdocu_small">typedef enum {
        Sim_DI_Instruction      = 0,
        Sim_DI_Data             = 1
} data_or_instr_t;</pre><p>

   
   </p></span></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This type is used to differentiate between data and instruction, usually in
   a TBL or memory transaction context.
   </dd>
</dl><p>
   </p><h3 class="jdocu"><a class="not-numbered" id="device-api-data-types.html:endianness_t">endianness_t</a></h3>
<p>
   
   
   <a id="device-api-data-types.html:endianness_t2"></a>
   
   </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-data-types.html:__jdocu_seealso_endianness_t"></a>endianness_t</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">typedef enum {
        Sim_Endian_Target,
        Sim_Endian_Host_From_BE,
        Sim_Endian_Host_From_LE
} endianness_t;</pre><p>
</p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Specifies the endianness to use for certain memory operations. When
   <code>Sim_Endian_Target</code> is used, the data from memory is
   copied without any endian conversion. 
   <code>Sim_Endian_Host_From_BE</code> and
   <code>Sim_Endian_Host_From_LE</code> copies data between a
   big-endian, or little-endian, memory and a host buffer.
   </dd>
</dl><p>
   </p><h3 class="jdocu"><a class="not-numbered" id="device-api-data-types.html:exception_type_t">exception_type_t</a></h3>
<p>
   
   
   <a id="device-api-data-types.html:exception_type_t2"></a>
   
   </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-data-types.html:__jdocu_seealso_exception_type_t"></a>exception_type_t</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<span class="jdocu_smaller">
   
<pre class="jdocu_small">typedef enum {
        SIM_PSEUDO_EXC(SIM_PSEUDO_EXC_ENUM)
} exception_type_t;</pre><p>

   
   </p></span></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Used to signal simulator exceptions for memory accesses. Errors
   usually correspond to hardware exceptions, but in some cases additional
   return values are needed, and then <i>pseudo exceptions</i> are used.
   The most common is <code>Sim_PE_No_Exception</code>, indicating that no error
   has occurred. Pseudo exceptions are used by devices, memory spaces, and
   Simics internally.
   <dl><dt id="device-api-data-types.html:dt:sim_pe_no_exception"><a href="#device-api-data-types.html:dt:sim_pe_no_exception"><b>Sim_PE_No_Exception</b></a></dt><dd>No error.</dd><dt id="device-api-data-types.html:dt:sim_pe_deferred"><a href="#device-api-data-types.html:dt:sim_pe_deferred"><b>Sim_PE_Deferred</b></a></dt><dd>Transaction completion is deferred via
   the call to <b><i>SIM_defer_transaction</i></b>.</dd><dt id="device-api-data-types.html:dt:sim_pe_async_required"><a href="#device-api-data-types.html:dt:sim_pe_async_required"><b>Sim_PE_Async_Required</b></a></dt><dd>The endpoint tried to defer the transaction
   with <b><i>SIM_defer_transaction</i></b> but the transaction
   cannot be deferred.</dd><dt id="device-api-data-types.html:dt:sim_pe_cancelled"><a href="#device-api-data-types.html:dt:sim_pe_cancelled"><b>Sim_PE_Cancelled</b></a></dt><dd>Special completion status passed to
   <code>transaction_completion_t</code> callbacks when asynchronous
   transactions are cancelled by Simics, for example, when simulation state
   is restored from a snapshot.</dd><dt id="device-api-data-types.html:dt:sim_pe_io_not_taken"><a href="#device-api-data-types.html:dt:sim_pe_io_not_taken"><b>Sim_PE_IO_Not_Taken</b></a></dt><dd>Access to unmapped memory. In the
   PCI memory spaces interpreted as master abort.</dd><dt id="device-api-data-types.html:dt:sim_pe_io_error"><a href="#device-api-data-types.html:dt:sim_pe_io_error"><b>Sim_PE_IO_Error</b></a></dt><dd>Accessed device returned error. In the
   PCI memory spaces interpreted as target abort.</dd><dt id="device-api-data-types.html:dt:sim_pe_inquiry_outside_memory"><a href="#device-api-data-types.html:dt:sim_pe_inquiry_outside_memory"><b>Sim_PE_Inquiry_Outside_Memory</b></a></dt><dd>Same as Sim_PE_IO_Not_Taken,
   but for inquiry accesses.</dd><dt id="device-api-data-types.html:dt:sim_pe_execute_outside_memory"><a href="#device-api-data-types.html:dt:sim_pe_execute_outside_memory"><b>Sim_PE_Execute_Outside_Memory</b></a></dt><dd>A processor tried to fetch
   instruction where no memory is defined.</dd><dt id="device-api-data-types.html:dt:sim_pe_inquiry_unhandled"><a href="#device-api-data-types.html:dt:sim_pe_inquiry_unhandled"><b>Sim_PE_Inquiry_Unhandled</b></a></dt><dd>The accessed device does not
   support inquiry operations.</dd><dt id="device-api-data-types.html:dt:sim_pe_stall_cpu"><a href="#device-api-data-types.html:dt:sim_pe_stall_cpu"><b>Sim_PE_Stall_Cpu</b></a></dt><dd>Timing model requested stall.</dd><dt id="device-api-data-types.html:dt:sim_pe_default_semantics"><a href="#device-api-data-types.html:dt:sim_pe_default_semantics"><b>Sim_PE_Default_Semantics</b></a></dt><dd>Used by user decoders and 
   user ASI handlers on SPARC to signal that the
   default semantics should be run.</dd><dt id="device-api-data-types.html:dt:sim_pe_ignore_semantics"><a href="#device-api-data-types.html:dt:sim_pe_ignore_semantics"><b>Sim_PE_Ignore_Semantics</b></a></dt><dd>Used by user ASI handlers on SPARC
   to signal no update of destination registers.</dd><dt id="device-api-data-types.html:dt:simics-internal"><a href="#device-api-data-types.html:dt:simics-internal"><b>Simics internal:</b></a></dt><dd>Sim_PE_Silent_Break,
   Sim_PE_Instruction_Finished, Sim_PE_Last.</dd></dl><p></p></dd>
</dl><p>
   </p><h3 class="jdocu"><a class="not-numbered" id="device-api-data-types.html:generic_transaction_t">generic_transaction_t</a></h3>
<p>
   
   
   <a id="device-api-data-types.html:generic_transaction_t2"></a>
   
   </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-data-types.html:__jdocu_seealso_generic_transaction_t"></a>generic_transaction_t</dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
A <code>generic_transaction_t</code>
   represents a memory transaction. It should only be accessed via the accessor
   functions documented in
   <a class="jdocu" href="#device-api-functions.html:Memory-Transactions">Device API Functions, Core, Memory
   Transactions</a>.</dd>
</dl><p>
   </p><h3 class="jdocu"><a class="not-numbered" id="device-api-data-types.html:global_notifier_type_t">global_notifier_type_t</a></h3>
<p>
   
   
   <a id="device-api-data-types.html:global_notifier_type_t2"></a>
   
   </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-data-types.html:__jdocu_seealso_global_notifier_type_t"></a>global_notifier_type_t</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<span class="jdocu_smaller">
   
<pre class="jdocu_small">typedef enum {
        Sim_Global_Notify_Object_Delete = 100,
        Sim_Global_Notify_Objects_Finalized,
        Sim_Global_Notify_Message,

        Sim_Global_Notify_Before_Snapshot_Restore = 150,
        Sim_Global_Notify_After_Snapshot_Restore,
} global_notifier_type_t;</pre><p>

   
   </p></span></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This enum is used to identify pre-defined global notifier. The
   <code>Sim_Global_Notify_Object_Delete</code> notifier is triggered by Simics
   when objects are being deleted. In the callback, objects are still fully
   available, but <b><i>SIM_marked_for_deletion</i></b> can be used to determine
   if an object is being deleted.
<p>
   The <code>Sim_Global_Notify_Objects_Finalized</code> notifier is triggered by
   Simics when new objects have been finalized, after their
   <code>objects_finalized</code> methods have been called.
</p><p>
   The <code>Sim_Global_Notify_Message</code> notifier is used by
   <b><i>SIM_trigger_global_message</i></b>.
</p><p>
   The corresponding names used in e.g. <b>list-notifiers</b>
   are as follows:
   </p><ul>
   <li>"global-object-delete" (<i>Sim_Global_Notify_Object_Delete</i>)</li>
   <li>"global-objects-finalized" (<i>Sim_Global_Notify_Objects_Finalized</i>)</li>
   <li>"global-message" (<i>Sim_Global_Notify_Message</i>)</li>
   </ul>
<p>
   </p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
     </a><b><i>SIM_add_global_notifier</i></b>,
     <b><i>SIM_add_global_notifier_once</i></b>,
     <b><i>SIM_delete_global_notifier</i></b>,
   </dd>
</dl><p>
   </p><h3 class="jdocu"><a class="not-numbered" id="device-api-data-types.html:hap_type_t">hap_type_t</a></h3>
<p>
   
   
   <a id="device-api-data-types.html:hap_type_t2"></a>
   
   </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-data-types.html:__jdocu_seealso_hap_type_t"></a>hap_type_t</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">typedef int hap_type_t;</pre><p>
</p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This data type is used to represent hap (occurrence) types. This is
   a runtime number that may change between different Simics
   invocations. Haps are normally identified by strings, but by
   calling <b><i>SIM_hap_get_number()</i></b>, a lookup from such a name
   to a <code>hap_type_t</code> can be made.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
     </a><b><i>SIM_get_all_hap_types</i></b>, 
     <b><i>SIM_hap_get_number</i></b>,
     <b><i>SIM_hap_add_type</i></b>
   </dd>
</dl><p>
   </p><h3 class="jdocu"><a class="not-numbered" id="device-api-data-types.html:init_arg_t">init_arg_t</a></h3>
<p>
   
   
     <a id="device-api-data-types.html:init_arg_t2"></a>
     
     </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-data-types.html:__jdocu_seealso_init_arg_t"></a>init_arg_t</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">typedef struct {
        const char *name;
        bool boolean;
        union {
                const char *string;
                bool enabled;
        } u;
} init_arg_t;</pre><p>

       </p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Data structure used to pass an initialization argument to the
       <b><i>SIM_init_simulator2</i></b> function. The <code>name</code> field is
       mandatory and the associated data is either a boolean or a string
       (<code>char *</code>). A list of <code>init_arg_t</code> is passed to
       <b><i>SIM_init_simulator2</i></b> where the last entry has the
       <code>name</code> field set to <code>NULL</code>.
       </dd>
</dl><p>
   </p><h3 class="jdocu"><a class="not-numbered" id="device-api-data-types.html:int8-int16-int32-int64-uint8-uint16-uint32-uint64-intptr_t-uintptr_t">int8, int16, int32, int64, uint8, uint16, uint32, uint64, intptr_t, uintptr_t</a></h3>
<p>
   
   
   <a id="device-api-data-types.html:int8"></a>
   <a id="device-api-data-types.html:int16"></a>
   <a id="device-api-data-types.html:int32"></a>
   <a id="device-api-data-types.html:int64"></a>
   <a id="device-api-data-types.html:uint8"></a>
   <a id="device-api-data-types.html:uint16"></a>
   <a id="device-api-data-types.html:uint32"></a>
   <a id="device-api-data-types.html:uint64"></a>
   <a id="device-api-data-types.html:intptr_t"></a>
   <a id="device-api-data-types.html:uintptr_t"></a>
   
   </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-data-types.html:__jdocu_seealso_"></a>int8, int16, int32, int64, 
   uint8, uint16, uint32, uint64,
   intptr_t, uintptr_t</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
These data types have host-dependent definitions. Use the
   <b>api-help</b> Simics command line command to get their
   exact definition.
   </dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
These are basic integer data types defined by the Simics headers
   (unless defined by system header files).
<p>
   The <code>int</code><em>n</em><code></code> types are defined to be signed
   integers of exactly <code></code><em>n</em><code></code> bits. The
   <code>uint</code><em>n</em><code></code> types are their unsigned counterparts.
</p><p>
   <code>intptr_t</code> and <code>uintptr_t</code> are signed and
   unsigned integer types of a size that lets any pointer to
   <code>void</code> be cast to it and then cast back to a pointer to
   <code>void</code>, and the result will compare equal to the
   original pointer. This typically means that the two types are 64
   bits wide.
</p><p>
   </p></dd>
</dl><p>
   </p><h3 class="jdocu"><a class="not-numbered" id="device-api-data-types.html:lang_void">lang_void</a></h3>
<p>
   
   
   <a id="device-api-data-types.html:lang_void2"></a>
   
   </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-data-types.html:__jdocu_seealso_lang_void"></a>lang_void</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">typedef void lang_void;</pre><p>
</p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
In some places in the Simics API, arguments of type 
   <code><nobr>lang_void *</nobr></code> are used. This data type is used to
   allow transparent passing of any data type in the current programming
   language as argument. In C, this works exactly like a 
   <code><nobr>void *</nobr></code> and in Python, it is any Python
   object.
<p>
   Typically, this is used by iterator functions in the API which take callback
   functions as arguments. The callback function is later called with the
   <code>lang_void</code> data and the object being iterated over.
   </p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
     </a><b><i>SIM_hap_add_callback</i></b>, 
     <b><i>SIM_register_typed_attribute</i></b>
   </dd>
</dl><p>
   </p><h3 class="jdocu"><a class="not-numbered" id="device-api-data-types.html:logical_address_t-physical_address_t-generic_address_t-linear_address_t">logical_address_t, physical_address_t, generic_address_t, linear_address_t</a></h3>
<p>
   
   
   <a id="device-api-data-types.html:logical_address_t"></a>
   <a id="device-api-data-types.html:physical_address_t"></a>
   <a id="device-api-data-types.html:generic_address_t"></a>
   <a id="device-api-data-types.html:linear_address_t"></a>
   
   </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-data-types.html:__jdocu_seealso_2"></a>logical_address_t, physical_address_t, generic_address_t,
   linear_address_t
   </dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
These data types are target architecture independent, and always
   large enough to hold 64-bit addresses.
   </dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
These are integer data types defined to reflect the nature of the
   simulated architecture.
<p>
   <code>logical_address_t</code> is an unsigned integer sufficiently
   large to contain logical (virtual) addresses on the target machine.
</p><p>
   <code>physical_address_t</code> is an unsigned integer sufficiently
   large to contain physical addresses on the target machine.
</p><p>
   <code>generic_address_t</code> is defined to be the largest of the
   <code>logical_address_t</code> and <code>physical_address_t</code>
   types.
</p><p>
   <code>linear_address_t</code> is used for linear addresses used on
   x86 machines after segmentation but before paging.
</p><p>
   Note that these data types are all defined to be 64-bit unsigned
   integers, and they can be printed by <b><i>printf</i></b> using the
   <code>ll</code> (ell-ell) size modifier.
   </p></dd>
</dl><p>
   </p><h3 class="jdocu"><a class="not-numbered" id="device-api-data-types.html:map_info_t">map_info_t</a></h3>
<p>
   
   
   <a id="device-api-data-types.html:map_info_t2"></a>
   <a id="device-api-data-types.html:swap_mode_t"></a>
   
   </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-data-types.html:__jdocu_seealso_map_info_t"></a>map_info_t, swap_mode_t</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<a id="device-api-data-types.html:map_type_t"></a>
   <span class="jdocu_smaller">
   
<pre class="jdocu_small">typedef enum swap_mode {
        Sim_Swap_None       = 0,
        Sim_Swap_Bus        = 1,
        Sim_Swap_Bus_Trans  = 2,
        Sim_Swap_Trans      = 3
} swap_mode_t;</pre><p>

</p><pre class="jdocu_small">typedef struct map_info {
        physical_address_t  base;
        physical_address_t  start;
        physical_address_t  length;
        int                 function;
        int16               priority;
        int                 align_size;
        swap_mode_t         reverse_endian;
} map_info_t;</pre><p>

   
   </p></span></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The <code>map_info_t</code> structure members have the following meaning:
   <ul>
   <li>
   <code>base</code>: The base address of the device mapping in the memory space.
   </li>
   <li>
   <code>start</code>: The address inside the device memory space where the mapping
   starts.</li>
   <li><code>length</code>: The length of the mapped memory, in bytes.</li>
   <li><code>function</code>: Used to map the same object several times
       with different functionality. Corresponds to the function argument used
       when mapping devices into a memory space.</li>
   <li>If the map target does not support large accesses, then
       <code>align_size</code> can be set to the maximum allowed size. Accesses
       spanning align boundaries will be split into several smaller
       transactions. The align size must be a power of two, or zero (which
       means "use the default value": 8 for devices and 8192 for memory).</li>
   <li>Mappings with an align size of 2, 4, or 8 may set the
       <code>reverse_endian</code> field to a non zero value. This can be used to
       model bridges that perform byte swapping on a specific bus width.</li>
   </ul>
<p>
   If both <code>base</code> and <code>length</code> are 0 the map will become a
   <code>default_target</code>.
</p><p>
   </p></dd>
</dl><p>
   </p><h3 class="jdocu"><a class="not-numbered" id="device-api-data-types.html:map_list_t">map_list_t</a></h3>
<p>
   
   
   <a id="device-api-data-types.html:map_list_t2"></a>
   <a id="device-api-data-types.html:map_type_t2"></a>
   
   </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-data-types.html:__jdocu_seealso_map_list_t"></a>map_list_t, map_type_t</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<a id="device-api-data-types.html:map_type_t3"></a><a id="device-api-data-types.html:map_info_t3"></a>
   <span class="jdocu_smaller">
   
<pre class="jdocu_small">typedef enum { 
        Sim_Map_Ram,
        Sim_Map_Rom,
        Sim_Map_IO,
        Sim_Map_Port,
        Sim_Map_Translate = 0x100, /* pseudo - do not use */
        Sim_Map_Translate_To_Space,
        Sim_Map_Translate_To_Ram,
        Sim_Map_Translate_To_Rom
} map_type_t;</pre><p>

   
</p><pre class="jdocu_small">typedef struct map_list {
        map_type_t       map_type;
        conf_object_t   *object;
        const char      *port;
#if !defined(PYWRAP)
        const void      *interface_ptr;
        const void      *target_interface;
        const void      *breakpoint_interface;
#if defined(SIMICS_6_API)
        const void      *breakpoint_query_interface;
#else
        const void      *breakpoint_query_v2_interface;
#endif
        const void      *bridge_interface;
#endif
        conf_object_t   *target_object;
        const char      *target_port;
        conf_object_t   *bridge;
        map_info_t       map_info;

        physical_address_t map_size; /* not constant, use with caution */

        int              deleted;  /* internal flag - should always be 0 ! */
} map_list_t;</pre><p>

   
   </p></span></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This data structure is used to pass information about the set of
   mappings a particular address in an address space contains.  
   </dd>
</dl><p>
   </p><h3 class="jdocu"><a class="not-numbered" id="device-api-data-types.html:map_target_t">map_target_t</a></h3>
<p>
   
   
   <a id="device-api-data-types.html:map_target_t2"></a>
   
   </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-data-types.html:__jdocu_seealso_map_target_t"></a>map_target_t</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<span class="jdocu_smaller">
<pre class="jdocu_small">typedef struct map_target map_target_t;</pre><p>

   </p></span></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
A map target can be viewed as an opaque representation of
   an object/interface pair which can function either as an endpoint
   for a memory transaction or as an address space where a
   memory transaction can be performed. To create a <code>map_target_t</code>
   object one should use the <b><i>SIM_new_map_target</i></b> function.
   The <b><i>SIM_free_map_target</i></b> function frees
   a <code>map_target_t</code> object. In order to get better performance,
   it is better to allocate a map target once and reuse it rather
   than to allocate and free it every time.
<p>
   Examples of map targets include IO banks, RAM, ROM, memory spaces,
   port spaces, translators and bridges.
</p><p>
   For certain targets, e.g. bridges or translators, the map target also
   holds information about a chained, or default, target.
   </p></dd>
<dt class="jdocu_descitem">PYTHON SPECIFICS</dt><dd>
In Python, it is allowed to use arguments of the <code>conf_object_t</code>
   type with Simics API functions that have parameters of
   the <code>map_target_t</code> type. The arguments of
   the <code>conf_object_t</code> type will be converted to
   <code>map_target_t</code> values automatically, via the call to
   the <b><i>SIM_new_map_target</i></b> function. Here is an example where
   <i>memory_space</i> is a Simics object, i.e. has
   the <code>conf_object_t</code> type:
   <pre class="jdocu_small">   t = transaction_t(...)
   SIM_issue_transaction(memory_space, t, addr)</pre><p>
</p><p>
   In Python, the objects of the <code>map_target_t</code> type have
   read-only <code>obj</code>, <code>port</code>, and <code>target</code> attributes.
   These attributes correspond to the arguments given to
   <b><i>SIM_new_map_target</i></b> that created
   a <code>map_target_t</code> object.
   </p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
   </a><b><i>SIM_new_map_target</i></b>, <b><i>SIM_free_map_target</i></b>,
   <b><i>SIM_map_target_object</i></b>, <b><i>SIM_map_target_port</i></b>,
   <b><i>SIM_map_target_target</i></b>, <code>translator_interface_t</code>
   </dd>
</dl><p>
   </p><h3 class="jdocu"><a class="not-numbered" id="device-api-data-types.html:mem_op_type_t">mem_op_type_t</a></h3>
<p>
   
   
   <a id="device-api-data-types.html:mem_op_type_t2"></a>
   
   </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-data-types.html:__jdocu_seealso_mem_op_type_t"></a>mem_op_type_t</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<span class="jdocu_smaller">
   
<pre class="jdocu_small">typedef enum {
        Sim_Trans_Load          = 0,
        Sim_Trans_Store         = Sim_Trn_Write,
        Sim_Trans_Instr_Fetch   = Sim_Trn_Instr,
        Sim_Trans_Prefetch      = Sim_Trn_Prefetch | Sim_Trn_Control,
        Sim_Trans_Cache         = Sim_Trn_Control
} mem_op_type_t;</pre><p>

   
   </p></span></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This enum is used to identify the type of a memory operation. The
   function <b><i>SIM_get_mem_op_type()</i></b> returns the type of a 
   <code>generic_transaction_t</code>, and <b><i>SIM_set_mem_op_type()</i></b>
   is used to set it.
   </dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
     </a><b><i>SIM_get_mem_op_type</i></b>, <b><i>SIM_set_mem_op_type</i></b>,
     <b><i>SIM_get_mem_op_type_name</i></b>
     <code>generic_transaction_t</code>,
   </dd>
</dl><p>
   </p><h3 class="jdocu"><a class="not-numbered" id="device-api-data-types.html:notifier_type_t">notifier_type_t</a></h3>
<p>
   
   
   <a id="device-api-data-types.html:notifier_type_t2"></a>
   
   </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-data-types.html:__jdocu_seealso_notifier_type_t"></a>notifier_type_t</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<span class="jdocu_smaller">
   
<pre class="jdocu_small">/* Note that notifier types can be added either by modifying this enum or
   by using SIM_notifier_type. The latter is typically preferred since it does
   not change the Simics API. */
typedef enum {
        Sim_Notify_Queue_Change,
        Sim_Notify_Cell_Change,
        Sim_Notify_Frequency_Change,
        Sim_Notify_Concurrency_Change,
        Sim_Notify_Object_Delete,
        Sim_Notify_Map_Change,
        Sim_Notify_State_Change,
        Sim_Notify_Freerunning_Mode_Change,
        Sim_Notify_Bank_Register_Value_Change,
} notifier_type_t;</pre><p>

   
   </p></span></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Values of the <code>notifier_type_t</code> type identify notification events.
   A <code>notifier_type_t</code> value should be obtained from
   the <b><i>SIM_notifier_type</i></b> function and can then be used in other
   functions such as <b><i>SIM_register_notifier</i></b>,
   <b><i>SIM_add_notifier</i></b>, <b><i>SIM_notify</i></b>.
<p>
   A few notification events have predefined (constant) values. They are listed
   below where a notifier type in the form of a string (as accepted by
   <b><i>SIM_notifier_type</i></b>) is followed by the constant of the
   <code>notifier_type_t</code> type corresponding to the notification event
   (as returned by <b><i>SIM_notifier_type</i></b>):
   </p><ul>
   <li>"queue-change" (<i>Sim_Notify_Queue_Change</i>)</li>
   <li>"cell-change" (<i>Sim_Notify_Cell_Change</i>)</li>
   <li>"frequency-change" (<i>Sim_Notify_Frequency_Change</i>)</li>
   <li>"concurrency-change" (<i>Sim_Notify_Concurrency_Change</i>)</li>
   <li>"object-delete" (<i>Sim_Notify_Object_Delete</i>)</li>
   <li>"map-change" (<i>Sim_Notify_Map_Change</i>)</li>
   <li>"state-change" (<i>Sim_Notify_State_Change</i>)</li>
   <li>"freerunning-mode-change"
        (<i>Sim_Notify_Freerunning_Mode_Change</i>)</li>
   <li>"bank-register-value-change"
        (<i>Sim_Notify_Bank_Register_Value_Change</i>)</li>
   </ul>
   </dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
     </a><b><i>SIM_notify</i></b>,
     <b><i>SIM_add_notifier</i></b>,
     <b><i>SIM_register_notifier</i></b>,
     <b><i>SIM_notifier_type</i></b>,
     <b><i>SIM_describe_notifier</i></b>,
     <b><i>SIM_notifier_description</i></b>
   </dd>
</dl><p>
   </p><h3 class="jdocu"><a class="not-numbered" id="device-api-data-types.html:processor_mode_t">processor_mode_t</a></h3>
<p>
   
   
   <a id="device-api-data-types.html:processor_mode_t2"></a>
   </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-data-types.html:__jdocu_seealso_processor_mode_t"></a>processor_mode_t</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">typedef enum {
        Sim_CPU_Mode_User       = 0,
        Sim_CPU_Mode_Supervisor = 1,
        Sim_CPU_Mode_Hypervisor
} processor_mode_t;</pre><p>
</p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The <code>processor_mode_t</code> data type is used to specify if a
   CPU is running in user mode or in a privileged mode (often called
   supervisor mode). For processor architectures with several
   privilege levels, the non-user levels are all identified as
   <code>Sim_CPU_Mode_Supervisor</code>.
   </dd>
</dl><p>
   </p><h3 class="jdocu"><a class="not-numbered" id="device-api-data-types.html:read_or_write_t">read_or_write_t</a></h3>
<p>
   
   
   <a id="device-api-data-types.html:read_or_write_t2"></a>
   
   </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-data-types.html:__jdocu_seealso_read_or_write_t"></a>read_or_write_t</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">typedef enum {
        Sim_RW_Read  = 0,
        Sim_RW_Write = 1
} read_or_write_t;</pre><p>
</p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Whether a memory access is a <i>read</i> (from memory) or a <i>write</i>
   (to memory).
   </dd>
</dl><p>
   </p><h3 class="jdocu"><a class="not-numbered" id="device-api-data-types.html:set_error_t">set_error_t</a></h3>
<p>
   
   
   <a id="device-api-data-types.html:set_error_t2"></a>
   
   </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-data-types.html:__jdocu_seealso_set_error_t"></a>set_error_t</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<span class="jdocu_smaller">
<pre class="jdocu_small">typedef enum {
        Sim_Set_Ok,
        Sim_Set_Object_Not_Found,
        Sim_Set_Interface_Not_Found,
        Sim_Set_Illegal_Value,
        Sim_Set_Illegal_Type,
        Sim_Set_Illegal_Index,
        Sim_Set_Attribute_Not_Found,
        Sim_Set_Not_Writable,

        Sim_Set_Error_Types     /* number of error types */
} set_error_t;</pre><p>

   </p></span></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The <b><i>SIM_set_attribute()</i></b> family of functions and the set functions
   registered with the <b><i>SIM_register_attribute()</i></b> family of
   functions return a <code>set_error_t</code> value to report success or
   failure.
<p>
   <b>Sim_Set_Ok</b><br>
   The attribute was successfully set.
</p><p>
   <b>Sim_Set_Object_Not_Found</b><br>
   The string value does not match any object name. Deprecated, use attributes
   of object type instead of string attributes referring to object names.
</p><p>
   <b>Sim_Set_Interface_Not_Found</b><br>
   The object value does not implement an interface required by the attribute.
</p><p>
   <b>Sim_Set_Illegal_Value</b><br>
   The value is of a legal type for the attribute, but outside the legal range.
</p><p>
   <b>Sim_Set_Illegal_Type</b><br>
   The value is of an illegal type for the attribute.
</p><p>
   <b>Sim_Set_Attribute_Not_Found</b><br>
   The object has no attribute with the specified name. Should only be returned
   by <b><i>SIM_set_attribute()</i></b> family of functions, not by attribute set
   functions.
</p><p>
   <b>Sim_Set_Not_Writable</b><br>
   The attribute is read-only.
</p><p>
   <b>Sim_Set_Error_Types</b><br>
   This is the number of valid error values and should not be used as
   an error code.
</p><p>
   </p></dd>
</dl><p>
   </p><h3 class="jdocu"><a class="not-numbered" id="device-api-data-types.html:simtime_t-cycles_t-pc_step_t-nano_secs_t">simtime_t, cycles_t, pc_step_t, nano_secs_t</a></h3>
<p>
   
   
   <a id="device-api-data-types.html:simtime_t"></a>
   <a id="device-api-data-types.html:cycles_t"></a>
   <a id="device-api-data-types.html:pc_step_t"></a>
   <a id="device-api-data-types.html:nano_secs_t"></a>
   
   </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-data-types.html:__jdocu_seealso_3"></a>simtime_t, cycles_t, pc_step_t, nano_secs_t
   </dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">typedef int64 simtime_t;</pre><p>

   
</p><pre class="jdocu_small">typedef simtime_t cycles_t;</pre><p>

   
</p><pre class="jdocu_small">typedef simtime_t pc_step_t;</pre><p>

   
</p><pre class="jdocu_small">typedef int64 nano_secs_t;</pre><p>

   </p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
These are the types used for keeping track of time in Simics.
<p>
   <code>cycles_t</code> is used when the time is specified in cycles,
   <code>pc_step_t</code> is used when the time is specified in steps, and
   <code>simtime_t</code> is used in places where it is unknown whether the
   time is in steps or cycles. See the <em>Understanding Simics Timing</em>
   application note for a discussion about the difference between steps and
   cycles.
</p><p>
   <code>nano_secs_t</code> is used to express a number of nanoseconds
   (10<sup>9</sup> seconds).
   </p></dd>
</dl><p>
   </p><h3 class="jdocu"><a class="not-numbered" id="device-api-data-types.html:translation_t">translation_t</a></h3>
<p>
   
   
   <a id="device-api-data-types.html:translation_flags_t"></a>
   <a id="device-api-data-types.html:translation_t2"></a>
   
</p><p>
   </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-data-types.html:__jdocu_seealso_translation_t"></a>translation_t</dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The <code>translation_t</code> type is used for the implementation
   of the <code>translator</code> and <code>transaction_translator</code>
   interfaces. It describes the range
   for which the translation is valid, its target as well as
   translation properties.
<p>
   The range for which the translation is valid is specified by the
   fields <i>base</i> and <i>size</i>. As a special case,
   if <i>size</i> and <i>base</i> are both 0, then the
   translation is valid for the entire address space. To allow optimizations
   (e.g., caching of translations) translators should return as wide ranges
   as possible.
</p><p>
   The <i>target</i> field specifies the object and interface
   port which is mapped into the address range in the form of a map target.
   Map targets can be created using the function
   <b><i>SIM_new_map_target</i></b>. Please note that the ownership over
   the returned map target is not transferred to the interface caller.
   This means that to avoid memory leaks the reference to the map
   target must be kept by the implementing object, and
   <b><i>SIM_free_map_target</i></b> function should be later used to
   deallocate the map target. Possible map targets include IO
   banks, RAM, ROM, memory spaces, port spaces, bridges, and translators.
   The <i>base</i> address in the source address space is
   mapped to the target address returned in the <i>start</i> field.
</p><p>
   A null value returned in the <i>target</i> field signifies that
   the translation cannot be done. This can happen if there is nothing mapped
   in the range defined by <i>base</i> and <i>size</i>
   (transactions directed to this region will be terminated
   with the pseudo exception <code>Sim_PE_IO_Not_Taken</code>) or
   if a translation valid for all requested accesses cannot be performed.
   In the latter case, the requestor is expected to repeat
   the interface call with just a single bit set in the access mask,
   e.g. <code>Sim_Access_Read</code>.
</p><p>
   If the returned translation is not static but instead depends on e.g.
   a device register, then the translator can set the flags field
   to <code>Sim_Translation_Dynamic</code>. This flag indicates that
   the translation must not be cached. If this flag is not used, then it
   is the responsibility of the translator to call
   either <b><i>SIM_map_target_flush</i></b> (preferably)
   or <b><i>SIM_translation_changed</i></b> function when a previously performed
   translation is no longer valid.
</p><p>
   The <code>Sim_Translation_Ambiguous</code> flag should not generally
   be used by models. It is used by Simics objects of
   the <b>memory-space</b> class to indicate an error in
   the memory mapping when several destinations are specified for the address.
</p><p>
   </p><pre class="jdocu_small">typedef enum {
        Sim_Translation_Dynamic = 1,
        Sim_Translation_Ambiguous = 2
} translation_flags_t;

typedef struct translation {
        const map_target_t *target;  /* target of translation */

        physical_address_t base;     /* base address of translated range */
        physical_address_t start;    /* start address in mapped object */
        physical_address_t size;     /* size of translated range */

        translation_flags_t flags;
} translation_t;
</pre><p>
</p><p>

   </p></dd><dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
     </a><b><i>SIM_map_target_flush</i></b>,
     <b><i>SIM_translation_changed</i></b>
   </dd>

   
</dl><p>
   

    
    </p><h2 class="jdocu"><a id="device-api-data-types.html:Model-Specific-Data-Types">3.2.2 Model Specific Data Types</a></h2>
<p></p><h3 class="jdocu"><a class="not-numbered" id="device-api-data-types.html:arm_device_type_t">arm_device_type_t</a></h3>
<p>
     
     
     <a id="device-api-data-types.html:arm_device_type_t2"></a>
     </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-data-types.html:__jdocu_seealso_arm_device_type_t"></a>arm_device_type_t</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<span class="jdocu_smaller">
           
<pre class="jdocu_small">typedef enum {
        Arm_DeviceType_nGnRnE = 0x0,
        Arm_DeviceType_nGnRE  = 0x1,
        Arm_DeviceType_nGRE   = 0x2,
        Arm_DeviceType_GRE    = 0x3,
        Arm_DeviceType_Unknown
} arm_device_type_t;</pre><p>

         
       </p></span></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Arm device memory types. Corresponds to the DeviceType pseudo code
         enumeration in the Armv8 A-profile Architecture Reference Manual.
       </dd>
</dl><p>
   </p><h3 class="jdocu"><a class="not-numbered" id="device-api-data-types.html:arm_mem_attr_t">arm_mem_attr_t</a></h3>
<p>
     
     
     <a id="device-api-data-types.html:arm_mem_attr_t2"></a>
     </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-data-types.html:__jdocu_seealso_arm_mem_attr_t"></a>arm_mem_attr_t</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<span class="jdocu_smaller">
           
<pre class="jdocu_small">typedef enum {
        Arm_MemAttr_NC = 0x0, // Non-cacheable
        Arm_MemAttr_WT = 0x2, // Write-through
        Arm_MemAttr_WB = 0x3, // Write-back
        Arm_MemAttr_Unknown
} arm_mem_attr_t;</pre><p>

         
       </p></span></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Memory cacheability. Corresponds to the MemAttr pseudo code constants
         in the Armv8 A-profile Architecture Reference Manual.
       </dd>
</dl><p>
   </p><h3 class="jdocu"><a class="not-numbered" id="device-api-data-types.html:arm_mem_hint_t">arm_mem_hint_t</a></h3>
<p>
     
     
     <a id="device-api-data-types.html:arm_mem_hint_t2"></a>
     </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-data-types.html:__jdocu_seealso_arm_mem_hint_t"></a>arm_mem_hint_t</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<span class="jdocu_smaller">
           
<pre class="jdocu_small">typedef enum {
        Arm_MemHint_No  = 0x0, // No Read-Allocate, No Write-Allocate
        Arm_MemHint_WA  = 0x1, // No Read-Allocate, Write-Allocate
        Arm_MemHint_RA  = 0x2, // Read-Allocate, No Write-Allocate
        Arm_MemHint_RWA = 0x3, // Read-Allocate, Write-Allocate
        Arm_MemHint_Unknown
} arm_mem_hint_t;</pre><p>

         
       </p></span></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Cache allocation hint. Corresponds to the MemHint pseudo code
         constants in the Armv8 A-profile Architecture Reference Manual.
       </dd>
</dl><p>
   </p><h3 class="jdocu"><a class="not-numbered" id="device-api-data-types.html:arm_mem_instr_origin_t">arm_mem_instr_origin_t</a></h3>
<p>
   
   
     <a id="device-api-data-types.html:arm_mem_instr_origin_t2"></a>
     </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-data-types.html:__jdocu_seealso_arm_mem_instr_origin_t"></a>arm_mem_instr_origin_t</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<span class="jdocu_smaller">
         
<pre class="jdocu_small">typedef enum {
        /* Normal load or store instructions */
        Instr_Normal_Arm = 0,

        /* Unprivileged memory access instructions. */
        Instr_Unprivileged_Load,
        Instr_Unprivileged_Store,

        /* Other loads/stores or cache affecting instructions */
        Instr_ldrex,
        Instr_strex,
        Instr_ldxp,
        Instr_stxp,

        /* Address translation instruction */
        Instr_At,

        /* Atomic read-modify-write instructions */
        Instr_Atomic,

        /* Cache maintenance instructions */
        Instr_Cache_Maintenance,

        /* Number of different of enum values, not a value in itself. */
        Instr_Count
} arm_mem_instr_origin_t;</pre><p>

         
       </p></span></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
List of special memory operations that can be send by a ARM processor.
       </dd>
</dl><p>
   </p><h3 class="jdocu"><a class="not-numbered" id="device-api-data-types.html:arm_mem_transient_t">arm_mem_transient_t</a></h3>
<p>
     
     
     <a id="device-api-data-types.html:arm_mem_transient_t2"></a>
     </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-data-types.html:__jdocu_seealso_arm_mem_transient_t"></a>arm_mem_transient_t</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<span class="jdocu_smaller">
           
<pre class="jdocu_small">typedef enum {
        Arm_Transient_True,
        Arm_Transient_False,
        Arm_Transient_Unknown
} arm_mem_transient_t;</pre><p>

         
       </p></span></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Transcience hint. Corresponds to the boolean used for transience by
         the pseudo code in the Armv8 A-profile Architecture Reference Manual.
       </dd>
</dl><p>
   </p><h3 class="jdocu"><a class="not-numbered" id="device-api-data-types.html:arm_mem_type_t">arm_mem_type_t</a></h3>
<p>
     
     
     <a id="device-api-data-types.html:arm_mem_type_t2"></a>
     </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-data-types.html:__jdocu_seealso_arm_mem_type_t"></a>arm_mem_type_t</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<span class="jdocu_smaller">
           
<pre class="jdocu_small">typedef enum {
        Arm_MemType_Normal,
        Arm_MemType_Device
} arm_mem_type_t;</pre><p>

         
       </p></span></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Arm memory types. Corresponds to the MemType pseudo code
         enumeration in the Armv8 A-profile Architecture Reference
         Manual.
       </dd>
</dl><p>
   </p><h3 class="jdocu"><a class="not-numbered" id="device-api-data-types.html:arm_memory_attributes_encoding_t">arm_memory_attributes_encoding_t</a></h3>
<p>
     
     
     <a id="device-api-data-types.html:arm_memory_attributes_encoding_t2"></a>
     </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-data-types.html:__jdocu_seealso_arm_memory_attributes_encoding_t"></a>arm_memory_attributes_encoding_t</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<span class="jdocu_smaller">
           
<pre class="jdocu_small">typedef union {
        struct {
                uint64 memory_type:2;            // arm_mem_type_t
                uint64 device_type:3;            // arm_device_type_t
                uint64 inner_cacheability:3;     // arm_mem_attr_t
                uint64 inner_allocation_hint:3;  // arm_mem_hint_t
                uint64 inner_transcience_hint:2; // arm_mem_transient_t
                uint64 outer_cacheability:3;     // arm_mem_attr_t
                uint64 outer_allocation_hint:3;  // arm_mem_hint_t
                uint64 outer_transcience_hint:2; // arm_mem_transient_t
                uint64 shareable:1;              // bool
                uint64 outer_shareable:1;        // bool
        } u;
        uint64 u64;
} arm_memory_attributes_encoding_t;</pre><p>

         
       </p></span></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This type should be used to encode or decode the uint64 value
         contained in an arm_memory_attributes atom. The comment beside each
         field is the type that should be used to interpret the field value.
       </dd>
</dl><p>
   </p><h3 class="jdocu"><a class="not-numbered" id="device-api-data-types.html:arm_memory_transaction_t">arm_memory_transaction_t</a></h3>
<p>
   
   
   <a id="device-api-data-types.html:arm_memory_transaction_t2"></a>
   
   </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-data-types.html:__jdocu_seealso_arm_memory_transaction_t"></a>arm_memory_transaction_t</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">typedef struct arm_memory_transaction {
        generic_transaction_t s;

        processor_mode_t mode;
        int rotate;
        arm_mem_instr_origin_t instr_origin;
} arm_memory_transaction_t;</pre><p>

   </p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This is the ARM specific memory transaction data structure.
   The generic data is stored in the <i>s</i> field.
<p>
   The <i>mode</i> field specifies the processor mode the MMU should assume
   when processing the transaction. This is the same as the current mode of the
   processor except for unprivileged load and store instructions when it is
   always <code>Sim_CPU_Mode_User</code>.
</p><p>
   The <i>rotate</i> field is non-zero if this transaction is from one of
   the AArch32 instructions for which an unaligned address is interpreted as an
   aligned load with the value rotated so that the addressed byte becomes the
   least significant byte if neither <code>SCTLR.U</code> nor <code>SCTLR.A</code>
   is set.
</p><p>
   The <i>instr_origin</i> field specifies the type of instruction that
   initiated this memory transaction.
</p><p>
   </p></dd>
</dl><p>
   </p><h3 class="jdocu"><a class="not-numbered" id="device-api-data-types.html:arm_smmu_attributes_t">arm_smmu_attributes_t</a></h3>
<p>
     
     
     <a id="device-api-data-types.html:arm_smmu_attributes_t2"></a>
     </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-data-types.html:__jdocu_seealso_arm_smmu_attributes_t"></a>arm_smmu_attributes_t</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<span class="jdocu_smaller">
           
<pre class="jdocu_small">typedef union {
        struct {
                uint64 sid:32;    // IMPLEMENTATION DEFINED size, between 0 and 32 bits
                uint64 ssid:20;   // IMPLEMENTATION DEFINED size, between 0 and 20 bits
                uint64 secsid:1;  // bool
                uint64 ssidv:1;   // bool
                uint64 atst:1;    // bool
        } u;
       uint64 u64;
} arm_smmu_attributes_t;</pre><p>

         
       </p></span></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This type should be used to encode or decode the uint64 value
         contained in an arm_smmu_attributes atom. The comment beside each
         field is the type that should be used to interpret the field value.
       </dd>
</dl><p>
   </p><h3 class="jdocu"><a class="not-numbered" id="device-api-data-types.html:arm_translation_regime_t">arm_translation_regime_t</a></h3>
<p>
     
     
     <a id="device-api-data-types.html:arm_translation_regime_t2"></a>
     </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-data-types.html:__jdocu_seealso_arm_translation_regime_t"></a>arm_translation_regime_t</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<span class="jdocu_smaller">
         
<pre class="jdocu_small">typedef enum {
        Arm_TR_EL3,  /* EL3         */
        Arm_TR_EL2,  /* EL2   PL2   */
        Arm_TR_EL20, /* EL2&amp;0       */
        Arm_TR_EL10, /* EL1&amp;0 PL1&amp;0 */
} arm_translation_regime_t;</pre><p>

         ,
       </p></span></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Arm MMU translation regimes. Named after the AArch64 translation
         regimes, but also used for the AArch32 ones.
       </dd>
</dl><p>
   </p><h3 class="jdocu"><a class="not-numbered" id="device-api-data-types.html:i2c_status_t">i2c_status_t</a></h3>
<p>
   
   
   <a id="device-api-data-types.html:i2c_status_t2"></a>
   </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-data-types.html:__jdocu_seealso_i2c_status_t"></a>i2c_status_t</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">typedef enum {
        /* The ACK bit related to the operation was 0. This typically
           means that the operation was successful */
        I2C_status_success = 0,
        /* The ACK bit related to the operation was 1. This typically
           means that the operation was unsuccessful */
        I2C_status_noack = 1,
        /* The operation could not be carried out, because the link is
           currently in use by another master */
        I2C_status_bus_busy
} i2c_status_t;</pre><p>
</p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The <code>i2c_status_t</code> type is used to communicate the
   results of various operations on the I2C link. The type is an enum,
   with the values <code>I2C_status_success</code>,
   <code>I2C_status_noack</code> and
   <code>I2C_status_bus_busy</code>.
<p>
   The <code>i2c_status_t</code> type typically represents an ACK bit;
   in this case <code>I2C_status_success</code> corresponds to 0,
   and <code>I2C_status_noack</code> corresponds to 1. In the
   <b><i>start_response</i></b> function of the <code>i2c_master</code>
   interface, the <code>i2c_status_t</code> parameter is additionally
   allowed to take the value <code>I2C_status_bus_busy</code>,
   meaning that the start failed since some other master is active
   using the i2c link. The value <code>I2C_status_bus_busy</code> is
   disallowed in all other function parameters in the
   <code>i2c_link</code>, <code>i2c_slave</code> and
   <code>i2c_master</code> interfaces.
</p><p>
   </p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<code>i2c_link_interface_t</code>,
   <code>i2c_master_interface_t</code>, <code>i2c_slave_interface_t</code>
   </dd>
</dl><p>
   </p><h3 class="jdocu"><a class="not-numbered" id="device-api-data-types.html:interrupt_source_t">interrupt_source_t</a></h3>
<p>
      
      
   <a id="device-api-data-types.html:interrupt_source_t2"></a>
</p><p>
      </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-data-types.html:__jdocu_seealso_interrupt_source_t"></a>interrupt_source_t</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">typedef enum {
        Interrupt_Source_Icr_Ipr,
        Interrupt_Source_Msi,
        Interrupt_Source_Virtual_Wire,
        Interrupt_Source_Nmi_Pin,
        Interrupt_Source_Lvt,
        Interrupt_Source_Iommu,
        Interrupt_Source_Int2,
        Interrupt_Source_Vmcs_Injection,
        Interrupt_Source_Legacy_Apic_Vector,
        Interrupt_Source_Self_Ipi,
        Interrupt_Source_Unknown,
} interrupt_source_t;</pre><p>
</p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Sources of interrupts.
         <ul>
            <li><code>Interrupt_Source_Icr_Ipr</code> means that the source is
            the Interrupt Control Register - Inter Processor Interrupt.</li>
            <li><code>Interrupt_Source_Msi</code> means that the source is an
            MSI.</li>
            <li><code>Interrupt_Source_Virtual_Wire</code> means that the
            source is the Virtual Wire.</li>
            <li><code>Interrupt_Source_Nmi_Pin</code> means that the source is
            the external NMI pin.</li>
            <li><code>Interrupt_Source_Lvt</code> means that the source is the
            local vector table (LVT).</li>
            <li><code>Interrupt_Source_Iommu</code> means that the source is
            the IOMMU.</li>
            <li><code>Interrupt_Source_Int2</code> means that the source is the
            INT2 instruction.</li>
            <li><code>Interrupt_Source_Vmcs_Injection</code> means that the
            source is an interrupt injected through the VMCS.</li>
            <li><code>Interrupt_Source_Legacy_Apic_Vector</code> means that the
            source is the legacy APIC interrupt vector.</li>
            <li><code>Interrupt_Source_Self_Ipi</code> means that the source is
            the SELF IPI Register.</li>
            <li><code>Interrupt_Source_Unknown</code> means that the source is
            unknown.</li>
         </ul>
         </dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<code>interrupt_subscriber_interface_t</code>
         </dd>
</dl><p>
   </p><h3 class="jdocu"><a class="not-numbered" id="device-api-data-types.html:mips_memory_transaction_t">mips_memory_transaction_t</a></h3>
<p>
   
   
   <a id="device-api-data-types.html:mips_memory_transaction_t2"></a>
   </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-data-types.html:__jdocu_seealso_mips_memory_transaction_t"></a>mips_memory_transaction_t</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<span class="jdocu_smaller">
   
   
<pre class="jdocu_small">typedef struct mips_memory_transaction {

        /* generic transaction */
        generic_transaction_t s;

        /* Cache coherency, values as the C field in EntryLo0 and EntryLo1. */
        unsigned int cache_coherency:3;
} mips_memory_transaction_t;</pre><p>

   
   </p></span></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This is the MIPS specific memory transaction data structure.
   The generic data is stored in the <i>s</i> field.
<p>
   The <i>cache_coherency</i> field specifies the cache coherency attribute
   of the memory transaction, as defined by the C field of the EntryLo0 and
   EntryLo1 coprocessor 0 registers.
</p><p>
   </p></dd>
</dl><p>
   </p><h3 class="jdocu"><a class="not-numbered" id="device-api-data-types.html:nios_memory_transaction_t">nios_memory_transaction_t</a></h3>
<p>
   
   </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-data-types.html:__jdocu_seealso_nios_memory_transaction_t"></a>nios_memory_transaction_t</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<span class="jdocu_smaller">
   
<pre class="jdocu_small">typedef struct nios_memory_transaction {
        /* generic transaction */
        generic_transaction_t s;
} nios_memory_transaction_t;</pre><p>

   
   </p></span></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The <i>s</i> field contains generic information about memory operations (see
   <code>generic_transaction_t</code>).
<p>
   </p></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="device-api-data-types.html:pci_memory_transaction_t">pci_memory_transaction_t</a></h3>
<p><a id="device-api-data-types.html:pci_memory_transaction_t2"></a>
   </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-data-types.html:__jdocu_seealso_pci_memory_transaction_t"></a>pci_memory_transaction_t</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">typedef struct pci_memory_transaction {
        generic_transaction_t INTERNAL_FIELD(s);
        uint32 INTERNAL_FIELD(original_size);

        int INTERNAL_FIELD(bus_address);

        int INTERNAL_FIELD(bus_number);
        int INTERNAL_FIELD(device_number);
        int INTERNAL_FIELD(function_number);

        uint32 INTERNAL_FIELD(tlp_prefix);
} pci_memory_transaction_t;</pre><p>

   </p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The <code>pci_memory_transaction_t</code> is used for memory accesses
   initiated by PCI devices.
<p>
   </p><div class="note">
<b>Note:</b>
All struct fields are internal and should never be used
   directly.</div>A <code>generic_transaction_t</code> can be converted to a
   <code>pci_memory_transaction_t</code> via the
   <b><i>SIM_pci_mem_trans_from_generic()</i></b> function. Never explicitly cast
   one struct to the other, always use the Simics API functions.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
     </a><b><i>SIM_pci_mem_trans_from_generic</i></b>,
     <code>generic_transaction_t</code>
   </dd>
</dl><p>
   </p><h3 class="jdocu"><a class="not-numbered" id="device-api-data-types.html:ppc_mem_instr_origin_t">ppc_mem_instr_origin_t</a></h3>
<p>
   
   
   <a id="device-api-data-types.html:ppc_mem_instr_origin_t2"></a>
   </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-data-types.html:__jdocu_seealso_ppc_mem_instr_origin_t"></a>ppc_mem_instr_origin_t</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<span class="jdocu_smaller">
   
<pre class="jdocu_small">typedef enum {
        /* Normal load or store instructions */
        Normal_Load_Store = 0,

        /* No data touched by the load/store will be placed in cache */
	Caching_Inhibited,

        Instr_Multiple,         /* load/store multiple */
        Instr_String,           /* load/store string */

        Instr_Altivec_Element,  /* Altivec load/store element */

        /* Data cache manipulations */
        Instr_dcbt,             /* data cache block touch */
        Instr_dcbst,            /* data cache block store */
        Instr_dcbtst,           /* data cache block touch for store */
        Instr_dcbi,             /* data cache block invalidate */
        Instr_dcbf,             /* data cache block flush */
        Instr_dcbfl,            /* data cache block flush local */
        Instr_dcba,             /* data cache block allocate */
        Instr_dcbz,             /* data cache block to zero */
        
        /* Instruction cache manipulations */
        Instr_icbi,             /* instruction cache block invalidate */
        
        /* Data stream (Altivec) manipulations */
        Instr_dst,              /* data stream touch */
        Instr_dstt,             /* data stream touch transient */
        Instr_dstst,            /* data stream touch for store */
        Instr_dststt,           /* data stream touch for store transient */

        /* e500 cache lock apu instructions */
        Instr_dcblc_l1,         /* data cache block lock clear (L1) */
        Instr_dcblc_l2,         /* data cache block lock clear (L2) */
        Instr_dcbtls_l1,        /* data cache block touch and lock set (L1)*/
        Instr_dcbtls_l2,        /* data cache block touch and lock set (L1)*/
        Instr_dcbtstls_l1,      /* data cache block touch for store and lock
                                   set (L1)*/
        Instr_dcbtstls_l2,      /* data cache block touch for store and lock
                                   set (L1)*/
        Instr_icblc_l1,         /* instruction cache block clear (L1) */
        Instr_icblc_l2,         /* instruction cache block clear (L2) */
        Instr_icbtls_l1,        /* instruction cache block touch and lock
                                   set (L1) */
        Instr_icbtls_l2,        /* instruction cache block touch and lock
                                   set (L1) */

        /* Other loads/stores or cache affecting instructions */
        Instr_lwarx,
        Instr_stwcx,
        Instr_ldarx,
        Instr_stdcx,
        Instr_lq,
        Instr_stq,

        /* Other cache affecting instructions */
        Instr_sync,
        Instr_eieio,
        Instr_ecowx,
        Instr_eciwx,
        Instr_tlbie,
        Instr_tlbsync,
        Instr_isync,

        Instr_lfdp,             /* Load Floating point Double Pair */
        Instr_stfdp,            /* Store Floating point Double Pair */

        Instr_spe,

        Instr_dcbal,            /* Obsolete - use Instr_dcba. */

        /* e500 cache lock apu instructions, platform cache versions */
        Instr_dcblc_pc,         /* data cache block lock clear */
        Instr_dcbtls_pc,        /* data cache block touch and lock set*/
        Instr_dcbtstls_pc,      /* data cache block touch for store and lock
                                   set */
        Instr_icblc_pc,         /* instruction cache block clear */
        Instr_icbtls_pc,        /* instruction cache block touch and lock
                                   set */
        Instr_Fpu               /* Load/store from FPU unit */
} ppc_mem_instr_origin_t;</pre><p>

   
   </p></span></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
List of special memory operations that can be send by a PPC processor.
   </dd>
</dl><p>
   </p><h3 class="jdocu"><a class="not-numbered" id="device-api-data-types.html:ppc_memory_transaction_t">ppc_memory_transaction_t</a></h3>
<p>
   
   
   <a id="device-api-data-types.html:ppc_memory_transaction_t2"></a>
   </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-data-types.html:__jdocu_seealso_ppc_memory_transaction_t"></a>ppc_memory_transaction_t</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<span class="jdocu_smaller">
   
   
<pre class="jdocu_small">typedef struct ppc_memory_transaction {

        /* generic transaction */
        generic_transaction_t s;

        processor_mode_t mode;
        ppc_mem_instr_origin_t instr_origin;
        logical_address_t ea_origin;
	uint8 wimg;
        uint8 alignment;

        /* cache operations may flag this to cause prefetches to be no-ops */
        uint8 inhibit_exception;

        /* External PID */
        uint8 external_pid;

        /* Decorated storage */
        ppc_decoration_t decoration;
} ppc_memory_transaction_t;</pre><p>

   
   </p></span></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This is the PPC specific memory transaction data structure.
   The generic data is stored in the <i>s</i> field.
<p>
   The current processor mode when generating this transaction is stored in the
   <i>mode</i> field.
</p><p>
   The type of instruction generating the memory transactions is provided by
   the <i>instr_origin</i> field. Note that it is mainly provided for
   special memory accesses like cache block operations..
</p><p>
   The <i>wimg</i> field is filled in by the MMU with the corresponding
   WIMG bits during the translation.
</p><p>
   The <i>alignment</i> field contains the size on which the transaction is
   required to be aligned.
</p><p>
   The <i>inhibit_exception</i> field is set for operations that should be
   ignored if triggering an exception.
</p><p>
   The <i>external_pid</i> field is only used internally for some Book-E
   cores. It is undefined for cores which do not have this feature.
</p><p>
   <i>decoration</i> contains decoration data.
   
</p><pre class="jdocu_small">typedef struct {
        ppc_decoration_type_t type;
        uint64 data;
} ppc_decoration_t;</pre><p>

</p><p>
   The <i>type</i> field specifies whether the transaction is decorated or
   not, and if it is, the decoration type. It will be one of:
</p><p>
   
</p><pre class="jdocu_small">typedef enum {
        Decoration_None,
        Decoration_Notify,
        Decoration_Load,
        Decoration_Store
} ppc_decoration_type_t;</pre><p>

</p><p>
   The <i>data</i> field holds the decoration data supplied by the
   instruction. It is only valid if <i>type</i> is not
   <code>Decoration_None</code>.
</p><p>
   Note that not all processors implement decorated storage.
</p><p>
   </p></dd>
</dl><p>
   </p><h3 class="jdocu"><a class="not-numbered" id="device-api-data-types.html:riscv_cpu_mode_t">riscv_cpu_mode_t</a></h3>
<p>
   
   
     <a id="device-api-data-types.html:riscv_cpu_mode_t2"></a>
     </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-data-types.html:__jdocu_seealso_riscv_cpu_mode_t"></a>riscv_cpu_mode_t</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<span class="jdocu_smaller">
         
<pre class="jdocu_small">typedef enum {
        Riscv_Mode_User            = 0x0,
        Riscv_Mode_Supervisor      = 0x1,
        Riscv_Mode_Reserved        = 0x2,
        Riscv_Mode_Machine         = 0x3,

        Riscv_Mode_Guest_User       = 0x10,
        Riscv_Mode_Guest_Supervisor = 0x11
} riscv_cpu_mode_t;</pre><p>

         
       </p></span></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
List of privilege levels of the RISC-V core.
       </dd>
</dl><p>
   </p><h3 class="jdocu"><a class="not-numbered" id="device-api-data-types.html:serial_peripheral_interface_flags_t">serial_peripheral_interface_flags_t</a></h3>
<p>
   
   
   <a id="device-api-data-types.html:serial_peripheral_interface_flags_t2"></a>
   </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-data-types.html:__jdocu_seealso_serial_peripheral_interface_flags_t"></a>serial_peripheral_interface_flags_t</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">typedef enum serial_peripheral_interface_flags {
        SPI_Flags_CPHA = 0x1,
        SPI_Flags_CPOL = 0x2
} serial_peripheral_interface_flags_t;</pre><p>

   </p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The <code>serial_peripheral_interface_flags_t</code> type is used
   to describe some properties of an SPI connection.  The type is a
   bitfield, currently defining two values, CPOL and CPHA.  If a
   master device connects to a slave using a CPOL/CPHA combination
   incompatible with the slave device, then the results of any SPI
   transfer are undefined.
<p>
   The <code>SPI_Flags_CPOL</code> bit defines the <em>polarity</em> of
   the clock pin (SCK): A value of zero means that the pin is low when
   the bus is idle, while a value of one means that the pin is high
   when the bus is idle.
</p><p>
   The <code>SPI_Flags_CPHA</code> bit defines the <em>phase</em> of the
   clock pin. If the CPHA and CPOL bits are equal, data bits are read
   on the falling edge of the SCK pin and changed on the rising edge
   of the pin; if the bits are not equal, data bits are read on the
   rising edge and changed on the falling edge of the SCK pin.
</p><p>
   </p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
     </a><code>serial_peripheral_interface_slave_interface_t</code>
   </dd>
</dl><p>
   </p><h3 class="jdocu"><a class="not-numbered" id="device-api-data-types.html:usb_transfer_t">usb_transfer_t</a></h3>
<p>
   
    
   <a id="device-api-data-types.html:usb_transfer_t2"></a>
   </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-data-types.html:__jdocu_seealso_usb_transfer_t"></a>usb_transfer_t</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">typedef enum {
        USB_Transfer_Completed,
        USB_Transfer_Not_Ready
} usb_transfer_completion_t;

typedef enum {
        USB_Direction_None,
        USB_Direction_In,
        USB_Direction_Out
} usb_direction_t;

typedef enum {
        USB_Status_Undef,
        USB_Status_Ack,
        USB_Status_Nak,
        USB_Status_Stall
} usb_status_t;

typedef enum {
        USB_Type_Control,
        USB_Type_Interrupt,
        USB_Type_Isochronous,
        USB_Type_Bulk
} usb_type_t;

typedef enum {
        USB_Speed_Low,
        USB_Speed_Full,
        USB_Speed_High
} usb_speed_t;

typedef struct {
        uint8  bmRequestType;
        uint8  bRequest;
        uint16 wValue;
        uint16 wIndex;
        uint16 wLength;
} usb_device_request_t;

typedef struct {
        /* Endpoint/function specific information */
        uint8                 function_address;
        uint8                 endpoint_number;
        /* Type specific information */
        usb_type_t            type;
#ifndef PYWRAP
        union {
                usb_device_request_t   control_request;
                nano_secs_t            periodic_time;
        } u;
#endif /* PYWRAP */
        /* Data specific */
        usb_direction_t       direction;
        int                   size;
        dbuffer_t             *buf;
        /* Status */
        usb_status_t          status;
} usb_transfer_t;

</pre><p>
</p><p>
   </p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
All USB related data types are Simics internal, and should not be
   used by user-defined classes.  The data types may change in future
   versions of Simics.
<p>
   The <code>usb_transfer_t</code> type is independent of USB host and
   USB device implementations and is used for sending data over USB.
</p><p>
   There are two fields to identify the pipe: <i>function_address</i> is
   the function/device address for the target USB device;
   <i>endpoint_number</i> specifies the endpoint number.
</p><p>
   The type of transfer is defined using the <i>type</i> field. The type is
   either control, bulk, interrupt, or isochronous. The
   <i>u.control_request</i> field is only valid for control transfers. It
   contains the information that would be in the setup packet of a control
   transfer. The <i>u.periodic_time</i> field is only valid for periodic
   transfers, i.e., interrupt and isochronous transfers. It specifies the
   minimum response time for a transfer expected by the USB host. A USB device
   do not need to fulfill the expectation. It is merely a way to tell the USB
   device how to keep the timing specified in the periodic list scheduling.
</p><p>
   The <i>usb_direction</i> field specifies the direction of the data in
   the USB transfer. Only the actual data packet is used to specify the
   direction, even if a real transfer consists of a mix of SETUP/OUT/IN/STATUS
   packets. <code>USB_Direction_None</code> means that the transfer does not
   contain any data, for example, in <code>Set_Address</code> control
   transfers. <i>size</i> is the number of bytes the USB host can
   receive for IN transfers and the number of bytes sent for OUT
   transfers. <i>buf</i> contains the IN or OUT data. Note that <i>buf</i>
   can contain data for several data packets concatenated together. The
   endpoint descriptors in USB host and USB device define the maximum packet
   size for the pipe, but there is no limitation in Simics.
</p><p>
   The <i>status</i> field contains the status for the transfer. The status
   is typically only set by the USB device. The USB host does not set the
   status field when it has completed an IN transfer.
</p><p>
   
   </p></dd>
</dl><p>
   </p><h3 class="jdocu"><a class="not-numbered" id="device-api-data-types.html:x86_memory_transaction_t">x86_memory_transaction_t</a></h3>
<p>
   
   
   <a id="device-api-data-types.html:x86_memory_transaction_t2"></a>
   
   </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-data-types.html:__jdocu_seealso_x86_memory_transaction_t"></a>x86_memory_transaction_t</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<span class="jdocu_smaller">
   
   <pre class="jdocu_small">typedef struct x86_memory_transaction {
        generic_transaction_t s;                /* Superclass */
        linear_address_t      linear_address;   
        physical_address_t    guest_physical_address;
        uint16                segnum;           /* segment number */
        uint16                access_linear:1;  /* Linear access */
        uint16                io:1;             /* I/O (port) access */
        uint16                fault_as_if_write:1;
        uint16                guest_phys_valid:1;
        processor_mode_t      mode;
        x86_access_type_t     access_type;
        x86_memory_type_t     pat_type;
        x86_memory_type_t     mtrr_type;
        x86_memory_type_t     effective_type;
        int                   sequence_number; /* used for -stall */
} x86_memory_transaction_t;
</pre><p>
</p><p>
   
   
   </p></span></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The <i>s</i> field contains generic information about memory
   operations (see <code>generic_transaction_t</code>).
   <p>
   The <i>mode</i> is the current mode (user or supervisor) of the cpu.
</p><p>
   The <i>linear_address</i> contains the address for transactions
   with linear addresses.
</p><p>
   The <i>access_linear</i> flag is set for all transactions with
   linear addresses.
</p><p>
   The <i>io</i> flag is set on port accesses (from IN and OUT instructions).
   It is cleared for regular memory accesses, and also for memory mapped I/O.
</p><p>
   The <i>fault_as_if_write</i> flag indicates that an access should set
   the page fault access bits as a write even if the access is a read.
</p><p>
   The <i>access_type</i> field contains the type of the transaction.
   <a id="device-api-data-types.html:x86_access_type_t"></a>
   <span class="jdocu_smaller">
   
   See online help for expanded output of this type:
   api-help x86_access_type_t
   
</span></p><pre class="jdocu_small">typedef enum x86_access_type {
        FOR_X86_ACCESS_TYPES(X86_ACCESS_TYPE_ENUM)
} x86_access_type_t;</pre><p>

   
</p><p>
   The effective memory type for the access is contained in
   <i>effective_type</i>. The MMU calculates the effective memory type and uses
   the <i>pat_type</i> and <i>mtrr_type</i> members as temporary storage and
   input to that calculation. The <i>pat_type</i> and <i>mtrr_type</i> members
   should not be used by code outside of the MMU.
</p><p>
   <a id="device-api-data-types.html:x86_memory_type_t"></a>
   <span class="jdocu_smaller">
    
</span></p><pre class="jdocu_small">typedef enum {
        X86_None,
        X86_Strong_Uncacheable,    /* UC */
        X86_Uncacheable,           /* UC- */
        X86_Write_Combining,       /* WC */
        X86_Write_Through,         /* WT */
        X86_Write_Back,            /* WB */
        X86_Write_Protected        /* WP */
} x86_memory_type_t;</pre><p>

   
   </p></dd>
</dl><p>
   </p><h3 class="jdocu"><a class="not-numbered" id="device-api-data-types.html:x86_sync_instruction_type_t">x86_sync_instruction_type_t</a></h3>
<p>
   
   
   <a id="device-api-data-types.html:x86_sync_instruction_type_t2"></a>
   </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-data-types.html:__jdocu_seealso_x86_sync_instruction_type_t"></a>x86_sync_instruction_type_t</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<span class="jdocu_smaller">
   
<pre class="jdocu_small">typedef enum {
        X86_SFence = 1,
        X86_LFence = 2,
        X86_MFence = 3
} x86_sync_instruction_type_t;</pre><p>

   
   </p></span></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Type of synchronisation instruction for x86.
     Used in the <code>Core_Sync_Instruction</code> hap.
   </dd>
</dl><p>
   </p><h3 class="jdocu"><a class="not-numbered" id="device-api-data-types.html:xtensa_memory_transaction_t">xtensa_memory_transaction_t</a></h3>
<p>
   
   </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-data-types.html:__jdocu_seealso_xtensa_memory_transaction_t"></a>xtensa_memory_transaction_t</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<span class="jdocu_smaller">
   
<pre class="jdocu_small">typedef struct xtensa_memory_transaction {
        /* generic transaction */
        generic_transaction_t s;
} xtensa_memory_transaction_t;</pre><p>

   
   </p></span></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The <i>s</i> field contains generic information about memory operations (see
   <code>generic_transaction_t</code>).
<p>
   </p></dd>
</dl><p>

    
    </p><h2 class="jdocu"><a id="device-api-data-types.html:Internal-Data-Types">3.2.3 Internal Data Types</a></h2>
<p></p><h3 class="jdocu"><a class="not-numbered" id="device-api-data-types.html:Collection-of-Internal-Data-Types">Collection of Internal Data Types</a></h3>
<p>

</p><p>
   </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-data-types.html:__jdocu_seealso_4"></a><a id="device-api-data-types.html:addr_type_t">addr_type_t</a>,
   <a id="device-api-data-types.html:byte_string_t">byte_string_t</a>,
   struct ether_addr<a id="device-api-data-types.html:structether_addr"></a><a id="device-api-data-types.html:ether_addrstruct"></a>,
   <a id="device-api-data-types.html:event_queue_type_t">event_queue_type_t</a>,
   <a id="device-api-data-types.html:icode_mode_t">icode_mode_t</a>,
   <a id="device-api-data-types.html:image_spage_t">image_spage_t</a>,
   <a id="device-api-data-types.html:instruction_trace_callback_t">instruction_trace_callback_t</a>,
   <a id="device-api-data-types.html:intervals_func_t">intervals_func_t</a>,
   <a id="device-api-data-types.html:interval_set_t">interval_set_t</a>,
   <a id="device-api-data-types.html:interval_set_iter_t">interval_set_iter_t</a>,
   <a id="device-api-data-types.html:os_time_t">os_time_t</a>,
   struct os_tm<a id="device-api-data-types.html:structos_tm"></a><a id="device-api-data-types.html:os_tmstruct"></a>,
   <a id="device-api-data-types.html:page_info_t">page_info_t</a>,
   <a id="device-api-data-types.html:prof_data_t">prof_data_t</a>,
   <a id="device-api-data-types.html:prof_data_address_t">prof_data_address_t</a>,
   <a id="device-api-data-types.html:prof_data_counter_t">prof_data_counter_t</a>,
   <a id="device-api-data-types.html:prof_data_iter_t">prof_data_iter_t</a>,
   <a id="device-api-data-types.html:rand_state_t">rand_state_t</a>,
   <a id="device-api-data-types.html:range_node_t">range_node_t</a>,
   <a id="device-api-data-types.html:sim_ic_type_t">sim_ic_type_t</a>,
   <a id="device-api-data-types.html:simics_internal_counters_t">simics_internal_counters_t</a>,
   <a id="device-api-data-types.html:socket_t">socket_t</a>,
   <a id="device-api-data-types.html:state_save_kind_t">state_save_kind_t</a>,
   <a id="device-api-data-types.html:strbuf_t">strbuf_t</a>,
   struct simcontext<a id="device-api-data-types.html:structsimcontext"></a><a id="device-api-data-types.html:simcontextstruct"></a>,
   <a id="device-api-data-types.html:vtmem_inform_opcode_t">vtmem_inform_opcode_t</a>
   </dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
These data types are exported for Simics internal use.
   </dd>
</dl><p>
    
</p></section><section class="page" id="device-api-functions.html"><h1 class="jdocu"><a id="device-api-functions.html:Device-API-Functions">3.3 Device API Functions</a></h1>
<p>

    </p><h2 class="jdocu"><a class="not-numbered" id="device-api-functions.html:Attribute-Values">Attribute Values</a></h2>
<p></p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_alloc_attr_dict">SIM_alloc_attr_dict()</a></h3>
<p>

<a id="device-api-functions.html:SIM_alloc_attr_dict2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_alloc_attr_dict"></a><b>SIM_alloc_attr_dict</b>  create empty attribute dictionary</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">attr_value_t
SIM_alloc_attr_dict(unsigned length);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns an <code>attr_value_t</code> of type
  dict with size <i>len</i>. The dictionary
  elements are initialized to invalid values.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
All contexts (including Threaded Context)
   </dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
   </a><b><i>SIM_attr_dict_set_item</i></b>, <b><i>SIM_alloc_attr_list</i></b>
   </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_alloc_attr_list">SIM_alloc_attr_list()</a></h3>
<p>

<a id="device-api-functions.html:SIM_alloc_attr_list2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_alloc_attr_list"></a><b>SIM_alloc_attr_list</b>  create uninitialized attribute list</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">attr_value_t
SIM_alloc_attr_list(unsigned length);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns an <code>attr_value_t</code> of type
  list with size <i>length</i>. The list
  elements are initialized to invalid values.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
All contexts (including Threaded Context)
   </dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
   </a><b><i>SIM_make_attr_list</i></b>, <b><i>SIM_attr_list_set_item</i></b>
   </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_attr_copy">SIM_attr_copy()</a></h3>
<p>

<a id="device-api-functions.html:SIM_attr_copy2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_attr_copy"></a><b>SIM_attr_copy</b>  copy attribute value</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">attr_value_t
SIM_attr_copy(attr_value_t val);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Return a deep copy of <i>val</i>. The caller obtains ownership
   of the copy and needs to free it after use; the argument is not modified.
<p>
   This function is not available from Python.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
All contexts (including Threaded Context)
   </dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<b><i>SIM_attr_free</i></b></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_attr_dict_resize">SIM_attr_dict_resize()</a></h3>
<p>

<a id="device-api-functions.html:SIM_attr_dict_resize2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_attr_dict_resize"></a><b>SIM_attr_dict_resize</b>  resize dict attribute value</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_attr_dict_resize(attr_value_t *NOTNULL attr, unsigned newsize);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Resize <i>attr</i>, which must be of dict type, to
   <i>newsize</i> elements. New elements are marked invalid.
   Dropped elements are freed.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_attr_dict_set_item">SIM_attr_dict_set_item()</a></h3>
<p>

<a id="device-api-functions.html:SIM_attr_dict_set_item2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_attr_dict_set_item"></a><b>SIM_attr_dict_set_item</b>  set dict attribute element</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_attr_dict_set_item(attr_value_t *NOTNULL attr, unsigned index,
                       attr_value_t key, attr_value_t value);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Set the element numbered <i>index</i> of the dict
   <i>attr</i> to <i>key</i> and <i>value</i>. The
   previous key and value at that position are freed. The ownership for
   <i>key</i> and <i>value</i> is transferred from the caller to
   <i>attr</i>. The <i>key</i> must be of integer, string or
   object type.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_attr_free">SIM_attr_free()</a></h3>
<p>

<a id="device-api-functions.html:SIM_attr_free2"></a><a id="device-api-functions.html:SIM_free_attribute"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_attr_free"></a><b>SIM_attr_free</b><b>, SIM_free_attribute</b>  free attribute</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_attr_free(attr_value_t *NOTNULL value);
</pre><p></p><pre class="jdocu_small">void
SIM_free_attribute(attr_value_t value);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Free the memory allocation used by the value pointed to by
   <i>value</i>. For values of list or dict type, this recursively
   frees all contents; for string or data values, the allocation containing the
   payload is freed. It is an error to use the value or any sub-part of it
   after it has been freed.
<p>
   <b><i>SIM_attr_free</i></b> is the preferred call because it changes the type
   of the argument variable to Invalid, preventing accidental use after
   freeing. <b><i>SIM_free_attribute</i></b> only differs in how the argument is
   passed, but cannot change the argument variable as it is passed by value.
</p><p>
   </p><div class="note">
<b>Note:</b>
These functions are not available in Python; memory
   allocation is managed automatically there.</div></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
All contexts (including Threaded Context)
   </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_attr_integer">SIM_attr_integer()</a></h3>
<p>

<a id="device-api-functions.html:SIM_attr_integer2"></a><a id="device-api-functions.html:SIM_attr_boolean"></a><a id="device-api-functions.html:SIM_attr_string"></a><a id="device-api-functions.html:SIM_attr_string_detach"></a><a id="device-api-functions.html:SIM_attr_floating"></a><a id="device-api-functions.html:SIM_attr_object"></a><a id="device-api-functions.html:SIM_attr_object_or_nil"></a><a id="device-api-functions.html:SIM_attr_data_size"></a><a id="device-api-functions.html:SIM_attr_data"></a><a id="device-api-functions.html:SIM_attr_list_size"></a><a id="device-api-functions.html:SIM_attr_list_item"></a><a id="device-api-functions.html:SIM_attr_list"></a><a id="device-api-functions.html:SIM_attr_dict_size"></a><a id="device-api-functions.html:SIM_attr_dict_key"></a><a id="device-api-functions.html:SIM_attr_dict_value"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_attr_integer"></a><b>SIM_attr_integer</b><b>, SIM_attr_boolean</b><b>, SIM_attr_string</b><b>, SIM_attr_string_detach</b><b>, SIM_attr_floating</b><b>, SIM_attr_object</b><b>, SIM_attr_object_or_nil</b><b>, SIM_attr_data_size</b><b>, SIM_attr_data</b><b>, SIM_attr_list_size</b><b>, SIM_attr_list_item</b><b>, SIM_attr_list</b><b>, SIM_attr_dict_size</b><b>, SIM_attr_dict_key</b><b>, SIM_attr_dict_value</b>  extract values stored in <code>attr_value_t</code> values</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE int64
SIM_attr_integer(attr_value_t attr);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE bool
SIM_attr_boolean(attr_value_t attr);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE const char *
SIM_attr_string(attr_value_t attr);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE char *
SIM_attr_string_detach(attr_value_t *attr);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE double
SIM_attr_floating(attr_value_t attr);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE conf_object_t *
SIM_attr_object(attr_value_t attr);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE conf_object_t *
SIM_attr_object_or_nil(attr_value_t attr);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE unsigned
SIM_attr_data_size(attr_value_t attr);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE const uint8 *
SIM_attr_data(attr_value_t attr);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE unsigned
SIM_attr_list_size(attr_value_t attr);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE attr_value_t
SIM_attr_list_item(attr_value_t attr, unsigned index);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE attr_value_t *
SIM_attr_list(attr_value_t attr);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE unsigned
SIM_attr_dict_size(attr_value_t attr);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE attr_value_t
SIM_attr_dict_key(attr_value_t attr, unsigned index);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE attr_value_t
SIM_attr_dict_value(attr_value_t attr, unsigned index);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Extract a value encapsulated in <i>attr</i>. It is an error to
     call an accessor function with an <i>attr</i> of the wrong type.
<p>
     <b><i>SIM_attr_integer</i></b> returns the integer attribute value
     modulo-reduced to the interval
     [2<sup>63</sup>,2<sup>63</sup>1].
     (Converting the return value to <code>uint64</code> gives the integer
     attribute value modulo-reduced to [0,2<sup>64</sup>1].)
</p><p>
     <b><i>SIM_attr_string</i></b>, <b><i>SIM_attr_data</i></b> and
     <b><i>SIM_attr_list</i></b> return values owned by <i>attr</i>. 
     Ownership is not transferred to the caller.
     </p><p>
     <b><i>SIM_attr_string_detach</i></b> returns the string
     in <i>attr</i> and changes the value pointed to by
     <i>attr</i> into a nil attribute. Ownership of the string is
     transferred to the caller.
     </p><p>
     <b><i>SIM_attr_object_or_nil</i></b> accepts an <i>attr</i> parameter
     of either object or nil type. In case of a nil attribute, the function
     returns NULL.
     </p><p>
     <b><i>SIM_attr_list_size</i></b> and <b><i>SIM_attr_dict_size</i></b> return
     the number of items in the list and key-value pairs in the dict
     respectively. <b><i>SIM_attr_data_size</i></b> returns the number of bytes
     in the data value.
     </p><p>
     <b><i>SIM_attr_list_item</i></b> returns the item at <i>index</i>.
     The index must be less than the number of items in the list. The item
     returned is still owned by <i>attr</i>. Ownership is not
     transferred to the caller.
     </p><p>
     <b><i>SIM_attr_list</i></b> returns a pointer directly into the internal
     array of the attribute value; it is mainly present as an optimisation. Use
     <b><i>SIM_attr_list_item</i></b> and <b><i>SIM_attr_list_set_item</i></b>
     for type-safety instead.
     </p><p>
     <b><i>SIM_attr_dict_key</i></b> and <b><i>SIM_attr_dict_value</i></b> return
     the key and value at <i>index</i>. The index must be less than the
     number of items in the dict. The value returned is still owned by
     <i>attr</i>. Ownership is not transferred to the caller.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
All contexts (including Threaded Context)
     </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_attr_is_integer">SIM_attr_is_integer()</a></h3>
<p>

<a id="device-api-functions.html:SIM_attr_is_integer2"></a><a id="device-api-functions.html:SIM_attr_is_boolean"></a><a id="device-api-functions.html:SIM_attr_is_string"></a><a id="device-api-functions.html:SIM_attr_is_floating"></a><a id="device-api-functions.html:SIM_attr_is_object"></a><a id="device-api-functions.html:SIM_attr_is_invalid"></a><a id="device-api-functions.html:SIM_attr_is_data"></a><a id="device-api-functions.html:SIM_attr_is_list"></a><a id="device-api-functions.html:SIM_attr_is_dict"></a><a id="device-api-functions.html:SIM_attr_is_nil"></a><a id="device-api-functions.html:SIM_attr_is_int64"></a><a id="device-api-functions.html:SIM_attr_is_uint64"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_attr_is_integer"></a><b>SIM_attr_is_integer</b><b>, SIM_attr_is_boolean</b><b>, SIM_attr_is_string</b><b>, SIM_attr_is_floating</b><b>, SIM_attr_is_object</b><b>, SIM_attr_is_invalid</b><b>, SIM_attr_is_data</b><b>, SIM_attr_is_list</b><b>, SIM_attr_is_dict</b><b>, SIM_attr_is_nil</b><b>, SIM_attr_is_int64</b><b>, SIM_attr_is_uint64</b>  <code>attr_value_t</code> type predicates</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE bool
SIM_attr_is_integer(attr_value_t attr);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE bool
SIM_attr_is_boolean(attr_value_t attr);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE bool
SIM_attr_is_string(attr_value_t attr);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE bool
SIM_attr_is_floating(attr_value_t attr);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE bool
SIM_attr_is_object(attr_value_t attr);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE bool
SIM_attr_is_invalid(attr_value_t attr);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE bool
SIM_attr_is_data(attr_value_t attr);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE bool
SIM_attr_is_list(attr_value_t attr);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE bool
SIM_attr_is_dict(attr_value_t attr);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE bool
SIM_attr_is_nil(attr_value_t attr);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE bool
SIM_attr_is_int64(attr_value_t attr);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE bool
SIM_attr_is_uint64(attr_value_t attr);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Indicates whether the value stored in <i>attr</i> is of the specified
     type. <b><i>SIM_attr_is_int64</i></b> and <b><i>SIM_attr_is_uint64</i></b> 
     additionally test whether the integer value would fit in the given C type.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_attr_list_resize">SIM_attr_list_resize()</a></h3>
<p>

<a id="device-api-functions.html:SIM_attr_list_resize2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_attr_list_resize"></a><b>SIM_attr_list_resize</b>  resize list attribute value</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_attr_list_resize(attr_value_t *NOTNULL attr, unsigned newsize);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Resize <i>attr</i>, which must be of list type,
   to <i>newsize</i> elements.
   New elements are set to invalid value.
   Dropped elements are freed.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_attr_list_set_item">SIM_attr_list_set_item()</a></h3>
<p>

<a id="device-api-functions.html:SIM_attr_list_set_item2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_attr_list_set_item"></a><b>SIM_attr_list_set_item</b>  set list attribute element</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_attr_list_set_item(attr_value_t *NOTNULL attr, unsigned index,
                       attr_value_t elem);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Set the element numbered <i>index</i> of the list
   <i>attr</i> to <i>elem</i>. The previous value at
   that position is freed. The ownership for <i>elem</i> is transferred
   from the caller to <i>attr</i>.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_attr_scanf">SIM_attr_scanf()</a></h3>
<p>

<a id="device-api-functions.html:SIM_attr_scanf2"></a><a id="device-api-functions.html:SIM_ascanf"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_attr_scanf"></a><b>SIM_attr_scanf</b><b>, SIM_ascanf</b>  parse list attribute values</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">bool
SIM_attr_scanf(attr_value_t *NOTNULL list, const char *NOTNULL fmt, ...);
</pre><p></p><pre class="jdocu_small">bool
SIM_ascanf(attr_value_t *NOTNULL list,
           const char *NOTNULL fmt, ...) __attribute__((alias("SIM_attr_scanf")));
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Reads and converts entries in <i>list</i> according to the format
   string <i>fmt</i>. Returns <code>true</code> if all elements were
   successfully converted, <code>false</code> otherwise.
<p>
   The characters in the format string mean:
</p><p>
   <span class="jdocu_smaller">
   <table>

    <tbody><tr>
     <td class="jdocu_border"><b>format char</b></td>
     <td class="jdocu_border"><b>argument type</b></td>
     <td class="jdocu_border"><b>element must be</b></td>
    </tr>

    <tr>
     <td class="jdocu_border"><code>i</code></td>
     <td class="jdocu_border"><code>int64 *</code></td>
     <td class="jdocu_border">integer</td>
    </tr>

    <tr>
     <td class="jdocu_border"><code>b</code></td>
     <td class="jdocu_border"><code>int *</code></td>
     <td class="jdocu_border">boolean</td>
    </tr>

    <tr>
     <td class="jdocu_border"><code>f</code></td>
     <td class="jdocu_border"><code>double *</code></td>
     <td class="jdocu_border">floating</td>
    </tr>

    <tr>
     <td class="jdocu_border"><code>s</code></td>
     <td class="jdocu_border"><code>const char **</code></td>
     <td class="jdocu_border">string</td>
    </tr>

    <tr>
     <td class="jdocu_border"><code>S</code></td>
     <td class="jdocu_border"><code>const char **</code></td>
     <td class="jdocu_border">string or nil</td>
    </tr>

    <tr>
     <td class="jdocu_border"><code>o</code></td>
     <td class="jdocu_border"><code>conf_object_t **</code></td>
     <td class="jdocu_border">object</td>
    </tr>

    <tr>
     <td class="jdocu_border"><code>O</code></td>
     <td class="jdocu_border"><code>conf_object_t **</code></td>
     <td class="jdocu_border">object or nil</td>
    </tr>

    <tr>
     <td class="jdocu_border"><code>l</code></td>
     <td class="jdocu_border"><code>attr_value_t **</code></td>
     <td class="jdocu_border">list</td>
    </tr>

    <tr>
     <td class="jdocu_border"><code>d</code></td>
     <td class="jdocu_border"><code>attr_value_t **</code></td>
     <td class="jdocu_border">data</td>
    </tr>

    <tr>
     <td class="jdocu_border"><code>a</code></td>
     <td class="jdocu_border"><code>attr_value_t **</code></td>
     <td class="jdocu_border">any except invalid</td>
    </tr>

   </tbody></table>
   </span>
</p><p>
   The <i>fmt</i> string may also include a period (<code>.</code>) at the end,
   taken to mean that more elements may follow. If the period is not present,
   the length of the list must equal the number of specified elements.
</p><p>
   Converted values of type <code>attr_value_t *</code> and
   <code>const char *</code> are still owned by <i>list</i>.
</p><p>
   <b><i>SIM_ascanf</i></b> is an alias of <b><i>SIM_attr_scanf</i></b>
   and will be deprecated.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
All contexts (including Threaded Context)
   </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_make_attr_boolean">SIM_make_attr_boolean()</a></h3>
<p>

<a id="device-api-functions.html:SIM_make_attr_boolean2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_make_attr_boolean"></a><b>SIM_make_attr_boolean</b>  make boolean attribute</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE attr_value_t
SIM_make_attr_boolean(bool b);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns an <code>attr_value_t</code> of boolean type.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_make_attr_data">SIM_make_attr_data()</a></h3>
<p>

<a id="device-api-functions.html:SIM_make_attr_data2"></a><a id="device-api-functions.html:SIM_make_attr_data_adopt"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_make_attr_data"></a><b>SIM_make_attr_data</b><b>, SIM_make_attr_data_adopt</b>  create raw data attribute</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">attr_value_t
SIM_make_attr_data(size_t size, const void *data);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE attr_value_t
SIM_make_attr_data_adopt(size_t size, void *data);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns an <code>attr_value_t</code> of type data using
     <i>size</i> and <i>data</i> for the binary data.
     The maximum size of the binary data is 2**32-1 bytes, i.e.
     <i>size</i> should fit into a 32-bit unsigned integer.
<p>
     <b><i>SIM_make_attr_data</i></b> will make a copy of the argument data.
</p><p>
     <b><i>SIM_make_attr_data_adopt</i></b> is mainly provided for compatibility;
     it will assume ownership of the argument data, which must have been
     allocated using one of the <b><i>MM_MALLOC</i></b> functions.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
All contexts (including Threaded Context)
     </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_make_attr_floating">SIM_make_attr_floating()</a></h3>
<p>

<a id="device-api-functions.html:SIM_make_attr_floating2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_make_attr_floating"></a><b>SIM_make_attr_floating</b>  make floating point attribute</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE attr_value_t 
SIM_make_attr_floating(double d);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns an <code>attr_value_t</code> of floating type with value
     <i>d</i>.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_make_attr_int64">SIM_make_attr_int64()</a></h3>
<p>

<a id="device-api-functions.html:SIM_make_attr_int642"></a><a id="device-api-functions.html:SIM_make_attr_uint64"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_make_attr_int64"></a><b>SIM_make_attr_int64</b><b>, SIM_make_attr_uint64</b>  make integer attribute</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE attr_value_t
SIM_make_attr_int64(int64 i);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE attr_value_t
SIM_make_attr_uint64(uint64 i);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns an <code>attr_value_t</code> of integer type with value
     <i>i</i>.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_make_attr_invalid">SIM_make_attr_invalid()</a></h3>
<p>

<a id="device-api-functions.html:SIM_make_attr_invalid2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_make_attr_invalid"></a><b>SIM_make_attr_invalid</b>  make invalid attribute</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE attr_value_t
SIM_make_attr_invalid(void);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns an <code>attr_value_t</code> of invalid type.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_make_attr_list">SIM_make_attr_list()</a></h3>
<p>

<a id="device-api-functions.html:SIM_make_attr_list2"></a><a id="device-api-functions.html:SIM_make_attr_list_vararg"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_make_attr_list"></a><b>SIM_make_attr_list</b><b>, SIM_make_attr_list_vararg</b>  make list attribute</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">attr_value_t
SIM_make_attr_list(unsigned length, ...);
</pre><p></p><pre class="jdocu_small">attr_value_t
SIM_make_attr_list_vararg(unsigned length, va_list va);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns an <code>attr_value_t</code> of type list
   with size <i>length</i>. The list is filled with data from the
   arguments following, which should be of type <code>attr_value_t</code>.
<p>
   This function must be called with exactly <i>length</i>+1 arguments.
   The attribute parameters should all be valid attributes; e.g.,
   attributes of invalid type are not allowed.
   The <i>length</i> argument must be a constant expression.
</p><p>
   The newly created list assumes ownership of the passed parameters, which
   therefore should not be freed.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
All contexts (including Threaded Context)
   </dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<b><i>SIM_alloc_attr_list</i></b></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_make_attr_nil">SIM_make_attr_nil()</a></h3>
<p>

<a id="device-api-functions.html:SIM_make_attr_nil2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_make_attr_nil"></a><b>SIM_make_attr_nil</b>  make nil attribute</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE attr_value_t
SIM_make_attr_nil(void);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns an <code>attr_value_t</code> of type nil.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_make_attr_object">SIM_make_attr_object()</a></h3>
<p>

<a id="device-api-functions.html:SIM_make_attr_object2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_make_attr_object"></a><b>SIM_make_attr_object</b>  make object attribute</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE attr_value_t
SIM_make_attr_object(conf_object_t *obj);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns an <code>attr_value_t</code> of object type
     with value <i>obj</i>. Returns a nil value if
     <i>obj</i> is <code>NULL</code>.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_make_attr_string">SIM_make_attr_string()</a></h3>
<p>

<a id="device-api-functions.html:SIM_make_attr_string2"></a><a id="device-api-functions.html:SIM_make_attr_string_adopt"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_make_attr_string"></a><b>SIM_make_attr_string</b><b>, SIM_make_attr_string_adopt</b>  make string attribute</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">attr_value_t
SIM_make_attr_string(const char *str);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE attr_value_t
SIM_make_attr_string_adopt(char *str);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns an <code>attr_value_t</code> of type string with value
     <i>str</i>. Returns Nil if <i>str</i> is <code>NULL</code>.
<p>
     <b><i>SIM_make_attr_string</i></b> will make a copy of the argument string.
</p><p>
     <b><i>SIM_make_attr_string_adopt</i></b> is mainly provided for 
     compatibility; it will assume ownership of the argument string, which
     must have been allocated using one the <b><i>MM_MALLOC</i></b> functions.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
All contexts (including Threaded Context)
     </dd>
</dl><p>

    </p><h2 class="jdocu"><a class="not-numbered" id="device-api-functions.html:Configuration">Configuration</a></h2>
<p></p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_attribute_error">SIM_attribute_error()</a></h3>
<p>

<a id="device-api-functions.html:SIM_attribute_error2"></a><a id="device-api-functions.html:SIM_c_attribute_error"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_attribute_error"></a><b>SIM_attribute_error</b><b>, SIM_c_attribute_error</b>  specify reason for attribute error</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_attribute_error(const char *NOTNULL msg);
</pre><p></p><pre class="jdocu_small">void
SIM_c_attribute_error(const char *NOTNULL msg, ...);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
When used inside an attribute <b><i>set_attr</i></b>/<b><i>get_attr</i></b>
   method, indicates why it failed to set or retrieve the attribute.
   This function only serves to give an informative message to the user.
   The object or attribute names need not be mentioned in the
   <i>msg</i> argument; Simics will supply this automatically.
   <b><i>SIM_c_attribute_error</i></b> is similar but the <i>msg</i>
   argument and those following it are used for string formatting in the
   same way as in the standard <b><i>sprintf</i></b> function. This function
   is not available from Python.
<p>
   The error message supplied will be attached to any frontend exception
   generated by the attribute access.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_register_attribute">SIM_register_attribute</a>, <a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_get_attribute">
   SIM_get_attribute</a>, <a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_set_attribute"> SIM_set_attribute</a></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_class_port">SIM_class_port()</a></h3>
<p>

<a id="device-api-functions.html:SIM_class_port2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_class_port"></a><b>SIM_class_port</b>  check if class has specified port object</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">conf_class_t *
SIM_class_port(const conf_class_t *NOTNULL cls, const char *NOTNULL name);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns the class of objects on the port named <i>name</i>,
   or NULL if no such port is registered.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_register_port">
     SIM_register_port</a>, <a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_register_simple_port"> SIM_register_simple_port
   </a></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_copy_class">SIM_copy_class()</a></h3>
<p>

<a id="device-api-functions.html:SIM_copy_class2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_copy_class"></a><b>SIM_copy_class</b>  create a copy of an existing class</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">conf_class_t *
SIM_copy_class(const char *NOTNULL name, const conf_class_t *NOTNULL src_cls,
               const char *desc);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This function creates a copy of the class <i>src_class</i>
   named <i>name</i>.
<p>
   Additional attributes and interfaces can be registered on the
   newly created class.
</p><p>
   The new class is described by <i>desc</i> unless
   this parameter is NULL which means that the original class description
   should be used.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
The newly created class is returned.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_extend_class">
        SIM_extend_class</a>, <a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_create_class"> SIM_create_class
   </a></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_create_class">SIM_create_class()</a></h3>
<p>

<a id="device-api-functions.html:SIM_create_class2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_create_class"></a><b>SIM_create_class</b>  create class</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">conf_class_t *
SIM_create_class(const char *NOTNULL name,
                 const class_info_t *NOTNULL class_info);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This function creates a new class that can be instantiated by
   calling the <b><i>SIM_create_object</i></b> function.  It is a 
   replacement for <b><i>SIM_register_class</i></b> and should be
   used in all new code. 
<p>
   The <i>name</i> can contain upper and lower case ASCII letters,
   hyphens, underscores, and digits. It must not begin with a digit or a hyphen
   and must not end with a hyphen.
</p><p>
   <i>class_info</i> may be freed when the function has returned.
   
   
</p><pre class="jdocu_small">typedef enum {
        Sim_Class_Kind_Vanilla = 0, /* object is saved at checkpoints */
        Sim_Class_Kind_Session = 1, /* object is saved as part of a
                                     * session only */
        Sim_Class_Kind_Pseudo = 2,  /* object is never saved */

        Sim_Class_Kind_Extension = 3, /* extension class
                                         (see SIM_extend_class) */
} class_kind_t;</pre><p>

   
</p><pre class="jdocu_small">typedef struct class_info {
        conf_object_t *(*alloc)(conf_class_t *cls);
        lang_void *(*init)(conf_object_t *obj);
        void (*finalize)(conf_object_t *obj);
        void (*objects_finalized)(conf_object_t *obj);

        void (*deinit)(conf_object_t *obj);
        void (*dealloc)(conf_object_t *obj);

        const char           *description;
        const char           *short_desc;
        class_kind_t          kind;
} class_info_t;</pre><p>
</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Class structure, or
   <code>NULL</code> on error.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_register_class_alias">
     SIM_register_class_alias</a>, <a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_class_info_t"> class_info_t
   </a></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_ensure_partial_attr_order">SIM_ensure_partial_attr_order()</a></h3>
<p>

<a id="device-api-functions.html:SIM_ensure_partial_attr_order2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_ensure_partial_attr_order"></a><b>SIM_ensure_partial_attr_order</b>  ensure attribute order</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_ensure_partial_attr_order(conf_class_t *NOTNULL cls,
                              const char *NOTNULL before,
                              const char *NOTNULL after);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Attribute initialization order is guaranteed to be identical to the order
   in which the attributes were registered. In some cases a particular order
   is required in order for a model to work correctly.
<p>
   This function checks the registration order of the attributes
   <i>before</i> and <i>after</i> in the class
   <i>cls</i>. If <i>before</i> is not registered
   before <i>after</i>, or if at least one of the two are not
   registered at all, an ASSERT is triggered.
</p><p>
   Use this function to ensure that e.g. code refactoring does not break
   a required attribute order.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_register_attribute">SIM_register_attribute</a></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_extend_class">SIM_extend_class()</a></h3>
<p>

<a id="device-api-functions.html:SIM_extend_class2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_extend_class"></a><b>SIM_extend_class</b>  extend class with contents from an extension class</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_extend_class(conf_class_t *NOTNULL cls, conf_class_t *NOTNULL ext);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The function extends the class <i>cls</i> with attributes,
   interfaces, port objects and port interfaces defined by the
   extension class <i>ext</i>.
<p>
   The extension class must be of the type
   <code>Sim_Class_Kind_Extension</code> and must not define any attributes
   or interfaces which have already been defined by the class being
   augmented.
</p><p>
   Besides normal object initialization, the <b><i>init_object</i></b>
   method for the extension class, will be called when
   <i>cls</i> is instantiated. The pointer returned by
   <b><i>init_object</i></b> can be retrieved using
   <b><i>SIM_extension_data</i></b>. The <b><i>init_object</i></b> method
   may return NULL if no private data pointer is needed; this does
   not signify an error condition for extension classes.
</p><p>
   The <b><i>finalize_instance</i></b> method defined by the extension class
   will be called before the <b><i>finalize_instance</i></b> method is called for
   the class being extended.
</p><p>
   The <b><i>SIM_extension_class</i></b> function is intended to be used
   to extend a class with generic functionality, common to multiple
   classes.</p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_create_class">
     SIM_create_class</a>, <a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_register_class"> SIM_register_class</a>, <a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_extension_data"> SIM_extension_data
   </a></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_extension_data">SIM_extension_data()</a></h3>
<p>

<a id="device-api-functions.html:SIM_extension_data2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_extension_data"></a><b>SIM_extension_data</b>  get class extension data</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void *
SIM_extension_data(conf_object_t *obj, conf_class_t *ext_cls);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns the private data pointer of an object associated
   with the extension class <i>ext_cls</i>. The returned pointer is
   the value returned by the <b><i>init_object</i></b> method called
   for the extension class <i>ext_cls</i>.
<p>
   The object <i>obj</i> must be an instance of a class
   which has been extended with the extension class <i>ext_cls</i>
   using the <b><i>SIM_extend_class</i></b> function.</p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_object_data">
      SIM_object_data</a>, <a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_register_class"> SIM_register_class</a>, <a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_extend_class"> SIM_extend_class
   </a></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_get_class">SIM_get_class()</a></h3>
<p>

<a id="device-api-functions.html:SIM_get_class2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_get_class"></a><b>SIM_get_class</b>  get class</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">conf_class_t *
SIM_get_class(const char *NOTNULL name);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns the configuration class called <i>name</i>.
   <a id="device-api-functions.html:conf_class_t"></a>
<p>
   If it finds no class called <i>name</i>, <b><i>SIM_get_class</i></b>
   will load a module implementing that class, if any can be found, and return
   the newly created class.
</p><p>
   Note that loading a module can not be done during the simulation execution:
   in that case, <b><i>SIM_get_class</i></b> will trigger an error instead. If
   you encounter this problem, a simple work-around is to make sure that all
   necessary modules are loaded before starting the execution.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Opaque pointer referencing the class,
   or NULL if not found.</dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_General</b> Thrown if the class has not been registered.
   <p>
   </p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context, except when loading a module.
   </dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_get_class_name">
     SIM_get_class_name
   </a></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_get_class_data">SIM_get_class_data()</a></h3>
<p>

<a id="device-api-functions.html:SIM_get_class_data2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_get_class_data"></a><b>SIM_get_class_data</b>  get class data</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">lang_void *
SIM_get_class_data(conf_class_t *cls);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Obtain the class data that was set using <b><i>SIM_set_class_data</i></b>. This
   can be called at any time during the object initialisation process.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_set_class_data">SIM_set_class_data</a></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_get_class_name">SIM_get_class_name()</a></h3>
<p>

<a id="device-api-functions.html:SIM_get_class_name2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_get_class_name"></a><b>SIM_get_class_name</b>  get class name</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">const char *
SIM_get_class_name(const conf_class_t *NOTNULL class_data);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns the name of the class. Simics retains ownership of the returned
   string; it must not be modified or freed by the caller.
<p>
   In Python, the name of an object's class is available via
   the <i>classname</i> attribute: </p><pre class="jdocu_small">obj.classname</pre><p>.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_get_class">
     SIM_get_class
   </a></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_get_interface">SIM_get_interface()</a></h3>
<p>

<a id="device-api-functions.html:SIM_get_interface2"></a><a id="device-api-functions.html:SIM_c_get_interface"></a><a id="device-api-functions.html:SIM_get_class_interface"></a><a id="device-api-functions.html:SIM_c_get_class_interface"></a><a id="device-api-functions.html:SIM_get_port_interface"></a><a id="device-api-functions.html:SIM_c_get_port_interface"></a><a id="device-api-functions.html:SIM_get_class_port_interface"></a><a id="device-api-functions.html:SIM_c_get_class_port_interface"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_get_interface"></a><b>SIM_get_interface</b><b>, SIM_c_get_interface</b><b>, SIM_get_class_interface</b><b>, SIM_c_get_class_interface</b><b>, SIM_get_port_interface</b><b>, SIM_c_get_port_interface</b><b>, SIM_get_class_port_interface</b><b>, SIM_c_get_class_port_interface</b>  get interface</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">const void *
SIM_get_interface(const conf_object_t *NOTNULL obj, const char *NOTNULL name);
</pre><p></p><pre class="jdocu_small">const void *
SIM_c_get_interface(const conf_object_t *NOTNULL obj, const char *NOTNULL name);
</pre><p></p><pre class="jdocu_small">const void *
SIM_get_class_interface(const conf_class_t *NOTNULL cls, 
                        const char *NOTNULL name);
</pre><p></p><pre class="jdocu_small">const void *
SIM_c_get_class_interface(const conf_class_t *NOTNULL cls, 
                          const char *NOTNULL name);
</pre><p></p><pre class="jdocu_small">const void *
SIM_get_port_interface(const conf_object_t *NOTNULL obj, 
                       const char *NOTNULL name, const char *portname);
</pre><p></p><pre class="jdocu_small">const void *
SIM_c_get_port_interface(const conf_object_t *NOTNULL obj, 
                         const char *NOTNULL name, 
                         const char *portname);
</pre><p></p><pre class="jdocu_small">const void *
SIM_get_class_port_interface(const conf_class_t *NOTNULL cls,
                             const char *NOTNULL name, 
                             const char *portname);
</pre><p></p><pre class="jdocu_small">const void *
SIM_c_get_class_port_interface(const conf_class_t *NOTNULL cls,
                               const char *NOTNULL name, 
                               const char *portname);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Get the interface with name <i>name</i> from object
   <i>obj</i>. Returns NULL, and raises an exception if
   <i>obj</i> does not implement the interface.
<p>
   <b><i>SIM_get_port_interface</i></b> returns a port interface
   instance as registered with
   <b><i>SIM_register_port_interface</i></b>. The
   <i>portname</i> selects a particular implementation of the
   interface by <i>obj's</i> class. If no port name is supplied,
   the function behaves as <b><i>SIM_get_interface</i></b>.
</p><p>
   <b><i>SIM_get_class_interface</i></b> and
   <b><i>SIM_get_class_port_interface</i></b> are similar but return the
   interface for a class instead of an object.
</p><p>
   <b><i>SIM_c_get_interface</i></b>,
   <b><i>SIM_c_get_port_interface</i></b>,
   <b><i>SIM_c_get_class_interface</i></b> and
   <b><i>SIM_c_get_class_port_interface</i></b> are similar to their respective
   counterparts but never raise an exception, nor do they accept dashes
   inside <i>name</i> or <i>portname</i> instead of 
   underscores.
</p><p>
   The <b><i>SIM_C_GET_INTERFACE</i></b> macro is a useful type-safe replacement
   for SIM_c_get_interface. The macro takes an object and the name of the
   interface without quotes. Compare the three forms:
   </p><pre class="jdocu_small">SIM_c_get_interface(obj, PCI_DEVICE_INTERFACE);
SIM_c_get_interface(obj, "pci_device");
SIM_C_GET_INTERFACE(obj, pci_device);
   </pre><p>
</p><p>
   The data the result points to is owned by Simics. The caller
   must not deallocate or modify it.
</p><p>
   In Python, there is usually no need to use these functions
   since Simics objects' interfaces are available via the <i>iface</i>
   attribute. Here is sample Python code calling
   the <b><i>signal_raise</i></b> method of the object's
   <code>signal</code> interface:<br>
   </p><pre class="jdocu_small">obj.iface.signal.signal_raise()</pre><p>
</p><p>
   In a similar way one can call interfaces of an object's
   port objects. Here is a respective example where
   an object <b>obj</b> with a port object <b>obj.port.reset</b>
   has a <code>signal</code> interface:<br>
   </p><pre class="jdocu_small">obj.port.reset.iface.signal.signal_raise()</pre><p>
</p><p>
   Port interfaces - interfaces that are registered with
   <b><i>SIM_register_port_interface</i></b> and are considered legacy - are also
   directly accessible in Python. Here is sample code calling
   the <b><i>signal_raise</i></b> method of the <code>signal</code> interface
   from the object's <code>RESET</code> port:<br>
   </p><pre class="jdocu_small">obj.ports.RESET.signal.signal_raise()</pre><p>
</p><p>
   In order to check if a Simics object implements an interface
   the following Python code can be used:<br>
   </p><pre class="jdocu_small">if hasattr(obj.iface, "signal"):  # check whether obj has signal interface
    ...</pre><p></p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Pointer to interface, or NULL if not found.
   </dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_Lookup</b> Thrown if the interface is not implemented by
   <i>obj's</i> class.<br>
<p>
   <b>SimExc_General</b> Thrown if the interface name is illegal.
</p><p>
   </p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
All contexts (including Threaded Context)
   </dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_register_interface">
     SIM_register_interface
   </a></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_is_restoring_state">SIM_is_restoring_state()</a></h3>
<p>

<a id="device-api-functions.html:SIM_is_restoring_state2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_is_restoring_state"></a><b>SIM_is_restoring_state</b>  check if state restoring phase</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">bool
SIM_is_restoring_state(conf_object_t *obj);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns true if the configuration system is currently restoring the saved
   state for the object <code>obj</code> when reading a checkpoint, applying a
   persistent state or restoring a snapshot.
<p>
   <b><i>SIM_is_restoring_state</i></b> is typically used to prevent side effects
   in attribute set methods that only should run when the attribute is set
   manually, for example when hot plugging.
</p><p>
   <table>

   <tbody><tr><td class="jdocu_noborder"></td>
       <td class="jdocu_noborder"><b><i>SIM_object_is_configured</i></b></td>
       <td class="jdocu_noborder"><b><i>SIM_is_restoring_state</i></b></td></tr>

   <tr><td class="jdocu_noborder">Creating object</td>          <td class="jdocu_noborder">false</td> <td class="jdocu_noborder">false</td></tr>

   <tr><td class="jdocu_noborder">Loading checkpoint</td>       <td class="jdocu_noborder">false</td> <td class="jdocu_noborder">true</td></tr>

   <tr><td class="jdocu_noborder">Loading persistent state</td> <td class="jdocu_noborder">true</td>  <td class="jdocu_noborder">true</td></tr>

   <tr><td class="jdocu_noborder">Loading snapshot</td> <td class="jdocu_noborder">true</td><td class="jdocu_noborder">true</td></tr>

   <tr><td class="jdocu_noborder">Manual attribute access (hot plug)</td>
       <td class="jdocu_noborder">true</td>  <td class="jdocu_noborder">false</td></tr>

   </tbody></table>
</p><p>
   LIMITATION: This function currently returns true for all objects in Simics
   while some state is being restored and not only for the affected objects.</p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_object_is_configured">SIM_object_is_configured</a></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_marked_for_deletion">SIM_marked_for_deletion()</a></h3>
<p>

<a id="device-api-functions.html:SIM_marked_for_deletion2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_marked_for_deletion"></a><b>SIM_marked_for_deletion</b>  is object being deleted</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">bool
SIM_marked_for_deletion(const conf_object_t *NOTNULL obj);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Indicates if the given object is being deleted. This information can be
   useful by other objects that want to clean up their references.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
<code>true</code> if the object is being
   deleted.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_delete_objects">SIM_delete_objects</a></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_object_clock">SIM_object_clock()</a></h3>
<p>

<a id="device-api-functions.html:SIM_object_clock2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_object_clock"></a><b>SIM_object_clock</b>  get object clock</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">conf_object_t *
SIM_object_clock(const conf_object_t *NOTNULL obj);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Retrieve the default clock used by an object. This is either set by
   the <i>queue</i> attribute, or inherited from the default clock of
   the object's parent. The default clock is used as time reference for the
   object.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
All contexts (including Threaded Context)
   </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_object_data">SIM_object_data()</a></h3>
<p>

<a id="device-api-functions.html:SIM_object_data2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_object_data"></a><b>SIM_object_data</b>  get object-specific data pointer</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">lang_void *
SIM_object_data(conf_object_t *NOTNULL obj);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns the private data pointer of an object. This pointer is
     available to the class for storing instance-specific state. 
     <p>
     It is initialised to the return value of the <b><i>init</i></b> 
     (from <code>class_info_t</code>) method 
     that is called during object creation.  For classes created using
     the legacy <b><i>SIM_register_class</i></b>, the same functionality
     is provided by the <b><i>init_object</i></b> method .
</p><p>
     For classes implemented in Python, the data (which is then a Python
     value) can also be accessed as <code>obj.object_data</code>.
</p><p>
     For classes written in C, the preferred way to store
     instance-specific state is by co-allocation with the object's
     <code>conf_object_t</code> structure instead of using
     <b><i>SIM_object_data</i></b>.  Such classes should define the
     <b><i>alloc</i></b> method in the <code>class_info_t</code>
     passed to <b><i>SIM_create_class</i></b> for allocating its instance
     data.  For classes using the legacy <b><i>SIM_register_class</i></b> 
     class registration function, they should define the
     <b><i>alloc_object</i></b> method in the <code>class_data_t</code> 
     data structure.</p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_create_class">
       SIM_create_class</a>, <a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_register_class"> SIM_register_class
     </a></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
All contexts (including Threaded Context)
   </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_object_id">SIM_object_id()</a></h3>
<p>

<a id="device-api-functions.html:SIM_object_id2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_object_id"></a><b>SIM_object_id</b>  get object identifier</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">const char *
SIM_object_id(const conf_object_t *NOTNULL obj);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns the unique identifier for an object. The identifier is a
   string that is guaranteed to be unique and will never change, even
   if the object moves to another hierarchical location.
<p>
   The return value is a static string that should not be modified or
   freed by the caller.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
All contexts (including Threaded Context)
   </dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_object_name">SIM_object_name</a></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_object_is_configured">SIM_object_is_configured()</a></h3>
<p>

<a id="device-api-functions.html:SIM_object_is_configured2"></a><a id="device-api-functions.html:SIM_set_object_configured"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_object_is_configured"></a><b>SIM_object_is_configured</b><b>, SIM_set_object_configured</b>  get/set configured status</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">bool
SIM_object_is_configured(const conf_object_t *NOTNULL obj);
</pre><p></p><pre class="jdocu_small">void
SIM_set_object_configured(conf_object_t *NOTNULL obj);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<b><i>SIM_object_is_configured</i></b> indicates whether
     <i>obj</i> is configured. <b><i>SIM_set_object_configured</i></b>
     sets the object as configured.
  <p>
     An object is configured once its <b><i>finalize_instance</i></b> method
     (<b><i>post_init</i></b> in DML) has completed, or
     <b><i>SIM_set_object_configured</i></b> has been called for it. Being
     configured indicates that the object is in a consistent state and is
     ready to be used by other objects.
  </p><p>
     <b><i>SIM_set_object_configured</i></b> is used to avoid circular
     dependencies between objects. It may only be called from the object's
     own <b><i>finalize_instance</i></b> method, when the object is known to
     be in a consistent state.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
<b><i>SIM_object_is_configured</i></b>:
       all contexts (including Threaded Context);
       <b><i>SIM_set_object_configured</i></b>: Global Context
     </dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_require_object">
       SIM_require_object</a>, <a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_register_class"> SIM_register_class</a>, <a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_is_restoring_state"> SIM_is_restoring_state
     </a></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_object_name">SIM_object_name()</a></h3>
<p>

<a id="device-api-functions.html:SIM_object_name2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_object_name"></a><b>SIM_object_name</b>  get object name</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">const char *
SIM_object_name(const conf_object_t *NOTNULL obj);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns the name of an object. This name identifies the object
   uniquely, but may change if the object is moved to another
   hierarchical location.
<p>
   The return value is a string, owned by <code>obj</code>, that should not be
   modified or freed by the caller.
</p><p>
   In Python, an object's name is available via the <i>name</i> attribute:
   </p><pre class="jdocu_small">obj.name</pre><p>.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
All contexts (including Threaded Context)
   </dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_object_id">SIM_object_id</a></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_picosecond_clock">SIM_picosecond_clock()</a></h3>
<p>

<a id="device-api-functions.html:SIM_picosecond_clock2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_picosecond_clock"></a><b>SIM_picosecond_clock</b>  get object picosecond clock</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">conf_object_t *
SIM_picosecond_clock(conf_object_t *NOTNULL obj);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Return the picosecond clock used by an object <i>obj</i>.
<p>
   The returned clock uses a cycle period of exactly 1 ps. It
   has full picosecond resolution even if the processor (or clock)
   driving the simulation uses a lower resolution.
   An event posted at a particular picosecond triggers always at that
   precise time, without any rounding issues.
</p><p>
   The returned object is the <b>vtime.ps</b> port object of
   the default clock for the object, and it implements the
   <code>cycle_event</code> interface.
</p><p>
   The API functions <b><i>SIM_event_post_cycle</i></b>,
   <b><i>SIM_event_post_time</i></b>, <b><i>SIM_event_find_next_cycle</i></b>,
   <b><i>SIM_event_cancel_time</i></b>, and <b><i>SIM_cycle_count</i></b>
   can be used directly on the picosecond clock.
</p><p>
   </p><div class="note">
<b>Note:</b>
The function <b><i>SIM_time</i></b> is currently not
   supported for the picosecond clock; it will return
   same value as if the function is invoked on the default clock.
   </div><div class="note">
<b>Note:</b>
The picosecond clock will wrap around after roughly
   200 days of virtual time (2^64 ps).</div></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_object_clock">SIM_object_clock</a></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
All contexts (including Threaded Context)
   </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_register_attribute">SIM_register_attribute()</a></h3>
<p>

<a id="device-api-functions.html:SIM_register_attribute2"></a><a id="device-api-functions.html:SIM_register_class_attribute"></a><a id="device-api-functions.html:SIM_register_attribute_with_user_data"></a><a id="device-api-functions.html:SIM_register_class_attribute_with_user_data"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_register_attribute"></a><b>SIM_register_attribute</b><b>, SIM_register_class_attribute</b><b>, SIM_register_attribute_with_user_data</b><b>, SIM_register_class_attribute_with_user_data</b>  register attribute</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_register_attribute(
        conf_class_t *NOTNULL cls, const char *NOTNULL name,
        attr_value_t (*get_attr)(conf_object_t *),
        set_error_t (*set_attr)(conf_object_t *, attr_value_t *),
        attr_attr_t attr, const char *type, const char *desc);
</pre><p></p><pre class="jdocu_small">void
SIM_register_class_attribute(
        conf_class_t *NOTNULL cls, const char *NOTNULL name,
        attr_value_t (*get_attr)(conf_class_t *),
        set_error_t (*set_attr)(conf_class_t *, attr_value_t *),
        attr_attr_t attr, const char *type, const char *desc);
</pre><p></p><pre class="jdocu_small">void
SIM_register_attribute_with_user_data(
        conf_class_t *NOTNULL cls, const char *NOTNULL name,
        attr_value_t (*get_attr)(conf_object_t *, lang_void *),
        lang_void *user_data_get,
        set_error_t (*set_attr)(conf_object_t *, attr_value_t *, lang_void *),
        lang_void *user_data_set,
        attr_attr_t attr, const char *type, const char *desc);
</pre><p></p><pre class="jdocu_small">void
SIM_register_class_attribute_with_user_data(
        conf_class_t *NOTNULL cls, const char *NOTNULL name,
        attr_value_t (*get_attr)(conf_class_t *, lang_void *),
        lang_void *user_data_get,
        set_error_t (*set_attr)(conf_class_t *, attr_value_t *, lang_void *),
        lang_void *user_data_set,
        attr_attr_t attr, const char *type, const char *desc);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Add the attribute <i>name</i> to the set of attributes
   of the class <i>cls</i>.
<p>
   For <b><i>SIM_register_attribute</i></b> and
   <b><i>SIM_register_class_attribute</i></b>, the function
   <i>get_attr</i> is called with the object as argument, and returns
   the current value of the attribute. For
   <b><i>SIM_register_attribute_with_user_data</i></b> and
   <b><i>SIM_register_class_attribute_with_user_data</i></b>, the function
   <i>get_attr</i> takes an additional user data argument, which takes
   the value passed as <i>user_data_get</i>.
</p><p>
   On error, <i>get_attr</i> should call
   <b><i>SIM_attribute_error</i></b>. The return value is then ignored; typically,
   <b><i>SIM_make_attr_invalid</i></b> is used to generate an explicitly invalid
   value.
</p><p>
   If <i>get_attr</i> is a null pointer, the attribute will be
   write-only.
</p><p>
   For <b><i>SIM_register_attribute</i></b> and
   <b><i>SIM_register_class_attribute</i></b>, the function
   <i>set_attr</i> is called with the object as argument. For
   <b><i>SIM_register_attribute_with_user_data</i></b> and
   <b><i>SIM_register_class_attribute_with_user_data</i></b>, the function
   <i>set_attr</i> takes an additional user data argument, which takes
   the value passed as <i>user_data_set</i>. The
   <i>set_attr</i> function is called when the attribute is initialised
   or changed. The argument value is owned by the caller, so any data from it
   must be copied.
</p><p>
   The <i>set_attr</i> method should return <code>Sim_Set_Ok</code>
   if the new value could be set. On error, it should return an appropriate
   error code (usually <code>Sim_Set_Illegal_Value</code>), and optionally
   call <b><i>SIM_attribute_error</i></b> with an explanatory message.
</p><p>
   If <i>set_attr</i> is a null pointer, the attribute will be
   read-only.
</p><p>
   The <i>attr</i> parameter is one of
   <code>Sim_Attr_Required</code>, <code>Sim_Attr_Optional</code> or
   <code>Sim_Attr_Pseudo</code>.
</p><p>
   Attributes marked <code>Sim_Attr_Required</code> or
   <code>Sim_Attr_Optional</code> are saved in checkpoints. Both
   <i>set_attr</i> and <i>get_attr</i> must be non-null
   for such attributes.
</p><p>
   All attributes that are marked <code>Sim_Attr_Required</code>
   must be present in all configurations.
</p><p>
   The set of permitted values is encoded in the string <i>type</i>.
</p><p>
   The type strings are composed as follows:
</p><p>
   </p><ul>
     <li>
       Most types are represented by a single letter:
       <table>

         <tbody><tr>
           <td class="jdocu_noborder"><code>i</code></td>
           <td class="jdocu_noborder">integer</td>
         </tr>

         <tr>
           <td class="jdocu_noborder"><code>f</code></td>
           <td class="jdocu_noborder">floating-point</td>
         </tr>

         <tr>
           <td class="jdocu_noborder"><code>s</code></td>
           <td class="jdocu_noborder">string</td>
         </tr>

         <tr>
           <td class="jdocu_noborder"><code>b</code></td>
           <td class="jdocu_noborder">boolean</td>
         </tr>

         <tr>
           <td class="jdocu_noborder"><code>o</code></td>
           <td class="jdocu_noborder">object</td>
         </tr>

         <tr>
           <td class="jdocu_noborder"><code>d</code></td>
           <td class="jdocu_noborder">data</td>
         </tr>

         <tr>
           <td class="jdocu_noborder"><code>n</code></td>
           <td class="jdocu_noborder">nil</td>
         </tr>

         <tr>
           <td class="jdocu_noborder"><code>a</code></td>
           <td class="jdocu_noborder">any type (not valid when the attribute is marked with
               <code>Sim_Attr_Required</code>)</td>
         </tr>

       </tbody></table>
     </li>

     <li>
       The <code>|</code> (vertical bar) operator specifies the union of
       two types; eg, <code>s|o</code> is the type of a string or an object.
     </li>

     <li>
       Lists are defined inside square brackets: <code>[]</code>. There are two
       kinds of list declarations:
<p>
       </p><ul>
         <li>
           A heterogeneous list of fixed length is defined by the types of its
           elements. For example, <code>[ios]</code> specifies a 3-element list
           consisting of an integer, an object and a string, in that order.
         </li>
         <li>
           A homogeneous list of varying length is defined by a single type
           followed by a length modifier:
<p>
           <table>

             <tbody><tr>
               <td class="jdocu_noborder"><code>{</code><i>N</i><code>:</code><i>M</i><code>}</code></td>
               <td class="jdocu_noborder">between <i>N</i> and <i>M</i> elements, inclusive</td>
             </tr>

             <tr>
               <td class="jdocu_noborder"><code>{</code><i>N</i><code>}</code></td>
               <td class="jdocu_noborder">exactly <i>N</i> elements</td>
             </tr>

             <tr>
               <td class="jdocu_noborder"><code>*</code></td>
               <td class="jdocu_noborder">zero or more elements</td>
             </tr>

             <tr>
               <td class="jdocu_noborder"><code>+</code></td>
               <td class="jdocu_noborder">one or more elements</td>
             </tr>

           </tbody></table>
</p><p>
           For example, <code>[i{3,5}]</code> specifies a list of
           3, 4 or 5 integers.
         </p></li>
       </ul>
<p>
       Inside heterogeneous lists, <code>|</code> (union) has higher precedence
       than juxtaposition; ie, <code>[i|so|n]</code> defines a list of two
       elements, the first being an integer or a string and the second
       an object or NIL.
     </p></li>
   </ul>
<p>
   <b><i>SIM_register_class_attribute</i></b> and
   <b><i>SIM_register_class_attribute_with_user_data</i></b> will register a class
   attribute. Class attributes are the same for all instances of the class.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_register_class">SIM_register_class()</a></h3>
<p>

<a id="device-api-functions.html:SIM_register_class2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_register_class"></a><b>SIM_register_class</b>  register class</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">conf_class_t *
SIM_register_class(const char *NOTNULL name,
                   const class_data_t *NOTNULL class_data);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This function is considered legacy. New code should use the 
   <b><i>SIM_create_class</i></b> function to create new classes 
   in the Simics simulator. 
<p>
   The function registers a new class that can be instantiated by
   calling the <b><i>SIM_create_object</i></b> function.
</p><p>
   The <i>name</i> can contain upper and lower case ASCII letters,
   hyphens, underscores, and digits. It must not begin with a digit or a hyphen
   and must not end with a hyphen.
</p><p>
   <i>class_data</i> may be freed when the function has returned.
   
   
</p><pre class="jdocu_small">typedef struct class_data {
        conf_object_t *(*alloc_object)(lang_void *data);
        lang_void *(*init_object)(conf_object_t *obj, lang_void *data);
        void (*finalize_instance)(conf_object_t *obj);

        void (*pre_delete_instance)(conf_object_t *obj);
        int (*delete_instance)(conf_object_t *obj);

        const char           *description;
        const char           *class_desc;
        class_kind_t          kind;
} class_data_t;</pre><p>
</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Class structure, or
   <code>NULL</code> on error.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_create_class">
     SIM_create_class</a>, <a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_register_class_alias"> SIM_register_class_alias</a>, <a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_class_data_t"> class_data_t
   </a></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_register_class_alias">SIM_register_class_alias()</a></h3>
<p>

<a id="device-api-functions.html:SIM_register_class_alias2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_register_class_alias"></a><b>SIM_register_class_alias</b>  register class alias</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_register_class_alias(const char *NOTNULL alias, const char *NOTNULL name);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Register an alias <i>alias</i> for the existing
   class <i>class_name</i>. Using aliases allows the
   <i>read-configuration</i> command to read configuration files that
   define objects of type <i>alias</i>, while the
   <i>write-configuration</i> command always uses <i>class_name</i>.
<p>
   Aliases are used to support compatibility with old class names if a
   class is renamed. They can also be used to allow different modules,
   which define different specific implementations of the same generic
   base class, to read the same configuration files.</p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_create_class">
     SIM_create_class</a>, <a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_register_class"> SIM_register_class
   </a></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_register_clock">SIM_register_clock()</a></h3>
<p>
  
  

<a id="device-api-functions.html:SIM_register_clock2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_register_clock"></a><b>SIM_register_clock</b>  register mandatory interface and attributes for clock objects</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">int
SIM_register_clock(conf_class_t *NOTNULL cls,
                   const cycle_interface_t *NOTNULL iface);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Register the <i>cls</i> class as a class for schedulable clock
   objects. This includes registering the <code>cycle</code> interface
   (<i>iface</i>), in addition to which <b><i>SIM_register_clock</i></b>
   registers the <i>cell</i> attribute required for scheduling the clock
   and some other Simics specific attributes. Simics will be able to schedule
   objects instantiated from the class <i>cls</i>.
<p>
   The return value is 0 if everything works, and non-zero if something
   fails. Depending on the stage that failed, <b><i>SIM_register_clock()</i></b>
   will return the error value provided by <b><i>SIM_register_interface()</i></b>.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Returns non-zero on failure, 0 otherwise.
   </dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_General</b> Thrown if the <code>cycle</code> interface has
   already been registered for this class.
<p>
   </p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_register_interface">
     SIM_register_interface</a>, <a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_register_attribute">
     SIM_register_attribute
   </a></dd>
</dl><p>

  </p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_register_compatible_interfaces">SIM_register_compatible_interfaces()</a></h3>
<p>

<a id="device-api-functions.html:SIM_register_compatible_interfaces2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_register_compatible_interfaces"></a><b>SIM_register_compatible_interfaces</b>  register earlier versions of interface</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_register_compatible_interfaces(conf_class_t *NOTNULL cls,
                                   const char *NOTNULL name);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Register any earlier versions of the interface <i>name</i> for class
   <i>cls</i>. The interface <i>name</i> must already be registered for
   the class.
<p>
   When supported, this function lets a module implement a single version of an
   interface while still exporting earlier versions.
</p><p>
   The following interfaces are currently accepted by this function, with the
   additional interfaces that are exported given in parenthesis:
   BREAKPOINT_QUERY_V2, PROCESSOR_INFO_V2 (PROCESSOR_INFO).</p></dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_General</b> Thrown if no interface is registered with the given
   name, if compatible versions of the interface have already been registered,
   or if the interface does not have any earlier versions that this function
   knows about.
   <p>
   </p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_register_interface">SIM_register_interface()</a></h3>
<p>

<a id="device-api-functions.html:SIM_register_interface2"></a><a id="device-api-functions.html:SIM_register_port_interface"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_register_interface"></a><b>SIM_register_interface</b><b>, SIM_register_port_interface</b>  register interface</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">int
SIM_register_interface(conf_class_t *NOTNULL cls, const char *NOTNULL name,
                       const void *NOTNULL iface);
</pre><p></p><pre class="jdocu_small">int
SIM_register_port_interface(conf_class_t *NOTNULL cls,
                            const char *NOTNULL name,
                            const void *NOTNULL iface,
                            const char *NOTNULL portname,
                            const char *desc);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Register that <i>cls</i> implements the <i>name</i>
   interface. The interface itself should be supplied in the
   <i>iface</i> argument.
<p>
   <b><i>SIM_register_port_interface</i></b> registers a port instance of an
   interface that must be looked up using
   <b><i>SIM_get_port_interface</i></b>. The <i>portname</i> parameter is
   the name of the port. The port name may not be the same as any attribute
   name used by the class. A short description of the port is provided with the
   <i>desc</i> parameter and should be identical for all interfaces for
   a port. These two functions are considered legacy. New code should use
   SIM_register_port and SIM_register_interface instead.
</p><p>
   The data <i>iface</i> points to must not be deallocated or overwritten
   by the caller. Simics will use that data to store the interface
   structure. It will never be freed or written to by Simics.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Returns non-zero on failure, 0 otherwise.
   </dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_General</b> Thrown if the interface name is illegal, or if this
   interface has already been registered for this class.
<p>
   </p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_get_interface">SIM_get_interface</a></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_register_port">SIM_register_port()</a></h3>
<p>

<a id="device-api-functions.html:SIM_register_port2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_register_port"></a><b>SIM_register_port</b>  register port class</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_register_port(conf_class_t *NOTNULL cls, const char *NOTNULL name,
                  conf_class_t *NOTNULL port_cls, const char *desc);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Add a port named <i>name</i> of class <i>port_cls</i>
   to the set of ports defined by the class <i>cls</i>.
<p>
   The result of this is that whenever an object of class <i>cls</i> is
   created, Simics will automatically create a port object of class
   <code>port_cls</code>. The name of the port object is created by appending
   <code>.</code> followed by the <i>name</i> string to the parent object's
   name.
</p><p>
   If the port name contains dots or brackets, then intermediate port objects
   are registered as well. For instance, the port name <code>x.array[2]</code> will
   implicitly register ports <code>x</code> of class <code>namespace</code>, and
   <code>x.array</code> of class <code>index-map</code>.
</p><p>
   Each port name may be registered at most once in a class. One exception is
   namespace classes: If the port is registered once as class
   <code>namespace</code> and once as some other class, then the <code>namespace</code>
   registration is dropped. Also, if a port is registered twice as class
   <code>index-map</code>, or twice as class <code>namespace</code>, then the second
   registration is dropped.</p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_register_simple_port">SIM_register_simple_port</a></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_register_simple_port">SIM_register_simple_port()</a></h3>
<p>

<a id="device-api-functions.html:SIM_register_simple_port2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_register_simple_port"></a><b>SIM_register_simple_port</b>  register port</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">conf_class_t *
SIM_register_simple_port(conf_class_t *NOTNULL cls, const char *NOTNULL name,
                         const char *desc);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Add a port named <i>name</i> to the set of
   ports defined by the class <i>cls</i>. The port will be an
   instance of a class named <i>"parent_class_name.portname"</i> where
   <i>portname</i> is the specified name of the port with
   leading namespaces omitted and any array indices removed.
   The port class is created if it does not exist already.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
The port class is returned.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_register_port">SIM_register_port</a></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_register_typed_attribute">SIM_register_typed_attribute()</a></h3>
<p>

<a id="device-api-functions.html:SIM_register_typed_attribute2"></a><a id="device-api-functions.html:SIM_register_typed_class_attribute"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_register_typed_attribute"></a><b>SIM_register_typed_attribute</b><b>, SIM_register_typed_class_attribute</b>  register attribute</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">int
SIM_register_typed_attribute(
        conf_class_t *NOTNULL cls, const char *NOTNULL name,
        attr_value_t (*get_attr)(lang_void *user_data,
                                 conf_object_t *obj,
                                 attr_value_t *idx),
        lang_void *user_data_get,
        set_error_t (*set_attr)(lang_void *user_data,
                                conf_object_t *obj,
                                attr_value_t *val, attr_value_t *idx),
        lang_void *user_data_set,
        attr_attr_t attr, const char *type, const char *idx_type,
        const char *desc);
</pre><p></p><pre class="jdocu_small">int
SIM_register_typed_class_attribute(
        conf_class_t *NOTNULL cls, const char *NOTNULL name,
        attr_value_t (*get_attr)(lang_void *ptr,
                                 conf_class_t *c,
                                 attr_value_t *idx),
        lang_void *user_data_get,
        set_error_t (*set_attr)(lang_void *ptr,
                                conf_class_t *c,
                                attr_value_t *val,
                                attr_value_t *idx),
        lang_void *user_data_set,
        attr_attr_t attr, const char *type, const char *idx_type,
        const char *desc);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<div class="note">
<b>Note:</b>
The functions <b><i>SIM_register_typed_attribute</i></b> and
   <b><i>SIM_register_typed_class_attribute</i></b> are legacy. New code should
   use <b><i>SIM_register_attribute</i></b> or
   <b><i>SIM_register_class_attribute</i></b>.</div>Add the attribute <i>name</i> to the set of attributes
   of the class <i>cls</i>.
<p>
   The function <i>get_attr</i> is called with the object and the value
   from <i>user_data_get</i> as arguments, and returns the current
   value of the attribute.
</p><p>
   On error, <i>get_attr</i> should call
   <b><i>SIM_attribute_error</i></b>. The return value is then ignored; typically,
   <b><i>SIM_make_attr_invalid</i></b> is used to generate an explicitly invalid
   value.
   </p><p>
   If <i>get_attr</i> is a null pointer, the attribute will be
   write-only.
</p><p>
   The function <i>set_attr</i> is called with the object and the value
   from <i>user_data_set</i> as arguments when the attribute is
   initialised or changed. The argument value is owned by the caller, so any
   data from it must be copied.
</p><p>
   The <i>set_attr</i> method should return <code>Sim_Set_Ok</code>
   if the new value could be set. On error, it should return an appropriate
   error code (usually <code>Sim_Set_Illegal_Value</code>), and optionally
   call <b><i>SIM_attribute_error</i></b> with an explanatory message.
</p><p>
   If <i>set_attr</i> is a null pointer, the attribute will be
   read-only.
</p><p>
   The <i>attr</i> parameter is one of
   <code>Sim_Attr_Required</code>, <code>Sim_Attr_Optional</code>
   or <code>Sim_Attr_Pseudo</code>.
</p><p>
   Attributes marked <code>Sim_Attr_Required</code> or
   <code>Sim_Attr_Optional</code> are saved in checkpoints. Both
   <i>set_attr</i> and <i>get_attr</i> must be non-null
   for such attributes.
</p><p>
   All attributes that are marked <code>Sim_Attr_Required</code>
   must be present in all configurations.
</p><p>
   The set of permitted values is encoded in the string <i>type</i>,
   and in <i>idx_type</i> for values during indexed access.
   A <code>NULL</code> value for either type string means that values of
   any type are permitted.
</p><p>
   The type strings are composed as follows:
</p><p>
   </p><ul>
     <li>
       Most types are represented by a single letter:
       <table>

         <tbody><tr>
           <td class="jdocu_noborder"><code>i</code></td>
           <td class="jdocu_noborder">integer</td>
         </tr>

         <tr>
           <td class="jdocu_noborder"><code>f</code></td>
           <td class="jdocu_noborder">floating-point</td>
         </tr>

         <tr>
           <td class="jdocu_noborder"><code>s</code></td>
           <td class="jdocu_noborder">string</td>
         </tr>

         <tr>
           <td class="jdocu_noborder"><code>b</code></td>
           <td class="jdocu_noborder">boolean</td>
         </tr>

         <tr>
           <td class="jdocu_noborder"><code>o</code></td>
           <td class="jdocu_noborder">object</td>
         </tr>

         <tr>
           <td class="jdocu_noborder"><code>d</code></td>
           <td class="jdocu_noborder">data</td>
         </tr>

         <tr>
           <td class="jdocu_noborder"><code>n</code></td>
           <td class="jdocu_noborder">nil</td>
         </tr>

         <tr>
           <td class="jdocu_noborder"><code>D</code></td>
           <td class="jdocu_noborder">dictionary</td>
         </tr>

         <tr>
           <td class="jdocu_noborder"><code>a</code></td>
           <td class="jdocu_noborder">any type</td>
         </tr>

       </tbody></table>
     </li>

     <li>
       The <code>|</code> (vertical bar) operator specifies the union of
       two types; eg, <code>s|o</code> is the type of a string or an object.
     </li>

     <li>
       Lists are defined inside square brackets: <code>[]</code>. There are two
       kinds of list declarations:
       <p>
       </p><ul>
         <li>
           A heterogeneous list of fixed length is defined by the types of its
           elements. For example, <code>[ios]</code> specifies a 3-element list
           consisting of an integer, an object and a string, in that order.
         </li>
         <li>
           A homogeneous list of varying length is defined by a single type
           followed by a length modifier:
<p>
           <table>

             <tbody><tr>
               <td class="jdocu_noborder"><code>{</code><i>N</i><code>:</code><i>M</i><code>}</code></td>
               <td class="jdocu_noborder">between <i>N</i> and <i>M</i> elements, inclusive</td>
             </tr>

             <tr>
               <td class="jdocu_noborder"><code>{</code><i>N</i><code>}</code></td>
               <td class="jdocu_noborder">exactly <i>N</i> elements</td>
             </tr>

             <tr>
               <td class="jdocu_noborder"><code>*</code></td>
               <td class="jdocu_noborder">zero or more elements</td>
             </tr>

             <tr>
               <td class="jdocu_noborder"><code>+</code></td>
               <td class="jdocu_noborder">one or more elements</td>
             </tr>

           </tbody></table>
</p><p>
           For example, <code>[i{3,5}]</code> specifies a list of 
           3, 4 or 5 integers.
         </p></li>
       </ul>
<p>
       Inside heterogeneous lists, <code>|</code> (union) has higher precedence
       than juxtaposition; ie, <code>[i|so|n]</code> defines a list of two
       elements, the first being an integer or a string and the second
       an object or NIL.
     </p></li>
   </ul>
<p>
   <b><i>SIM_register_typed_class_attribute</i></b> will register a class
   attribute. Class attributes are the same for all instances of the class.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Returns zero if successful, and
   non-zero otherwise.</dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_General</b> Thrown if the attribute name is invalid, and if the
   attribute is not a required, optional, session or pseudo attribute.<br>
<p>
   <b>SimExc_AttrNotReadable</b> Thrown if a checkpointed attribute is not
   readable.<br>
</p><p>
   <b>SimExc_AttrNotWritable</b> Thrown if a checkpointed attribute is not
   writable.<br>
   </p><p>
   </p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_require_object">SIM_require_object()</a></h3>
<p>

<a id="device-api-functions.html:SIM_require_object2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_require_object"></a><b>SIM_require_object</b>  make sure an object is fully configured</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_require_object(conf_object_t *NOTNULL obj);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
If <i>obj</i> has not yet been set as configured, then that
     object's <b><i>finalize</i></b> method (<b><i>post_init</i></b> in
     DML) is run; otherwise, nothing happens. After completion of that
     method, <i>obj</i> will be set as configured.
  <p>
     Each object will have its <b><i>finalize</i></b> method called automatically,
     usually in hierarchical order, during object creation. Since it is only
     permitted to call methods on objects that have been configured,
     <b><i>SIM_require_object</i></b> is a way to allow such calls during
     finalisation by ensuring that those objects are correctly set up. A better
     way to call methods on other objects during finalization is to defer such
     calls to the <b><i>objects_finalized</i></b> method.
  </p><p>
     <b><i>SIM_require_object</i></b> may only be called from the
     <b><i>finalize</i></b> method of another object.
  </p><p>
     Finalisation cycles can occur if two or more objects call
     <b><i>SIM_require_object</i></b> on each other. Such cycles are treated as
     errors. To avoid them, call <b><i>SIM_set_object_configured</i></b> as soon
     as the object has reached a consistent state.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_object_is_configured">
       SIM_object_is_configured</a>, <a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_create_class">
       SIM_create_class</a>, <a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_is_restoring_state">
       SIM_is_restoring_state
     </a></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_set_attribute_default">SIM_set_attribute_default()</a></h3>
<p>

<a id="device-api-functions.html:SIM_set_attribute_default2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_set_attribute_default"></a><b>SIM_set_attribute_default</b>  set default value for an attribute in a child object</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">set_error_t
SIM_set_attribute_default(conf_object_t *NOTNULL obj, const char *NOTNULL name,
                          attr_value_t val);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<b><i>SIM_set_attribute_default</i></b> sets the default value
   for attribute <i>name</i> of object <i>obj</i>.
   The default value is used if no explicit value has been provided
   when the object is instantiated.
<p>
   After the call <i>val</i> is still owned by the caller.
</p><p>
   The function may only called while <i>obj</i> is being
   under construction and before its attributes have been set.
   More precisely, it is only legal to use this function from 
   <b><i>init_object</i></b> callbacks or from an attribute setters
   belonging to a hierarchical ancestor of the object.
</p><p>
   The main purpose of this function is setting suitable default
   attribute values for port objects.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Returns <code>Sim_Set_Ok</code>
   if successful.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_register_port">
     SIM_register_port</a>, <a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_register_class"> SIM_register_class
   </a></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_set_class_data">SIM_set_class_data()</a></h3>
<p>

<a id="device-api-functions.html:SIM_set_class_data2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_set_class_data"></a><b>SIM_set_class_data</b>  set class data</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_set_class_data(conf_class_t *cls, lang_void *data);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Set extra data for the specified class. This is particularly useful if the
   same class methods are used for multiple distinct classes, for instance for
   generated classes.
<p>
   The class data can be fetched at any time during the object initialisation,
   using <b><i>SIM_get_class_data</i></b>.</p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_get_class_data">SIM_get_class_data</a></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
</dl><p>

    </p><h2 class="jdocu"><a class="not-numbered" id="device-api-functions.html:Callbacks">Callbacks</a></h2>
<p></p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_cbdata_data">SIM_cbdata_data()</a></h3>
<p>

<a id="device-api-functions.html:SIM_cbdata_data2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_cbdata_data"></a><b>SIM_cbdata_data</b>  get cbdata data pointer</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE void *
SIM_cbdata_data(const cbdata_t *cbd);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Return the data pointer of the callback data <i>cbd</i>.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<code>cbdata_t</code></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_cbdata_type">SIM_cbdata_type()</a></h3>
<p>

<a id="device-api-functions.html:SIM_cbdata_type2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_cbdata_type"></a><b>SIM_cbdata_type</b>  get cbdata type pointer</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE const cbdata_type_t *
SIM_cbdata_type(const cbdata_t *cbd);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Return a pointer to the type information of the callback data
     <i>cbd</i>.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<code>cbdata_t</code></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_free_cbdata">SIM_free_cbdata()</a></h3>
<p>

<a id="device-api-functions.html:SIM_free_cbdata2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_free_cbdata"></a><b>SIM_free_cbdata</b>  free cbdata</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE void
SIM_free_cbdata(cbdata_t *cbd);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Free the callback data <i>cbd</i> by calling its
     <b><i>dealloc</i></b> function.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<code>cbdata_t</code></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_make_cbdata">SIM_make_cbdata()</a></h3>
<p>

<a id="device-api-functions.html:SIM_make_cbdata2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_make_cbdata"></a><b>SIM_make_cbdata</b>  create cbdata</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE cbdata_t
SIM_make_cbdata(const cbdata_type_t *type, void *data);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Create new callback data of type <i>type</i> and value
     <i>data</i>.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<code>cbdata_t</code></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_make_simple_cbdata">SIM_make_simple_cbdata()</a></h3>
<p>

<a id="device-api-functions.html:SIM_make_simple_cbdata2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_make_simple_cbdata"></a><b>SIM_make_simple_cbdata</b>  create untyped cbdata</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE cbdata_t
SIM_make_simple_cbdata(void *obj);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Create new untyped callback data of value <i>data</i>. An untyped
     callback data has no <b><i>dealloc</i></b> function.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<code>cbdata_t</code></dd>
</dl><p>

    </p><h2 class="jdocu"><a class="not-numbered" id="device-api-functions.html:Errors-and-Exceptions">Errors and Exceptions</a></h2>
<p></p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_clear_exception">SIM_clear_exception()</a></h3>
<p>

<a id="device-api-functions.html:SIM_clear_exception2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_clear_exception"></a><b>SIM_clear_exception</b>  clear pending exception</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">sim_exception_t
SIM_clear_exception();
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Clears the currently pending frontend exception and returns the value of it.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Returns the exception that was pending before
   the call, or <code>SimExc_No_Exception</code>.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
     </a><b><i>SIM_get_pending_exception</i></b>, <b><i>SIM_last_error</i></b>
   </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_describe_pseudo_exception">SIM_describe_pseudo_exception()</a></h3>
<p>

<a id="device-api-functions.html:SIM_describe_pseudo_exception2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_describe_pseudo_exception"></a><b>SIM_describe_pseudo_exception</b>  return pseudo exception description</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">const char *
SIM_describe_pseudo_exception(exception_type_t ex);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This function returns a descriptive string for the specified
   <code>exception_type_t</code>.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Exception description, or
   an error message if input is not a known pseudo-exception.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_exception_type_t">
     exception_type_t
   </a></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_get_pending_exception">SIM_get_pending_exception()</a></h3>
<p>

<a id="device-api-functions.html:SIM_get_pending_exception2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_get_pending_exception"></a><b>SIM_get_pending_exception</b>  get current pending exception</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">sim_exception_t
SIM_get_pending_exception();
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This function returns the exception type of the current pending exception,
   or <code>SimExc_No_Exception</code> if none available.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
     </a><b><i>SIM_clear_exception</i></b>, <b><i>SIM_last_error</i></b>
   </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_last_error">SIM_last_error()</a></h3>
<p>

<a id="device-api-functions.html:SIM_last_error2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_last_error"></a><b>SIM_last_error</b>  get error message from last frontend exception</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">const char *
SIM_last_error();
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns the error message associated with the most recently raised
   frontend exception, even if that exception has been cleared.
<p>
   The returned string is only valid until the next use of the Simics API
   in the same thread.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
     </a><b><i>SIM_clear_exception</i></b>, <b><i>SIM_get_pending_exception</i></b>
   </dd>
</dl><p>

    </p><h2 class="jdocu"><a class="not-numbered" id="device-api-functions.html:Notifiers">Notifiers</a></h2>
<p></p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_add_notifier">SIM_add_notifier()</a></h3>
<p>

<a id="device-api-functions.html:SIM_add_notifier2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_add_notifier"></a><b>SIM_add_notifier</b>  add a notifier callback</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">notifier_handle_t *
SIM_add_notifier(
        conf_object_t *NOTNULL obj,
        notifier_type_t type,
        conf_object_t *subscriber,
        void (*callback)(conf_object_t *subscriber,
                         conf_object_t *NOTNULL notifier,
                         lang_void *data),
        lang_void *data);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<b><i>SIM_add_notifier</i></b> installs a notifier of type <i>type</i>
   on the object <i>obj</i>.
<p>
   The <i>subscriber</i> argument should be the object listening for
   the notification; this object is passed as the first
   argument to the <i>callback</i> function. The installed callback is
   automatically removed if the subscriber object is deleted.
   It is legal to pass <code>NULL</code> in the <i>subscriber</i>
   argument if there is no object associated with the callback. 
</p><p>
   The <i>data</i> argument is passed as the last argument to the
   <i>callback</i> function.
</p><p>
   The function returns a handle to the installed notifier
   or <code>NULL</code> if the notifier type is not supported by the object.
</p><p>
   Adding a notifier callback from another notifier callback of the same
   notifier type and object does not trigger an immediate callback invocation
   (from the same call to <b><i>SIM_notify</i></b>).</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_delete_notifier">SIM_delete_notifier</a></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
       </a><b><i>SIM_delete_notifier</i></b>, <b><i>SIM_register_notifier</i></b>
   </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_class_has_notifier">SIM_class_has_notifier()</a></h3>
<p>

<a id="device-api-functions.html:SIM_class_has_notifier2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_class_has_notifier"></a><b>SIM_class_has_notifier</b>  query class for notifier</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">bool
SIM_class_has_notifier(conf_class_t *NOTNULL cls, notifier_type_t type);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<b><i>Sim_class_has_notifier</i></b> returns <code>true</code> if the class
   <i>cls</i> supports the notifier specified by <i>type</i>.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_delete_notifier">SIM_delete_notifier()</a></h3>
<p>

<a id="device-api-functions.html:SIM_delete_notifier2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_delete_notifier"></a><b>SIM_delete_notifier</b>  delete notifier callback</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_delete_notifier(conf_object_t *NOTNULL obj, notifier_handle_t *handle);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<b><i>SIM_delete_notifier</i></b> deletes the notifier callback
   specified by the handle <i>handle</i>.
<p>
   Notifiers callbacks are deleted automatically when
   the subscribing object is deleted.
</p><p>
   Deleting a notifier callback from another notifier callback of the same
   notifier type and object may or may not inhibit the last invocation of the
   deleted callback; this is undefined.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_add_notifier">SIM_add_notifier</a></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_describe_notifier">SIM_describe_notifier()</a></h3>
<p>

<a id="device-api-functions.html:SIM_describe_notifier2"></a><a id="device-api-functions.html:SIM_notifier_description"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_describe_notifier"></a><b>SIM_describe_notifier</b><b>, SIM_notifier_description</b>  set short description</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_describe_notifier(notifier_type_t type, const char *NOTNULL generic_desc);
</pre><p></p><pre class="jdocu_small">const char *
SIM_notifier_description(notifier_type_t type);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<b><i>SIM_describe_notifier</i></b> sets <i>generic_desc</i> as
   a generic description of the notification specified by the <i>type</i>
   argument. If the function is called multiple times then the description
   supplied during the last invocation of the function will be used.
   The generic description is shown when no description has been provided to the
   <b><i>SIM_register_notifier</i></b> or <b><i>SIM_register_tracked_notifier</i></b>
   functions.
<p>
   <b><i>SIM_notifier_description</i></b> returns a generic description that
   was set with the <b><i>SIM_describe_notifier</i></b>
   for the notification specified by the <i>type</i> argument, or the empty
   string if no description has been set.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_has_notifier">SIM_has_notifier()</a></h3>
<p>

<a id="device-api-functions.html:SIM_has_notifier2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_has_notifier"></a><b>SIM_has_notifier</b>  query object for notifier</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">bool
SIM_has_notifier(conf_object_t *NOTNULL obj, notifier_type_t type);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<b><i>SIM_has_notifier</i></b> returns <code>true</code> if the object
   <i>obj</i> supports the notifier specified by <i>type</i>.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<b><i>SIM_register_notifier</i></b></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_notifier_type">SIM_notifier_type()</a></h3>
<p>

<a id="device-api-functions.html:SIM_notifier_type2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_notifier_type"></a><b>SIM_notifier_type</b>  get notifier type</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">notifier_type_t
SIM_notifier_type(const char *NOTNULL type);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Given a notifier type <i>type</i> specified in the form of a
   string, return a <code>notifier_type_t</code> identifier which uniquely
   corresponds to this type.
<p>
   This function always returns a valid notifier type; if a particular
   type string has not been seen before, then a new notifier type is created
   and associated with this string.
</p><p>
   The string must consist of printable 7-bit ASCII characters, and by
   convention it should be expressed as a noun with words separated by dashes.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_notify">SIM_notify()</a></h3>
<p>

<a id="device-api-functions.html:SIM_notify2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_notify"></a><b>SIM_notify</b>  trigger notification callbacks</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_notify(conf_object_t *NOTNULL obj, notifier_type_t type);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The <b><i>SIM_notify</i></b> function triggers all callbacks
   associated with the notifier <i>notifier</i> which have been
   installed on the object <i>obj</i>.
   <p>
   The order in which notifier callbacks are invoked is undefined, but the same
   order every time.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
       </a><b><i>SIM_register_notifier</i></b>, <b><i>SIM_add_notifier</i></b>
   </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_register_notifier">SIM_register_notifier()</a></h3>
<p>

<a id="device-api-functions.html:SIM_register_notifier2"></a><a id="device-api-functions.html:SIM_register_tracked_notifier"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_register_notifier"></a><b>SIM_register_notifier</b><b>, SIM_register_tracked_notifier</b>  register notifier</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_register_notifier(conf_class_t *NOTNULL cls, notifier_type_t type,
                      const char *desc);
</pre><p></p><pre class="jdocu_small">void
SIM_register_tracked_notifier(conf_class_t *NOTNULL cls, notifier_type_t type,
                              const char *desc,
                              void (*subscribed_changed)(conf_object_t *obj,
                                                         notifier_type_t type,
                                                         bool has_subscribers));
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
These functions add the notifier <i>type</i> (returned by
   the <b><i>SIM_notifier_type</i></b> function) to the set of
   notifiers supported by the class <i>cls</i>. The <i>desc</i>
   argument can be used to provide any relevant documentation, e.g.,
   information about when the notifier is triggered and how it should be used
   by the objects that subscribe to it. For uniformity, we suggest formatting
   the description similar to this one of the "frequency-change"
   notifier: "Notifier that is triggered when frequency changes. New frequency
   can be read via the frequency interface of the object."
<p>
   <b><i>SIM_register_notifier</i></b> is the base registration function. It should
   be used in most cases.
</p><p>
   <b><i>SIM_register_tracked_notifier</i></b> accepts an additional argument -
   the <i>subscribed_changed</i> callback. This callback can be used
   to track whether any respective notification subscribers are installed.
   The callback is invoked in following cases:
   </p><ul>
   <li>a. there are no objects subscribed to <i>type</i>'s
          notifications from <i>obj</i> of <i>cls</i> class,
          and a new object subscribes to such notifications, i.e., calls
          <b><i>SIM_add_notifier</i></b>. In this case the callback is invoked
          with the <i>has_subscribers</i> argument equal to
          <code>true</code>.</li>
   <li>b. the only object that was subscribed to <i>type</i>'s
          notifications from <i>obj</i> of <i>cls</i> class
          unsubscribes from such notifications, either explicitly by a
          call to <b><i>SIM_delete_notifier</i></b>, or implicitly when the
          subscriber object is deleted.
          In this case the callback is
          invoked with the <i>has_subscribers</i> argument equal to
          <code>false</code>.</li>
   </ul>
<p>
   If the <i>subscribed_changed</i> argument is equal to
   <code>NULL</code> then it is just ignored.
</p><p>
   The <b><i>subscribed_changed</i></b> callback is not invoked while the notifier
   object is being deleted. Thus, if the callback relies on data structures
   owned by the notifier object, then it is still safe for the object's
   destructor to deinitialize these data structures needed by the
   callback.
</p><p>
   It is legal to call <b><i>SIM_register_notifier</i></b> multiple times for
   the same class and the same notifier type. All subsequent invocations done
   after the notifier was registered are ignored. Calling
   <b><i>SIM_register_tracked_notifier</i></b> multiple times registers multiple
   <i>subscribed_changed</i> callbacks. All of them will be invoked as
   it is specified above.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
       </a><b><i>SIM_notifier_type</i></b>,
       <b><i>SIM_notify</i></b>, <b><i>SIM_add_notifier</i></b>
   </dd>
</dl><p>

    </p><h2 class="jdocu"><a class="not-numbered" id="device-api-functions.html:Global-Notifiers">Global Notifiers</a></h2>
<p></p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_add_global_notifier">SIM_add_global_notifier()</a></h3>
<p>

<a id="device-api-functions.html:SIM_add_global_notifier2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_add_global_notifier"></a><b>SIM_add_global_notifier</b>  add a global notifier callback</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">global_notifier_callback_t *
SIM_add_global_notifier(
        global_notifier_type_t type,
        conf_object_t *subscriber,
        void (*callback)(conf_object_t *subscriber, lang_void *data),
        lang_void *data);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<b><i>SIM_add_global_notifier</i></b> installs a callback on the global
   notifier of type <i>type</i>. The callback will be executed in
   Global Context. The callback can uninstall itself, using
   <b><i>SIM_delete_global_notifier</i></b>, but must not uninstall any other
   global notifiers.
<p>
   The <i>subscriber</i> argument should be the object listening on
   the notifier; this object is passed as the first
   argument to the callback. The installed callback is automatically
   removed if the subscriber object is deleted.
   It is legal to pass <code>NULL</code> in the <i>subscriber</i>
   argument if there is no object associated with the callback. 
</p><p>
   The function returns a handle to the installed callback
   or <code>NULL</code> if the notifier type is unknown.
</p><p>
   Adding a notifier callback from another notifier callback of the same
   notifier type does not trigger an immediate callback invocation.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_add_global_notifier_once">SIM_add_global_notifier_once()</a></h3>
<p>

<a id="device-api-functions.html:SIM_add_global_notifier_once2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_add_global_notifier_once"></a><b>SIM_add_global_notifier_once</b>  add a global notifier callback</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">global_notifier_callback_t *
SIM_add_global_notifier_once(
        global_notifier_type_t type,
        conf_object_t *subscriber,
        void (*callback)(conf_object_t *subscriber, lang_void *data),
        lang_void *data);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The <b><i>SIM_add_global_notifier_once</i></b> is similar to
   <b><i>SIM_add_global_notifier</i></b>, except that the notifier will be removed
   automatically after the callback has been called once.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_delete_global_notifier">SIM_delete_global_notifier()</a></h3>
<p>

<a id="device-api-functions.html:SIM_delete_global_notifier2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_delete_global_notifier"></a><b>SIM_delete_global_notifier</b>  delete global notifier callback</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_delete_global_notifier(global_notifier_callback_t *handle);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<b><i>SIM_delete_global_notifier</i></b> deletes the global notifier callback
   specified by the handle <i>handle</i>.
<p>
   Global notifier callbacks are deleted automatically when
   the subscribing object is deleted.
</p><p>
   Deleting a notifier callback from another notifier callback of the same
   notifier type may or may not inhibit the last invocation of the deleted
   callback; this is undefined.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
</dl><p>

    </p><h2 class="jdocu"><a class="not-numbered" id="device-api-functions.html:Haps">Haps</a></h2>
<p></p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_hap_add_type">SIM_hap_add_type()</a></h3>
<p>

<a id="device-api-functions.html:SIM_hap_add_type2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_hap_add_type"></a><b>SIM_hap_add_type</b>  register a new hap type</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">hap_type_t
SIM_hap_add_type(const char *NOTNULL hap,
                 const char *NOTNULL params,
                 const char *param_desc,
                 const char *index,
                 const char *desc,
                 int unused);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Creates a run-time defined hap type. 
<p>
   The <i>params</i> parameter specifies the argument that callbacks
   for this hap is called with; e.g., <code>"s"</code> or
   <code>"II"</code>. The first two arguments are always <code>lang_void *</code>
   and <code>conf_object_t *</code> respectively, and should not be included
   in that string. The table below shows which characters may be used, and
   what their meaning is:
</p><p>
   <table>

   <tbody><tr><td class="jdocu_noborder"><code>i</code></td><td class="jdocu_noborder">an int</td></tr>

   <tr><td class="jdocu_noborder"><code>I</code></td><td class="jdocu_noborder">an int64 (64 bit integer)</td></tr>

   <tr><td class="jdocu_noborder"><code>e</code></td><td class="jdocu_noborder">an <code>exception_type_t</code></td></tr>

   <tr><td class="jdocu_noborder"><code>o</code></td><td class="jdocu_noborder">a script specific object; i.e.,
           <code>void *</code> in C and any Python object in Python</td></tr>

   <tr><td class="jdocu_noborder"><code>s</code></td><td class="jdocu_noborder">a string</td></tr>

   <tr><td class="jdocu_noborder"><code>m</code></td><td class="jdocu_noborder">a memory transaction
           (<code>generic_transaction_t *</code> in C)</td></tr>

   <tr><td class="jdocu_noborder"><code>c</code></td><td class="jdocu_noborder">a configuration object
           (<code>conf_object_t *</code> in C)</td></tr>

   </tbody></table>
</p><p>
   <i>param_desc</i> should be a string of space-separated
   parameter names, or NULL if <i>params</i> is the empty
   string. There should be one word in <i>param_desc</i> for each
   character in <i>params</i>.
</p><p>
   <i>index</i> is a string describing the index value for this hap, or
   NULL if there is no index value.
</p><p>
   <i>desc</i> is a description string for the hap.</p></dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_General</b> Thrown if hap is already defined.  However, consequent
   calls with the same parameters will be successful, and return the same hap
   type number each time.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
The hap type
   number or -1 on error.
<p>
   </p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_hap_get_name">SIM_hap_get_name()</a></h3>
<p>

<a id="device-api-functions.html:SIM_hap_get_name2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_hap_get_name"></a><b>SIM_hap_get_name</b>  get hap name by number</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">const char *
SIM_hap_get_name(hap_type_t hap);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns the name of <i>hap</i>, or <code>NULL</code> for no
   such hap. The returned value is a static string that should not
   be modified or freed by the caller.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_hap_get_number">SIM_hap_get_number()</a></h3>
<p>

<a id="device-api-functions.html:SIM_hap_get_number2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_hap_get_number"></a><b>SIM_hap_get_number</b>  get hap number by name</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">hap_type_t
SIM_hap_get_number(const char *NOTNULL hap);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Return the runtime number associated with a hap identifier. All haps are
   listed in the <em>Haps</em> chapter in each reference manual.</dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_Lookup</b> Thrown if no hap is associated with name <i>hap</i>.
<p>
   </p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
The hap type number, or 0 on failure.
   </dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_hap_is_active">SIM_hap_is_active()</a></h3>
<p>

<a id="device-api-functions.html:SIM_hap_is_active2"></a><a id="device-api-functions.html:SIM_hap_is_active_obj"></a><a id="device-api-functions.html:SIM_hap_is_active_obj_idx"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_hap_is_active"></a><b>SIM_hap_is_active</b><b>, SIM_hap_is_active_obj</b><b>, SIM_hap_is_active_obj_idx</b>  check if hap has callbacks</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">bool
SIM_hap_is_active(hap_type_t hap);
</pre><p></p><pre class="jdocu_small">bool
SIM_hap_is_active_obj(hap_type_t hap, conf_object_t *NOTNULL obj);
</pre><p></p><pre class="jdocu_small">bool
SIM_hap_is_active_obj_idx(hap_type_t hap, conf_object_t *NOTNULL obj,
                          int64 index);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Indicate whether the hap has any callback functions to be called
   when the hap is triggered with the given arguments (object and
   index). The return value is approximate: if false, no functions
   would be called; if true, there may be functions to call.
<p>
   The <b><i>SIM_hap_is_active</i></b> function should be avoided; it may be
   slower and less precise than the other variants.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_hap_occurred_always">SIM_hap_occurred_always()</a></h3>
<p>

<a id="device-api-functions.html:SIM_hap_occurred_always2"></a><a id="device-api-functions.html:SIM_c_hap_occurred_always_vararg"></a><a id="device-api-functions.html:SIM_c_hap_occurred_always"></a><a id="device-api-functions.html:SIM_hap_occurred"></a><a id="device-api-functions.html:SIM_c_hap_occurred_vararg"></a><a id="device-api-functions.html:SIM_c_hap_occurred"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_hap_occurred_always"></a><b>SIM_hap_occurred_always</b><b>, SIM_c_hap_occurred_always_vararg</b><b>, SIM_c_hap_occurred_always</b><b>, SIM_hap_occurred</b><b>, SIM_c_hap_occurred_vararg</b><b>, SIM_c_hap_occurred</b>  trigger a hap occurrence</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">int
SIM_hap_occurred_always(hap_type_t hap, conf_object_t *obj,
                        int64 value, attr_value_t *NOTNULL list);
</pre><p></p><pre class="jdocu_small">int
SIM_c_hap_occurred_always_vararg(hap_type_t hap, conf_object_t *obj,
                                 int64 value, va_list ap);
</pre><p></p><pre class="jdocu_small">int
SIM_c_hap_occurred_always(hap_type_t hap, conf_object_t *obj,
                          int64 value, ...);
</pre><p></p><pre class="jdocu_small">int
SIM_hap_occurred(hap_type_t hap, conf_object_t *obj,
                 int64 value, attr_value_t *NOTNULL list);
</pre><p></p><pre class="jdocu_small">int
SIM_c_hap_occurred_vararg(hap_type_t hap, conf_object_t *obj,
                          int64 value, va_list ap);
</pre><p></p><pre class="jdocu_small">int
SIM_c_hap_occurred(hap_type_t hap, conf_object_t *obj,
                   int64 value, ...);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
These functions are used to trigger a hap of type <code>hap</code>. When a hap
   triggers, all callback functions installed on the hap are called.
<p>
   The <code>obj</code> argument is the object that the hap triggering is
   associated with. It may be NULL for haps that are not associated with an
   object.
</p><p>
   The <code>value</code> argument is used for filtering out callback functions to
   call based on the index or range that they are installed for. What the
   index or range corresponds to is hap specific, but could for example be the
   exception number for the <code>Core_Exception</code> hap.
</p><p>
   SIM_hap_occurred() will only call the callbacks once every simulated cycle;
   if this hap is triggered several times during one cycle, the callbacks will
   still only be called once. The SIM_hap_occurred_always() function will
   always call the hap callback functions every time. It is recommended that
   SIM_hap_occurred_always() is used.
</p><p>
   These hap triggering functions return whether or not there were any matching
   callback function registered on the hap. This can be useful information when
   one wants a default behavior to be triggered (for example, stopping the
   simulation) if nobody is listening to the hap.
</p><p>
   The hap-specific parameters to the callback function can be passed in
   various ways: The <b><i>SIM_c_hap_occurred...</i></b> functions are only
   available in C/C++ and are variadic or take a <code>va_list</code> as argument.
   <b><i>SIM_hap_occurred</i></b> and <b><i>SIM_hap_occurred_always</i></b> are
   mainly intended to be used from Python, taking the parameters from an
   attribute value of list type, or an empty list (<code>[]</code>) if no
   parameters are passed. In all cases, the number and types of passed
   parameters must agree with the hap type definition.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
The return value is 0 if no callbacks are
   registered on the hap and non-zero if there are callbacks registered.
   </dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_General</b> Thrown if <code>hap</code> is not a valid hap type or if
   the values in the <code>list</code> argument are of the wrong type.
   <p>
   </p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_hap_remove_type">SIM_hap_remove_type()</a></h3>
<p>

<a id="device-api-functions.html:SIM_hap_remove_type2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_hap_remove_type"></a><b>SIM_hap_remove_type</b>  remove a hap type</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_hap_remove_type(const char *NOTNULL hap);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Remove a run-time defined hap type.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
</dl><p>

    </p><h2 class="jdocu"><a class="not-numbered" id="device-api-functions.html:Logging">Logging</a></h2>
<p></p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_log_info">SIM_log_info()</a></h3>
<p>

<a id="device-api-functions.html:SIM_log_info2"></a><a id="device-api-functions.html:SIM_log_spec_violation"></a><a id="device-api-functions.html:SIM_log_unimplemented"></a><a id="device-api-functions.html:SIM_log_error"></a><a id="device-api-functions.html:SIM_log_critical"></a><a id="device-api-functions.html:SIM_log_message"></a><a id="device-api-functions.html:SIM_log_message_vararg"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_log_info"></a><b>SIM_log_info</b><b>, SIM_log_spec_violation</b><b>, SIM_log_unimplemented</b><b>, SIM_log_error</b><b>, SIM_log_critical</b><b>, SIM_log_message</b><b>, SIM_log_message_vararg</b>  output log message</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_log_info(int level, conf_object_t *NOTNULL dev, int grp,
             const char *NOTNULL fmt, ...);
</pre><p></p><pre class="jdocu_small">void
SIM_log_spec_violation(int level, conf_object_t *NOTNULL dev, int grp,
                       const char *NOTNULL fmt, ...);
</pre><p></p><pre class="jdocu_small">void
SIM_log_unimplemented(int level, conf_object_t *NOTNULL dev, int grp,
                      const char *NOTNULL fmt, ...);
</pre><p></p><pre class="jdocu_small">void
SIM_log_error(conf_object_t *NOTNULL dev, int grp,
              const char *NOTNULL fmt, ...);
</pre><p></p><pre class="jdocu_small">void
SIM_log_critical(conf_object_t *NOTNULL dev, int grp,
                 const char *NOTNULL fmt, ...);
</pre><p></p><pre class="jdocu_small">void
SIM_log_message(conf_object_t *obj, int level, uint64 group_ids,
                log_type_t log_type, const char *message);
</pre><p></p><pre class="jdocu_small">void
SIM_log_message_vararg(conf_object_t *NOTNULL obj, int level, uint64 grp,
                       log_type_t log_type, const char *NOTNULL fmt, ...);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<pre class="jdocu_small">SIM_log_warning(dev, grp, msg)  #  Python-only</pre><p>
</p><p>
   Logging functions and macros are used to emit information and error messages.
</p><p>
   The functions above should only be used in Python. In C they are
   <b>deprecated</b> and the following preprocessor macros can be used instead.
</p><p>
   </p><pre class="jdocu_small">#define SIM_LOG_INFO(level, dev, grp, ...)
#define SIM_LOG_SPEC_VIOLATION(level, dev, grp, ...)
#define SIM_LOG_UNIMPLEMENTED(level, dev, grp, ...)
#define SIM_LOG_ERROR(dev, grp, ...)
#define SIM_LOG_WARNING(dev, grp, ...)
#define SIM_LOG_CRITICAL(dev, grp, ...)
#define SIM_LOG_INFO_ONCE(level1, level2, dev, grp, ...)
#define SIM_LOG_SPEC_VIOLATION_ONCE(level1, level2, dev, grp, ...)
#define SIM_LOG_UNIMPLEMENTED_ONCE(level1, level2, dev, grp, ...)
#define SIM_LOG_WARNING_ONCE(dev, grp, ...)</pre><p>
</p><p>
   The logging macros are among the few API features that may be
   called while a frontend exception is pending.
</p><p>
   The <i>level</i> parameter indicates the importance; a lower value
   means a more important message.
</p><p>
   <i>level</i> should be between 1 and 4:
   </p><ol>
     <li>important messages that are always printed</li>
     <li>"high-level" informative messages</li>
     <li>standard debug messages</li>
     <li>detailed information, such as register accesses</li>
   </ol>
<p>
   SIM_LOG_ERROR has no <i>level</i> parameter and will always emit
   messages.
</p><p>
   The <i>grp</i> parameter should have a bit set for each log
   group that the message corresponds to, as defined by the
   <b><i>SIM_log_register_groups</i></b> function, while a value of 0
   equals <i>any</i> group.
</p><p>
   The <i>level</i> and <i>grp</i> parameters allow
   the user to selectively display more or fewer messages using the
   <b>log-level</b>, <b>log-group</b> and <b>log-type</b>
   commands.
</p><p>
   The <i>fmt</i> argument and those following it are used for string
   formatting in the same way as in the standard <b><i>sprintf</i></b> function.
</p><p>
   The use of the different functions and macros is discussed in
   <em>Simics Model Builder User's Guide</em>, section "Logging":
   </p><ul>
     <li><em>info</em>: Normal informational message</li>
     <li><em>warning</em>: Unexpected problem in the model, but simulation
         can continue.</li>
     <li><em>error</em>: Unexpected error in the model
         (indicates a bug in the model)</li>
     <li><em>critical</em>: Critical error that will interrupt the simulation
         (indicates a bug that the model may not recover from)</li>
     <li><em>spec_violation</em>: Target program violates the specification</li>
     <li><em>unimplemented</em>: Attempt to use not yet implemented
         functionality</li>
   </ul>
   If the <i>sim-&gt;stop_on_error</i> attribute is set to true, for
   example if Simics was started with the <code>--stop-on-error</code> command
   line flag, then Simics will exit with an error code when a log message of the
   <em>error</em> type is generated.
<p>
   If the <i>sim-&gt;warnings_as_errors</i> attribute is set to true, for
   example if Simics was started with the <code>--warnings-as-errors</code> command
   line flag, then a log warning has the same effect as a log error.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
All contexts (including Threaded Context)
   </dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
     </a><b><i>SIM_log_register_groups</i></b>, <b><i>SIM_attribute_error</i></b>
   </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_log_level">SIM_log_level()</a></h3>
<p>

<a id="device-api-functions.html:SIM_log_level2"></a><a id="device-api-functions.html:SIM_set_log_level"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_log_level"></a><b>SIM_log_level</b><b>, SIM_set_log_level</b>  set and get log level</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">unsigned
SIM_log_level(const conf_object_t *NOTNULL obj);
</pre><p></p><pre class="jdocu_small">void
SIM_set_log_level(conf_object_t *NOTNULL obj, unsigned level);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Retrieve or set the log level of an object.
   The level must be in the range 0..4 inclusive.
   Higher values mean more detailed logging.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_log_register_groups">SIM_log_register_groups()</a></h3>
<p>

<a id="device-api-functions.html:SIM_log_register_groups2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_log_register_groups"></a><b>SIM_log_register_groups</b>  register names of log groups</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_log_register_groups(conf_class_t *NOTNULL cls,
                        const char *const *NOTNULL names);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Register a list of log groups that an object can
   use to separate messages. The order of the groups in the list defines the
   group ids that should be used in calls to <b><i>SIM_log_info</i></b> and
   similar functions. The <i>group_ids</i> argument to those functions
   should have a bit set corresponding to the group; i.e., a value of 1 for the
   first group, 2 for the second, 4 for the third, etc. <i>names</i>
   should be a <code>NULL</code>-terminated array.
<p>
   A class may have up to 63 user-defined log groups.
</p><p>
   The <code>Default_Log_Group</code> group is present on all classes. It is used
   for log entries where no group is specified.</p></dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_General</b> Thrown in case of an error, e.g. if log groups are
   already registered.<br>
<p>
   </p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<b><i>SIM_log_info</i></b></dd>
</dl><p>

    </p><h2 class="jdocu"><a class="not-numbered" id="device-api-functions.html:Transaction-Types">Transaction Types</a></h2>
<p></p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:atom_id_t">atom_id_t</a></h3>
<p>
     
     
   <a id="device-api-functions.html:atom_id_t2"></a>
   
   </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_atom_id_t"></a>atom_id_t</dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Each atom type is associated
   with a unique id, the <code>atom_id_t</code>. Most atoms types are
   pre-defined by Simics Core and have static ids, but there are
   also dynamically assigned ids which are used for custom atom types.
<p>
   Atom ids are internal to Simics Core and should never be used explicitly
   by a Simics models. Instead, there are API functions like
   e.g. <b><i>ATOM_size</i></b> or <b><i>ATOM_initiator</i></b> which should be
   used instead.
   </p></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:atom_t">atom_t</a></h3>
<p>
     
     
   <a id="device-api-functions.html:atom_t2"></a>
   
   </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_atom_t"></a>atom_t</dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The <code>atom_t</code> type is a container
   type for tagged data associated with a transaction. The kind of data
   stored in the atom is determined by the <i>id</i> field, and a pointer
   to the data or the data itself is stored in the <i>ptr</i> field.
<p>
   Atoms should always be initialized using provided constructor functions
   like <b><i>ATOM_flags</i></b> or <b><i>ATOM_size</i></b>. Usage of
   the constructors ensures that the data payload is of the correct type
   and that the <b><i>id</i></b> is set to the correct value.
</p><p>
   Atom lists must be terminated with the special <code>ATOM_LIST_END</code>
   marker.
   </p></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:transaction_completion_t">transaction_completion_t</a></h3>
<p>
     
     
   <a id="device-api-functions.html:transaction_completion_t2"></a>
   
   </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_transaction_completion_t"></a>transaction_completion_t</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">typedef exception_type_t (*transaction_completion_t)(
        conf_object_t *obj, transaction_t *t, exception_type_t ex);</pre><p>
</p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Callback invoked when an asynchronous transaction is completed.
   The callback is stored in a <code>completion</code> atom belonging
   to the transaction <i>t</i>. Similarly, <i>obj</i> is an
   object stored in either an <code>owner</code> atom or an
   <code>initiator</code> atom. The former takes precedence if both are
   present.
<p>
   Completion callbacks are only invoked for transactions monitored
   with either <b><i>SIM_monitor_transaction</i></b> or
   <b><i>SIM_monitor_chained_transaction</i></b>, or for transactions
   deferred with <b><i>SIM_defer_owned_transaction</i></b>.
</p><p>
   The completion status for the operation is given in the
   <i>ex</i> argument, and is usually equal to
   <code>Sim_PE_No_Exception</code>.
</p><p>
   The return value of the callback is the completion status
   for the transaction <i>t</i>. This status is used to complete
   the parent transaction if the transaction is being monitored with
   <b><i>SIM_monitor_chained_transaction</i></b>. The return value is
   also returned by <b><i>SIM_monitor_transaction</i></b> or
   <b><i>SIM_monitor_chained_transaction</i></b> when a transaction is
   completed synchronously.
</p><p>
   If the callback returns <code>Sim_PE_Deferred</code>, then
   the transaction <i>t</i> is left uncompleted. It must then
   be completed later on by an explicit call to
   <b><i>SIM_complete_transaction</i></b>.
</p><p>
   </p></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:transaction_flags_t">transaction_flags_t</a></h3>
<p>
     
     
   <a id="device-api-functions.html:transaction_flags_t2"></a>
   
   </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_transaction_flags_t"></a>transaction_flags_t</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">typedef enum {
        Sim_Transaction_Fetch         = 1 &lt;&lt; 0,
        Sim_Transaction_Write         = 1 &lt;&lt; 1,
        Sim_Transaction_Control       = 1 &lt;&lt; 2,

        Sim_Transaction_Inquiry       = 1 &lt;&lt; 8,
        Sim_Transaction_Incoherent    = 1 &lt;&lt; 9,
        Sim_Transaction_Atomic        = 1 &lt;&lt; 10,
} transaction_flags_t;</pre><p>
</p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The <code>transaction_flags_t</code> type is bitmask
   used to specify the transaction type. It is a combination
   of the following bits:
<p>
   <code>Sim_Transaction_Fetch</code> indicates that the transaction is
   an instruction fetch.
</p><p>
   <code>Sim_Transaction_Write</code> is set if the transaction is a write.
</p><p>
   <code>Sim_Transaction_Control</code> is set if the transaction does not
   actually transfer any data. One example of such transactions is
   cache control operations.
</p><p>
   The <code>Sim_Transaction_Inquiry</code> bit signifies that side
   effects normally triggered by the transaction should be suppressed.
   Examples of side effects include triggering breakpoints and
   clearing "read-to-clear" device registers.
</p><p>
   When neither <code>Sim_Transaction_Fetch</code>
   nor <code>Sim_Transaction_Write</code> is set the transaction is
   a read transaction.
</p><p>
   </p></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:transaction_t">transaction_t</a></h3>
<p>
     
     
   <a id="device-api-functions.html:transaction_t2"></a>
   
   </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_transaction_t"></a>transaction_t</dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
A <code>transaction_t</code>
   represents a memory transaction. The properties of the
   transaction is stored in the form of an atom list, where each
   atom describes a particular aspect of the transaction, like the
   size of the transaction.
<p>
   The field <i>atoms</i> points to the atoms list,
   which must be terminated with the constant <code>ATOM_LIST_END</code>.
</p><p>
   The <i>prev</i> field points to an optional parent transaction.
   If a particular atom is not found in the atoms list, then the
   parent's list of atoms is consulted instead. The <i>prev</i>
   pointer is also used when a chained transaction is monitored
   with <b><i>SIM_monitor_chained_transaction</i></b>.
</p><p>
   Besides the fields above, the transaction contains some internal
   fields that should be initialized to 0. The internal fields should
   not be referenced explicitly since they are likely to change
   in future Simics releases.
</p><p>
   For details, please refer to "Transactions" chapter in
   the Model Builder's User Guide.
</p><p>
   </p></dd>
</dl><p>
    </p><h2 class="jdocu"><a class="not-numbered" id="device-api-functions.html:Transactions">Transactions</a></h2>
<p></p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:ATOM_flags">ATOM_flags()</a></h3>
<p>

<a id="device-api-functions.html:ATOM_flags2"></a><a id="device-api-functions.html:ATOM_data"></a><a id="device-api-functions.html:ATOM_size"></a><a id="device-api-functions.html:ATOM_initiator"></a><a id="device-api-functions.html:ATOM_completion"></a><a id="device-api-functions.html:ATOM_list_end"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_ATOM_flags"></a><b>ATOM_flags</b><b>, ATOM_data</b><b>, ATOM_size</b><b>, ATOM_initiator</b><b>, ATOM_completion</b><b>, ATOM_list_end</b>  transaction atom's constructor</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">static inline atom_t ATOM_flags(transaction_flags_t val);
</pre><p></p><pre class="jdocu_small">static inline atom_t ATOM_data(uint8 *val);
</pre><p></p><pre class="jdocu_small">static inline atom_t ATOM_size(uint32 val);
</pre><p></p><pre class="jdocu_small">static inline atom_t ATOM_initiator(conf_object_t *val);
</pre><p></p><pre class="jdocu_small">static inline atom_t ATOM_completion(transaction_completion_t val);
</pre><p></p><pre class="jdocu_small">static inline atom_t ATOM_list_end(int val);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The functions construct transaction atoms.
<p>
   <b><i>ATOM_flags</i></b> returns a transaction atom specifying transaction
   flags (see description of <code>transaction_flags_t</code> for information
   about available transaction flags).
</p><p>
   <b><i>ATOM_data</i></b> returns a transaction atom that holds the pointer
   to a buffer that is used to get the data from (for write transactions)
   to store the data to (for read and instruction fetch transactions).
</p><p>
   <b><i>ATOM_size</i></b> returns a transaction atom that holds
   the size of a transaction.
</p><p>
   <b><i>ATOM_initiator</i></b> returns a transaction atom that holds
   the initiator of a transaction.
</p><p>
   <b><i>ATOM_completion</i></b> creates a completion atom - a special atom
   that holds a callback that is invoked when a transaction is completed
   asynchronously.
</p><p>
   <b><i>ATOM_list_end</i></b> returns a special atom that should end the list
   of transaction atoms. One can use the <code>ATOM_LIST_END</code> macro instead.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
An atom value</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
All contexts (including Threaded Context)</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
Sample C code to create a 1-byte read transaction:
   <span class="jdocu_small">
   <pre class="jdocu_small">     uint8 val;
     atom_t atoms[] = {
         // the flags atom value specifies the transaction type:
         // - 0 defines a read transaction
         // - Sim_Transaction_Write - a write transaction
         // - Sim_Transaction_Fetch - an instruction fetch transaction
         ATOM_flags(0),

         ATOM_data(&amp;val),
         ATOM_size(sizeof val),
         ATOM_initiator(obj),
         ATOM_LIST_END
     };
     transaction_t t = { atoms };
   </pre><p>
   
   </p></span></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
       </a><code>transaction_t</code>, <code>transaction_flags_t</code>,
       <code>transaction_completion_t</code>
   </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_complete_transaction">SIM_complete_transaction()</a></h3>
<p>

<a id="device-api-functions.html:SIM_complete_transaction2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_complete_transaction"></a><b>SIM_complete_transaction</b>  complete a deferred transaction</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_complete_transaction(transaction_t *t, exception_type_t status);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The <b><i>SIM_complete_transaction</i></b> completes a previously
   deferred transaction <i>t</i> using the exception status
   <i>status</i>. The transaction <i>t</i> must be the
   return value of a previous call to <b><i>SIM_defer_transaction</i></b>
   or a transaction passed to <b><i>SIM_defer_owned_transaction</i></b>.
<p>
   If the transaction <i>t</i> has not been monitored, then the
   completion code is stored in an internal transaction field
   until the transaction is monitored with <b><i>SIM_monitor_transaction</i></b>
   or <b><i>SIM_monitor_chained_transaction</i></b>, at which time
   the completion callback is invoked using the stored completion code.
</p><p>
   Note that <b><i>SIM_complete_transaction</i></b> is normally only used
   to complete asynchronous transactions. Synchronous transactions are
   completed by returning the appropriate return code directly
   from the <b><i>issue</i></b> method.</p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
        </a><b><i>SIM_defer_transaction</i></b>,
        <b><i>SIM_monitor_transaction</i></b>,
        <b><i>SIM_monitor_chained_transaction</i></b>,
        <b><i>SIM_poll_transaction</i></b>
   </dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_defer_owned_transaction">SIM_defer_owned_transaction()</a></h3>
<p>

<a id="device-api-functions.html:SIM_defer_owned_transaction2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_defer_owned_transaction"></a><b>SIM_defer_owned_transaction</b>  defer transaction completion using an existing transaction</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">transaction_t *
SIM_defer_owned_transaction(transaction_t *t);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
When a transaction cannot be completed immediately in the <b><i>issue</i></b>
   method of the <code>transaction</code> interface, then the completion
   can be deferred to a later time by calling <b><i>SIM_defer_transaction</i></b>
   which allocates a new transaction. One alternative is calling
   <b><i>SIM_defer_owned_transaction</i></b> which allows the caller to
   allocate the deferred transaction explicitly, in which case
   provides a heap-allocated transaction <i>t</i> which is linked
   to the transaction which should be deferred through its <i>prev</i>
   field. The provided transaction should have an <code>owner</code> and a
   <code>completion</code> atoms, which are used when the deferred
   transaction is completed.
<p>
   When a transaction is deferred, the status code
   <code>Sim_PE_Deferred</code> must be returned from
   the <b><i>issue</i></b> method of the <code>transaction</code> interface.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
The transaction <i>t</i>, or <code>NULL</code>
   if the transaction was issued synchronously and cannot be deferred.
   When a transaction cannot be deferred, the <b><i>issue</i></b> method
   may choose to return the error status
   <code>Sim_PE_Async_Required</code>.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_defer_transaction">SIM_defer_transaction()</a></h3>
<p>

<a id="device-api-functions.html:SIM_defer_transaction2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_defer_transaction"></a><b>SIM_defer_transaction</b>  defer transaction completion</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">transaction_t *
SIM_defer_transaction(conf_object_t *obj, transaction_t *t);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
When a transaction cannot be completed immediately in the <b><i>issue</i></b>
   method of the <code>transaction</code> interface, then the completion
   can be deferred to a later time by calling <b><i>SIM_defer_transaction</i></b>
   with the transaction as a parameter.
<p>
   The <b><i>SIM_defer_transaction</i></b> function returns a new transaction
   pointer which is guaranteed to be available until it is completed
   with a call to <b><i>SIM_complete_transaction</i></b>.
   When a transaction is deferred, the status code
   <code>Sim_PE_Deferred</code> must be returned from
   the <b><i>issue</i></b> method of the <code>transaction</code> interface.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Deferred transaction, or <code>NULL</code>
   if the transaction was issued synchronously and cannot be deferred.
   When a transaction cannot be deferred, the <b><i>issue</i></b> method
   may choose to return the error status
   <code>Sim_PE_Async_Required</code>.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_get_transaction_bytes">SIM_get_transaction_bytes()</a></h3>
<p>

<a id="device-api-functions.html:SIM_get_transaction_bytes2"></a><a id="device-api-functions.html:SIM_get_transaction_bytes_offs"></a><a id="device-api-functions.html:SIM_get_transaction_value_le"></a><a id="device-api-functions.html:SIM_get_transaction_value_be"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_get_transaction_bytes"></a><b>SIM_get_transaction_bytes</b><b>, SIM_get_transaction_bytes_offs</b><b>, SIM_get_transaction_value_le</b><b>, SIM_get_transaction_value_be</b>  get transaction data payload</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_get_transaction_bytes(const transaction_t *t, buffer_t buf);
</pre><p></p><pre class="jdocu_small">void
SIM_get_transaction_bytes_offs(const transaction_t *t, unsigned offs,
                               buffer_t buf, bool zerofill_holes);
</pre><p></p><pre class="jdocu_small">uint64
SIM_get_transaction_value_le(const transaction_t *t);
</pre><p></p><pre class="jdocu_small">uint64
SIM_get_transaction_value_be(const transaction_t *t);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Copy the data payload from a transaction to the provided buffer
   <i>buf</i>. The size of the buffer must match the size of the
   transaction.
<p>
   <b><i>SIM_get_transaction_bytes_offs</i></b> retrieves
   the bytes of the transaction which starts at offset <i>offs</i>.
   The sum of the offset and the buffer size must not
   exceed the transaction size.
   </p><p>
   <b><i>SIM_get_transaction_value_le</i></b> returns the value obtained
   when the transaction buffer is interpreted as an encoded
   little endian integer. The size of the transaction must
   not exceed 8 for this function to be used.
   </p><p>
   <b><i>SIM_get_transaction_value_be</i></b> returns the value obtained
   when the transaction buffer is interpreted as an encoded
   big endian integer.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
All contexts (including Threaded Context)
   </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_get_transaction_id">SIM_get_transaction_id()</a></h3>
<p>

<a id="device-api-functions.html:SIM_get_transaction_id2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_get_transaction_id"></a><b>SIM_get_transaction_id</b>  obtain checkpoint ID for a deferred a transaction</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">int64
SIM_get_transaction_id(transaction_t *t);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The <b><i>SIM_get_transaction_id</i></b> function is used by objects that
   checkpoint the transaction state. The returned ID uniquely identifies the
   transaction and should be stored in a checkpoint together with the relevant
   state that the object keeps for the transaction. The same ID should then be
   given to <b><i>SIM_reconnect_transaction</i></b> during checkpoint load.
<p>
   This function must only be called on a deferred transaction.</p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
        </a><b><i>SIM_reconnect_transaction</i></b>
   </dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_inspect_address_routing">SIM_inspect_address_routing()</a></h3>
<p>

<a id="device-api-functions.html:SIM_inspect_address_routing2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_inspect_address_routing"></a><b>SIM_inspect_address_routing</b>  track the route of a transaction through memory hierarchy</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">bool
SIM_inspect_address_routing(const map_target_t *NOTNULL mt,
                            transaction_t *NOTNULL t,
                            uint64 addr,
                            bool (*NOTNULL callback)(
                                    const map_target_t *mt,
                                    const transaction_t *t,
                                    uint64 addr,
                                    uint64 base,
                                    uint64 start,
                                    uint64 size,
                                    access_t access,
                                    translation_flags_t flags,
                                    lang_void *data),
                            lang_void *data);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This function allows to track the route of a transaction through memory
   hierarchy. The route is traced as if the transaction <i>t</i> was
   issued at the address <i>addr</i> to the destination represented
   by the map target <i>mt</i>. Note that when this function is used
   the endpoint of the transaction will not be accessed.
<p>
   The transaction <i>t</i> can be of any type: a read, a write, or an
   instruction fetch. Please note that the type of the transaction may affect
   its path through memory hierarchy. The size of the transaction
   <i>t</i> is ignored: when accesses are done larger transactions
   may be split depending on how the memory mapping are set up;
   no such splitting is occurred while the transaction route is traced with
   <b><i>SIM_inspect_address_routing</i></b>. It is allowed to use transactions
   with zero size.
</p><p>
   The <i>callback</i> callback will be called for every device (memory
   spaces and translator objects) encountered on the transactions route to the
   destination as well as for the destination device (this is usually a device
   implementing the <code>transaction</code> interface or the
   <code>io_memory</code> interface). The first invocation of
   <i>callback</i> is done with the <i>mt</i> argument itself.
</p><p>
   The arguments passed to the callback are:<br>
</p><p>
   - <i>mt</i> is a map target representing an intermediate device or
     the endpoint. If nothing is mapped then <code>NULL</code> (or <code>None</code>
     in Python) value is passed. The map target value should not be cached
     but it can be inspected<br>
</p><p>
   - <i>t</i> is usually the original transaction, but it can be also a
     new transaction in the case when additional atoms were appended to the
     original transaction via the transaction chaining (see, e.g., the
     documentation for the <code>transaction_translator</code> interface)<br>
</p><p>
   - <i>addr</i> is address inside the intermediate device or the
     endpoint where the transaction is sent<br>
</p><p>
   - <i>base</i>, <i>start</i>, <i>size</i>,
     <i>access</i>, and <i>flags</i> arguments describe
     the mapping which led to the <i>mt</i> map target. These
     arguments (except for <i>access</i>) are the same as
     the fields of the <code>translation_t</code> structure. Please refer to
     the <code>translation_t</code>'s documentation for their description.
     The <i>access</i> argument is a bitmask specifying access types.
     The bit corresponding to the type of the <i>t</i> transaction
     is always set. Other access bits may also be set optionally. But
     the latter is not guaranteed even if read/write/execute accesses
     are routed similarly<br>
</p><p>
   - <i>data</i> is the <i>data</i> argument passed to
     <b><i>SIM_inspect_address_routing</i></b><br>
</p><p>
   The <i>callback</i> callback may return false to stop inspection.
   I.e. if the false value is returned <i>callback</i> will not be
   invoked any more.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
The function returns false if
   <i>callback</i> returned false in order to stop the inspection.
   Otherwise, true is returned.</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
<pre class="jdocu_small"> <pre class="jdocu_small"># The following example shows how one can determine
# the destination of a read transaction sent from a CPU object:

import conf, simics

def get_destination(memory_space, address):
    '''Example function returning destination object for the access
    sent to address in the memory space memory_space.'''
    mt = simics.SIM_new_map_target(memory_space, None, None)
    t = simics.transaction_t()  # read transaction of zero size
    l = [None]  # data for the callback

    def callback(mt, t, addr, base, start, size, access, flags, l):
        l[0] = (simics.SIM_map_target_object(mt)
                if mt is not None
                else None)
        return True

    simics.SIM_inspect_address_routing(mt, t, address, callback, l)

    # We free mt here but it can be saved and reused if needed.
    # Transaction t can also be reused.
    simics.SIM_free_map_target(mt)
    return l[0]

# Please specify here CPU object and address you are interested in:
cpu = simics.SIM_get_processor(0)
address_of_access = 0x1000

dest = get_destination(
    cpu.iface.processor_info_v2.get_physical_memory(),
    address_of_access)

print("Destination: ",
      dest.name if dest is not None else "'nothing is mapped'")
</pre><p>
</p><p>
 </p></pre><p>
   </p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_inspect_breakpoints">SIM_inspect_breakpoints()</a></h3>
<p>

<a id="device-api-functions.html:SIM_inspect_breakpoints2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_inspect_breakpoints"></a><b>SIM_inspect_breakpoints</b>  find out breakpoints that a transaction would trigger</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">bool
SIM_inspect_breakpoints(
        const map_target_t *NOTNULL mt,
        transaction_t *NOTNULL t,
        uint64 start,
        uint64 end,
        bool (*NOTNULL callback)(
                conf_object_t *trigger_object,
                breakpoint_set_t bp_set,
                const transaction_t *t,
                uint64 start,
                uint64 end,
                lang_void *data),
        lang_void *data);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The function allows to find out the breakpoints that would be triggered
   if a transaction <i>t</i> would be sent to the address range inside
   the map target <i>mt</i>. The address range is specified by
   the <i>start</i> and <i>end</i> arguments and includes
   both start and end of the range. Only breakpoints matching
   the transaction <i>t</i>'s type (i.e., a read, a write,
   or an instruction fetch) are reported. The size of
   the transaction <i>t</i> is ignored and can be zero.
<p>
   For all matching breakpoints Simics invokes <i>callback</i>.
   The <i>callback</i> function may be called multiple times: with
   different <i>trigger_object</i> objects. The <i>callback</i>
   function gets the following two arguments that describe the breakpoints:<br>
</p><p>
   - <i>trigger_object</i> is the object implementing
     the <code>breakpoint_trigger</code> interface. The interface is used
     during simulation to signal that an access triggers a breakpoint<br>
</p><p>
   - <i>bp_set</i> is a set of breakpoints. The breakpoints
     match the transaction <i>t</i>'s type and intersect
     the [<i>start</i>, <i>end</i>] range within
     the <i>mt</i> map target. <i>Bp_set</i> should
     only be used inside <i>callback</i>. Data ownership is preserved
     by the caller (i.e., Simics)<br>
</p><p>
   Auxiliary information is provided to <i>callback</i> via
   the following arguments:<br>
</p><p>
   - <i>t</i> is usually the original transaction, but it can be also
     a new transaction in the case when additional atoms were appended to the
     original transaction via the transaction chaining (see, e.g., the
     documentation for the <code>transaction_translator</code> interface)<br>
</p><p>
   - <i>callback</i>'s <i>start</i> and <i>end</i>
     arguments specify an address range inside the <i>trigger_object</i>
     Simics object where the accesses to the requested address range inside
     the <i>mt</i> map target would go. The size of the range
     reported to <i>callback</i> may be smaller than the size of
     the requested range. This may occur, e.g., when different parts of
     the original address range are translated to different destinations
     based the memory mappings of the simulated machine<br>
</p><p>
   - <i>callback</i>'s <i>data</i> is
     the <i>data</i> argument passed to
     <b><i>SIM_inspect_breakpoints</i></b><br>
</p><p>
   The <i>callback</i> function may return <code>false</code>
   to stop searching for breakpoints. I.e. if the <code>false</code> value
   is returned <i>callback</i> will not be invoked any more
   even if more breakpoints are present.
</p><p>
   The <b><i>SIM_inspect_breakpoints</i></b> function is an inspection function:
   the endpoint of the transaction is never accessed when the function
   is used.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
The function returns <code>false</code> if
   <i>callback</i> returned false in order to stop the inspection.
   Otherwise, <code>true</code> is returned.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_issue_read_transaction">SIM_issue_read_transaction()</a></h3>
<p>

<a id="device-api-functions.html:SIM_issue_read_transaction2"></a><a id="device-api-functions.html:SIM_issue_write_transaction"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_issue_read_transaction"></a><b>SIM_issue_read_transaction</b><b>, SIM_issue_write_transaction</b>  functions for issuing <code>transaction_t</code> transactions</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE exception_type_t
SIM_issue_read_transaction(
        map_target_t *NOTNULL mt, uint64 addr, buffer_t buf,
        bool inquiry, conf_object_t *initiator);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE exception_type_t
SIM_issue_write_transaction(
        map_target_t *NOTNULL mt, uint64 addr, bytes_t bytes,
        bool inquiry, conf_object_t *initiator);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
These functions provide a simple way to issue read and write
   <code>transaction_t</code> transactions in C code. In Python, please use
   the <b><i>SIM_issue_transaction</i></b> function.
<p>
   The functions have the following parameters:<br>
</p><p>
   - <i>mt</i> specifies the destination to send a transaction to.<br>
</p><p>
   - <i>addr</i> is the address used to issue a transaction.<br>
</p><p>
   - the <b><i>SIM_issue_read_transaction</i></b>'s <i>buf</i> parameter
     has <code>buffer_t</code> type and specifies a writable buffer for storing
     the read data. The <i>data.data</i> field points to the host memory
     where the results should be stored. The <i>data.len</i> field
     specifies the number of bytes to read.<br>
</p><p>
   - The <b><i>SIM_issue_write_transaction</i></b>'s <i>bytes</i> parameter
     is of <code>bytes_t</code> type and provides the data that should
     be written. The <i>data.data</i> field points to the buffer
     holding the data that should be written. The <i>data.len</i> field
     specifies the number of bytes to write.<br>
</p><p>
   - <i>inquiry</i> specifies whether the transaction should have
     the <code>Sim_Transaction_Inquiry</code> flag set. The flag signifies that
     side effects normally triggered by the transaction should be suppressed.
     Examples of side effects include triggering breakpoints and clearing
     "read-to-clear" device registers.<br>
</p><p>
   - <i>initiator</i> specifies the object issuing a transaction. It
     may be <code>NULL</code>. The value is used for setting the
     initiator atom of the transaction.<br>
</p><p>
   These functions don't support the case when a model needs to provide custom
   atoms in <code>transaction_t</code> transactions. For such cases as well as
   when using Python the <b><i>SIM_issue_transaction</i></b> function should be
   used.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Status of the issued transaction, usually
     <code>Sim_PE_No_Exception</code> or <code>Sim_PE_IO_Not_Taken</code>.
     See the <code>exception_type</code>'s documentation for more information.
   </dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
<pre class="jdocu_small">    /* Sample C code that reads an 8-byte little-endian value. If in the
       simulated hardware the endpoint stores values in big-endian format then
       macros from &lt;simics/util/swabber.h&gt; can be used for conversion. */
    uint64 value = -1;  // variable to read data into
    exception_type_t ex = SIM_issue_read_transaction(
        mt,
        addr,
        (buffer_t) {
            .data = (uint8 *)&amp;value,
            .len = sizeof value,
        },
        false,  /* inquiry flag */
        obj     /* initiator */
        );
    if (ex == Sim_PE_No_Exception) {
        /* Read was successful: 'value' contains valid data. */
        SIM_LOG_INFO(4, obj, 0, "Read '%#llx' at %#llx", value, addr);
    } else {
        /* Read operation was not successful. There is no valid data
           in 'value'. Put any error handling code here. */
        SIM_LOG_ERROR(obj, 0, "Read at %#llx failed", addr);
    }
</pre><p>
</p><p>
  
     
  </p><pre class="jdocu_small">    /* Sample C code that writes an 8-byte little-endian value. If in the
       simulated hardware the endpoint stores values in big-endian format then
       macros from &lt;simics/util/swabber.h&gt; can be used for conversion. */
    uint64 write_value = 1;  // Data to write. '1' is written in this example.
    SIM_LOG_INFO(4, obj, 0, "Writing '%#llx' at %#llx", write_value, addr);
    exception_type_t ex = SIM_issue_write_transaction(
        mt,
        addr,
        (bytes_t) {
            .data = (uint8 *)&amp;write_value,
            .len = sizeof write_value,
        },
        false,  /* inquiry flag */
        obj     /* initiator */
        );
    if (ex == Sim_PE_No_Exception) {
        /* Write was successful. */
    } else {
        /* Write operation was not successful.
           Put any error handling code here. */
        SIM_LOG_ERROR(obj, 0, "Write at %#llx failed", addr);
    }
    </pre><p>
</p><p>
  
   </p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
       </a><code>exception_type_t</code>, <code>map_target_t</code>,
       <b><i>SIM_issue_transaction</i></b>, <code>transaction_t</code>
   </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_issue_transaction">SIM_issue_transaction()</a></h3>
<p>

<a id="device-api-functions.html:SIM_issue_transaction2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_issue_transaction"></a><b>SIM_issue_transaction</b>  issue transaction</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">exception_type_t
SIM_issue_transaction(const map_target_t *NOTNULL mt,
                      transaction_t *NOTNULL t, uint64 addr);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<b><i>SIM_issue_transaction</i></b> issues the transaction <i>t</i>
   with the address <i>addr</i> to the destination
   represented by the map target <i>mt</i>. In Python, the <i>mt</i>
   argument can also be a <code>conf_object_t</code>.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
The function returns <code>Sim_PE_Deferred</code> if the transaction was
        deferred for completion at a some later time. The corresponding pseudo
        exception is returned if the transaction completed directly (normally
        <code>Sim_PE_No_Exception</code> or <code>Sim_PE_IO_Not_Taken</code>).
   </dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
        </a><code>exception_type_t</code>, <code>transaction_t</code>,
        <b><i>SIM_new_map_target</i></b>, <b><i>SIM_free_map_target</i></b>,
        <b><i>SIM_issue_read_transaction</i></b>,
        <b><i>SIM_issue_write_transaction</i></b>,
        <b><i>SIM_defer_transaction</i></b>, <b><i>SIM_complete_transaction</i></b>,
        <b><i>SIM_monitor_transaction</i></b>, <b><i>SIM_transaction_wait</i></b>
   </dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_monitor_transaction">SIM_monitor_transaction()</a></h3>
<p>

<a id="device-api-functions.html:SIM_monitor_transaction2"></a><a id="device-api-functions.html:SIM_monitor_chained_transaction"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_monitor_transaction"></a><b>SIM_monitor_transaction</b><b>, SIM_monitor_chained_transaction</b>  monitor a transaction for deferred completion</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">exception_type_t
SIM_monitor_transaction(transaction_t *t, exception_type_t ex);
</pre><p></p><pre class="jdocu_small">exception_type_t
SIM_monitor_chained_transaction(transaction_t *t, exception_type_t ex);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The <b><i>SIM_monitor_transaction</i></b> function monitors
   an asynchronously issued transaction for completion.
   A transaction is asynchronously issued if it has a
   <code>completion</code> atom with a callback which is
   not <code>NULL</code>. The function should be
   called after the transaction has been issued, and the
   <i>ex</i> status code should be the return value from
   function used to <b><i>issue</i></b> the transaction, for example
   the <b><i>issue</i></b> method of the <code>transaction</code>
   interface.
<p>
   If <i>ex</i> equals <code>Sim_PE_Deferred</code>, then
   <b><i>SIM_monitor_transaction</i></b> will check if the transaction has in
   fact been completed already, and in that case, immediately invoke the
   completion callback. If the transaction is still uncompleted, then it
   will be marked as monitored and a subsequent call to
   <b><i>SIM_complete_transaction</i></b> will immediately complete the
   transaction by invoking the completion callback.
</p><p>
   If <i>ex</i> is not equal to <code>Sim_PE_Deferred</code>, then the
   transaction has been completed synchronously, and the completion
   callback is called using <i>ex</i> as the completion status.
</p><p>
   Note that it is illegal to call <b><i>SIM_monitor_transaction</i></b>
   for transactions that do not have a valid
   <code>completion</code> callback.
</p><p>
   <b><i>SIM_monitor_chained_transaction</i></b> is similar to
   <b><i>SIM_monitor_transaction</i></b> except that when a deferred
   transaction is completed, its parent transaction will be completed too.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Exception code returned by the
   completion function, or <code>Sim_PE_Deferred</code> if the
   transaction is monitored for completion at a later time.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
        </a><b><i>SIM_defer_transaction</i></b>,
        <b><i>SIM_complete_transaction</i></b>
   </dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_poll_transaction">SIM_poll_transaction()</a></h3>
<p>

<a id="device-api-functions.html:SIM_poll_transaction2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_poll_transaction"></a><b>SIM_poll_transaction</b>  check if a transaction has completed</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">exception_type_t
SIM_poll_transaction(transaction_t *t);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The <b><i>SIM_poll_transaction</i></b> function checks if the transaction
   <i>t</i> is marked as completed, in which case the associated
   status code is returned and the completion status for the transaction
   is cleared. If the transaction is uncompleted, then
   <i>Sim_PE_Deferred</i> is returned.
<p>
   It is illegal to call <b><i>SIM_poll_transaction</i></b> on a transaction
   which is monitored for completion using e.g. the
   <b><i>SIM_monitor_transaction</i></b> function.</p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<b><i>SIM_complete_transaction</i></b></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_reconnect_transaction">SIM_reconnect_transaction()</a></h3>
<p>

<a id="device-api-functions.html:SIM_reconnect_transaction2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_reconnect_transaction"></a><b>SIM_reconnect_transaction</b>  register that a deferred transaction has been restored</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_reconnect_transaction(transaction_t *t, int64 id);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The <b><i>SIM_reconnect_transaction</i></b> function is used by objects that
   checkpoint the transaction state. It should be called when the relevant
   state has been read from a checkpoint.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
        </a><b><i>SIM_get_transaction_id</i></b>
   </dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_register_python_atom_type">SIM_register_python_atom_type()</a></h3>
<p>

<a id="device-api-functions.html:SIM_register_python_atom_type2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_register_python_atom_type"></a><b>SIM_register_python_atom_type</b>  register an atom type which takes plain Python objects</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_register_python_atom_type(const char *NOTNULL name);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Register an atom type named <i>name</i>. The atom type
   can be used from Python and can hold any Python object.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_replace_transaction">SIM_replace_transaction()</a></h3>
<p>

<a id="device-api-functions.html:SIM_replace_transaction2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_replace_transaction"></a><b>SIM_replace_transaction</b>  replace transaction</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_replace_transaction(transaction_t *t_old, transaction_t *t_new);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Replace a transaction <i>t_old</i> with a new transaction
   <i>t_new</i>.
<p>
   A transaction which has been issued and is deferred by
   some downstream device can be replaced with a different
   transaction by initiator. This is mostly useful when a
   transaction is allocated on the stack and it turns out that the
   transaction is not completed synchronously, in which case
   <b><i>SIM_replace_transaction</i></b> can be used to move the
   transaction to e.g. the heap.
</p><p>
   This function ensures that the deferred transaction is
   properly linked with the <i>t_new</i> transaction. It
   is the caller's responsibility to fill in the contents
   of the new transaction, including the <i>prev</i> pointer.
</p><p>
   It is illegal to replace a transaction which has been monitored.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_set_transaction_bytes">SIM_set_transaction_bytes()</a></h3>
<p>

<a id="device-api-functions.html:SIM_set_transaction_bytes2"></a><a id="device-api-functions.html:SIM_set_transaction_bytes_offs"></a><a id="device-api-functions.html:SIM_set_transaction_value_le"></a><a id="device-api-functions.html:SIM_set_transaction_value_be"></a><a id="device-api-functions.html:SIM_set_transaction_bytes_constant"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_set_transaction_bytes"></a><b>SIM_set_transaction_bytes</b><b>, SIM_set_transaction_bytes_offs</b><b>, SIM_set_transaction_value_le</b><b>, SIM_set_transaction_value_be</b><b>, SIM_set_transaction_bytes_constant</b>  set transaction data payload</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_set_transaction_bytes(const transaction_t *t, bytes_t bytes);
</pre><p></p><pre class="jdocu_small">void
SIM_set_transaction_bytes_offs(const transaction_t *t, unsigned offs,
                               bytes_t bytes);
</pre><p></p><pre class="jdocu_small">void
SIM_set_transaction_value_le(const transaction_t *t, uint64 value);
</pre><p></p><pre class="jdocu_small">void
SIM_set_transaction_value_be(const transaction_t *t, uint64 value);
</pre><p></p><pre class="jdocu_small">void
SIM_set_transaction_bytes_constant(const transaction_t *t, uint8 value);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Set the data payload of a transaction to the contents provided by
   <i>bytes</i>. The number of provided bytes must match the
   transaction size exactly.
<p>
   The <b><i>SIM_set_transaction_bytes_offs</i></b> function sets
   some bytes of the transaction starting at offset <i>offs</i>.
   The sum of the offset and the number of provided bytes must not
   exceed the transaction size.
</p><p>
   The <b><i>SIM_set_transaction_value_le</i></b> function sets
   the transaction bytes to the little endian representation of 
   <i>value</i>. The size of the transaction must
   not exceed 8 for this function to be used. Similarly,
   <b><i>SIM_set_transaction_value_be</i></b> sets the transaction bytes
   to the big endian representation of the provided value.
   If the transaction is smaller than 8 bytes the functions will truncate
   the representation of the value.
</p><p>
   The <b><i>SIM_set_transaction_bytes_constant</i></b> function can be used
   when an endpoint wants to set all transaction bytes to <i>value</i>.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_transaction_flags">SIM_transaction_flags()</a></h3>
<p>

<a id="device-api-functions.html:SIM_transaction_flags2"></a><a id="device-api-functions.html:SIM_transaction_is_fetch"></a><a id="device-api-functions.html:SIM_transaction_is_write"></a><a id="device-api-functions.html:SIM_transaction_is_read"></a><a id="device-api-functions.html:SIM_transaction_is_inquiry"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_transaction_flags"></a><b>SIM_transaction_flags</b><b>, SIM_transaction_is_fetch</b><b>, SIM_transaction_is_write</b><b>, SIM_transaction_is_read</b><b>, SIM_transaction_is_inquiry</b>  return transaction type</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">transaction_flags_t
SIM_transaction_flags(const transaction_t *NOTNULL t);
</pre><p></p><pre class="jdocu_small">bool
SIM_transaction_is_fetch(const transaction_t *NOTNULL t);
</pre><p></p><pre class="jdocu_small">bool
SIM_transaction_is_write(const transaction_t *NOTNULL t);
</pre><p></p><pre class="jdocu_small">bool
SIM_transaction_is_read(const transaction_t *NOTNULL t);
</pre><p></p><pre class="jdocu_small">bool
SIM_transaction_is_inquiry(const transaction_t *NOTNULL t);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<b><i>SIM_transaction_flags</i></b> returns a
   <code>transaction_flags_t</code> bitmap describing transaction
   type. Most of the flags can be queried using
   specific accessors.
<p>
   The <b><i>SIM_transaction_is_fetch</i></b> function returns
   <code>true</code> if the transaction is an instruction fetch.
</p><p>
   The <b><i>SIM_transaction_is_read</i></b> function returns
   <code>true</code> if the transaction is a read operation.
</p><p>
   The <b><i>SIM_transaction_is_write</i></b> function returns
   <code>true</code> if the transaction is a write operation.
</p><p>
   The <b><i>SIM_transaction_is_inquiry</i></b> function returns
   <code>true</code> if the transaction is an inquiry operation.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
All contexts (including Threaded Context)
   </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_transaction_initiator">SIM_transaction_initiator()</a></h3>
<p>

<a id="device-api-functions.html:SIM_transaction_initiator2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_transaction_initiator"></a><b>SIM_transaction_initiator</b>  return transaction initiator</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">conf_object_t *
SIM_transaction_initiator(const transaction_t *t);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Return the initiator of the transaction.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
All contexts (including Threaded Context)
   </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_transaction_is_deferrable">SIM_transaction_is_deferrable()</a></h3>
<p>

<a id="device-api-functions.html:SIM_transaction_is_deferrable2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_transaction_is_deferrable"></a><b>SIM_transaction_is_deferrable</b>  check if a transaction can be deferred for later completion</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">bool
SIM_transaction_is_deferrable(const transaction_t *NOTNULL t);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The function allows to check whether a transaction can be deferred (with the
   <b><i>SIM_defer_transaction</i></b> or <b><i>SIM_defer_owned_transaction</i></b>
   function) for later completion which is done with a call
   to <b><i>SIM_complete_transaction</i></b>.
<p>
   Usually, this function is not needed since <b><i>SIM_defer_transaction</i></b>
   and <b><i>SIM_defer_owned_transaction</i></b> return <code>NULL</code>
   for transactions that cannot be deferred.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
<code>false</code> if the transaction was issued
   synchronously and cannot be deferred. Otherwise, <code>true</code>.
   When a transaction cannot be deferred, endpoint's <b><i>issue</i></b> method
   of the <code>transaction</code> interface may choose
   to return the error status <code>Sim_PE_Async_Required</code>.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_transaction_size">SIM_transaction_size()</a></h3>
<p>

<a id="device-api-functions.html:SIM_transaction_size2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_transaction_size"></a><b>SIM_transaction_size</b>  return transaction size</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">unsigned
SIM_transaction_size(const transaction_t *NOTNULL t);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Return the size of the transaction, in bytes.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
All contexts (including Threaded Context)
   </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_transaction_wait">SIM_transaction_wait()</a></h3>
<p>

<a id="device-api-functions.html:SIM_transaction_wait2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_transaction_wait"></a><b>SIM_transaction_wait</b>  wait for transaction completion</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">exception_type_t
SIM_transaction_wait(transaction_t *t, exception_type_t ex);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<b><i>SIM_transaction_wait</i></b> waits until an issued transaction
   has completed.
<p>
   The function may only be invoked for transactions which
   have a <code>completion</code> atom containing a <code>NULL</code>
   pointer. The <code>NULL</code> pointer means that the
   initiator will wait for transaction completion using this function.
   Moreover, <b><i>SIM_transaction_wait</i></b> must always be called
   after a transaction has been issued with a <code>NULL</code>
   completion callback.
</p><p>
   The <i>ex</i> argument should be the return value of
   the function or method used to issue the transaction.
</p><p>
   <b><i>SIM_transaction_wait</i></b> will not return until the
   transaction has completed. While waiting, a different
   user-level thread will be activated, which allows
   simulated time to advance.
</p><p>
   Note that the simulator cannot create a checkpoint while a call to
   the <b><i>SIM_transaction_wait</i></b> is in progress. See
   <b>help transaction-wait-all-completed</b> for more information
   related to checkpointing and <b><i>SIM_transaction_wait</i></b>.
</p><p>
   Transaction wait is not supported from all contexts. When unsupported,
   the transaction will appear to be issued synchronously.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Completion status of the transaction</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>

    </p><h2 class="jdocu"><a class="not-numbered" id="device-api-functions.html:Memory-Transactions">Memory Transactions</a></h2>
<p></p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_arm_mem_trans_from_generic">SIM_arm_mem_trans_from_generic()</a></h3>
<p>

<a id="device-api-functions.html:SIM_arm_mem_trans_from_generic2"></a><a id="device-api-functions.html:SIM_mips_mem_trans_from_generic"></a><a id="device-api-functions.html:SIM_ppc_mem_trans_from_generic"></a><a id="device-api-functions.html:SIM_x86_mem_trans_from_generic"></a><a id="device-api-functions.html:SIM_pci_mem_trans_from_generic"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_arm_mem_trans_from_generic"></a><b>SIM_arm_mem_trans_from_generic</b><b>, SIM_mips_mem_trans_from_generic</b><b>, SIM_ppc_mem_trans_from_generic</b><b>, SIM_x86_mem_trans_from_generic</b><b>, SIM_pci_mem_trans_from_generic</b>  convert generic transaction to CPU specific</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">struct arm_memory_transaction *
SIM_arm_mem_trans_from_generic(generic_transaction_t *NOTNULL mop);
</pre><p></p><pre class="jdocu_small">struct mips_memory_transaction *
SIM_mips_mem_trans_from_generic(generic_transaction_t *NOTNULL mop);
</pre><p></p><pre class="jdocu_small">struct ppc_memory_transaction *
SIM_ppc_mem_trans_from_generic(generic_transaction_t *NOTNULL mop);
</pre><p></p><pre class="jdocu_small">struct x86_memory_transaction *
SIM_x86_mem_trans_from_generic(generic_transaction_t *NOTNULL mop);
</pre><p></p><pre class="jdocu_small">struct pci_memory_transaction *
SIM_pci_mem_trans_from_generic(generic_transaction_t *NOTNULL mop);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Converts a pointer to a generic memory transaction into a pointer
   to a CPU specific memory transaction. The generic memory transaction
   must be part of a CPU specific one for this function to succeed.
   The pointer returned will be the same the input pointer if conversion
   is allowed, and NULL on failure.</dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_Type</b> Thrown if the generic transaction is not part of a CPU
   specific transaction.
   <p>
   </p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
New memory transaction pointer, or NULL on
   error.
<p>
   </p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_c_get_mem_op_value_buf">SIM_c_get_mem_op_value_buf()</a></h3>
<p>

<a id="device-api-functions.html:SIM_c_get_mem_op_value_buf2"></a><a id="device-api-functions.html:SIM_get_mem_op_value_buf"></a><a id="device-api-functions.html:SIM_get_mem_op_value_cpu"></a><a id="device-api-functions.html:SIM_get_mem_op_value_le"></a><a id="device-api-functions.html:SIM_get_mem_op_value_be"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_c_get_mem_op_value_buf"></a><b>SIM_c_get_mem_op_value_buf</b><b>, SIM_get_mem_op_value_buf</b><b>, SIM_get_mem_op_value_cpu</b><b>, SIM_get_mem_op_value_le</b><b>, SIM_get_mem_op_value_be</b>  get value for a memory operation</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_c_get_mem_op_value_buf(const generic_transaction_t *NOTNULL mop,
                           uint8 *NOTNULL dst);
</pre><p></p><pre class="jdocu_small">attr_value_t
SIM_get_mem_op_value_buf(const generic_transaction_t *NOTNULL mop);
</pre><p></p><pre class="jdocu_small">uint64
SIM_get_mem_op_value_cpu(const generic_transaction_t *NOTNULL mop);
</pre><p></p><pre class="jdocu_small">uint64
SIM_get_mem_op_value_le(const generic_transaction_t *NOTNULL mop);
</pre><p></p><pre class="jdocu_small">uint64
SIM_get_mem_op_value_be(const generic_transaction_t *NOTNULL mop);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns load or store value for a memory transaction. If the data
   size is 8 bytes or less the <b><i>SIM_get_mem_op_value_be</i></b>
   and <b><i>SIM_get_mem_op_value_le</i></b> functions can be used. For
   reads/writes larger than 8 bytes, the functions
   <b><i>SIM_c_get_mem_op_value_buf</i></b> or
   <b><i>SIM_get_mem_op_value_buf</i></b>
   should be used to get the data.
<p>
   If your model is compiled with one of the
   <code>DEVICE_IS_LITTLE_ENDIAN</code>, <code>DEVICE_IS_BIG_ENDIAN</code>
   pre-processor defines, then the
   <b><i><a id="device-api-functions.html:SIM_get_mem_op_value">SIM_get_mem_op_value</a></i></b> function can be used
   as an alias to the <b><i>SIM_get_mem_op_value_le</i></b> and
   <b><i>SIM_get_mem_op_value_be</i></b> versions.
</p><p>
   The <b><i>SIM_c_get_mem_op_value_buf</i></b> function is only available
   from C/C++. It places the data into the buffer pointed to by <i>dst</i>.
   No endian conversion is performed, i.e. data is returned in target
   endianness. There is no alignment requirement on the <code>dst</code>
   parameter.</p></dd>
<dt class="jdocu_descitem">WARNING</dt><dd>
When called from a memory-hierarchy
   (timing-model) only store values can be retrieved, since the load
   has not yet performed. To get the load value, a <i>snoop-device</i>
   should be used.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
<b><i>SIM_c_get_mem_op_value_buf</i></b> returns nothing. The out
   parameter <i>dst</i> is filled with the data buffer of the memory
   transaction. <b><i>SIM_get_mem_op_value_buf</i></b> returns an
   <code>attr_value_t</code> (type data) containing the data buffer
   of the memory transaction.
   <b><i>SIM_get_mem_op_value_be</i></b> returns the zero-extended value
   in host endian order (interpreted as big endian) for the memory transaction.
   <b><i>SIM_get_mem_op_value_le</i></b> returns the zero-extended value
   in host endian order (interpreted as little endian).
   <b><i>SIM_get_mem_op_value_cpu</i></b> interprets the data in the default
   endian order for the initiating processor. This function can only be used
   for processor initiated memory operations. It is recommended that one of the
   other functions are used instead.
<p>
   </p></dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_Memory</b> Thrown if the size of the operation is illegal.
   <p>
   </p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_c_set_mem_op_value_buf">SIM_c_set_mem_op_value_buf()</a></h3>
<p>

<a id="device-api-functions.html:SIM_c_set_mem_op_value_buf2"></a><a id="device-api-functions.html:SIM_set_mem_op_value_buf"></a><a id="device-api-functions.html:SIM_set_mem_op_value_cpu"></a><a id="device-api-functions.html:SIM_set_mem_op_value_le"></a><a id="device-api-functions.html:SIM_set_mem_op_value_be"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_c_set_mem_op_value_buf"></a><b>SIM_c_set_mem_op_value_buf</b><b>, SIM_set_mem_op_value_buf</b><b>, SIM_set_mem_op_value_cpu</b><b>, SIM_set_mem_op_value_le</b><b>, SIM_set_mem_op_value_be</b>  set value for a memory operation</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_c_set_mem_op_value_buf(generic_transaction_t *NOTNULL mop,
                           const uint8 *NOTNULL src);
</pre><p></p><pre class="jdocu_small">void
SIM_set_mem_op_value_buf(generic_transaction_t *NOTNULL mop,
                         attr_value_t value);
</pre><p></p><pre class="jdocu_small">void
SIM_set_mem_op_value_cpu(generic_transaction_t *NOTNULL mop, uint64 value);
</pre><p></p><pre class="jdocu_small">void
SIM_set_mem_op_value_le(generic_transaction_t *NOTNULL mop, uint64 value);
</pre><p></p><pre class="jdocu_small">void
SIM_set_mem_op_value_be(generic_transaction_t *NOTNULL mop, uint64 value);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Set the value returned to the requester of a memory operation.
   If the data size is 8 bytes or less the <b><i>SIM_set_mem_op_value_be</i></b>
   and <b><i>SIM_set_mem_op_value_le</i></b> functions can be used. For sizes
   larger than 8 bytes, the functions <b><i>SIM_c_set_mem_op_value_buf</i></b>
   or <b><i>SIM_set_mem_op_value_buf</i></b> should be used to set the data
   as an <code>attr_value_t</code> of data type.
<p>
   If your model is compiled with one of the
   <code>DEVICE_IS_LITTLE_ENDIAN</code>, <code>DEVICE_IS_BIG_ENDIAN</code>
   pre-processor defines, then the
   <b><i><a id="device-api-functions.html:SIM_set_mem_op_value">SIM_set_mem_op_value</a></i></b> function can be used
   as an alias to the <b><i>SIM_set_mem_op_value_le</i></b> and
   <b><i>SIM_set_mem_op_value_be</i></b> versions.
</p><p>
   <b><i>SIM_c_set_mem_op_value_buf</i></b> is only available from C/C++,
   it operates on data in target endian order. There is no alignment
   requirement on the <code>buf</code> parameter.
</p><p>
   <b><i>SIM_set_mem_op_value_be</i></b> takes data in host endian order
   and sets it in big-endian.
</p><p>
   <b><i>SIM_set_mem_op_value_le</i></b> takes data in host endian order
   and sets it in little-endian.
</p><p>
   <b><i>SIM_set_mem_op_value_cpu</i></b> takes data in host endian order
   and sets it in the default endian order for the initiating processor.
   This function can only be used for processor initiated memory operations.
   It is recommended that one of the other functions are used instead.
</p><p>
   The functions that set the memory operation based on a value will
   truncate the representation of that value if the memory operation
   is smaller than 8 bytes.</p></dd>
<dt class="jdocu_descitem">WARNING</dt><dd>
These functions cannot be called from a
   <i>timing-model</i> since the real operation will overwrite the value
   set. They should instead be used from a <i>snoop-device</i>.
   </dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_Memory</b> Thrown if the size of the operation is illegal.
   <p>
   </p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_get_mem_op_page_cross">SIM_get_mem_op_page_cross()</a></h3>
<p>

<a id="device-api-functions.html:SIM_get_mem_op_page_cross2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_get_mem_op_page_cross"></a><b>SIM_get_mem_op_page_cross</b>  detect transaction split</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE unsigned
SIM_get_mem_op_page_cross(const generic_transaction_t *NOTNULL mop);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
If a memory transaction was split because it straddled an MMU page,
   return 1 if it is the first part and 2 for the second. If the transaction
   was not split, return zero.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_get_mem_op_size">SIM_get_mem_op_size()</a></h3>
<p>

<a id="device-api-functions.html:SIM_get_mem_op_size2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_get_mem_op_size"></a><b>SIM_get_mem_op_size</b>  get transaction size</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE unsigned
SIM_get_mem_op_size(const generic_transaction_t *NOTNULL mop);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Retrieve the size, in bytes, of a memory transaction.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_get_mem_op_type">SIM_get_mem_op_type()</a></h3>
<p>

<a id="device-api-functions.html:SIM_get_mem_op_type2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_get_mem_op_type"></a><b>SIM_get_mem_op_type</b>  get type of transaction</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE mem_op_type_t
SIM_get_mem_op_type(const generic_transaction_t *NOTNULL mop);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This function returns the type of the memory transaction.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
    </a><code>generic_transaction_t</code>,
    <b><i>SIM_set_mem_op_type</i></b>
  </dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_get_mem_op_type_name">SIM_get_mem_op_type_name()</a></h3>
<p>

<a id="device-api-functions.html:SIM_get_mem_op_type_name2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_get_mem_op_type_name"></a><b>SIM_get_mem_op_type_name</b>  get name of memory operation type</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">const char *
SIM_get_mem_op_type_name(mem_op_type_t type);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns a string describing <i>type</i> or <code>NULL</code>
   if unknown.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_make_mem_op_write">SIM_make_mem_op_write()</a></h3>
<p>

<a id="device-api-functions.html:SIM_make_mem_op_write2"></a><a id="device-api-functions.html:SIM_make_mem_op_read"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_make_mem_op_write"></a><b>SIM_make_mem_op_write</b><b>, SIM_make_mem_op_read</b>  create a memory transaction</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">generic_transaction_t
SIM_make_mem_op_write(physical_address_t addr, bytes_t data,
                      bool inquiry, conf_object_t *initiator);
</pre><p></p><pre class="jdocu_small">generic_transaction_t
SIM_make_mem_op_read(physical_address_t addr, buffer_t buffer,
                     bool inquiry, conf_object_t *initiator);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Create and return a memory transaction for writing <i>data</i> to
     <i>addr</i>, or reading from <i>addr</i> into
     <i>buffer</i>. The number of bytes to transfer is specified by
     <i>data</i> and <i>buffer</i> respectively. The
     <i>initiator</i> is the object issuing the transaction; it may be
     NULL.
<p>
     These functions do not actually perform any memory operation; they just
     construct the <code>generic_transaction_t</code> that can be used in
     other calls.
</p><p>
     The <i>buffer</i> argument must refer to an allocated buffer, and
     <i>data</i> must contain valid data. They must remain valid and
     allocated during the life-time of the returned value.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
All contexts (including Threaded Context)</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_mem_op_ensure_future_visibility">SIM_mem_op_ensure_future_visibility()</a></h3>
<p>

<a id="device-api-functions.html:SIM_mem_op_ensure_future_visibility2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_mem_op_ensure_future_visibility"></a><b>SIM_mem_op_ensure_future_visibility</b>  request transaction visibility</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE void
SIM_mem_op_ensure_future_visibility(generic_transaction_t *NOTNULL mop);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Request that future accesses from the same virtual address (using a
   granularity given by the <i>min_cacheline_size</i> processor
   attribute) will be seen by the memory hierarchy. Otherwise, the simulator
   may cache accesses to this address for performance so that they are not seen
   by the memory model.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_mem_op_is_atomic">SIM_mem_op_is_atomic()</a></h3>
<p>

<a id="device-api-functions.html:SIM_mem_op_is_atomic2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_mem_op_is_atomic"></a><b>SIM_mem_op_is_atomic</b>  detect transaction atomicity</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE bool
SIM_mem_op_is_atomic(const generic_transaction_t *NOTNULL mop);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Return true if the transaction was part of an atomic instruction
   (usually a read followed by a write), false otherwise.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_mem_op_is_control">SIM_mem_op_is_control()</a></h3>
<p>

<a id="device-api-functions.html:SIM_mem_op_is_control2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_mem_op_is_control"></a><b>SIM_mem_op_is_control</b>  transaction control predicates</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE bool
SIM_mem_op_is_control(const generic_transaction_t *NOTNULL mop);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Checks whether <code>mem_op</code> is a control transaction (one that does not
  actually transfer any data, such as cache control operations).</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_mem_op_is_data">SIM_mem_op_is_data()</a></h3>
<p>

<a id="device-api-functions.html:SIM_mem_op_is_data2"></a><a id="device-api-functions.html:SIM_mem_op_is_instruction"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_mem_op_is_data"></a><b>SIM_mem_op_is_data</b><b>, SIM_mem_op_is_instruction</b>  transaction data/instruction predicates</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE bool
SIM_mem_op_is_data(const generic_transaction_t *NOTNULL mop);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE bool
SIM_mem_op_is_instruction(const generic_transaction_t *NOTNULL mop);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
These functions check whether <code>mem_op</code> is a data or an instruction
  transaction. Currently, the only transactions that are instruction
  transactions are instruction fetches.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_mem_op_is_from_cache">SIM_mem_op_is_from_cache()</a></h3>
<p>

<a id="device-api-functions.html:SIM_mem_op_is_from_cache2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_mem_op_is_from_cache"></a><b>SIM_mem_op_is_from_cache</b>  Cache initiated transaction</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE bool
SIM_mem_op_is_from_cache(const generic_transaction_t *NOTNULL mop);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Checks whether <code>mem_op</code> is sent from a cache timing model.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_mem_op_is_from_cpu">SIM_mem_op_is_from_cpu()</a></h3>
<p>

<a id="device-api-functions.html:SIM_mem_op_is_from_cpu2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_mem_op_is_from_cpu"></a><b>SIM_mem_op_is_from_cpu</b>  CPU initiated transaction</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE bool
SIM_mem_op_is_from_cpu(const generic_transaction_t *NOTNULL mop);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Checks whether <code>mem_op</code> is sent from a processor.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_mem_op_is_from_cpu_arch">SIM_mem_op_is_from_cpu_arch()</a></h3>
<p>

<a id="device-api-functions.html:SIM_mem_op_is_from_cpu_arch2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_mem_op_is_from_cpu_arch"></a><b>SIM_mem_op_is_from_cpu_arch</b>  CPU initiated transaction</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE bool
SIM_mem_op_is_from_cpu_arch(const generic_transaction_t *NOTNULL mop,
                            ini_type_t arch);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Checks whether <code>mem_op</code> is sent from a processor
  of a specific architecture.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_mem_op_is_from_device">SIM_mem_op_is_from_device()</a></h3>
<p>

<a id="device-api-functions.html:SIM_mem_op_is_from_device2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_mem_op_is_from_device"></a><b>SIM_mem_op_is_from_device</b>  Device initiated transaction</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE bool
SIM_mem_op_is_from_device(const generic_transaction_t *NOTNULL mop);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Checks whether <code>mem_op</code> is sent from a device.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_mem_op_is_prefetch">SIM_mem_op_is_prefetch()</a></h3>
<p>

<a id="device-api-functions.html:SIM_mem_op_is_prefetch2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_mem_op_is_prefetch"></a><b>SIM_mem_op_is_prefetch</b>  transaction control predicates</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE bool
SIM_mem_op_is_prefetch(const generic_transaction_t *NOTNULL mop);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Checks whether <code>mem_op</code> is prefetch transaction.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_mem_op_is_read">SIM_mem_op_is_read()</a></h3>
<p>

<a id="device-api-functions.html:SIM_mem_op_is_read2"></a><a id="device-api-functions.html:SIM_mem_op_is_write"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_mem_op_is_read"></a><b>SIM_mem_op_is_read</b><b>, SIM_mem_op_is_write</b>  transaction read/write predicates</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE bool
SIM_mem_op_is_read(const generic_transaction_t *NOTNULL mop);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE bool
SIM_mem_op_is_write(const generic_transaction_t *NOTNULL mop);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
These functions check whether <code>mem_op</code> is a read or a write
  transaction.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_mem_op_may_stall">SIM_mem_op_may_stall()</a></h3>
<p>

<a id="device-api-functions.html:SIM_mem_op_may_stall2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_mem_op_may_stall"></a><b>SIM_mem_op_may_stall</b>  detect transaction stall possibility</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE bool
SIM_mem_op_may_stall(const generic_transaction_t *NOTNULL mop);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
If true, the simulator will allow the transaction to stall execution.
   When false, a memory hierarchy must not attempt any stalling.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_set_mem_op_exception">SIM_set_mem_op_exception()</a></h3>
<p>

<a id="device-api-functions.html:SIM_set_mem_op_exception2"></a><a id="device-api-functions.html:SIM_get_mem_op_exception"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_set_mem_op_exception"></a><b>SIM_set_mem_op_exception</b><b>, SIM_get_mem_op_exception</b>  get/set transaction exception</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE void
SIM_set_mem_op_exception(generic_transaction_t *NOTNULL mop,
                         exception_type_t exc);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE exception_type_t
SIM_get_mem_op_exception(const generic_transaction_t *NOTNULL mop);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Retrieve or change the transaction exception. If set to a value other
   than <code>Sim_PE_No_Exception</code>, the transaction will be interrupted
   and an exception will be taken.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_set_mem_op_initiator">SIM_set_mem_op_initiator()</a></h3>
<p>

<a id="device-api-functions.html:SIM_set_mem_op_initiator2"></a><a id="device-api-functions.html:SIM_get_mem_op_initiator"></a><a id="device-api-functions.html:SIM_get_mem_op_ini_type"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_set_mem_op_initiator"></a><b>SIM_set_mem_op_initiator</b><b>, SIM_get_mem_op_initiator</b><b>, SIM_get_mem_op_ini_type</b>  get/set transaction initiator</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE void
SIM_set_mem_op_initiator(generic_transaction_t *NOTNULL mop,
                         ini_type_t type, conf_object_t *obj);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE conf_object_t *
SIM_get_mem_op_initiator(const generic_transaction_t *NOTNULL mop);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE ini_type_t
SIM_get_mem_op_ini_type(const generic_transaction_t *NOTNULL mop);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Retrieve or change the transaction initiator type and object.
   These two parameters must agree.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_set_mem_op_inquiry">SIM_set_mem_op_inquiry()</a></h3>
<p>

<a id="device-api-functions.html:SIM_set_mem_op_inquiry2"></a><a id="device-api-functions.html:SIM_get_mem_op_inquiry"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_set_mem_op_inquiry"></a><b>SIM_set_mem_op_inquiry</b><b>, SIM_get_mem_op_inquiry</b>  get/set transaction inquiry flag</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE void
SIM_set_mem_op_inquiry(generic_transaction_t *NOTNULL mop, bool inquiry);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE bool
SIM_get_mem_op_inquiry(const generic_transaction_t *NOTNULL mop);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Retrieve or change the transaction inquiry flag. An inquiry read has no
   side-effects. An inquiry write has no other side-effect than changing the
   bytes at the specified address and size.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_set_mem_op_physical_address">SIM_set_mem_op_physical_address()</a></h3>
<p>

<a id="device-api-functions.html:SIM_set_mem_op_physical_address2"></a><a id="device-api-functions.html:SIM_get_mem_op_physical_address"></a><a id="device-api-functions.html:SIM_set_mem_op_virtual_address"></a><a id="device-api-functions.html:SIM_get_mem_op_virtual_address"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_set_mem_op_physical_address"></a><b>SIM_set_mem_op_physical_address</b><b>, SIM_get_mem_op_physical_address</b><b>, SIM_set_mem_op_virtual_address</b><b>, SIM_get_mem_op_virtual_address</b>  get or set transaction address</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE void
SIM_set_mem_op_physical_address(generic_transaction_t *NOTNULL mop,
                                physical_address_t pa);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE physical_address_t
SIM_get_mem_op_physical_address(const generic_transaction_t *NOTNULL mop);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE void
SIM_set_mem_op_virtual_address(generic_transaction_t *NOTNULL mop,
                               logical_address_t va);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE logical_address_t
SIM_get_mem_op_virtual_address(const generic_transaction_t *NOTNULL mop);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Retrieve or set the physical or virtual (logical) addresses of a
   memory transaction.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_set_mem_op_reissue">SIM_set_mem_op_reissue()</a></h3>
<p>

<a id="device-api-functions.html:SIM_set_mem_op_reissue2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_set_mem_op_reissue"></a><b>SIM_set_mem_op_reissue</b>  request transaction reissue</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE void
SIM_set_mem_op_reissue(generic_transaction_t *NOTNULL mop);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Request that the transaction will be re-issued if a non-zero stall time
   is returned from a memory hierarchy. Otherwise, the memory model
   will not see the transaction again.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_set_mem_op_type">SIM_set_mem_op_type()</a></h3>
<p>

<a id="device-api-functions.html:SIM_set_mem_op_type2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_set_mem_op_type"></a><b>SIM_set_mem_op_type</b>  set type of transaction</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE void
SIM_set_mem_op_type(generic_transaction_t *NOTNULL mop, mem_op_type_t type);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This function sets the type of the memory transaction.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
    </a><code>generic_transaction_t</code>,
    <b><i>SIM_get_mem_op_type</i></b>
  </dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_set_mem_op_user_data">SIM_set_mem_op_user_data()</a></h3>
<p>

<a id="device-api-functions.html:SIM_set_mem_op_user_data2"></a><a id="device-api-functions.html:SIM_get_mem_op_user_data"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_set_mem_op_user_data"></a><b>SIM_set_mem_op_user_data</b><b>, SIM_get_mem_op_user_data</b>  get/set transaction user data</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE void
SIM_set_mem_op_user_data(generic_transaction_t *NOTNULL mop,
                         void *data);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE void *
SIM_get_mem_op_user_data(const generic_transaction_t *NOTNULL mop);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Retrieve or change user data associated with the transaction.
   This data is not touched by Simics in any way and its handling and
   interpretation is left to the user. It can be used
   to pass information from a timing model to a snoop device, but the data
   does not survive across a stall.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>

    </p><h2 class="jdocu"><a class="not-numbered" id="device-api-functions.html:Device-Translators">Device Translators</a></h2>
<p></p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_free_map_target">SIM_free_map_target()</a></h3>
<p>

<a id="device-api-functions.html:SIM_free_map_target2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_free_map_target"></a><b>SIM_free_map_target</b>  free a map target</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_free_map_target(map_target_t *mt);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Releases a map target and all associated resources.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<b><i>SIM_new_map_target</i></b></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_map_target_flush">SIM_map_target_flush()</a></h3>
<p>

<a id="device-api-functions.html:SIM_map_target_flush2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_map_target_flush"></a><b>SIM_map_target_flush</b>  ensure that old translations are not used</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">bool
SIM_map_target_flush(const map_target_t *NOTNULL mt,
                     uint64 base, uint64 size, access_t access);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This API function is intended to be used for the implementation
   the <code>translation_flush</code> interface. The documentation for
   the <code>translation_flush</code> interface describes
   how to use this function for the interface implementation.
<p>
   Additionally, this function can be used as a replacement for
   the <b><i>SIM_translation_changed</i></b> function
   to do a more fine-grain invalidation in the case when a previously
   returned translation becomes invalid.
</p><p>
   When a previously returned translation becomes invalid the translator object
   should notify Simics which can have translations cached. To notify Simics
   the translator object can either do the call to
   the <b><i>SIM_translation_changed</i></b> function or, as a potential
   performance optimization, do a more fine-grain invalidation by using
   the <b><i>SIM_map_target_flush</i></b> function.
</p><p>
   The translator object is expected to call
   the <b><i>SIM_map_target_flush</i></b> function for
   all targets of all previously returned translations which became invalid.
   If there are too many translations which are to be invalidated, then,
   performance-wise, it may be better just to do a single call to the
   <b><i>SIM_translation_changed</i></b> function. Also, if,
   during invalidation, any of the calls to the <b><i>SIM_map_target_flush</i></b>
   fails (i.e. the <code>false</code> value is returned by the function) then
   the translator is expected to call
   the <b><i>SIM_translation_changed</i></b> function which always succeeds.
</p><p>
   Please note that there is no need to call
   the <b><i>SIM_map_target_flush</i></b> function for the translations which
   were tagged with the <code>Sim_Translation_Dynamic</code> flag. Either, no
   invalidation is needed for the destinations where nothing is mapped.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_map_target_object">SIM_map_target_object()</a></h3>
<p>

<a id="device-api-functions.html:SIM_map_target_object2"></a><a id="device-api-functions.html:SIM_map_target_port"></a><a id="device-api-functions.html:SIM_map_target_target"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_map_target_object"></a><b>SIM_map_target_object</b><b>, SIM_map_target_port</b><b>, SIM_map_target_target</b>  inspect a map target</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">conf_object_t *
SIM_map_target_object(const map_target_t *NOTNULL mt);
</pre><p></p><pre class="jdocu_small">const char *
SIM_map_target_port(const map_target_t *NOTNULL mt);
</pre><p></p><pre class="jdocu_small">const map_target_t *
SIM_map_target_target(const map_target_t *NOTNULL mt);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Helper functions allowing inspection of the map_target_t objects.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Returns a Simics object, port, or
   chained target which was used
   for the creation of the <i>mt</i> map target, i.e.,
   the respective argument passed to <b><i>SIM_new_map_target</i></b>
   when the map target was created.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<b><i>SIM_new_map_target</i></b></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_new_map_target">SIM_new_map_target()</a></h3>
<p>

<a id="device-api-functions.html:SIM_new_map_target2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_new_map_target"></a><b>SIM_new_map_target</b>  create a map target</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">map_target_t *
SIM_new_map_target(conf_object_t *NOTNULL obj, const char *port,
                   const map_target_t *chained_target);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Create and return a new map target. A map target can be viewed as an opaque
   representation of an object/interface pair which can function
   either as an endpoint for a memory transaction
   or as an address space where a memory transaction can be performed.
<p>
   Map targets are usually used in conjunction with the
   <code>translator</code> interface and can represent anything
   which is mappable in a memory space, e.g., IO banks, RAM, ROM,
   memory spaces, port spaces, bridges, or translators. In order to
   get better performance, we recommend to allocate a map target once
   and reuse it rather than to allocate and delete it every time.
</p><p>
   If the <i>chained_target</i> parameter is null,
   <i>obj</i> is searched for one of the following interfaces:
   <code>ram</code>, <code>rom</code>, <code>io_memory</code>,
   <code>port_space</code>, <code>translator</code>,
   <code>transaction_translator</code>, <code>transaction</code> or
   <code>memory_space</code>. The interfaces are tried in the
   listed order, and the first interface found determines the "type" of the
   map target. For example, if <i>obj</i> implements both the
   <code>io_memory</code> and the <code>translator</code>
   interface, then the created map target will direct memory transactions
   to the <code>io_memory</code> interface.
</p><p>
   If a map target argument is passed in the
   <i>chained_target</i> parameter, then <i>obj</i> must
   implement one of the following interfaces:
   <code>translator</code>, <code>bridge</code>,
   or <code>translate</code>. The chained target contains information
   about a secondary map target used either directly or indirectly
   by the interface. For objects implementing the
   <code>translator</code> interface, the chained
   target is passed as an argument to the <b><i>translate</i></b>
   method. For bridges, the chained target is the target which
   is accessed through the bridge. For objects implementing
   <code>translate</code>, the chained target is used as the target
   of the translation if the <b><i>translate</i></b> method returns null.
</p><p>
   Note: Information about the chained target is encoded in the
   created map target, but no direct references are kept to the argument.
   In other words, ownership is not transferred by this call and
   the caller is responsible for releasing <i>chained_target</i>
   as appropriate.
</p><p>
   If a string is passed in the <i>port</i> parameter, then   
   Simics looks for port interfaces instead of regular interfaces.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Returns a map target, encoding information
   about the object, the interface, and the chained target, if any.
   NULL is returned if an exception was thrown.</dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_Lookup</b> Thrown if no usable port interface was found.
   </dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
   </a><b><i>SIM_free_map_target</i></b>, <code>map_target_t</code>,
   <b><i>SIM_map_target_object</i></b>, <code>translator_interface_t</code>
   </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_translation_changed">SIM_translation_changed()</a></h3>
<p>

<a id="device-api-functions.html:SIM_translation_changed2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_translation_changed"></a><b>SIM_translation_changed</b>  ensure that old translations are not used</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_translation_changed(conf_object_t *NOTNULL obj);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Devices implementing the <code>translator</code> interface
   need to call this function whenever a previously returned
   translation becomes invalid; the only exception is
   if all invalid translations were tagged with
   <code>Sim_Translation_Dynamic</code>, in which case this is
   not necessary.
<p>
   Failure to call this function will likely result in Simics
   continuing to use old translations, since those may have been
   cached internally.
   </p><p>
   The object implementing the translator should be passed
   in the <i>obj</i> parameter.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
   </a><code>translator_interface_t</code>
   </dd>
</dl><p>

    </p><h2 class="jdocu"><a class="not-numbered" id="device-api-functions.html:Time-and-Events">Time and Events</a></h2>
<p></p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_cycle_count">SIM_cycle_count()</a></h3>
<p>

<a id="device-api-functions.html:SIM_cycle_count2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_cycle_count"></a><b>SIM_cycle_count</b>  read cycle counter</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">cycles_t  
SIM_cycle_count(conf_object_t *NOTNULL obj);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<b><i>SIM_cycle_count</i></b> returns the current simulated clock cycle
   count at <i>obj</i>.
<p>
   If <i>obj</i> is a cycle counter implementing either the
   <code>cycle_event</code> interface or the <code>cycle</code>
   interface, then the returned count is the number of elapsed
   cycles according to that object. If <i>obj</i> is not a cycle
   counter, then the default clock associated with the object is
   queried for its cycle count.</p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
     </a><b><i>SIM_object_clock</i></b>
   </dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
<b><i>SIM_cycle_count</i></b> returns the current time in number of
   cycles.
   </dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_event_cancel_time">SIM_event_cancel_time()</a></h3>
<p>

<a id="device-api-functions.html:SIM_event_cancel_time2"></a><a id="device-api-functions.html:SIM_event_cancel_step"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_event_cancel_time"></a><b>SIM_event_cancel_time</b><b>, SIM_event_cancel_step</b>  cancel an event before expiration</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_event_cancel_time(conf_object_t *NOTNULL clock,
                      event_class_t *NOTNULL evclass,
                      conf_object_t *NOTNULL obj,
                      int (*pred)(lang_void *data, lang_void *match_data),
                      lang_void *match_data);
</pre><p></p><pre class="jdocu_small">void
SIM_event_cancel_step(conf_object_t *NOTNULL clock,
                      event_class_t *NOTNULL evclass,
                      conf_object_t *NOTNULL obj,
                      int (*pred)(lang_void *data, lang_void *match_data),
                      lang_void *match_data);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
All unexpired <i>evclass</i> events posted for <i>obj</i>
   on <i>clock</i> for which <i>pred</i> returns nonzero will
   be cancelled and their destructor methods (if any) called.
   <i>pred</i> will be called with the data associated with the event
   and the supplied <i>match_data</i>. If <i>pred</i> is null
   (None in Python), all <i>evclass</i> events for <i>obj</i>
   on <i>clock</i> will be cancelled.
<p>
   There are separate calls for events posted at a point in time (cycle or
   seconds) and on a specific step.</p></dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_InterfaceNotFound</b> Thrown by <b><i>SIM_event_cancel_step</i></b>
   if the <i>clock</i> object doesn't implement the <code>step</code>
   interface.
<p>
   </p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
     </a><b><i>SIM_register_event</i></b>, <b><i>SIM_event_post_time</i></b>
   </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_event_class_flags">SIM_event_class_flags()</a></h3>
<p>

<a id="device-api-functions.html:SIM_event_class_flags2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_event_class_flags"></a><b>SIM_event_class_flags</b>  get event class flags</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">event_class_flag_t
SIM_event_class_flags(event_class_t *NOTNULL ec);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Get the event class flags from a registered event class <i>ec</i>.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
     </a><b><i>SIM_register_event</i></b>
   </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_event_find_next_cycle">SIM_event_find_next_cycle()</a></h3>
<p>

<a id="device-api-functions.html:SIM_event_find_next_cycle2"></a><a id="device-api-functions.html:SIM_event_find_next_time"></a><a id="device-api-functions.html:SIM_event_find_next_step"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_event_find_next_cycle"></a><b>SIM_event_find_next_cycle</b><b>, SIM_event_find_next_time</b><b>, SIM_event_find_next_step</b>  find event expiration time</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">cycles_t
SIM_event_find_next_cycle(conf_object_t *NOTNULL clock,
                          event_class_t *NOTNULL evclass,
                          conf_object_t *NOTNULL obj,
                          int (*pred)(lang_void *data, lang_void *match_data),
                          lang_void *match_data);
</pre><p></p><pre class="jdocu_small">double
SIM_event_find_next_time(conf_object_t *NOTNULL clock,
                         event_class_t *NOTNULL evclass,
                         conf_object_t *NOTNULL obj,
                         int (*pred)(lang_void *data, lang_void *match_data),
                         lang_void *match_data);
</pre><p></p><pre class="jdocu_small">pc_step_t
SIM_event_find_next_step(conf_object_t *NOTNULL clock,
                         event_class_t *NOTNULL evclass,
                         conf_object_t *NOTNULL obj,
                         int (*pred)(lang_void *data, lang_void *match_data),
                         lang_void *match_data);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Return the number of cycles/seconds/steps to the first event of
   <i>evclass</i> of <i>obj</i> posted on <i>clock</i>
   for which <i>pred</i> is true, or 1 if no event
   matched. <i>pred</i> will be called with the data associated with
   the event and the supplied <i>match_data</i>. If <i>pred</i>
   is null (None in Python), the first <i>evclass</i> event for
   <i>obj</i> on <i>clock</i> will be used.
<p>
   There are separate calls of events posted at a point in time (cycle
   or seconds) and on a specific step. Note that the return value of
   <b><i>SIM_event_find_next_cycle</i></b> is only a preliminary
   estimate; the number of remaining cycles will change if the
   clock's frequency changes dynamically. To handle dynamically
   changing clock frequencies correctly, subscribe to the frequency
   changes via the clock's <code>simple_dispatcher</code> interface.</p></dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_InterfaceNotFound</b> Thrown by
   <b><i>SIM_event_find_next_step</i></b> if the <i>clock</i> object
   doesn't implement the <code>step</code> interface: Minus one is returned
   in such a case.
   <p>
   </p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
     </a><b><i>SIM_register_event</i></b>, <b><i>SIM_event_post_time</i></b>
   </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_event_post_time">SIM_event_post_time()</a></h3>
<p>

<a id="device-api-functions.html:SIM_event_post_time2"></a><a id="device-api-functions.html:SIM_event_post_cycle"></a><a id="device-api-functions.html:SIM_event_post_step"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_event_post_time"></a><b>SIM_event_post_time</b><b>, SIM_event_post_cycle</b><b>, SIM_event_post_step</b>  post an event</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void 
SIM_event_post_time(conf_object_t *NOTNULL clock,
                    event_class_t *NOTNULL evclass,
                    conf_object_t *NOTNULL obj,
                    double seconds,
                    lang_void *user_data);
</pre><p></p><pre class="jdocu_small">void
SIM_event_post_cycle(conf_object_t *NOTNULL clock,
                     event_class_t *NOTNULL evclass,
                     conf_object_t *NOTNULL obj,
                     cycles_t cycles,
                     lang_void *user_data);
</pre><p></p><pre class="jdocu_small">void
SIM_event_post_step(conf_object_t *NOTNULL clock,
                    event_class_t *NOTNULL evclass,
                    conf_object_t *NOTNULL obj,
                    pc_step_t steps,
                    lang_void *user_data);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
An event of <i>evclass</i> for object <i>obj</i> is posted
   on <i>clock</i> to occur at a given point in the future. The
   <i>user_data</i> will be associated with the event.
<p>
   The <i>clock</i> is the object that should be used for keeping track
   of time for the event. It can be a processor or an instance of the
   <b>clock</b> class.
</p><p>
   If a configuration class was specified when <i>evclass</i> was
   registered, then <i>obj</i> must be an instance of that class.
</p><p>
   The expiration point can be specified in seconds, cycles or steps by using
   the appropriate call, and these values are relative to the current
   state. Events that need to run synchronized
   (<code>Sim_EC_Machine_Sync</code>) can only be posted in seconds or
   cycles, not steps, since synchronization can only be perform in virtual
   time.
</p><p>
   </p><div class="note">
<b>Note:</b>
Events posted with <b><i>SIM_event_post_cycle</i></b> are posted at
   a certain point in time based on the clock's current frequency, not
   at a certain clock cycle. The difference is significant if the
   frequency of the <i>clock</i> object can change dynamically.
   </div></dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<dl><dt id="device-api-functions.html:dt:simexc_interfacenotfound"><a href="#device-api-functions.html:dt:simexc_interfacenotfound"><b>SimExc_InterfaceNotFound</b></a></dt><dd>Thrown by
   <b><i>SIM_event_post_step</i></b> if the <i>clock</i> object doesn't
   implement the <code>step</code> interface.</dd><dt id="device-api-functions.html:dt:simexc_general"><a href="#device-api-functions.html:dt:simexc_general"><b>SimExc_General</b></a></dt><dd>Thrown if the number of steps or time is
   negative or too far ahead, and, for <code>Sim_EC_Machine_Sync</code>
   events, if the event is posted less than a time quantum in the future.</dd></dl><p></p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
     </a><b><i>SIM_register_event</i></b>, <b><i>SIM_event_cancel_time</i></b>
   </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_get_event_class">SIM_get_event_class()</a></h3>
<p>

<a id="device-api-functions.html:SIM_get_event_class2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_get_event_class"></a><b>SIM_get_event_class</b>  get the event class</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">event_class_t *
SIM_get_event_class(conf_class_t *NOTNULL cl, const char *NOTNULL name);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Get an event class registered for a configuration class, as done by the
   SIM_register_event function. The <i>cl</i> is the configuration
   class and <i>name</i> is the name of the event class to retrieve.
<p>
   If the event class cannot be found, NULL is returned.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
     </a><b><i>SIM_register_event</i></b>
   </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_register_event">SIM_register_event()</a></h3>
<p>

<a id="device-api-functions.html:SIM_register_event2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_register_event"></a><b>SIM_register_event</b>  register an event</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">event_class_t *
SIM_register_event(
               const char *NOTNULL name,
               conf_class_t *cl,
               event_class_flag_t flags,
               void (*NOTNULL callback)(conf_object_t *obj, lang_void *data),
               void (*destroy)(conf_object_t *obj, lang_void *data),
               attr_value_t (*get_value)(conf_object_t *obj, lang_void *data),
               lang_void *(*set_value)(conf_object_t *obj, attr_value_t value),
               char *(*describe)(conf_object_t *obj, lang_void *data));
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Registers events identified by <i>name</i> and to be posted for
   objects of class <i>cl</i>, and returns the event class to be used
   in other calls. The supplied methods are:
<p>
   </p><dl><dt id="device-api-functions.html:dt:callback"><a href="#device-api-functions.html:dt:callback"><b><i>callback</i></b></a></dt><dd>Called when the event expires.</dd><dt id="device-api-functions.html:dt:destroy"><a href="#device-api-functions.html:dt:destroy"><b><i>destroy</i></b></a></dt><dd>Called when the event is removed from the queue without being called.
       The method is not allowed to use any event API calls; it is mainly
       intended for freeing event data. May be null.</dd><dt id="device-api-functions.html:dt:get_value"><a href="#device-api-functions.html:dt:get_value"><b><i>get_value</i></b></a></dt><dd>Called to convert the event data into a value that can be saved in a
       configuration. May be null when the event carries no data of
       interest.</dd><dt id="device-api-functions.html:dt:set_value"><a href="#device-api-functions.html:dt:set_value"><b><i>set_value</i></b></a></dt><dd>Called to convert a configuration value into event data. 
       May be null when the event carries no data of interest.</dd><dt id="device-api-functions.html:dt:describe"><a href="#device-api-functions.html:dt:describe"><b><i>describe</i></b></a></dt><dd>Called to generate a human-readable description of the event to be used 
       in the <b>print-event-queue</b> command. If written in C, must
       return an allocated string (using <code>MM_MALLOC</code> or
       <code>MM_STRDUP</code>).
       May be null, in which case the <i>name</i> is used.</dd></dl><p>Null function pointers correspond to the value None when invoked from
   Python.
</p><p>
   The <i>flags</i> is typically either zero or Sim_EC_Notsaved, where
   Sim_EC_Notsaved indicates that the event should not be saved as part of the
   configuration.  In that case, <i>get_value</i> and
   <i>set_value</i> must both be null, and <i>cl</i> may then
   also be null. The other flag bits defined in the event_class_flag_t are
   reserved for internal use in the Simics platform and some tightly coupled
   modules. See the event queue sample code for details of their use.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<b><i>SIM_event_post_time</i></b></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_run_unrestricted">SIM_run_unrestricted()</a></h3>
<p>

<a id="device-api-functions.html:SIM_run_unrestricted2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_run_unrestricted"></a><b>SIM_run_unrestricted</b>  run callback after current instruction</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_run_unrestricted(conf_object_t *NOTNULL obj,
                     void (*NOTNULL func)(conf_object_t *obj,
                                          lang_void *param),
                     lang_void *user_data);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The <i>func</i> functions will be called immediately, if Simics is not
   currently running an instruction, or as soon as the current instruction has
   completed.
<p>
   Note that with the introduction of Multicore Accelerator, if an instruction
   is running when calling <b><i>SIM_run_unrestricted</i></b>, other simulation
   threads may continue for a while until they stop and the callback is
   serviced. This means that an object using <b><i>SIM_run_unrestricted</i></b>
   may receive calls through for example the <code>io_memory</code> interface
   after returning from the scope where <b><i>SIM_run_unrestricted</i></b> is
   called but before the <i>func</i> callback function is called. For more
   information on considerations for Multicore Accelerator, see the
   <em>Simics Model Builder User's Guide</em>.
</p><p>
   If several functions are registered this way before any of them has had a
   chance to run, the functions will be run in their order of registration.
</p><p>
   This call is mainly useful for actions that for various reasons can not be
   done while an instruction is being emulated.
</p><p>
   The <i>obj</i> is an object that has a clock (as defined by
   <b><i>SIM_object_clock</i></b>). This object and <i>user_data</i> are
   passed to the callback function.
</p><p>
   Since the callback is run in Cell Context, simulation threads
   for other cells may be running when the callback is executed. Consequently,
   only objects in the same cell as <i>obj</i> may be accessed from
   the callback.</p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<b><i>SIM_run_alone</i></b></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
All contexts including Threaded Context (call);
   Cell Context (callback)
   </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_step_count">SIM_step_count()</a></h3>
<p>

<a id="device-api-functions.html:SIM_step_count2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_step_count"></a><b>SIM_step_count</b>  get step count</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">pc_step_t
SIM_step_count(conf_object_t *NOTNULL obj);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns the number of steps executed by the processor <i>obj</i>.
   A step is a completed instruction, an instruction causing a synchronous
   exception, or an asynchronous exception (interrupt).</dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_InterfaceNotFound</b> Thrown if the <i>obj</i> object
   doesn't implement the <code>step</code> interface. Minus one is returned
   in such a case.
<p>
   </p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_time">SIM_time()</a></h3>
<p>

<a id="device-api-functions.html:SIM_time2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_time"></a><b>SIM_time</b>  get current simulated time</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">double
SIM_time(conf_object_t *NOTNULL obj);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<b><i>SIM_time</i></b> returns the current time at <i>obj</i>.
<p>
   The returned time relates to how long the simulation has been
   running, and is usually not very useful in itself, but it can be
   used to compare with other times. The time on a specific processor
   is guaranteed to increase when simulation progresses, even if the
   clock frequency is changed. When adding a processor, it is assigned
   a current time to be synchronized with other processors in the
   simulation, or the time 0.0 if it is the first processor.
</p><p>
   </p><div class="note">
<b>Note:</b>
The precision of the returned value degrades significantly
   with simulated time due to its representation as a double.
   When absolute timestamps are needed for the actual simulation,
   it is recommended that the <b><i>SIM_cycle_count</i></b> function
   is used instead on the picosecond clock.
   </div><div class="note">
<b>Note:</b>
Using <b><i>SIM_time</i></b> on the picosecond clock will currently
   give the same result as <b><i>SIM_time</i></b> on the default clock.
   That is, the precision of this API function is limited
   by the frequency of the default clock.
   </div></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
     </a><b><i>SIM_picosecond_clock</i></b>
   </dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
<b><i>SIM_time</i></b> returns the current time in seconds as
   a floating point value.
   </dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>

    </p><h2 class="jdocu"><a class="not-numbered" id="device-api-functions.html:Version-and-Copyrights">Version and Copyrights</a></h2>
<p></p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_register_copyright">SIM_register_copyright()</a></h3>
<p>

<a id="device-api-functions.html:SIM_register_copyright2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_register_copyright"></a><b>SIM_register_copyright</b>  register copyright information</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_register_copyright(const char *NOTNULL str);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This registers specific copyright information related to an extension
   module or similar component of Simics. The Simics front-end command
   "copyright" will list, in addition to Simics copyright notices, any
   registered notices from libraries or plug-ins that have added a string
   using this function.
<p>
   The string should contain only standard ASCII characters, be pre-formatted
   for at most 80-character width terminal, be non-indented, and have
   no spurious new-line characters before or after the last line (except
   for the new-line that marks the end of the last line).
</p><p>
   The string will not be copied so needs to be either static or
   a copy generated by the callee (preferably static).</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:SIM_version">SIM_version()</a></h3>
<p>

<a id="device-api-functions.html:SIM_version2"></a><a id="device-api-functions.html:SIM_version_base"></a><a id="device-api-functions.html:SIM_version_major"></a><a id="device-api-functions.html:SIM_license"></a><a id="device-api-functions.html:SIM_license_file"></a><a id="device-api-functions.html:SIM_copyright"></a><a id="device-api-functions.html:SIM_vmxmon_version"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_SIM_version"></a><b>SIM_version</b><b>, SIM_version_base</b><b>, SIM_version_major</b><b>, SIM_license</b><b>, SIM_license_file</b><b>, SIM_copyright</b><b>, SIM_vmxmon_version</b>  get Simics version and license/copyright information</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">const char *
SIM_version();
</pre><p></p><pre class="jdocu_small">const char *
SIM_version_base();
</pre><p></p><pre class="jdocu_small">const char *
SIM_version_major();
</pre><p></p><pre class="jdocu_small">void
SIM_license();
</pre><p></p><pre class="jdocu_small">char *
SIM_license_file(const char *format);
</pre><p></p><pre class="jdocu_small">char *
SIM_copyright();
</pre><p></p><pre class="jdocu_small">char *
SIM_vmxmon_version();
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<dl><dt id="device-api-functions.html:dt:sim_version"><a href="#device-api-functions.html:dt:sim_version"><b><b><i>SIM_version</i></b></b></a></dt><dd>returns the version of all installed
   Simics products.</dd><dt id="device-api-functions.html:dt:sim_version_base"><a href="#device-api-functions.html:dt:sim_version_base"><b><b><i>SIM_version_base</i></b></b></a></dt><dd>returns the version of the Simics
   base package only.</dd><dt id="device-api-functions.html:dt:sim_version_major"><a href="#device-api-functions.html:dt:sim_version_major"><b><b><i>SIM_version_major</i></b></b></a></dt><dd>returns the current major
   version of Simics.</dd><dt id="device-api-functions.html:dt:sim_vmxmon_version"><a href="#device-api-functions.html:dt:sim_vmxmon_version"><b><b><i>SIM_vmxmon_version</i></b></b></a></dt><dd>returns the version of the VMP
   kernel module loaded on the host machine. <code>NULL</code> is returned
   if the module is not loaded.</dd><dt id="device-api-functions.html:dt:sim_license_file"><a href="#device-api-functions.html:dt:sim_license_file"><b><b><i>SIM_license_file</i></b></b></a></dt><dd>returns the filename of the
   currently applying License Agreement (SLA/EULA), if any is found. The
   <i>format</i> parameter can be either an empty string (text version)
   or "rtf" (RTF version).</dd><dt id="device-api-functions.html:dt:sim_copyright"><a href="#device-api-functions.html:dt:sim_copyright"><b><b><i>SIM_copyright</i></b></b></a></dt><dd>returns the copyright notice
   for Simics.</dd><dt id="device-api-functions.html:dt:sim_license"><a href="#device-api-functions.html:dt:sim_license"><b><b><i>SIM_license</i></b></b></a></dt><dd>doesn't return anything but
   prints out a short text describing licensing conditions.</dd></dl><p><b><i>SIM_version</i></b>, <b><i>SIM_version_base</i></b>,
   <b><i>SIM_version_major</i></b> return a string
   owned by Simics. These strings must not be deallocated or modified by the
   caller.
</p><p>
   <b><i>SIM_vmxmon_version</i></b>, <b><i>SIM_license_file</i></b>,
   and <b><i>SIM_copyright</i></b> return
   a newly allocated string which is owned by the caller. This means that
   when the function is called from C its return value should be later freed
   with the use of the MM_FREE macro.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
</dl><p>

    </p><h2 class="jdocu"><a id="device-api-functions.html:frags_t">3.3.1 frags_t</a></h2>
<p>
    
</p><p>
    The <code>frags_t</code> data type is part of the Simics API. It is used to
    manipulate and modify network packets inside models efficiently. It is
    meant to replace DBuffer in network device models wherever appropriate.
    See the <em>Model Builder User's Guide</em> for an introduction to
    programming with <code>frags_t</code>.
</p><p>
    </p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:Function-List">Function List</a></h3>
<p></p><h4 class="jdocu"><a class="not-numbered" id="device-api-functions.html:frags_add">frags_add()</a></h4>
<p>

<a id="device-api-functions.html:frags_add2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_frags_add"></a><b>frags_add</b>  add data to a <code>frags_t</code></dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE void
frags_add(frags_t *buf, const void *data, size_t len);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Append the new data <i>data</i> of size <i>len</i> to
     <i>buf</i>.
     A <code>frags_t</code> can hold up to 8 data fragments.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
None</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
<pre class="jdocu_small">uint8 new_data[2] = { 7, 8 };
frags_add(&amp;foo, new_data, sizeof(new_data));
</pre><p>

     </p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
       </a><b><i>frags_init_add</i></b>, <b><i>frags_init_add_from_frags</i></b>, 
       <b><i>frags_add_from_frags</i></b>
     </dd>
</dl><p>
</p><h4 class="jdocu"><a class="not-numbered" id="device-api-functions.html:frags_add_from_frags">frags_add_from_frags()</a></h4>
<p>

<a id="device-api-functions.html:frags_add_from_frags2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_frags_add_from_frags"></a><b>frags_add_from_frags</b>  append an existing <code>frags_t</code> to another</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE void
frags_add_from_frags(frags_t *dst, const frags_t *src,
                     size_t offset, size_t len);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Append <i>len</i> bytes of the data at offset
     <i>offset</i> in <i>src</i> to <i>dst</i>.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
None</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
<pre class="jdocu_small">frags_add_from_frags(&amp;foo, &amp;bar, 4, frags_len(&amp;bar) - 4);
</pre><p>

     </p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
       </a><b><i>frags_init_add</i></b>, <b><i>frags_add</i></b>,
       <b><i>frags_init_add_from_frags</i></b>
     </dd>
</dl><p>
</p><h4 class="jdocu"><a class="not-numbered" id="device-api-functions.html:frags_extract">frags_extract()</a></h4>
<p>

<a id="device-api-functions.html:frags_extract2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_frags_extract"></a><b>frags_extract</b>  extract the contents of a <code>frags_t</code></dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void frags_extract(const frags_t *buf, void *vdst);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Copy the whole contents of <i>buf</i> to <i>vdst</i>. The
     destination buffer <i>vdst</i> should be large enough to contain
     all data in <i>buf</i>.
<p>
     This function is completely equivalent to <b><i>frags_extract_slice()</i></b>
     with an <i>offset</i> and a <i>length</i> covering the
     whole contents of the <code>frags_t</code>, and is provided for
     convenience.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
None</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
<pre class="jdocu_small">uint8 all_data[frags_len(&amp;foo)];
frags_extract(&amp;foo, all_data);
</pre><p>

     </p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
       </a><b><i>frags_extract_8</i></b>, <b><i>frags_extract_slice</i></b>,
       <b><i>frags_extract_alloc</i></b>, <b><i>frags_extract_slice_alloc</i></b>
     </dd>
</dl><p>
</p><h4 class="jdocu"><a class="not-numbered" id="device-api-functions.html:frags_extract_8">frags_extract_8()</a></h4>
<p>

<a id="device-api-functions.html:frags_extract_82"></a><a id="device-api-functions.html:frags_extract_be16"></a><a id="device-api-functions.html:frags_extract_le16"></a><a id="device-api-functions.html:frags_extract_be32"></a><a id="device-api-functions.html:frags_extract_le32"></a><a id="device-api-functions.html:frags_extract_be64"></a><a id="device-api-functions.html:frags_extract_le64"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_frags_extract_8"></a><b>frags_extract_8</b><b>, frags_extract_be16</b><b>, frags_extract_le16</b><b>, frags_extract_be32</b><b>, frags_extract_le32</b><b>, frags_extract_be64</b><b>, frags_extract_le64</b>  extract a value</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">uint8 frags_extract_8(const frags_t *buf, size_t offset);
</pre><p></p><pre class="jdocu_small">uint16 frags_extract_be16(const frags_t *buf, size_t offset);
</pre><p></p><pre class="jdocu_small">uint16 frags_extract_le16(const frags_t *buf, size_t offset);
</pre><p></p><pre class="jdocu_small">uint32 frags_extract_be32(const frags_t *buf, size_t offset);
</pre><p></p><pre class="jdocu_small">uint32 frags_extract_le32(const frags_t *buf, size_t offset);
</pre><p></p><pre class="jdocu_small">uint64 frags_extract_be64(const frags_t *buf, size_t offset);
</pre><p></p><pre class="jdocu_small">uint64 frags_extract_le64(const frags_t *buf, size_t offset);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Extract a 8, 16, 32 or 64 bits value in either big-endian (<b><i>_be</i></b>)
     or little-endian (<b><i>_le</i></b>) format from the contents of the
     <code>frags_t</code> <i>buf</i> at offset <i>offset</i>.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Extracted value</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
<pre class="jdocu_small">uint8  val8  = frags_extract_8(&amp;frame, 1);
uint16 val16 = frags_extract_be16(&amp;frame, 2);
uint32 val32 = frags_extract_le32(&amp;frame, 4);
uint32 val64 = frags_extract_be64(&amp;frame, 8);
</pre><p>

     </p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
       </a><b><i>frags_extract</i></b>, <b><i>frags_extract_slice</i></b>
     </dd>
</dl><p>
</p><h4 class="jdocu"><a class="not-numbered" id="device-api-functions.html:frags_extract_alloc">frags_extract_alloc()</a></h4>
<p>

<a id="device-api-functions.html:frags_extract_alloc2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_frags_extract_alloc"></a><b>frags_extract_alloc</b>  return a copy of the contents of a <code>frags_t</code></dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void *frags_extract_alloc(const frags_t *buf);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Return an allocated copy of the contents of <i>buf</i>. The buffer
     returned is allocated with <b><i>MM_MALLOC()</i></b>, and its ownership is
     passed to the caller, which should free it when appropriate.
<p>
     This function is equivalent to allocating a buffer of the correct size
     with <b><i>MM_MALLOC()</i></b> followed by a call to
     <b><i>frags_extract()</i></b>, and is provided for convenience.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
A newly allocated copy of the contents</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
<pre class="jdocu_small">uint8 *all = frags_extract_alloc(&amp;foo);
/* ... */
MM_FREE(all);
</pre><p>

     </p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
       </a><b><i>frags_extract</i></b>, <b><i>frags_extract_slice</i></b>,
       <b><i>frags_extract_slice_alloc</i></b>
     </dd>
</dl><p>
</p><h4 class="jdocu"><a class="not-numbered" id="device-api-functions.html:frags_extract_slice">frags_extract_slice()</a></h4>
<p>

<a id="device-api-functions.html:frags_extract_slice2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_frags_extract_slice"></a><b>frags_extract_slice</b>  extract a slice of a <code>frags_t</code></dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void frags_extract_slice(const frags_t *buf, void *vdst, size_t offset, 
                         size_t len);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Copy a slice of size <i>len</i>, starting at offset
     <i>offset</i>, of the contents of <i>buf</i>, to
     <i>vdst</i>. The destination buffer <i>vdst</i> should be
     able to contain at least <i>len</i> bytes.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
None</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
<pre class="jdocu_small">uint8 some_data[16];
frags_extract_slice(&amp;foo, some_data, 4, 16);
</pre><p>

     </p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
       </a><b><i>frags_extract_8</i></b>, <b><i>frags_extract</i></b>,
       <b><i>frags_extract_alloc</i></b>, <b><i>frags_extract_slice_alloc</i></b>
     </dd>
</dl><p>
</p><h4 class="jdocu"><a class="not-numbered" id="device-api-functions.html:frags_extract_slice_alloc">frags_extract_slice_alloc()</a></h4>
<p>

<a id="device-api-functions.html:frags_extract_slice_alloc2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_frags_extract_slice_alloc"></a><b>frags_extract_slice_alloc</b>  return a partial copy of the contents of a
     <code>frags_t</code></dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void *frags_extract_slice_alloc(const frags_t *buf, size_t offset, size_t len);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Return an allocated copy of a slice of size <i>len</i>, starting
     at offset <i>offset</i>, of the contents of
     <i>buf</i>. The return value is allocated with
     <b><i>MM_MALLOC()</i></b>, and its ownership is passed to the caller, which
     should free it when appropriate.
<p>
     This function is equivalent to allocating a buffer of the correct size
     with <b><i>MM_MALLOC()</i></b> followed by a call to
     <b><i>frags_extract_slice()</i></b>, and is provided for convenience.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
A newly allocated, partial copy of the data</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
<pre class="jdocu_small">uint8 *slice = frags_extract_slice_alloc(&amp;foo, 4, 16);
/* ... */
MM_FREE(slice);
</pre><p>

     </p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
       </a><b><i>frags_extract</i></b>, <b><i>frags_extract_slice</i></b>,
       <b><i>frags_extract_alloc</i></b>
     </dd>
</dl><p>
</p><h4 class="jdocu"><a class="not-numbered" id="device-api-functions.html:frags_init">frags_init()</a></h4>
<p>

<a id="device-api-functions.html:frags_init2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_frags_init"></a><b>frags_init</b>  initialize a <code>frags_t</code></dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE void frags_init(frags_t *buf);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Initialize the <code>frags_t</code> <i>buf</i>. An alternative is
     to use the <code>FRAGS_INIT</code> constant value.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
None</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
<pre class="jdocu_small">/* Initialization with frags_init() */
frags_t bar;
frags_init(&amp;bar);
</pre><p>

       </p><pre class="jdocu_small">/* Initialization with FRAGS_INIT */
frags_t foo = FRAGS_INIT;
</pre><p>

     </p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<b><i>frags_init_add</i></b></dd>
</dl><p>
</p><h4 class="jdocu"><a class="not-numbered" id="device-api-functions.html:frags_init_add">frags_init_add()</a></h4>
<p>

<a id="device-api-functions.html:frags_init_add2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_frags_init_add"></a><b>frags_init_add</b>  initialize a <code>frags_t</code> with an initial value</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE void
frags_init_add(frags_t *buf, const void *data, size_t len);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Initialize the <code>frags_t</code> <i>buf</i> and set it to
     represent the initial data <i>data</i> of size
     <i>len</i>. 
<p>
     This function is exactly equivalent to using <b><i>frags_init()</i></b>,
     followed by <b><i>frags_add()</i></b>, and is provided for convenience.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
None</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
<pre class="jdocu_small">frags_t baz;
uint8 data[5] = { 0, 1, 2, 3, 4 };
frags_init_add(&amp;baz, data, sizeof(data));
</pre><p>

     </p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
       </a><b><i>frags_init</i></b>, <b><i>frags_add</i></b>
     </dd>
</dl><p>
</p><h4 class="jdocu"><a class="not-numbered" id="device-api-functions.html:frags_init_add_from_frags">frags_init_add_from_frags()</a></h4>
<p>

<a id="device-api-functions.html:frags_init_add_from_frags2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_frags_init_add_from_frags"></a><b>frags_init_add_from_frags</b>  initialize a <code>frags_t</code> from another</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE void
frags_init_add_from_frags(frags_t *dst, const frags_t *src,
                          size_t offset, size_t len);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Initialize <i>dst</i> and set its initial value to the data of
     size <i>len</i> starting at offset <i>offset</i> in
     <i>src</i>.
<p>
     This function is exactly equivalent to using <b><i>frags_init()</i></b>,
     followed by <b><i>frags_add_from_frags()</i></b>, and is provided for
     convenience.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
None</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
<pre class="jdocu_small">frags_t bat;
ASSERT(frags_len(&amp;foo) &gt; 16);
frags_init_add_from_frags(&amp;bat, &amp;foo, 16, frags_len(&amp;foo) - 16);
</pre><p>

     </p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
       </a><b><i>frags_init_add</i></b>, <b><i>frags_add</i></b>,
       <b><i>frags_add_from_frags</i></b>
     </dd>
</dl><p>
</p><h4 class="jdocu"><a class="not-numbered" id="device-api-functions.html:frags_it">frags_it()</a></h4>
<p>

<a id="device-api-functions.html:frags_it2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_frags_it"></a><b>frags_it</b>  return an iterator</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE frags_it_t
frags_it(const frags_t *buf, size_t offset, size_t len);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Return an iterator on the fragments that compose the data in
     <i>buf</i>, starting from offset <i>offset</i> and up to a
     length of <i>len</i>. To iterate on all the data in
     <i>buf</i>, <i>offset</i> should be set to 0 and
     <i>len</i> to the value returned by <b><i>frags_len()</i></b>.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
An iterator on the fragments covering the desired
     data range</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
<pre class="jdocu_small">unsigned sum = 0;
for (frags_it_t it = frags_it(&amp;foo, 0, frags_len(&amp;foo));
     !frags_it_end(it);
     it = frags_it_next(it)) {
        unsigned f_len = frags_it_len(it);
        const uint8 *f_data = frags_it_data(it);

        for (int i=0; i&lt;f_len; i++)
                sum += f_data[i];
}
</pre><p>

     </p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
       </a><b><i>frags_it_end</i></b>, <b><i>frags_it_next</i></b>,
       <b><i>frags_it_len</i></b>, <b><i>frags_it_data</i></b>
     </dd>
</dl><p>
</p><h4 class="jdocu"><a class="not-numbered" id="device-api-functions.html:frags_it_data">frags_it_data()</a></h4>
<p>

<a id="device-api-functions.html:frags_it_data2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_frags_it_data"></a><b>frags_it_data</b>  return the data of the current fragment</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE const uint8 *
frags_it_data(frags_it_t it);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Return a pointer to the data of the current fragment pointed by the
     iterator <i>it</i>.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
The data of the current fragment</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
<pre class="jdocu_small">unsigned sum = 0;
for (frags_it_t it = frags_it(&amp;foo, 0, frags_len(&amp;foo));
     !frags_it_end(it);
     it = frags_it_next(it)) {
        unsigned f_len = frags_it_len(it);
        const uint8 *f_data = frags_it_data(it);

        for (int i=0; i&lt;f_len; i++)
                sum += f_data[i];
}
</pre><p>

     </p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
       </a><b><i>frags_it</i></b>, <b><i>frags_it_end</i></b>,
       <b><i>frags_it_next</i></b>, <b><i>frags_it_len</i></b>
     </dd>
</dl><p>
</p><h4 class="jdocu"><a class="not-numbered" id="device-api-functions.html:frags_it_end">frags_it_end()</a></h4>
<p>

<a id="device-api-functions.html:frags_it_end2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_frags_it_end"></a><b>frags_it_end</b>  return whether an iterator is finished</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE bool 
frags_it_end(frags_it_t it);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Return <code>true</code> when the iterator <i>it</i> does not
     have any next fragment to return at the next call of
     <b><i>frags_it_next()</i></b>, and <code>false</code> otherwise.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
<code>true</code> if the iterator is finished,
     <code>false</code> otherwise.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
<pre class="jdocu_small">unsigned sum = 0;
for (frags_it_t it = frags_it(&amp;foo, 0, frags_len(&amp;foo));
     !frags_it_end(it);
     it = frags_it_next(it)) {
        unsigned f_len = frags_it_len(it);
        const uint8 *f_data = frags_it_data(it);

        for (int i=0; i&lt;f_len; i++)
                sum += f_data[i];
}
</pre><p>

     </p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
       </a><b><i>frags_it</i></b>, <b><i>frags_it_next</i></b>,
       <b><i>frags_it_len</i></b>, <b><i>frags_it_data</i></b>
     </dd>
</dl><p>
</p><h4 class="jdocu"><a class="not-numbered" id="device-api-functions.html:frags_it_len">frags_it_len()</a></h4>
<p>

<a id="device-api-functions.html:frags_it_len2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_frags_it_len"></a><b>frags_it_len</b>  return the length of the current fragment</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE size_t
frags_it_len(frags_it_t it);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Return the length of the current fragment pointed by the iterator
     <i>it</i>.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
The length of the current fragment</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
<pre class="jdocu_small">unsigned sum = 0;
for (frags_it_t it = frags_it(&amp;foo, 0, frags_len(&amp;foo));
     !frags_it_end(it);
     it = frags_it_next(it)) {
        unsigned f_len = frags_it_len(it);
        const uint8 *f_data = frags_it_data(it);

        for (int i=0; i&lt;f_len; i++)
                sum += f_data[i];
}
</pre><p>

     </p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
       </a><b><i>frags_it</i></b>, <b><i>frags_it_end</i></b>,
       <b><i>frags_it_next</i></b>, <b><i>frags_it_data</i></b>
     </dd>
</dl><p>
</p><h4 class="jdocu"><a class="not-numbered" id="device-api-functions.html:frags_it_next">frags_it_next()</a></h4>
<p>

<a id="device-api-functions.html:frags_it_next2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_frags_it_next"></a><b>frags_it_next</b>  return the next fragment's iterator</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE frags_it_t
frags_it_next(frags_it_t it);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Return an iterator pointing at the next data fragment. This function
     should only be called if <b><i>frags_end(it)</i></b> returns
     <code>false</code>.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
An iterator on the next fragment</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
<pre class="jdocu_small">unsigned sum = 0;
for (frags_it_t it = frags_it(&amp;foo, 0, frags_len(&amp;foo));
     !frags_it_end(it);
     it = frags_it_next(it)) {
        unsigned f_len = frags_it_len(it);
        const uint8 *f_data = frags_it_data(it);

        for (int i=0; i&lt;f_len; i++)
                sum += f_data[i];
}
</pre><p>

     </p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
       </a><b><i>frags_it</i></b>, <b><i>frags_it_end</i></b>,
       <b><i>frags_it_len</i></b>, <b><i>frags_it_data</i></b>
     </dd>
</dl><p>
</p><h4 class="jdocu"><a class="not-numbered" id="device-api-functions.html:frags_len">frags_len()</a></h4>
<p>

<a id="device-api-functions.html:frags_len2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_frags_len"></a><b>frags_len</b>  return the total data length</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE size_t frags_len(const frags_t *buf);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Return the total length of the data represented by <i>buf</i>.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
The total data length</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
<pre class="jdocu_small">unsigned len = frags_len(&amp;foo);
</pre><p>

     </p></dd>
</dl><p>
</p><h4 class="jdocu"><a class="not-numbered" id="device-api-functions.html:frags_prefix">frags_prefix()</a></h4>
<p>

<a id="device-api-functions.html:frags_prefix2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_frags_prefix"></a><b>frags_prefix</b>  prefix a <code>frags_t</code> with a header</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE frags_t
frags_prefix(const void *header, size_t header_len, const frags_t *body);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Create a <code>frags_t</code> composed of the header <i>header</i>
     of size <i>header_len</i>, followed by the contents of the
     <code>frags_t</code> <i>body</i>.
<p>
     This function is equivalent to a sequence of <b><i>frags_init()</i></b>,
     <b><i>frags_add()</i></b>, <b><i>frags_add_from_frags()</i></b> to build a new
     fragment containing the prefix. It is provided for convenience.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
A new <code>frags_t</code> including
     <i>header</i> and <i>body</i></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
<pre class="jdocu_small">uint8 eth_header[14] = { 0 };
frags_t packet = frags_prefix(eth_header, sizeof(eth_header), &amp;foo);
</pre><p>

     </p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
       </a><b><i>frags_suffix</i></b>, <b><i>frags_add_from_frags</i></b>
     </dd>
</dl><p>
</p><h4 class="jdocu"><a class="not-numbered" id="device-api-functions.html:frags_suffix">frags_suffix()</a></h4>
<p>

<a id="device-api-functions.html:frags_suffix2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_frags_suffix"></a><b>frags_suffix</b>  append a suffix to a <code>frags_t</code></dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE frags_t
frags_suffix(const frags_t *body, void *header, size_t header_len);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Create a <code>frags_t</code> composed of the contents of the
     <code>frags_t</code> <i>body</i>, followed by the data
     <i>header</i> of size <i>header_len</i>.
<p>
     This function is equivalent to a sequence of <b><i>frags_init()</i></b>,
     <b><i>frags_add_from_frags()</i></b>, <b><i>frags_add()</i></b> to build a new
     fragment containing the suffix. It is provided for convenience.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
A new <code>frags_t</code> including
     <i>body</i> and <i>header</i></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
<pre class="jdocu_small">uint8 eth_checksum[4] = { 0 };
frags_t frame = frags_suffix(&amp;foo, eth_checksum, sizeof(eth_checksum));
</pre><p>

     </p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
       </a><b><i>frags_prefix</i></b>, <b><i>frags_add_from_frags</i></b>
     </dd>
</dl><p>
</p><h4 class="jdocu"><a class="not-numbered" id="device-api-functions.html:frags_t-frags_it_t">frags_t, frags_it_t</a></h4>
<p>
   
   
     <a id="device-api-functions.html:frags_t2"></a>
     <a id="device-api-functions.html:frags_it_t"></a>
     
     </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_frags_t"></a>frags_t, frags_it_t</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">typedef struct frags frags_t;</pre><p>

         
</p><pre class="jdocu_small">typedef struct frags_it frags_it_t;</pre><p>

       </p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
These types encapsulate a data packet, for use by
         models that send and receive data, such as network devices.
<p>
         The structures should never be used directly. Only use the accessor
         functions.
       </p></dd>
</dl><p>


    </p><h2 class="jdocu"><a id="device-api-functions.html:Dynamic-Memory-Management">3.3.2 Dynamic Memory Management</a></h2>
<p>
</p><p>
   
</p><p>
   These are routines for manual dynamic memory allocation providing
   some memory leak detection. They replace the standard C <b><i>malloc</i></b>
   facility in Simics APIs.
</p><p>
   Example: to allocate an array of 13 elements of type <code>device_t</code>,
   use
</p><p>
</p><pre class="jdocu_small">    device_t *d = MM_MALLOC(13, device_t);
</pre><p>
</p><p>
   It must be possible to get a pointer to the type by appending an asterisk to
   the type name; so <code>struct foo *</code> is acceptable, but
   <code>int (*)(void)</code> is not. Use a typedef in these cases.
</p><p>
   It is not possible to mix these calls with the <b><i>malloc</i></b>
   facility for the same allocations.
</p><p>
   </p><h3 class="jdocu"><a class="not-numbered" id="device-api-functions.html:Macro-List">Macro List</a></h3>
<p></p><h4 class="jdocu"><a class="not-numbered" id="device-api-functions.html:MM_FREE">MM_FREE()</a></h4>
<p>

<a id="device-api-functions.html:MM_FREE2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_MM_FREE"></a><b>MM_FREE</b>  free allocation</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">MM_FREE(p);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<b><i>MM_FREE</i></b> frees an allocation previously made with
  <b><i>MM_MALLOC</i></b>, <b><i>MM_MALLOC_SZ</i></b>, <b><i>MM_ZALLOC</i></b>,
  <b><i>MM_ZALLOC_SZ</i></b>, <b><i>MM_REALLOC</i></b>, <b><i>MM_REALLOC_SZ</i></b>
  or <b><i>MM_STRDUP</i></b>.
<p>
  A null pointer argument is legal, in which case nothing happens.</p></dd>
</dl><p>
</p><h4 class="jdocu"><a class="not-numbered" id="device-api-functions.html:MM_MALLOC">MM_MALLOC()</a></h4>
<p>

<a id="device-api-functions.html:MM_MALLOC2"></a><a id="device-api-functions.html:MM_MALLOC_SZ"></a><a id="device-api-functions.html:MM_ZALLOC"></a><a id="device-api-functions.html:MM_ZALLOC_SZ"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_MM_MALLOC"></a><b>MM_MALLOC</b><b>, MM_MALLOC_SZ</b><b>, MM_ZALLOC</b><b>, MM_ZALLOC_SZ</b>  allocate memory</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">MM_MALLOC(nelems, type);
</pre><p></p><pre class="jdocu_small">MM_MALLOC_SZ(size, type);
</pre><p></p><pre class="jdocu_small">MM_ZALLOC(nelems, type);
</pre><p></p><pre class="jdocu_small">MM_ZALLOC_SZ(size, type);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<b><i>MM_MALLOC</i></b> allocates <i>nelems</i> objects of type
  <i>type</i>. <b><i>MM_MALLOC_SZ</i></b> specifies the total allocation size
  in bytes.
<p>
  <b><i>MM_ZALLOC</i></b> and <b><i>MM_ZALLOC_SZ</i></b> do the same thing as
  <b><i>MM_MALLOC</i></b> and <b><i>MM_ZALLOC</i></b> respectively but in addition
  fill the allocated memory with null bytes.
</p><p>
  If <i>nelems</i> or <i>size</i> are zero, either a null pointer
  or a pointer to a zero-sized allocation is returned.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Pointer to the allocated object(s).</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
All contexts (including Threaded Context)</dd>
</dl><p>
</p><h4 class="jdocu"><a class="not-numbered" id="device-api-functions.html:MM_REALLOC">MM_REALLOC()</a></h4>
<p>

<a id="device-api-functions.html:MM_REALLOC2"></a><a id="device-api-functions.html:MM_REALLOC_SZ"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_MM_REALLOC"></a><b>MM_REALLOC</b><b>, MM_REALLOC_SZ</b>  reallocate memory</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">MM_REALLOC(p, nelems, type);
</pre><p></p><pre class="jdocu_small">MM_REALLOC_SZ(p, size, type);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<b><i>MM_REALLOC</i></b> changes the size of an allocated memory block to
  <i>nelems</i> elements. <b><i>MM_REALLOC_SZ</i></b> specifies the new size
  in bytes.
<p>
  The allocation must originally have been made by a call to
  <b><i>MM_MALLOC</i></b>, <b><i>MM_MALLOC_SZ</i></b>, <b><i>MM_ZALLOC</i></b>,
  <b><i>MM_ZALLOC_SZ</i></b>, <b><i>MM_REALLOC</i></b>, <b><i>MM_REALLOC_SZ</i></b>
  or <b><i>MM_STRDUP</i></b>.
</p><p>
  If the passed pointer is null, then these macros are equivalent to an
  allocation of the desired amount. If <i>nelems</i> or <i>size</i> is
  zero, either a null pointer or a pointer to a zero-sized allocation is
  returned, and the original allocation is freed.
</p><p>
  The allocation must be freed using <b><i>MM_FREE</i></b>.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Pointer to the reallocated object(s).
  </dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
All contexts (including Threaded Context)</dd>
</dl><p>
</p><h4 class="jdocu"><a class="not-numbered" id="device-api-functions.html:MM_STRDUP">MM_STRDUP()</a></h4>
<p>

<a id="device-api-functions.html:MM_STRDUP2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="device-api-functions.html:__jdocu_seealso_MM_STRDUP"></a><b>MM_STRDUP</b>  duplicate a string</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">MM_STRDUP(str);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Allocates and initializes a copy of the null-terminated string
  <i>str</i>. The allocation must be freed with <b><i>MM_FREE</i></b>.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Pointer to the newly allocated
  string.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
All contexts (including Threaded Context)</dd>
</dl><p>

    
</p></section><section class="page" id="obsolete-device-api-types-and-functions.html"><h1 class="jdocu"><a id="obsolete-device-api-types-and-functions.html:Obsolete-Device-API-Types-and-Functions">3.4 Obsolete Device API Types and Functions</a></h1>
<p>
    
</p><p>
    

    The following types and functions are still available when a module is
    compiled for an obsolete API. Compiling for an obsolete API is described
    in the <em>Model Builder User's Guide</em>.
</p><p>
    The DBuffer library is part of the Simics API.  Up to Simics 4.0, it was
    the preferred method to transfer data blocks, such as network packets,
    inside the simulation. For code using the new link based on the link
    library, and for new models, we recommend using the <code>frags_t</code>
    data type instead.

</p><p>
    </p><h2 class="jdocu"><a id="obsolete-device-api-types-and-functions.html:Obsolete-Device-API-Types">3.4.1 Obsolete Device API Types</a></h2>
<p></p><h3 class="jdocu"><a class="not-numbered" id="obsolete-device-api-types-and-functions.html:dbuffer_t">dbuffer_t</a></h3>
<p>
   
   
   <a id="obsolete-device-api-types-and-functions.html:dbuffer_t2"></a>
   </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="obsolete-device-api-types-and-functions.html:__jdocu_seealso_dbuffer_t"></a>dbuffer_t</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<span class="jdocu_smaller">
   
<pre class="jdocu_small">typedef struct dbuffer dbuffer_t;</pre><p>

   
   </p></span></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This type is used to store blocks of binary data.  It is optimized
   for fast adding and removing of data, and does fast copying between
   buffers using copy-on-write semantics.
<p>
   The type is not inherently thread safe, so each instance must have a single
   thread as owner, and only the owner can read or write from the instance,
   however ownership can be transferred to another thread. To share the data
   with other threads, the instance must first be cloned using
   <b><i>dbuffer_clone</i></b>.
</p><p>
   </p><div class="note">
<b>Note:</b>
This is a legacy data type. New code should use one of
   <code>frags_t</code>, <code>bytes_t</code> or <code>buffer_t</code>.</div></dd>
</dl><p>
   </p><h3 class="jdocu"><a class="not-numbered" id="obsolete-device-api-types-and-functions.html:init_prefs_t">init_prefs_t</a></h3>
<p>
   
   
   <a id="obsolete-device-api-types-and-functions.html:init_prefs_t2"></a>
   </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="obsolete-device-api-types-and-functions.html:__jdocu_seealso_init_prefs_t"></a>init_prefs_t</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<span class="jdocu_small">
   
   
<pre class="jdocu_small">typedef struct {
        bool batch_mode;
        bool quiet;
        bool verbose;
        bool python_verbose;
        bool disable_istc;
        bool disable_dstc;
        bool module_cache_enable;
        bool rdp;
        bool sign_module;
        const char *log_file;

        /* The Simics project to use */
        const char *project;       // NULL to use saved prefs value

        const char *package_list;  // internal, do not use

        bool no_windows;
        bool fail_on_warnings;
        const char *deprecation_level; // see sim-&gt;warn_deprecated
        bool warn_deprecated;       // same as deprecation_level == 2
        bool no_warn_deprecated;    // same as deprecation_level == 0

        bool warn_multithread;  /* deprecated and ignored (bug 21597) */
        bool check_ifaces;
        bool no_global_settings;    // do not read preferences and recent-files

        /* the following should be -1 if not set by command line options
           to tell SIM_init_simulator() to use the saved preference value */
        int log_enable;
} init_prefs_t;</pre><p>

   
   </p></span></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The <code>init_prefs_t</code> types are
   deprecated and should not be used in new code.
   </dd>
</dl><p>
   </p><h3 class="jdocu"><a class="not-numbered" id="obsolete-device-api-types-and-functions.html:log_type_t">log_type_t</a></h3>
<p>
   
   
   <a id="obsolete-device-api-types-and-functions.html:log_type_t2"></a>
   </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="obsolete-device-api-types-and-functions.html:__jdocu_seealso_log_type_t"></a>log_type_t</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<span class="jdocu_smaller">
   
   
<pre class="jdocu_small">typedef enum {
        Sim_Log_Info,           // Normal informational message
        Sim_Log_Error,          // Simics error
        Sim_Log_Spec_Violation, // target program violates the specification
        Sim_Log_Unimplemented,  // not implemented in Simics
        Sim_Log_Critical,       // Critical error stopping Simics
        Sim_Log_Trace,          // Breakpoint trace messages
        Sim_Log_Warning,        // Simics warning
        Sim_Log_Num_Types,      // Do not use
} log_type_t;</pre><p>

   
   </p></span></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This type defines different log types that are used by the logging
   facility to categorise messages.
   </dd>
</dl><p>
   
    </p><p>
    </p><h2 class="jdocu"><a id="obsolete-device-api-types-and-functions.html:Obsolete-Device-API-Functions">3.4.2 Obsolete Device API Functions</a></h2>
<p></p><h3 class="jdocu"><a class="not-numbered" id="obsolete-device-api-types-and-functions.html:SIM_is_loading_micro_checkpoint">SIM_is_loading_micro_checkpoint()</a></h3>
<p>

<a id="obsolete-device-api-types-and-functions.html:SIM_is_loading_micro_checkpoint2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="obsolete-device-api-types-and-functions.html:__jdocu_seealso_SIM_is_loading_micro_checkpoint"></a><b>SIM_is_loading_micro_checkpoint</b>  obsolete API function</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">bool
SIM_is_loading_micro_checkpoint(conf_object_t *obj);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Don't use. There is no longer a concept of micro-checkpoints after
   removal of reverse execution.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="obsolete-device-api-types-and-functions.html:dbuffer_append">dbuffer_append()</a></h3>
<p>

<a id="obsolete-device-api-types-and-functions.html:dbuffer_append2"></a><a id="obsolete-device-api-types-and-functions.html:dbuffer_prepend"></a><a id="obsolete-device-api-types-and-functions.html:dbuffer_insert"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="obsolete-device-api-types-and-functions.html:__jdocu_seealso_dbuffer_append"></a><b>dbuffer_append</b><b>, dbuffer_prepend</b><b>, dbuffer_insert</b>  Add data to a dbuffer</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">uint8 *
dbuffer_append(dbuffer_t *dbuffer, size_t len);
</pre><p></p><pre class="jdocu_small">uint8 *
dbuffer_prepend(dbuffer_t *dbuffer, size_t len);
</pre><p></p><pre class="jdocu_small">uint8 *
dbuffer_insert(dbuffer_t *dbuffer, size_t offset, size_t len);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
These functions will extend the dbuffer with <i>len</i>
   bytes and return a pointer to the added bytes.  The
   <b><i>dbuffer_insert</i></b> function adds the new data at
   <i>offset</i> in the buffer, while the
   <b><i>dbuffer_prepend</i></b> and <b><i>dbuffer_append</i></b> functions
   add it at the beginning and end, respectively.
<p>
   The returned pointer points to a memory area that is only guaranteed to
   contain valid data for the newly added bytes, and it is illegal to
   reference data before it or more than <i>len</i>-1 bytes ahead.
   The new memory area is not guaranteed to be initialized.
</p><p>
   The returned pointer is also only valid until the next operation on
   the dbuffer function, except for calling <b><i>dbuffer_len</i></b>.</p></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="obsolete-device-api-types-and-functions.html:dbuffer_append_external_data">dbuffer_append_external_data()</a></h3>
<p>

<a id="obsolete-device-api-types-and-functions.html:dbuffer_append_external_data2"></a><a id="obsolete-device-api-types-and-functions.html:dbuffer_prepend_external_data"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="obsolete-device-api-types-and-functions.html:__jdocu_seealso_dbuffer_append_external_data"></a><b>dbuffer_append_external_data</b><b>, dbuffer_prepend_external_data</b>  Add static data</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">uint8 *
dbuffer_append_external_data(dbuffer_t *dbuffer, void *data,
                             size_t len, bool adopt);
</pre><p></p><pre class="jdocu_small">uint8 *
dbuffer_prepend_external_data(dbuffer_t *dbuffer, void *data,
                              size_t len, bool adopt);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
These functions work similar to <b><i>dbuffer_append</i></b> and
   <b><i>dbuffer_prepend</i></b>, but with the difference that the data
   isn't copied.  Instead, the buffer will reference the data pointed
   to directly.
 <p>
   If the <i>adopt</i> flag is true, the control of the data
   block is transferred to the dbuffer.  It is assumed to be a block
   allocated with <b><i>MM_MALLOC</i></b>, and will be freed with
   <b><i>MM_FREE</i></b> when the dbuffer is released.
 </p><p>
   If the <i>adopt</i> flag is false, the dbuffer will not free the
   memory. Since there is no way to control the lifetime of the external
   reference if the dbuffer reference has been passed to another function, this
   option should never be used to point to memory on the stack or to memory
   that will eventually deallocated. Pointing to static memory is usually
   safe. This should also only be used for buffers that will only be read from,
   since there is no way to know when the external pointer is used, and when a
   copy is used.</p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#obsolete-device-api-types-and-functions.html:__jdocu_seealso_dbuffer_append">
       dbuffer_append
   </a></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="obsolete-device-api-types-and-functions.html:dbuffer_append_value">dbuffer_append_value()</a></h3>
<p>

<a id="obsolete-device-api-types-and-functions.html:dbuffer_append_value2"></a><a id="obsolete-device-api-types-and-functions.html:dbuffer_prepend_value"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="obsolete-device-api-types-and-functions.html:__jdocu_seealso_dbuffer_append_value"></a><b>dbuffer_append_value</b><b>, dbuffer_prepend_value</b>  Add data with uniform content</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">uint8 *
dbuffer_append_value(dbuffer_t *dbuffer, int value, size_t len);
</pre><p></p><pre class="jdocu_small">uint8 *
dbuffer_prepend_value(dbuffer_t *dbuffer, int value, size_t len);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This adds data to a dbuffer and sets all the added bytes to
   <i>value</i>.  It has the same effect as using
   <b><i>dbuffer_append</i></b> or <b><i>dbuffer_append</i></b> and calling
   <b><i>memset</i></b> to set the contents.
<p>
   The return value is a pointer to the data just added.</p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#obsolete-device-api-types-and-functions.html:__jdocu_seealso_dbuffer_append">
       dbuffer_append
   </a></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="obsolete-device-api-types-and-functions.html:dbuffer_clone">dbuffer_clone()</a></h3>
<p>

<a id="obsolete-device-api-types-and-functions.html:dbuffer_clone2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="obsolete-device-api-types-and-functions.html:__jdocu_seealso_dbuffer_clone"></a><b>dbuffer_clone</b>  Make a full copy of another buffer</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">dbuffer_t *
dbuffer_clone(dbuffer_t *dbuffer);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This function returns a new dbuffer that contains the same data as
   the buffer given in the <i>dbuffer</i> parameter.  This
   doesn't involve copying any memory, since they can share the same
   storage initially.  However, they are still completely independent,
   and operations on one buffer has no effect on the other.
<p>
   The returned dbuffer should be released with
   <b><i>dbuffer_free</i></b> when it is no longer needed.</p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#obsolete-device-api-types-and-functions.html:__jdocu_seealso_new_dbuffer">
       new_dbuffer</a>, <a class="jdocu" href="#obsolete-device-api-types-and-functions.html:__jdocu_seealso_dbuffer_free"> dbuffer_free
   </a></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="obsolete-device-api-types-and-functions.html:dbuffer_copy_append">dbuffer_copy_append()</a></h3>
<p>

<a id="obsolete-device-api-types-and-functions.html:dbuffer_copy_append2"></a><a id="obsolete-device-api-types-and-functions.html:dbuffer_copy_prepend"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="obsolete-device-api-types-and-functions.html:__jdocu_seealso_dbuffer_copy_append"></a><b>dbuffer_copy_append</b><b>, dbuffer_copy_prepend</b>  Copy data from a dbuffer</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
dbuffer_copy_append(dbuffer_t *dst, dbuffer_t *src, size_t offset, size_t len);
</pre><p></p><pre class="jdocu_small">void
dbuffer_copy_prepend(dbuffer_t *dst, dbuffer_t *src, size_t offset, size_t len);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
These functions copies <i>len</i> bytes from the dbuffer
   <i>src</i>, at offset <i>offset</i>, and adds it to
   the beginning or end of the dbuffer <i>dst</i>.
<p>
   This can often be done without actually copying any memory, so it
   is usually very efficient.</p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#obsolete-device-api-types-and-functions.html:__jdocu_seealso_dbuffer_append">
       dbuffer_append
   </a></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="obsolete-device-api-types-and-functions.html:dbuffer_free">dbuffer_free()</a></h3>
<p>

<a id="obsolete-device-api-types-and-functions.html:dbuffer_free2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="obsolete-device-api-types-and-functions.html:__jdocu_seealso_dbuffer_free"></a><b>dbuffer_free</b>  Release a dbuffer</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
dbuffer_free(dbuffer_t *dbuffer);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Release a dbuffer that will not be used anymore.  This will also
   free any data in the buffer that isn't also used by other buffers.
   After calling this function, the dbuffer must not be used anymore.
<p>
   See also src/include/simics/util/dbuffer.h</p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#obsolete-device-api-types-and-functions.html:__jdocu_seealso_new_dbuffer">
       new_dbuffer
   </a></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="obsolete-device-api-types-and-functions.html:dbuffer_len">dbuffer_len()</a></h3>
<p>

<a id="obsolete-device-api-types-and-functions.html:dbuffer_len2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="obsolete-device-api-types-and-functions.html:__jdocu_seealso_dbuffer_len"></a><b>dbuffer_len</b>  Get the size of a dbuffer</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">size_t
dbuffer_len(const dbuffer_t *dbuffer);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This function returns the amount of data stored in a dbuffer.  This
   is the number of bytes that will be returned by
   <b><i>dbuffer_read_all</i></b>.</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="obsolete-device-api-types-and-functions.html:dbuffer_read">dbuffer_read()</a></h3>
<p>

<a id="obsolete-device-api-types-and-functions.html:dbuffer_read2"></a><a id="obsolete-device-api-types-and-functions.html:dbuffer_read_all"></a><a id="obsolete-device-api-types-and-functions.html:dbuffer_read_some"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="obsolete-device-api-types-and-functions.html:__jdocu_seealso_dbuffer_read"></a><b>dbuffer_read</b><b>, dbuffer_read_all</b><b>, dbuffer_read_some</b>  Extract data for reading</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">const uint8 *
dbuffer_read(dbuffer_t *dbuffer, size_t offset, size_t len);
</pre><p></p><pre class="jdocu_small">const uint8 *
dbuffer_read_all(dbuffer_t *dbuffer);
</pre><p></p><pre class="jdocu_small">const uint8 *
dbuffer_read_some(dbuffer_t *dbuffer, size_t offset, size_t len,
                  size_t *actual_len);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The <i>offset</i> and <i>len</i> parameters specify
   a region of the buffer to read from.  The returned pointer is
   guaranteed to point to a contiguous block of memory of size
   <i>len</i>.  It is illegal to write to the block return by
   these functions, since they may be shared by other dbuffers.  Use
   the <b><i>dbuffer_update</i></b> functions if you need to both read
   and write to the dbuffer.
 <p>
   The returned pointer is only valid until the next operation on the
   dbuffer, except for calling <b><i>dbuffer_len</i></b>.
</p><p>
   The <i>offset</i> and <i>len</i> must specify a
   valid region, so that the end of the region is not past the end of
   the dbuffer.
 </p><p>
   The <b><i>dbuffer_read_some</i></b> function takes an
   <i>actual_len</i> parameter, and may return a smaller
   buffer than requested.  The actual number of valid bytes in the
   returned buffer is stored in *<i>actual_len</i>.  It will
   return a smaller buffer if it would have had to copy memory to
   return a pointer to the whole region.  This means that you can use
   this function repeatedly to extract all the requested data in the
   most efficient way.  If <code>NULL</code> is passed for
   <i>actual_len</i>, it will return the full region.
 </p><p>
   The <b><i>dbuffer_read_all</i></b> function assumes 0 for
   <i>offset</i>, and <code>buffer_len(dbuffer)</code> for
   <i>len</i>.</p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#obsolete-device-api-types-and-functions.html:__jdocu_seealso_dbuffer_update">
       dbuffer_update</a>, <a class="jdocu" href="#obsolete-device-api-types-and-functions.html:__jdocu_seealso_dbuffer_replace"> dbuffer_replace
   </a></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="obsolete-device-api-types-and-functions.html:dbuffer_remove">dbuffer_remove()</a></h3>
<p>

<a id="obsolete-device-api-types-and-functions.html:dbuffer_remove2"></a><a id="obsolete-device-api-types-and-functions.html:dbuffer_remove_head"></a><a id="obsolete-device-api-types-and-functions.html:dbuffer_remove_tail"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="obsolete-device-api-types-and-functions.html:__jdocu_seealso_dbuffer_remove"></a><b>dbuffer_remove</b><b>, dbuffer_remove_head</b><b>, dbuffer_remove_tail</b>  Remove data from a dbuffer</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
dbuffer_remove(dbuffer_t *dbuffer, size_t offset, size_t remove_len);
</pre><p></p><pre class="jdocu_small">void
dbuffer_remove_head(dbuffer_t *dbuffer, size_t remove_len);
</pre><p></p><pre class="jdocu_small">void
dbuffer_remove_tail(dbuffer_t *dbuffer, size_t remove_len);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
These functions will remove <i>remove_len</i> bytes from
   <i>dbuffer</i>.  The <b><i>dbuffer_remove</i></b> function will remove
   data starting at <i>offset</i>, while the other functions will
   remove data from the beginning or end of the buffer.
<p>
   This usually doesn't involve moving any memory contents, and should
   be very efficient even if the buffer is large.
</p><p>
   The size of data to remove must be available in the buffer. For example
   <i>offset</i> + <i>remove_len</i> must not be greater than
   the buffers length. Similarly for the <b><i>dbuffer_truncate</i></b> function
   there must be at least <i>new_size</i> bytes in the current buffer.</p></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="obsolete-device-api-types-and-functions.html:dbuffer_replace">dbuffer_replace()</a></h3>
<p>

<a id="obsolete-device-api-types-and-functions.html:dbuffer_replace2"></a><a id="obsolete-device-api-types-and-functions.html:dbuffer_replace_all"></a><a id="obsolete-device-api-types-and-functions.html:dbuffer_replace_some"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="obsolete-device-api-types-and-functions.html:__jdocu_seealso_dbuffer_replace"></a><b>dbuffer_replace</b><b>, dbuffer_replace_all</b><b>, dbuffer_replace_some</b>  Replace data</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">uint8 *
dbuffer_replace(dbuffer_t *dbuffer, size_t offset, size_t len);
</pre><p></p><pre class="jdocu_small">uint8 *
dbuffer_replace_all(dbuffer_t *dbuffer);
</pre><p></p><pre class="jdocu_small">uint8 *
dbuffer_replace_some(dbuffer_t *dbuffer, size_t offset, size_t len,
                     size_t *actual_len);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The <i>offset</i> and <i>len</i> parameters specify
   a region of the buffer to write to.  The returned pointer is
   guaranteed to point to a contiguous block of memory of size
   <i>len</i>, but is not guaranteed to contain the existing
   data in the buffer.  Use these functions when completely replacing
   a region of the buffer with new data.
 <p>
   The returned pointer is only valid until the next operation on the
   dbuffer, except for calling <b><i>dbuffer_len</i></b>.
</p><p>
   The <i>offset</i> and <i>len</i> must specify a
   valid region, so that the end of the region is not past the end of
   the dbuffer.
</p><p>
   The <b><i>dbuffer_replace_some</i></b> function takes an
   <i>actual_len</i> parameter, and may return a smaller
   buffer than requested.  The actual number of valid bytes in the
   returned buffer is stored in *<i>actual_len</i>.  It will
   return a smaller buffer if it would have had to copy memory to
   return a pointer to the whole region.  This means that you can use
   this function repeatedly to write all the requested data in the
   most efficient way.  If <code>NULL</code> is passed for
   <i>actual_len</i>, it will return the full region.
 </p><p>
   The <b><i>dbuffer_replace_all</i></b> function assumes 0 for
   <i>offset</i>, and <code>buffer_len(dbuffer)</code> for
   <i>len</i>.</p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#obsolete-device-api-types-and-functions.html:__jdocu_seealso_dbuffer_read">
       dbuffer_read</a>, <a class="jdocu" href="#obsolete-device-api-types-and-functions.html:__jdocu_seealso_dbuffer_update"> dbuffer_update
   </a></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="obsolete-device-api-types-and-functions.html:dbuffer_split">dbuffer_split()</a></h3>
<p>

<a id="obsolete-device-api-types-and-functions.html:dbuffer_split2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="obsolete-device-api-types-and-functions.html:__jdocu_seealso_dbuffer_split"></a><b>dbuffer_split</b>  Split a dbuffer</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">dbuffer_t *
dbuffer_split(dbuffer_t *dbuffer, size_t offset);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This function returns a new dbuffer that contains the
   <i>offset</i> first bytes from <i>dbuffer</i>, and
   removes those bytes from <i>dbuffer</i>  The effect is that
   the dbuffer is split in two halves, leaving the second half in the
   original dbuffer and returning the first half as a new dbuffer.
<p>

   The returned dbuffer should be released with
   <b><i>dbuffer_free</i></b> when it is no longer needed.</p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#obsolete-device-api-types-and-functions.html:__jdocu_seealso_new_dbuffer">
       new_dbuffer</a>, <a class="jdocu" href="#obsolete-device-api-types-and-functions.html:__jdocu_seealso_dbuffer_free"> dbuffer_free
   </a></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="obsolete-device-api-types-and-functions.html:dbuffer_update">dbuffer_update()</a></h3>
<p>

<a id="obsolete-device-api-types-and-functions.html:dbuffer_update2"></a><a id="obsolete-device-api-types-and-functions.html:dbuffer_update_all"></a><a id="obsolete-device-api-types-and-functions.html:dbuffer_update_some"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="obsolete-device-api-types-and-functions.html:__jdocu_seealso_dbuffer_update"></a><b>dbuffer_update</b><b>, dbuffer_update_all</b><b>, dbuffer_update_some</b>  Extract data for updating</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">uint8 *
dbuffer_update(dbuffer_t *dbuffer, size_t offset, size_t len);
</pre><p></p><pre class="jdocu_small">uint8 *
dbuffer_update_all(dbuffer_t *dbuffer);
</pre><p></p><pre class="jdocu_small">uint8 *
dbuffer_update_some(dbuffer_t *dbuffer, size_t offset, size_t len,
                    size_t *actual_len);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The <i>offset</i> and <i>len</i> parameters specify
   a region of the buffer to access.  The returned pointer is
   guaranteed to point to a contiguous block of memory of size
   <i>len</i>.  The block can be used for reading and writing
   data to the dbuffer.
 <p>
   The returned pointer is only valid until the next operation on the
   dbuffer, except for calling <b><i>dbuffer_len</i></b>.
</p><p>
   The <i>offset</i> and <i>len</i> must specify a
   valid region, so that the end of the region is not past the end of
   the dbuffer.
 </p><p>
   The <b><i>dbuffer_update_some</i></b> function takes an
   <i>actual_len</i> parameter, and may return a smaller
   buffer than requested.  The actual number of valid bytes in the
   returned buffer is stored in *<i>actual_len</i>.  It will
   return a smaller buffer if it would have had to copy memory to
   return a pointer to the whole region.  This means that you can use
   this function repeatedly to access all the requested data in the
   most efficient way.  If <code>NULL</code> is passed for
   <i>actual_len</i>, it will return the full region.
 </p><p>
   The <b><i>dbuffer_update_all</i></b> function assumes 0 for
   <i>offset</i>, and <code>buffer_len(dbuffer)</code> for
   <i>len</i>.</p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#obsolete-device-api-types-and-functions.html:__jdocu_seealso_dbuffer_read">
       dbuffer_read</a>, <a class="jdocu" href="#obsolete-device-api-types-and-functions.html:__jdocu_seealso_dbuffer_replace"> dbuffer_replace
   </a></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="obsolete-device-api-types-and-functions.html:new_dbuffer">new_dbuffer()</a></h3>
<p>

<a id="obsolete-device-api-types-and-functions.html:new_dbuffer2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="obsolete-device-api-types-and-functions.html:__jdocu_seealso_new_dbuffer"></a><b>new_dbuffer</b>  Create a new dbuffer</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">dbuffer_t *
new_dbuffer();
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This function returns an empty dbuffer. Use it when you need a new
   dbuffer, and call <b><i>dbuffer_free</i></b> when it isn't needed
   anymore.
<p>
   See also src/include/simics/util/dbuffer.h</p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#obsolete-device-api-types-and-functions.html:__jdocu_seealso_dbuffer_free">
       dbuffer_free</a>, <a class="jdocu" href="#obsolete-device-api-types-and-functions.html:__jdocu_seealso_dbuffer_clone"> dbuffer_clone
   </a></dd>
</dl><p>

</p></section><section class="page" id="model-to-model-interfaces.html"><h1 class="jdocu"><a id="model-to-model-interfaces.html:Model-to-Model-Interfaces">4 Model-to-Model Interfaces</a></h1>
<p>

    















































































































































































</p></section><section class="page" id="__rm_interface_a20.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_a20.html:__rm_interface_a20">a20</a></h1>
<p>

<a id="__rm_interface_a20.html:a20"></a><a id="__rm_interface_a20.html:a20_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This interface is used between the A20 line handling device
   (typically the keyboard controller) and the x86 processor. The processor
   implements this interface and the keyboard controller calls it.
<p>
   </p><pre class="jdocu_small">SIM_INTERFACE(a20) {
        void (*set_a20_line)(conf_object_t *NOTNULL obj, int value);
        int (*get_a20_line)(conf_object_t *NOTNULL obj);
};

#define A20_INTERFACE "a20"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_apic_bus.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_apic_bus.html:__rm_interface_apic_bus">apic_bus</a></h1>
<p>

<a id="__rm_interface_apic_bus.html:apic_bus"></a><a id="__rm_interface_apic_bus.html:apic_bus_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This interface is implemented by all apic buses, and used by the IO-APICs to
   send a message over the bus. 
<p>
   Messages with delivery mode <code>Apic_Delivery_Mode_Ext_INT</code> needs to be
   acknowledged. They are acknowledged at the object pointed to by the apic's
   "pic" attribute via the <code>interrupt_cpu</code> interface.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(apic_bus) {
        apic_bus_status_t (*interrupt)(conf_object_t *obj,
                                       apic_destination_mode_t dest_mode,
                                       apic_delivery_mode_t delivery_mode,
                                       int level_assert,
                                       apic_trigger_mode_t trigger_mode,
                                       uint8 vector,
                                       uint8 destination);
};

#define APIC_BUS_INTERFACE "apic_bus"
</pre><p>
</p><p>

    
</p><pre class="jdocu_small">typedef enum {
        Apic_Destination_Mode_Physical = 0,
        Apic_Destination_Mode_Logical = 1
} apic_destination_mode_t;</pre><p>

    
</p><pre class="jdocu_small">typedef enum {
        Apic_Delivery_Mode_Fixed = 0,
        Apic_Delivery_Mode_Lowest_Priority = 1,
        Apic_Delivery_Mode_SMI = 2,
        Apic_Delivery_Mode_Remote_Read = 3,
        Apic_Delivery_Mode_NMI = 4,
        Apic_Delivery_Mode_INIT = 5,
        Apic_Delivery_Mode_Start_Up = 6,
        Apic_Delivery_Mode_Ext_INT = 7
} apic_delivery_mode_t;</pre><p>

    
</p><pre class="jdocu_small">typedef enum {
        Apic_Trigger_Mode_Edge = 0,
        Apic_Trigger_Mode_Level = 1
} apic_trigger_mode_t;</pre><p>

    
</p><pre class="jdocu_small">typedef enum {
        Apic_Bus_Accepted = 0,
        Apic_Bus_Retry = 1,
        Apic_Bus_No_Target = 2,
        Apic_Bus_Invalid = 3
} apic_bus_status_t;</pre><p>

</p><p>
   See the architecture software developer's manual for more information about
   the parameters. For IPIs, the sender is responsible for filtering out
   reserved vectors (vectors 0 through 15) and flagging the appropriate error
   on the sending side. For I/O-APIC initiated interrupts, reserved vectors can
   be sent and will flag errors in the receiving APICs.
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_apic_cpu.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_apic_cpu.html:__rm_interface_apic_cpu">apic_cpu</a></h1>
<p>

<a id="__rm_interface_apic_cpu.html:apic_cpu"></a><a id="__rm_interface_apic_cpu.html:apic_cpu_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This interface is implemented by the local APIC device and is used by the
   processor and machine initialization code to interact with the local APIC.
<p>
   The <b><i>tpr_r</i></b> and <b><i>tpr_w</i></b> methods read and write the task
   priority register. The format of the <i>tpr</i> argument and the
   returned value from <b><i>tpr_r</i></b> is the same as for CR8, meaning
   TPR[bits 7:4], zero extended to 64 bits.
</p><p>
   Interrupts coming from the CPU itself are passed via the
   <b><i>local_int</i></b> function. The type of interrupt is one of the constants
   defined in <code>local_apic_interrupt_t</code>.
</p><p>
   
</p><pre class="jdocu_small">typedef enum {
        Apic_Lvt_2e = 0x2e0,
        Apic_CMCI = 0x2f0,
        Apic_Performance_Counter = 0x340,
        Apic_Thermal_Sensor = 0x330
} local_apic_interrupt_t;</pre><p>

</p><p>
   The <b><i>init</i></b> function is called by the CPU when it receives the INIT
   signal. The APIC should only update its internal state and not propagate
   this signal further. Both the CPU and the APIC should reset their pending
   interrupt flags when this function is called. The <b><i>init</i></b> function
   is not called at instantiation time.
</p><p>
   The <b><i>power_on</i></b> function is called at machine creation time, and the
   call initializes the APIC to the power on state. The <i>bsp</i> argument
   is true if the APIC is connected to the boot processor, and false
   otherwise. The initial APIC ID is set through the <i>apic_id</i>
   argument. The <b><i>power_on</i></b> function would typically be called from
   component code for the processor that includes the APIC.
</p><p>
   The <b><i>enabled_r</i></b> method returns bit 11 from the APIC BASE MSR, and
   is used by the processor to return the correct status for CPUID.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(apic_cpu) {
        uint64 (*tpr_r)(conf_object_t *NOTNULL obj);
        void (*tpr_w)(conf_object_t *NOTNULL obj, uint64 tpr);
        void (*local_int)(conf_object_t *NOTNULL obj,
                          local_apic_interrupt_t int_type);
        void (*power_on)(conf_object_t *NOTNULL obj, bool bsp, int apic_id);
        void (*init)(conf_object_t *NOTNULL obj);
        bool (*enabled_r)(conf_object_t *NOTNULL obj);
};

#define APIC_CPU_INTERFACE "apic_cpu"
</pre><p>
</p><p>

   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_arinc429_bus.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_arinc429_bus.html:__rm_interface_arinc429_bus">arinc429_bus</a></h1>
<p>

<a id="__rm_interface_arinc429_bus.html:arinc429_bus"></a><a id="__rm_interface_arinc429_bus.html:arinc429_bus_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><pre class="jdocu_small">SIM_INTERFACE(arinc429_bus) {
    void (*send_word)(conf_object_t *bus, uint32 word, int parity_ok);
};
</pre><p>
</p><p>

   Interface to Arinc-429 serial buses.
</p><p>
   The <b><i>send_word</i></b> function is used by a device to send an
   Arinc-429 formatted word. The most significant bit (bit 31) is the
   parity bit, but if the device have checksumming built in, it can
   set <i>parity_ok</i> to tell the bus to ignore bit 31 of the data.
</p><p>
   If the parity bit is already calculated, pass -1 as <i>parity_ok</i>.
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_arinc429_receiver.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_arinc429_receiver.html:__rm_interface_arinc429_receiver">arinc429_receiver</a></h1>
<p>

<a id="__rm_interface_arinc429_receiver.html:arinc429_receiver"></a><a id="__rm_interface_arinc429_receiver.html:arinc429_receiver_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><pre class="jdocu_small">SIM_INTERFACE(arinc429_receiver) {
    void (*receive_word)(conf_object_t *dev, uint32 word, int parity_ok);
};
</pre><p>
</p><p>

   Interface to Arinc-429 compatible receivers.
</p><p>
   The <b><i>receive_word</i></b> is called when there is traffic on the bus.
   <i>word</i> contains the data received (with valid parity bit),
   and the <i>parity_ok</i> tells whether the parity of the word
   is correct or not.
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_arm.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_arm.html:__rm_interface_arm">arm</a></h1>
<p>

<a id="__rm_interface_arm.html:arm"></a><a id="__rm_interface_arm.html:arm_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This interface is implemented by ARM processors to provide various
   functionality that is specific for this class of processors.
<p>
   The <b><i>read_register_mode</i></b> and <b><i>write_register_mode</i></b>
   functions are used to access banked copies of the registers. They are used
   just like the <code>int_register</code> interface <b><i>read</i></b> and
   <b><i>write</i></b> functions, except that they take an extra parameter
   <i>mode</i> that specifies which register bank should be used.
   <i>mode</i> should be the mode bits in the cpsr corresponding to
   the mode shifted right to bits 0-4.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(arm) {
        uint64 (*read_register_mode)(conf_object_t *processor_obj,
                                     int reg_num, int mode);
        void (*write_register_mode)(conf_object_t *processor_obj,
                                    int reg_num, int mode, uint64 value);
};

#define ARM_INTERFACE "arm"

</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_arm_avic.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_arm_avic.html:__rm_interface_arm_avic">arm_avic</a></h1>
<p>

<a id="__rm_interface_arm_avic.html:arm_avic"></a><a id="__rm_interface_arm_avic.html:arm_avic_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>ARM AVIC</code> interface makes it possible for an ARM
    processor to get the interrupt vector address from an AVIC device
    connected to the processor core. Both processor and AVIC must
    enable the AVIC interface to support this feature.
<p>
    The processor calls <b><i>get_interrupt_address</i></b> function to
    get the interrupt vector address. The AVIC returns an
    <em>arm_avic_t</em> struct with a <i>valid</i> field and an
    <i>address</i> field, the <i>address</i> field is only valid when
    the <i>valid</i> is not <code>0</code>.
</p><p>
   </p><pre class="jdocu_small">typedef struct arm_avic {
        int valid;
        uint32 address;
} arm_avic_t;

SIM_INTERFACE(arm_avic) {
        arm_avic_t (*get_interrupt_address)(conf_object_t *obj);
};

#define ARM_AVIC_INTERFACE "arm_avic"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_arm_coprocessor.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_arm_coprocessor.html:__rm_interface_arm_coprocessor">arm_coprocessor</a></h1>
<p>

<a id="__rm_interface_arm_coprocessor.html:arm_coprocessor"></a><a id="__rm_interface_arm_coprocessor.html:arm_coprocessor_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">A coprocessor for the ARM has to provide the
   arm_coprocessor_interface. This interface
   defines the functions that will be called when
   the coprocessor instructions (cdp, ldc, mcr, mrc, mrrc, mcrr, stc)
   are executed.
<p>
   The read_register_64_bit and write_register_64_bit are used for
   mrrc and mccr instructions which read and write 64 bit values
   in to two registers.
</p><p>
   The interface also defines a flag, finished, which indicates
   whether a memory transfer operation is finished or not.
</p><p>
   The function reset is called when the cpu is reset,
   and allows the coprocessor to also do a reset,
   the argument hard_reset indicates whether the reset
   was soft (0) or hard (1).
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(arm_coprocessor) {
        void (*process_data)(conf_object_t *NOTNULL obj,
                             uint32 CRd,
                             uint32 opcode_1,
                             uint32 CRn,
                             uint32 CRm,
                             uint32 opcode_2,
                             int type);
        void (*load_coprocessor)(conf_object_t *NOTNULL obj,
                                 uint32 CRd,
                                 uint32 N,
                                 uint32 Options,
                                 uint32 value,
                                 int type);

        uint32 (*read_register)(conf_object_t *NOTNULL obj,
                                uint32 opcode_1,
                                uint32 CRn,
                                uint32 CRm,
                                uint32 opcode_2,
                                int type);
        void (*write_register)(conf_object_t *NOTNULL obj,
                               uint32 value,
                               uint32 opcode_1,
                               uint32 CRn,
                               uint32 CRm,
                               uint32 opcode_2,
                               int type);
        uint64 (*read_register_64_bit)(conf_object_t *NOTNULL obj,
                                       uint32 opcode_1,
                                       uint32 CRm,
                                       int type);
        void (*write_register_64_bit)(conf_object_t *NOTNULL obj,
                                      uint64 value,
                                      uint32 opcode_1,
                                      uint32 CRm,
                                      int type);
        uint32 (*store_coprocessor)(conf_object_t *NOTNULL obj,
                               uint32 CRd,
                               uint32 N,
                               uint32 Options,
                               int type);
        void (*reset)(conf_object_t *NOTNULL obj, int hard_reset);
};

#define ARM_COPROCESSOR_INTERFACE "arm_coprocessor"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_arm_cpu_group_event.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_arm_cpu_group_event.html:__rm_interface_arm_cpu_group_event">arm_cpu_group_event</a></h1>
<p>

<a id="__rm_interface_arm_cpu_group_event.html:arm_cpu_group_event"></a><a id="__rm_interface_arm_cpu_group_event.html:arm_cpu_group_event_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This interface is only intended to be used between Arm CPU objects. It
   contains the functions needed for cross-CPU communication related to
   event signalling.
<p>
   <b><i>signal_event</i></b> notifies the CPU to set the event register.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(arm_cpu_group_event) {
        void (*signal_event)(conf_object_t *obj);
};

#define ARM_CPU_GROUP_EVENT_INTERFACE "arm_cpu_group_event"

</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Threaded Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_arm_cpu_group_exclusive.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_arm_cpu_group_exclusive.html:__rm_interface_arm_cpu_group_exclusive">arm_cpu_group_exclusive</a></h1>
<p>

<a id="__rm_interface_arm_cpu_group_exclusive.html:arm_cpu_group_exclusive"></a><a id="__rm_interface_arm_cpu_group_exclusive.html:arm_cpu_group_exclusive_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This interface is only intended to be used between Arm CPU objects. It
   contains the functions needed for cross-CPU communication related to
   exclusive memory accesses.
<p>
   <b><i>mark_exclusive</i></b> notifies the CPU that another CPU has marked the
   address range as exclusive. The CPU must then probe all CPUs in the CPU
   group for exclusive address ranges using <b><i>probe_exclusive</i></b> and
   possibly invalidate them using <b><i>clear_exclusive</i></b> before accessing
   the address range.
</p><p>
   <b><i>clear_and_probe_exclusive</i></b> notifies the CPU to invalidate any
   exclusive address ranges that it has overlapping the specified clear address
   range. Also returns true if the CPU still has any exclusive address ranges
   overlapping the specified probe address range.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(arm_cpu_group_exclusive) {
        void (*mark_exclusive)(
                conf_object_t *obj,
                physical_address_t address,
                physical_address_t size);
        bool (*clear_and_probe_exclusive)(
                conf_object_t *obj,
                physical_address_t clear_address,
                physical_address_t clear_size,
                physical_address_t probe_address,
                physical_address_t probe_size);
};

#define ARM_CPU_GROUP_EXCLUSIVE_INTERFACE "arm_cpu_group_exclusive"

</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Threaded Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_arm_cpu_group_tlb.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_arm_cpu_group_tlb.html:__rm_interface_arm_cpu_group_tlb">arm_cpu_group_tlb</a></h1>
<p>

<a id="__rm_interface_arm_cpu_group_tlb.html:arm_cpu_group_tlb"></a><a id="__rm_interface_arm_cpu_group_tlb.html:arm_cpu_group_tlb_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This interface is only intended to be used between Arm CPU objects. It
   contains the functions needed for cross-CPU communication related to
   TLB invalidation.
<p>
   <b><i>invalidate_tlb</i></b> notifies the CPU to invalidate TLB entries related
   to the translation regime. If <i>by_virtual_address</i> is true only
   entries containing the specified virtual address should be invalidated,
   otherwise all entries should be invalidated.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(arm_cpu_group_tlb) {
        void (*invalidate_tlb)(
                conf_object_t *obj,
                arm_translation_regime_t translation_regime,
                bool by_virtual_address,
                logical_address_t virtual_address);
};

#define ARM_CPU_GROUP_TLB_INTERFACE "arm_cpu_group_tlb"

</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Threaded Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_arm_external_debug.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_arm_external_debug.html:__rm_interface_arm_external_debug">arm_external_debug</a></h1>
<p>

<a id="__rm_interface_arm_external_debug.html:arm_external_debug"></a><a id="__rm_interface_arm_external_debug.html:arm_external_debug_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This <code>arm_external_debug</code> interface is used for
   external debug feature.
<p>
   The <b><i>handle_semihosting</i></b> function is called whenever the aarch64
   instruction hlt 0xf000 is executed where semihosting is enabled for use.
</p><p>
   The <b><i>read_reg</i></b> function is called reading the registers in external
   debug device.
</p><p>
   The <b><i>write_reg</i></b> function is called writing the registers in
   external debug device.
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_arm_gic.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_arm_gic.html:__rm_interface_arm_gic">arm_gic</a></h1>
<p>

<a id="__rm_interface_arm_gic.html:arm_gic"></a><a id="__rm_interface_arm_gic.html:arm_gic_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This <code>arm_gic</code> interface is used
   accessing registers in a device implementing the Generic Interrupt
   Controller architecture..
<p>
   The <b><i>read_register</i></b> function is called reading the registers in GIC
   device.
</p><p>
   The <b><i>write_register</i></b> function is called writing the registers in
   GIC device.
</p><p>
   The <b><i>cpu_state_changed</i></b> function is called to notify the GIC device
   that the cpu has changed state. This function is only called when the cpu
   changes state with an interrupt pending. 
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_arm_gic_cpu_state.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_arm_gic_cpu_state.html:__rm_interface_arm_gic_cpu_state">arm_gic_cpu_state</a></h1>
<p>

<a id="__rm_interface_arm_gic_cpu_state.html:arm_gic_cpu_state"></a><a id="__rm_interface_arm_gic_cpu_state.html:arm_gic_cpu_state_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This <code>arm_gic_cpu_state</code>
   interface is used providing cpu states for a device implementing the Generic
   Interrupt Controller architecture.
<p>
   The <b><i>get_cpu_state_info</i></b> function is called to get current state of
   the a CPU, e.g. exception level, secure mode. 
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_arm_trustzone.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_arm_trustzone.html:__rm_interface_arm_trustzone">arm_trustzone</a></h1>
<p>

<a id="__rm_interface_arm_trustzone.html:arm_trustzone"></a><a id="__rm_interface_arm_trustzone.html:arm_trustzone_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This interface is implemented by ARM processors that supports the arm ARM
   TrustZone feature. The <b><i>get_security_mode</i></b> function returns the
   current state of the processor, whereas <b><i>mem_op_security_mode</i></b>
   extracts the mode of a memory operation in progress.
<p>
   The <b><i>get_security_mode</i></b> functions corresponds to the expression
   <code>(cpsr.mode != Monitor &amp;&amp; scr.ns) ? Arm_Trustzone_Non_Secure :
   Arm_Trustzone_Secure</code>. The <b><i>mem_op_security_mode</i></b> function
   always returns <code>Arm_Trustzone_Non_Secure</code> when the processor is in
   non-secure mode, in secure mode it returns the <code>ns</code> bit in the
   first-level page table entry for the actual area being accessed.
</p><p>
   </p><pre class="jdocu_small">typedef enum {
        Arm_Trustzone_Secure = 0,
        Arm_Trustzone_Non_Secure = 1
} arm_trustzone_mode_t;

SIM_INTERFACE(arm_trustzone) {
        arm_trustzone_mode_t (*get_security_mode)(conf_object_t *NOTNULL obj);
        arm_trustzone_mode_t (*mem_op_security_mode)(
                conf_object_t *NOTNULL obj,
                generic_transaction_t *NOTNULL memop);
};

#define ARM_TRUSTZONE_INTERFACE "arm_trustzone"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_bridge.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_bridge.html:__rm_interface_bridge">bridge</a></h1>
<p>

<a id="__rm_interface_bridge.html:bridge"></a><a id="__rm_interface_bridge.html:bridge_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>bridge</code> interface is implemented by objects
   that bridge between memory spaces. The <b><i>not_taken</i></b> function
   is called if the access is not claimed by any device in the
   destination memory-space. If a memory transaction reaches a mapping
   that has the same bridge object as the previous mapping, the access
   is considered as not taken, and the <b><i>not_taken</i></b> function
   for the first bridge mapping is called.
   <pre class="jdocu_small">SIM_INTERFACE(bridge) {
        exception_type_t (*not_taken)(conf_object_t *NOTNULL obj,
                                      conf_object_t *NOTNULL src_space,
                                      conf_object_t *NOTNULL dst_space,
                                      exception_type_t ex,
                                      generic_transaction_t *NOTNULL mem_op,
                                      map_info_t mapinfo);
};

#define BRIDGE_INTERFACE "bridge"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_can_device.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_can_device.html:__rm_interface_can_device">can_device</a></h1>
<p>

<a id="__rm_interface_can_device.html:can_device"></a><a id="__rm_interface_can_device.html:can_device_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><pre class="jdocu_small">SIM_INTERFACE(can_device) {
        void (*receive)(conf_object_t *obj, can_frame_t *frame);
};
#define CAN_DEVICE_INTERFACE "can_device"
</pre><p>
</p><p>

   The <code>can_device</code> interface is implemented by CAN controllers.
   The <b><i>receive</i></b> function is called by can-endpoint to pass CAN frame
   from other can-endpoint to the connected CAN controller.
</p><p>
   The CAN frame is expressed by the <i>frame</i> parameter, which is a
   pointer of <code>can_frame_t</code>. The following is the details of 
   <code>can_frame_t</code>:
</p><p>
   
   </p><ul> 
    <li><code>Standard Format</code>:<br>
    Arbitration Field(11bit_ID+RTR)+Control Field(IDE+r0+DLC)
    </li>
    <li><code>Extended Format</code>:<br>
    Arbitration Field(11bit_sID+SRR+IDE+18bit_eID+RTR)+Control Field(r1+r0+DLC)
    </li>
   </ul>
   Above are the Arbitration Field and Control Field of the physical Standard
   frame and Extended frame. But the <code>can_frame_t</code> only focus on the
   logical meanings of such fields and tries to adapt different CAN controllers:
   <ul>
     <li><code>identifier</code>: For Standard frame, 11bit_ID should be put in
     <code>identifier[10:0]</code>;for Extended frame, 11bit_sID should be put in 
     <code>identifier[28:18]</code> and 18bit_eID should be put in
     <code>identifier[17:0]</code>.</li>

     <li><code>extended</code>: There isn't IDE in can_frame_t, instead,
     <code>extended</code> is used to indicate if the frame is Extended frame or
     Standard frame.</li>

     <li><code>rtr</code>: There isn't SRR in can_frame_t for Extended frame,
     instead, <code>rtr</code> is used to indicate if the frame is a remote frame or
     not. Here we don't care whether the frame is Extended frame or Standard
     frame.</li>
     
     <li><code>data_length</code>: The <code>data_length</code> contains the arithmetic
     value of the DLC.</li>
     
     <li><code>data[CAN_DATA_MAX_NUM]</code>: This is the data field of Date frame.
     </li>
     
     <li><code>crc</code>: This is the crc field of a CAN frame.</li>
   </ul>
   
<pre class="jdocu_small">typedef struct {
        /* arbitration field */
        uint32 identifier;
        bool extended;
        bool rtr;
        /* control field */
        uint8 data_length;
        /* data field */
        uint8 data[CAN_DATA_MAX_NUM];
        /* crc field */
        uint16 crc;
} can_frame_t;</pre><p>

</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_can_link.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_can_link.html:__rm_interface_can_link">can_link</a></h1>
<p>

<a id="__rm_interface_can_link.html:can_link"></a><a id="__rm_interface_can_link.html:can_link_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><pre class="jdocu_small">SIM_INTERFACE(can_link) {
        can_status_t (*send)(conf_object_t *obj, can_frame_t *frame);
};
#define CAN_LINK_INTERFACE "can_link"
</pre><p>
</p><p>

   The <code>can_link</code> interface is implemented by can-endpoint.
   The <b><i>send</i></b> function is called by CAN controller to pass CAN frame
   to the connected can-endpoint. Then can-link delivers the CAN frame to other
   can-endpoints.
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_coreint.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_coreint.html:__rm_interface_coreint">coreint</a></h1>
<p>

<a id="__rm_interface_coreint.html:coreint"></a><a id="__rm_interface_coreint.html:coreint_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Interface between CoreInt capable processor and interrupt controller.
<p>
   This interface is implemented by CoreInt capable interrupt controllers and
   allows the processor to automatically acknowledge external interrupts
   without software intervention.
</p><p>
   The <b><i>acknowledge</i></b> function is called by the processor when an
   external interrupt is taken. If coreint is enabled in the interrupt
   controller, the interrupt controller should lower the interrupt signal
   towards the processor and return the interrupt source
   vector. This way the software doesn't have to go and query the
   interrupt controller for the source. If coreint is not enabled, the
   interrupt should not do anything and the vector value in the reply is
   undefined.
</p><p>
   </p><pre class="jdocu_small">#include &lt;simics/pywrap.h&gt;
#include &lt;simics/base/types.h&gt;

#if defined(__cplusplus)
extern "C" {
#endif

typedef struct {
        bool enabled;
        uint64 vector;
} coreint_reply_t;

#define COREINT_INTERFACE "coreint"
SIM_INTERFACE(coreint) {
        coreint_reply_t (*acknowledge)(conf_object_t *obj, conf_object_t *core);
};
</pre><p>
</p><p>

   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_cxl_map.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_cxl_map.html:__rm_interface_cxl_map">cxl_map</a></h1>
<p>

<a id="__rm_interface_cxl_map.html:cxl_map"></a><a id="__rm_interface_cxl_map.html:cxl_map_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This interface is used to claim ranges in CXL address spaces.
<p>
   Functions <b><i>add_map</i></b> and <b><i>del_map</i></b> are used to add and
   remove maps, <i>map_obj</i> will be mapped in the address space
   indicated by <i>type</i> according to the information in <i>info</i>.
</p><p>
   Note: This interface is considered tech-preview and may change without
   notice.
</p><p>
   </p><pre class="jdocu_small">typedef enum {
        CXL_Type_Not_Set,
        CXL_Type_Io,
        CXL_Type_Mem,
        CXL_Type_Cache,
        CXL_Type_Other,
} cxl_type_t;

SIM_INTERFACE(cxl_map)
{
        void (*add_map)(conf_object_t *obj, conf_object_t *map_obj,
                        map_info_t info, cxl_type_t type);
        void (*del_map)(conf_object_t *obj, conf_object_t *map_obj,
                        physical_address_t base, cxl_type_t type);
};

#define CXL_MAP_INTERFACE "cxl_map"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_cxl_mem_downstream_port_managing.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_cxl_mem_downstream_port_managing.html:__rm_interface_cxl_mem_downstream_port_managing">cxl_mem_downstream_port_managing</a></h1>
<p>

<a id="__rm_interface_cxl_mem_downstream_port_managing.html:cxl_mem_downstream_port_managing"></a><a id="__rm_interface_cxl_mem_downstream_port_managing.html:cxl_mem_downstream_port_managing_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Functions <b><i>enable_decoder</i></b> and <b><i>disable_decoder</i></b> are used
   to enable and disable HDM decoders on a cxl-hdm-port device.
<p>
   </p><pre class="jdocu_small">SIM_INTERFACE(cxl_mem_downstream_port_managing)
{
        bool (*register_port_mem_obj)(conf_object_t *obj, uint8 port_number,
                                      conf_object_t *port_mem_obj);
        void (*unregister_port_mem_obj)(conf_object_t *obj, uint8 port_number);
};

#define CXL_MEM_DOWNSTREAM_PORT_MANAGING_INTERFACE "cxl_mem_downstream_port_managing"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_cxl_non_device_decoder_handling.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_cxl_non_device_decoder_handling.html:__rm_interface_cxl_non_device_decoder_handling">cxl_non_device_decoder_handling</a></h1>
<p>

<a id="__rm_interface_cxl_non_device_decoder_handling.html:cxl_non_device_decoder_handling"></a><a id="__rm_interface_cxl_non_device_decoder_handling.html:cxl_non_device_decoder_handling_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Functions <b><i>enable_decoder</i></b> and <b><i>disable_decoder</i></b> are used
   to enable and disable HDM decoders on a cxl-hdm-port device.
<p>
   </p><pre class="jdocu_small">SIM_INTERFACE(cxl_non_device_decoder_handling)
{
        int (*enable_decoder)(conf_object_t *obj, uint8 index, uint8 ig,
                              uint8 iw, uint64 base, uint64 size,
                              uint64 target_list);
        int (*disable_decoder)(conf_object_t *obj, uint8 decoder_index);
};

#define CXL_NON_DEVICE_DECODER_HANDLING_INTERFACE "cxl_non_device_decoder_handling"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_datagram_link.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_datagram_link.html:__rm_interface_datagram_link">datagram_link</a></h1>
<p>

<a id="__rm_interface_datagram_link.html:datagram_link"></a><a id="__rm_interface_datagram_link.html:datagram_link_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><pre class="jdocu_small">SIM_INTERFACE(datagram_link) {
        /* Transmit a message to the object. */
        void (*receive)(conf_object_t *NOTNULL obj, bytes_t msg);
};

#define DATAGRAM_LINK_INTERFACE "datagram_link"
</pre><p>
</p><p>
  
</p><p>
  This interface is implemented by objects that receive messages from a
  datagram-link, and by the datagram-link connection endpoints themselves.
</p><p>
  There is a single function <b><i>receive()</i></b>, which is used to pass the
  message <i>msg</i> to the object <i>obj</i>. 
</p><p>
  The message <i>msg</i> is treated as a series of bytes with no
  special format or meaning expected. If <i>obj</i> is a datagram-link
  endpoint, it will forward the message to all other endpoints registered on
  the link except the sender, effectively broadcasting the message on the
  link. If <i>obj</i> is a device, it will simply receive the message
  as sent by the original sender.
</p><p>
  Note that the symmetry of the interface allows two devices to be connected
  directly to each other and talk as if connected via a datagram-link. This is
  however not supported by the default datagram-link component, so a special
  connector must be created for this purpose. Additionally, the standard link
  features, such as multicell configurations and latency, will not be available
  in that setup.
</p><p>
  
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem"><table>

  <tbody><tr><td class="jdocu_noborder"><b><i>receive</i></b></td><td class="jdocu_noborder">Cell Context</td></tr>

  </tbody></table>
  
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_ethernet_cable.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_ethernet_cable.html:__rm_interface_ethernet_cable">ethernet_cable</a></h1>
<p>

<a id="__rm_interface_ethernet_cable.html:ethernet_cable"></a><a id="__rm_interface_ethernet_cable.html:ethernet_cable_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><pre class="jdocu_small">SIM_INTERFACE(ethernet_cable) {
        void (*link_status)(conf_object_t *NOTNULL ep, bool link_up);
};
#define ETHERNET_CABLE_INTERFACE "ethernet_cable"
</pre><p>
</p><p>

   This interface is implemented by Ethernet devices and link endpoints that
   are interested in the link status of the peer.
</p><p>
   The <b><i>link_status</i></b> function is used to notify the peer that the link
   status at the local end is up or down. The
   <b>ethernet-cable-link</b> class propagates this information to the
   device connected at the other end.
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem"><table>

   <tbody><tr><td class="jdocu_noborder"><b><i>link_status</i></b></td><td class="jdocu_noborder">Cell Context</td></tr>

   </tbody></table>
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_ethernet_common.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_ethernet_common.html:__rm_interface_ethernet_common">ethernet_common</a></h1>
<p>

<a id="__rm_interface_ethernet_common.html:ethernet_common"></a><a id="__rm_interface_ethernet_common.html:ethernet_common_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><pre class="jdocu_small">SIM_INTERFACE(ethernet_common) {
        void (*frame)(conf_object_t *NOTNULL obj, const frags_t *frame,
                      eth_frame_crc_status_t crc_status);
};
#define ETHERNET_COMMON_INTERFACE "ethernet_common"
</pre><p>
</p><p>
   
</p><p>
   This interface is implemented by objects that receive Ethernet frames, both
   Ethernet devices and Ethernet link endpoints.
</p><p>
   There is a single function <b><i>frame</i></b> which sends an Ethernet frame,
   without preamble nor SFD (Start Frame Delimiter), but with a CRC field.
</p><p>
   The <i>crc_status</i> parameter provides out-of-band information on
   the contents of the frame with regards to the CRC field using one of the
   values in the <code>eth_frame_crc_status_t</code> enum:
</p><p>
   
   </p><ul>
     <li><code>Eth_Frame_CRC_Match</code> means that the frame contents are
     correct. The CRC field in the frame should not be relied upon as its
     computation may have been skipped for optimization, and it may contain any
     value, including zero, a random value or a correctly computed CRC.</li>

     <li><code>Eth_Frame_CRC_Mismatch</code> means that the frame contents are
     incorrect. The CRC field in the frame must contain a CRC that does not
     match the frame contents, i.e., to send an incorrect frame on the link,
     you must make sure that the CRC field will not match when computed.</li>

     <li><code>Eth_Frame_CRC_Unknown</code> means that the relation between the
     frame contents and the CRC field is unknown. The relation can be
     established by computing the frame's CRC and comparing it to the frame's
     CRC field.</li>
   </ul>
   
<pre class="jdocu_small">typedef enum {
        Eth_Frame_CRC_Match,
        Eth_Frame_CRC_Mismatch,
        Eth_Frame_CRC_Unknown
} eth_frame_crc_status_t;</pre><p>

</p><p>
   When a device calls a link's <b><i>frame</i></b> function, it can set
   crc_status to any of the three values. If the link receives a
   <code>Eth_Frame_CRC_Unknown</code>, it will compute the CRC itself to set the
   status to <code>Eth_Frame_CRC_Match</code> or <code>Eth_Frame_CRC_Mismatch</code>.
</p><p>
   When a link calls a device's <code>frame</code> function, crc_status will be set
   to either <code>Eth_Frame_CRC_Match</code> or <code>Eth_Frame_CRC_Mismatch</code>,
   and never <code>Eth_Frame_CRC_Unknown</code>.
</p><p>
   When two devices are directly connected to each others without using a link,
   the interpretation of <code>Eth_Frame_CRC_Unknown</code> is up to the devices'
   implementation.
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem"><table>

   <tbody><tr><td class="jdocu_noborder"><b><i>frame</i></b></td><td class="jdocu_noborder">Cell Context</td></tr>

   </tbody></table>
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_ethernet_probe.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_ethernet_probe.html:__rm_interface_ethernet_probe">ethernet_probe</a></h1>
<p>

<a id="__rm_interface_ethernet_probe.html:ethernet_probe"></a><a id="__rm_interface_ethernet_probe.html:ethernet_probe_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><pre class="jdocu_small">typedef enum {
        Eth_Probe_Port_A = 0,
        Eth_Probe_Port_B = 1
} eth_probe_side_t;
</pre><p>
</p><p>
   
   
   </p><pre class="jdocu_small">typedef void (*ethernet_probe_snoop_t)(lang_void *user_data,
                                       conf_object_t *probe,
                                       eth_probe_side_t to_side,
                                       const frags_t *frame,
                                       eth_frame_crc_status_t crc_status);
</pre><p>
</p><p>
   
   
   </p><pre class="jdocu_small">SIM_INTERFACE(ethernet_probe) {
        void (*attach_snooper)(conf_object_t *NOTNULL probe,
                               ethernet_probe_snoop_t snoop_fun,
                               lang_void *user_data);
        void (*attach_probe)(conf_object_t *NOTNULL probe,
                             ethernet_probe_snoop_t snoop_fun,
                             lang_void *user_data);
        void (*detach)(conf_object_t *NOTNULL probe);
        void (*send_frame)(conf_object_t *NOTNULL probe,
                           eth_probe_side_t to_side,
                           const frags_t *frame,
                           eth_frame_crc_status_t crc_status);
};

#define ETHERNET_PROBE_INTERFACE "ethernet_probe"
</pre><p>
</p><p>
   
</p><p>
   This interface is implemented by <b>eth-probe</b> objects. Once a
   probe has been inserted between a device and an Ethernet link, the functions
   of this interface can be used to setup callbacks:
</p><p>
   </p><dl><dt id="__rm_interface_ethernet_probe.html:dt:attach_snooper"><a href="#__rm_interface_ethernet_probe.html:dt:attach_snooper"><b><b><i>attach_snooper()</i></b></b></a></dt><dd>Attach a snooper function: the
   probe will pass each frame to the snooper function, then forward it
   unchanged where it should be going</dd><dt id="__rm_interface_ethernet_probe.html:dt:attach_probe"><a href="#__rm_interface_ethernet_probe.html:dt:attach_probe"><b><b><i>attach_probe()</i></b></b></a></dt><dd>Attach a probe function: the probe
   will pass each frame to the probe function, and give it the responsibility
   of forwarding the frame or any number of modified or additional frames using
   the <b><i>send_frame()</i></b> function.</dd><dt id="__rm_interface_ethernet_probe.html:dt:detach"><a href="#__rm_interface_ethernet_probe.html:dt:detach"><b><b><i>detach</i></b></b></a></dt><dd>Detach the currently registered callback from
   the probe.</dd><dt id="__rm_interface_ethernet_probe.html:dt:send_frame"><a href="#__rm_interface_ethernet_probe.html:dt:send_frame"><b><b><i>send_frame</i></b></b></a></dt><dd>Send a frame via the probe, either to the
   side A or B of the probe. Which side is which can be obtained with the <b>&lt;eth-probe&gt;.info</b> function.</dd></dl><p>This interface should only be used for inspection, and never as part of the
   actual simulation. The snoop functions must not affect the simulation in any
   way.
</p><p>
   The <i>clock</i> parameter tells the link on which clock to post the
   events that call the snoop function. The snoop function will be called at
   the delivery time of the network packet, which means that it will be called
   at the same time as any Ethernet devices attached to the same clock that
   receives packets from the same link.
</p><p>
   Snooped frames with a matching CRC will contain the correct frame check
   sequence.
</p><p>
   The <i>user_data</i> parameter is passed to the snoop function every
   time it is called.
   
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_ethernet_snoop.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_ethernet_snoop.html:__rm_interface_ethernet_snoop">ethernet_snoop</a></h1>
<p>

<a id="__rm_interface_ethernet_snoop.html:ethernet_snoop"></a><a id="__rm_interface_ethernet_snoop.html:ethernet_snoop_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><pre class="jdocu_small">typedef void (*ethernet_link_snoop_t)(lang_void *user_data,
                                      conf_object_t *clock,
                                      const frags_t *packet,
                                      eth_frame_crc_status_t crc_status);</pre><p>

   </p><pre class="jdocu_small">SIM_INTERFACE(ethernet_snoop) {
        conf_object_t *(*attach)(conf_object_t *NOTNULL link,
                                 conf_object_t *clock,
                                 ethernet_link_snoop_t snoop_fun,
                                 lang_void *user_data);
};
#define ETHERNET_SNOOP_INTERFACE "ethernet_snoop"
</pre><p>
</p><p>

   This interface is implemented by Ethernet link objects. It is used to attach
   snoop functions to the link. The snoop function will receive all traffic
   going over the link.
</p><p>
   This interface should only be used for inspection, and never as part of the
   actual simulation. The snoop functions must not affect the simulation in any
   way.
</p><p>
   The <i>clock</i> parameter tells the link on which clock to post the
   events that call the snoop function. The snoop function will be called at
   the delivery time of the network packet, which means that it will be called
   at the same time as any Ethernet devices attached to the same clock that
   receives packets from the same link.
</p><p>
   Snooped frames with a matching CRC will contain the correct frame check
   sequence.
</p><p>
   The <i>user_data</i> parameter is passed to the snoop function every
   time it is called.
   
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem"><table>

   <tbody><tr><td class="jdocu_noborder"><b><i>attach</i></b></td><td class="jdocu_noborder">Global Context</td></tr>

   </tbody></table>
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_ethernet_vlan_snoop.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_ethernet_vlan_snoop.html:__rm_interface_ethernet_vlan_snoop">ethernet_vlan_snoop</a></h1>
<p>

<a id="__rm_interface_ethernet_vlan_snoop.html:ethernet_vlan_snoop"></a><a id="__rm_interface_ethernet_vlan_snoop.html:ethernet_vlan_snoop_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><pre class="jdocu_small">typedef void (*ethernet_link_snoop_t)(lang_void *user_data,
                                      conf_object_t *clock,
                                      const frags_t *packet,
                                      eth_frame_crc_status_t crc_status);</pre><p>

   </p><pre class="jdocu_small">SIM_INTERFACE(ethernet_vlan_snoop) {
        conf_object_t *(*attach)(
                conf_object_t *NOTNULL link, conf_object_t *clock,
                ethernet_link_snoop_t snoop_fun, lang_void *user_data,
                uint16 vlan_id, bool is_vlan_trunk);
};
#define ETHERNET_VLAN_SNOOP_INTERFACE "ethernet_vlan_snoop"
</pre><p>
</p><p>

   This interface is implemented by Ethernet VLAN switch link objects. It is
   used to attach snoop functions to the link. The snoop function will receive
   all traffic going over the link, either on a single VLAN, or on all of them.
</p><p>
   This interface should only be used for inspection, and never as part of the
   actual simulation. The snoop functions must not affect the simulation in any
   way.
</p><p>
   The <i>clock</i> parameter tells the link on which clock to post the
   events that call the snoop function. The snoop function will be called at
   the delivery time of the network packet, which means that it will be called
   at the same time as any Ethernet devices attached to the same clock that
   receives packets from the same link.
</p><p>
   Snooped frames with a matching CRC will contain the correct frame check
   sequence.
</p><p>
   The <i>user_data</i> parameter is passed to the snoop function every
   time it is called.
   
</p><p>
   The <i>vlan_id</i> indicates on which VLAN the snoop function should
   be attached (as its native VLAN).
</p><p>
   The <i>is_vlan_trunk</i> flag indicates whether the snoop function
   should also receive the traffic on all other VLANs, tagged with an 802.1Q
   tag.
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem"><table>

   <tbody><tr><td class="jdocu_noborder"><b><i>attach</i></b></td><td class="jdocu_noborder">Global Context</td></tr>

   </tbody></table>
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_extended_serial.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_extended_serial.html:__rm_interface_extended_serial">extended_serial</a></h1>
<p>

<a id="__rm_interface_extended_serial.html:extended_serial"></a><a id="__rm_interface_extended_serial.html:extended_serial_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This interface extends the <code>serial_device</code> with
   a <b><i>write_at()</i></b> function. It is similar to the <b><i>write()</i></b>
   function of the mentioned interface, but accepts an on-screen character
   position. This interface is implemented by text consoles allowing them
   to be connected to text oriented frame buffers, such as VGA in text mode.
<p>
   </p><pre class="jdocu_small">SIM_INTERFACE(extended_serial) {
        void (*write_at)(conf_object_t *obj,
                         int value, int x, int y, int fg, int bg);
        void (*graphics_mode)(conf_object_t *obj, int in_graphics_mode);
};

#define EXTENDED_SERIAL_INTERFACE "extended_serial"
</pre><p>
</p><p>

   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_firewire_bus.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_firewire_bus.html:__rm_interface_firewire_bus">firewire_bus</a></h1>
<p>

<a id="__rm_interface_firewire_bus.html:firewire_bus"></a><a id="__rm_interface_firewire_bus.html:firewire_bus_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><pre class="jdocu_small">SIM_INTERFACE(firewire_bus) {
        int (*connect_device)(conf_object_t *NOTNULL bus,
                              conf_object_t *NOTNULL dev);
        int (*disconnect_device)(conf_object_t *NOTNULL bus,
                                 conf_object_t *NOTNULL dev);
        void (*set_device_bus_id)(conf_object_t *NOTNULL bus,
                                  conf_object_t *NOTNULL dev,
                                  uint16 bus_id);

        void (*set_id_mask)(conf_object_t *NOTNULL bus,
                            conf_object_t *NOTNULL dev,
                            uint16 id_mask);

        firewire_ack_code_t (*transfer)(conf_object_t *NOTNULL bus,
                                        conf_object_t *NOTNULL source,
                                        dbuffer_t *packet, int crc_calculated);

        int (*register_channel)(conf_object_t *NOTNULL bus,
                                conf_object_t *NOTNULL dev,
                                uint32 channel);
        int (*unregister_channel)(conf_object_t *NOTNULL bus,
                                  conf_object_t *NOTNULL dev,
                                  uint32 channel);

        void (*reset)(conf_object_t *NOTNULL bus);
};
#define FIREWIRE_BUS_INTERFACE "firewire_bus"
</pre><p>
</p><p>

   This interface must be implemented by all firewire buses.
</p><p>
   <b><i>connect_device</i></b> is called when a device wants to connect to the
   bus. The bus should return 0 upon success.
</p><p>
   <b><i>disconnect_device</i></b> is called when a device wants to disconnect
   from the bus. The bus should return 0 upon success.
   </p><p>
   <b><i>set_device_bus_id</i></b> sets the bus id for the device. This needs to
   be called by a device when its Node_IDS[bus_id] field is updated. The
   new bus id should be placed in bits 15-6 in the bus_id argument.
</p><p>
   <b><i>set_id_mask</i></b> can be called by a device to specify a mask that
   should be applied to the device ID when routing transfers. This can be
   used to e.g. accept transfers to multiple bus-numbers.
</p><p>
   <b><i>transfer</i></b> sends a packet. The bus will
   route the transfer to the correct device(s). The <i>source</i>
   parameter should be set to the device which sent the transfer. The bus uses
   this parameter to avoid sending packets to their sender. If the
   <i>crc_calculated</i> argument
   is non-zero the packet's crc fields are filled in.The return code is one
   of:
</p><p>
   
</p><pre class="jdocu_small">typedef enum {
        /* Values defined in the FireWire specification */
        Firewire_Ack_Complete = 1,
        Firewire_Ack_Pending = 2,
        Firewire_Ack_Busy_X = 4,
        Firewire_Ack_Busy_A = 5,
        Firewire_Ack_Busy_B = 6,
        Firewire_Ack_Tardy = 0xb,
        Firewire_Ack_Conflict_Error = 0xc,
        Firewire_Ack_Data_Error = 0xd,
        Firewire_Ack_Type_Error = 0xe,
        Firewire_Ack_Address_Error = 0xf,
        
        /* Values not defined in FireWire but used in Simics */
        Firewire_Ack_No_Destination = 0x10, /* no destination found */
        Firewire_Ack_No_Ack = 0x11 /* no ack signal sent for packet */
} firewire_ack_code_t;</pre><p>

</p><p>
   <b><i>register_channel</i></b> can be called to tell the bus that the device
   want to receive isochronous transfers to channel <i>channel</i>.
   channel must be in the range [0, 63).
   A device can register several channels. It is an error to subscribe a
   device to a channel it is already subscribed to.
   Returns 0 on success.
</p><p>
   <b><i>unregister_channel</i></b> tells the bus the device is no longer
   interested in transfers to channel <i>channel</i>. channel must be
   in the range [0, 63). It is an error to unsubscribe a device from a channel
   if it isn't subscribing to it. Returns 0 on success.
</p><p>
   <b><i>reset</i></b> can be called to cause a bus reset. After the bus reset,
   all the devices may have received new IDs. 
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_firewire_device.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_firewire_device.html:__rm_interface_firewire_device">firewire_device</a></h1>
<p>

<a id="__rm_interface_firewire_device.html:firewire_device"></a><a id="__rm_interface_firewire_device.html:firewire_device_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><pre class="jdocu_small">SIM_INTERFACE(firewire_device) {
        firewire_ack_code_t (*transfer)(conf_object_t *NOTNULL dev,
                                        dbuffer_t *packet, int crc_calculated);

        void (*reset)(conf_object_t *NOTNULL dev, uint16 id,
                      uint8 root_id,
                      uint32_array_t self_ids);
        uint32 (*get_self_id_template)(
                conf_object_t *NOTNULL dev);

        int (*get_rhb)(conf_object_t *NOTNULL dev);
        uint8 (*get_port_count)(conf_object_t *NOTNULL dev);
        uint16 (*get_port_mask)(conf_object_t *NOTNULL dev);
};
#define FIREWIRE_DEVICE_INTERFACE "firewire_device"
</pre><p>
</p><p>

   This interface must be implemented by all firewire devices.
</p><p>
   <b><i>transfer</i></b> is called when the device receives a packet.
   If the crc_calculated argument
   is non-zero the packet's crc fields are filled in.The return code is one
   of:
</p><p>
   
</p><pre class="jdocu_small">typedef enum {
        /* Values defined in the FireWire specification */
        Firewire_Ack_Complete = 1,
        Firewire_Ack_Pending = 2,
        Firewire_Ack_Busy_X = 4,
        Firewire_Ack_Busy_A = 5,
        Firewire_Ack_Busy_B = 6,
        Firewire_Ack_Tardy = 0xb,
        Firewire_Ack_Conflict_Error = 0xc,
        Firewire_Ack_Data_Error = 0xd,
        Firewire_Ack_Type_Error = 0xe,
        Firewire_Ack_Address_Error = 0xf,
        
        /* Values not defined in FireWire but used in Simics */
        Firewire_Ack_No_Destination = 0x10, /* no destination found */
        Firewire_Ack_No_Ack = 0x11 /* no ack signal sent for packet */
} firewire_ack_code_t;</pre><p>

</p><p>
   <b><i>reset</i></b> is called when the bus is reset. <i>id</i> is
   the new ID of the device (top 10 bits represent the bus number, and the low
   6 bits the node ID). <i>root_id</i> is the node ID for the root
   node. <i>self_ids</i> is the list of Self-ID packets
   during the Self-ID phase of the reset.
</p><p>
   
     An array of unsigned 32-bit integers.
   
</p><pre class="jdocu_small">typedef struct {
        size_t len;
        uint32 *data;
} uint32_array_t;</pre><p>

</p><p>
   <b><i>get_self_id_template</i></b> is an accessor function called by the bus
   or other self-ID provider to provide the static parts of the Self-ID for
   this device. The ID and port parts will be overwritten by the Self-ID
   provider.
</p><p>
   <b><i>get_rhb</i></b> gets the current status of the root hold off bit in the
   device.
</p><p>
   <b><i>get_port_count</i></b> returns the number of ports the device has. The
   largest allowed value is 16 and the lowest 1. This should remain constant
   during the lifetime of the device and always return a valid value.
</p><p>
   <b><i>get_port_mask</i></b> returns a bitmask. Each bit is one if that port is
   enabled and zero if it is disabled. The least significant bit describes port
   0 and the most significant bit port 15. The bits for ports which do not
   exist on the device should be set to zero.
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_fmn_station_control.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_fmn_station_control.html:__rm_interface_fmn_station_control">fmn_station_control</a></h1>
<p>

<a id="__rm_interface_fmn_station_control.html:fmn_station_control"></a><a id="__rm_interface_fmn_station_control.html:fmn_station_control_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>fmn_station_control</code> interface is implemented by
   Fast Messaging Network stations for processors prior to the XLP II.
<p>
   For all functions, the <i>thread_id</i> parameter denotes
   the thread id for the core that invokes the call.
</p><p>
   The <b><i>send_message</i></b> function notifies the station to
   initiate a message send on the FMN. The <i>rt_value</i>
   parameter carries control bits and the message to send; its content
   and bit layout is determined by the system architecture. The return
   value indicates whether the FMN station is able to send the message.
   The station must check for available resources and immediately return
   <code>1</code> if the message will be queued for delivery, otherwise, if
   the station is not ready or if no buffers are available, the station
   immediately returns <code>0</code>.
</p><p>
   The <b><i>load_message</i></b> function notifies the station
   to initiate a message load on the FMN. The <i>bucket</i>
   indicates the FMN station bucket to read from.
</p><p>
   The <b><i>wait</i></b> function is used by the core to probe the
   station if it should put itself to sleep waiting for a message or
   not. Each bit in the <i>vector</i> corresponds to a bucket
   to check for messages, i.e. bit 0 corresponds to bucket 0. The
   station must return <code>0</code> if there are any messages in any of
   the buckets requested. The station must return <code>1</code> if there
   are no messages in any of the buckets. Returning <code>1</code> means
   that the core can go to sleep until the station wakes the core. The
   station must later send a wake signal to the core when a new
   message arrive to any of the buckets checked in the last call to
   <b><i>wait</i></b>. The station wakes the core by raising the signal
   on the <em>wakeup</em> port interface for the core.
</p><p>
   The <b><i>sync</i></b> function enforces a hazard barrier across
   the <b><i>send_message</i></b> function executions, thereby enforcing
   a strict ordering of the message sequence delivered to the FMN.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(fmn_station_control) {
        uint64 (*send_message)(conf_object_t *NOTNULL obj,
                               uint32 thread_id,
                               uint64 rt_value);
        void (*load_message)(conf_object_t *NOTNULL obj,
                             uint32 thread_id,
                             uint8 bucket);
        int (*wait)(conf_object_t *NOTNULL obj,
                    uint32 thread_id,
                    uint8 vector);
        void (*sync)(conf_object_t *NOTNULL obj,
                     uint32 thread_id);

};
#define FMN_STATION_CONTROL_INTERFACE "fmn_station_control"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_fmn_station_control_v2.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_fmn_station_control_v2.html:__rm_interface_fmn_station_control_v2">fmn_station_control_v2</a></h1>
<p>

<a id="__rm_interface_fmn_station_control_v2.html:fmn_station_control_v2"></a><a id="__rm_interface_fmn_station_control_v2.html:fmn_station_control_v2_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>fmn_station_control_v2</code> interface is implemented by Fast
   Messaging Network stations for the XLP II processor.
<p>
   For all functions, the <i>thread_id</i> parameter denotes the thread
   id for the core that invokes the call.
</p><p>
   The <b><i>send_message</i></b> function is called when the processor executes
   the <code>msgsnd</code> instruction. The <i>rt_value</i> parameter
   contains the value of the <code>rt</code> register. The function must return
   the value to be written into the <code>rd</code> register.
</p><p>
   The <b><i>load_message</i></b> function is called when the processor executes
   the <code>msgld</code> instruction. The <i>rt_value</i> parameter
   contains the value of the <code>rt</code> register. The function must return
   the value to be written into the <code>rd</code> register.
</p><p>
   The <b><i>wait</i></b> function is called when the processor executes the
   <code>msgwait</code> instruction. The <i>rt_value</i> parameter contains
   the value of the <code>rt</code> register. The function should return <code>1</code>
   if the receive queues are empty, <code>0</code> if not. If the receive queues
   are empty the station must wake the thread by raising the signal on the
   <em>wakeup</em> port of the thread when the next message arrives to one of
   the receive queues.
</p><p>
   The <b><i>sync</i></b> function is called when the processor executes the
   <code>msgsync</code> instruction.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(fmn_station_control_v2) {
        uint64 (*send_message)(conf_object_t *NOTNULL obj,
                               uint32 thread_id,
                               uint64 rt_value);
        uint64 (*load_message)(conf_object_t *NOTNULL obj,
                               uint32 thread_id,
                               uint64 rt_value);
        int (*wait)(conf_object_t *NOTNULL obj,
                    uint32 thread_id,
                    uint64 rt_value);
        void (*sync)(conf_object_t *NOTNULL obj,
                     uint32 thread_id);
};
#define FMN_STATION_CONTROL_V2_INTERFACE "fmn_station_control_v2"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_frequency.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_frequency.html:__rm_interface_frequency">frequency</a></h1>
<p>

<a id="__rm_interface_frequency.html:frequency"></a><a id="__rm_interface_frequency.html:frequency_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>frequency</code> interface is used to publish
   a frequency to other objects.
<p>
   The <b><i>get</i></b> method returns the current frequency.
</p><p>
   The object implementing this interface is expected to implement
   the <code>Sim_Notify_Frequency_Change</code> notifier, which should be
   raised when the object changes its frequency. Objects subscribing
   to this notifier can acquire the new frequency by doing a new call
   to the <b><i>get</i></b> method.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(frequency) {
        double (*get)(conf_object_t *NOTNULL obj);
};
#define FREQUENCY_INTERFACE "frequency"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_frequency_listener.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_frequency_listener.html:__rm_interface_frequency_listener">frequency_listener</a></h1>
<p>

<a id="__rm_interface_frequency_listener.html:frequency_listener"></a><a id="__rm_interface_frequency_listener.html:frequency_listener_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>frequency_listener</code> interface is used for
   modeling frequency changes.
<p>
   The frequency change initiator should call <b><i>set()</i></b> to set the
   new frequency. The <b><i>set()</i></b> function may be called multiple times
   with the same frequency value. The frequency is specified by the
   <code>numerator</code> and <code>denominator</code> arguments in units of Hz.
</p><p>
   The <b><i>set()</i></b> function should also be used to set the initial
   value for a target.
</p><p>
   An object that implements the <code>frequency_listener</code>
   interface typically has an attribute that refers to an object and
   port that implements the <code>simple_dispatcher</code>
   interface, from where the frequency originates.
</p><p>
   The initiator of a frequency change should implement the
   <code>simple_dispatcher</code> interface, and it should only call
   the <b><i>set()</i></b> function on objects that have registered with
   this interface.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(frequency_listener) {
        void (*set)(conf_object_t *NOTNULL obj, uint64 numerator,
                    uint64 denominator);
};

#define FREQUENCY_LISTENER_INTERFACE "frequency_listener"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_generic_message_device.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_generic_message_device.html:__rm_interface_generic_message_device">generic_message_device</a></h1>
<p>

<a id="__rm_interface_generic_message_device.html:generic_message_device"></a><a id="__rm_interface_generic_message_device.html:generic_message_device_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><pre class="jdocu_small">SIM_INTERFACE(generic_message_device) {
        void (*receive_frame)(conf_object_t *dev, conf_object_t *link,
                              dbuffer_t *frame);
};

#define GENERIC_MESSAGE_DEVICE_INTERFACE "generic_message_device"
</pre><p>
</p><p>

   This interface is implemented by generic message device objects that connect
   to <b>generic-message-link</b> objects.  It is used by the link
   object to send messages to the device object. The link should implement the
   <code>generic_message_link</code> interface.
</p><p>
   The <b><i>receive_frame</i></b> function is called by the link to send a frame
   to the device.  The frame is passed as a <code><a id="__rm_interface_generic_message_device.html:dbuffer_t">dbuffer_t</a></code>
   pointer that may not be modified without cloning it first.
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem"><table>

   <tbody><tr><td class="jdocu_noborder"><b><i>receive_frame</i></b></td><td class="jdocu_noborder">Cell Context</td></tr>

   </tbody></table>
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_generic_message_link.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_generic_message_link.html:__rm_interface_generic_message_link">generic_message_link</a></h1>
<p>

<a id="__rm_interface_generic_message_link.html:generic_message_link"></a><a id="__rm_interface_generic_message_link.html:generic_message_link_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><pre class="jdocu_small">SIM_INTERFACE(generic_message_link) {
#ifndef PYWRAP
        int  (*connect_device)(conf_object_t *_obj, conf_object_t *dev,
                               int *new_connection, uint32 address);
        void (*disconnect_device)(conf_object_t *_obj, conf_object_t *dev);
#endif
        void (*send_frame)(conf_object_t *_obj, int id, uint32 address,
                           dbuffer_t *frame, nano_secs_t delay);
};

#define GENERIC_MESSAGE_LINK_INTERFACE "generic_message_link"
</pre><p>
</p><p>

   </p><div class="note">
<b>Note:</b>
This interface is used for gml-link which is based on the link library.
    Refer to the <em>Link Library</em> for more information.</div>This interface is implemented by generic message link objects that provide a
   data link layer interface for frame delivery. It is used by the device
   object to talk to the link object. The device must implement the
   <code>generic_message_device</code> interface.
<p>
   The <b><i>connect_device</i></b> function attaches a generic link device to the
   link. The return value is an identification number that should be used
   in subsequent calls to the link to identify the device. The
   <i>address</i> parameter sets the address of the device on the link.
   Currently the <i>new_connection</i> parameter is not in use, a NULL
   pointer can be passed as the parameter.
</p><p>
   The <b><i>disconnect_device</i></b> function detaches a generic link
   device from the link.  It will not receive any more frames from the
   link and may not call any functions in the interface, except
   <b><i>connect_device</i></b>.
</p><p>
   The <b><i>send_frame</i></b> function is used by a device to send a generic
   device frame onto the link to be delivered to another device connected to
   the same link.  The frame should be a <code><a id="__rm_interface_generic_message_link.html:dbuffer_t">dbuffer_t</a></code>
   containing a data frame.  The <i>address</i> parameter is the address
   to sent the frame to. The <i>delay</i> makes it possible to add a
   small delay to the frame.  This can be used when a device wants to send
   multiple frames at once, but want them to be delivered in a specific
   sequence.  Instead of using an event handler to send each frame, they can be
   sent at once, with an increasing delay for each frame. The delay is given in
   nanoseconds.
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem"><table>

   <tbody><tr><td class="jdocu_noborder"><b><i>connect_device</i></b></td><td class="jdocu_noborder">Global Context</td></tr>

   <tr><td class="jdocu_noborder"><b><i>disconnect_device</i></b></td><td class="jdocu_noborder">Global Context</td></tr>

   <tr><td class="jdocu_noborder"><b><i>send_frame</i></b></td><td class="jdocu_noborder">Cell Context</td></tr>

   </tbody></table>
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_hpi.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_hpi.html:__rm_interface_hpi">hpi</a></h1>
<p>

<a id="__rm_interface_hpi.html:hpi"></a><a id="__rm_interface_hpi.html:hpi_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This interface defines HPI, Host Port Interface, which can be 
   used by a host to access the DSP memory space. The access
   functions have been designed to resemble the HPI hardware interface.
<p>
   The interface consists of three read/write access functions;
   <b><i>read/write_hpic()</i></b> accesses the HPI controller 
   register. Typically the host uses <b><i>write_hpic()</i></b> 
   to clear the HINT bit (writing a one to the bit) when the
   interrupt has been serviced.
</p><p>
   The <b><i>read/write_hpia()</i></b> functions are used to read 
   or set the address to the memory location which should be later 
   read or written. Reading HPIA either returns HPIAR or HPIAW
   depending on if last access to HPID was a read or write.
   Setting HPIA sets both HPIAR and HPIAW.
</p><p>
   Finally, to access the memory the <b><i>read/write_hpid()</i></b>
   functions are used. These functions have a autoincrement flag
   allowing the HPIAR or HPIAW to automatically increment the
   value with 4 after the access is finished.
</p><p>
   All access functions assumes that the registers and data are
   represented in host endianness.
</p><p>
   <span class="jdocu_smaller">
   </span></p><pre class="jdocu_small">SIM_INTERFACE(hpi) {
        /* HCNTL = 0 */
        uint32 (*read_hpic)(conf_object_t *obj);
        void  (*write_hpic)(conf_object_t *obj, uint32 value);
        
        /* HCNTL = 1 */
        uint32 (*read_hpia)(conf_object_t *obj);
        void  (*write_hpia)(conf_object_t *obj, uint32 value);
        
        /* HCNTL = 1 (autoincrement == 0) */
        /* HCNTL = 2 (autoincrement == 1) */
        uint32 (*read_hpid)(conf_object_t *obj, int autoincrement);
        void  (*write_hpid)(conf_object_t *obj, uint32 value,
                            int autoincrement);        
};

#define HPI_INTERFACE "hpi"
</pre><p>
</p><p>
   
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_i2c_master_v2.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_i2c_master_v2.html:__rm_interface_i2c_master_v2">i2c_master_v2</a></h1>
<p>

<a id="__rm_interface_i2c_master_v2.html:i2c_master_v2"></a><a id="__rm_interface_i2c_master_v2.html:i2c_master_v2_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><pre class="jdocu_small">typedef enum {
        I2C_ack = 0,
        I2C_noack = 1
} i2c_ack_t;

SIM_INTERFACE(i2c_master_v2) {
        void (*acknowledge)(conf_object_t *device, i2c_ack_t ack);
        void (*read_response)(conf_object_t *device, uint8 value);
};

#define I2C_MASTER_V2_INTERFACE "i2c_master_v2"
</pre><p>
</p><p>

   The <code>i2c_master_v2</code> interface should be implemented
   by devices that intend to act as a master on an I2C link.
</p><p>
   The function <b><i>acknowledge</i></b> is called in response to a
   <b><i>start</i></b> or <b><i>write</i></b> call in the
   <code>i2c_slave_v2</code> interface of the slave device.
   <b><i>read_response</i></b> is called as response to a
   <b><i>read</i></b> call.  More details can be found in the
   documentation of the <a class="jdocu" href="#__rm_interface_i2c_slave_v2.html">i2c_slave_v2</a> interface.
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_i2c_slave_v2.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_i2c_slave_v2.html:__rm_interface_i2c_slave_v2">i2c_slave_v2</a></h1>
<p>

<a id="__rm_interface_i2c_slave_v2.html:i2c_slave_v2"></a><a id="__rm_interface_i2c_slave_v2.html:i2c_slave_v2_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><pre class="jdocu_small">SIM_INTERFACE(i2c_slave_v2) {
        void (*start)(conf_object_t *device, uint8 address);
        void (*read)(conf_object_t *device);
        void (*write)(conf_object_t *device, uint8 value);
        void (*stop)(conf_object_t *device);
        attr_value_t (*addresses)(conf_object_t *device);
};
#define I2C_SLAVE_V2_INTERFACE "i2c_slave_v2"
</pre><p>
</p><p>

   The <code>i2c_slave_v2</code> interface is used together with the <a class="jdocu" href="#__rm_interface_i2c_master_v2.html"><code>i2c_master_v2</code></a>
   interface to model communication over an I2C bus. Most calls to a method in
   the <code>i2c_slave_v2</code> interface expect a response call to a method
   in the <code>i2c_master_v2</code> interface. It is up to each device to
   find the caller's interface; usually it is configured with an attribute in
   both the master and slave device.
</p><p>
   The <code>i2c_slave_v2</code> and <code>i2c_master_v2</code> interfaces
   replace the obsolete interfaces <code>i2c_master</code>,
   <code>i2c_slave</code>, <code>i2c_link</code>, and
   <code>i2c_bridge</code>.
</p><p>
   An I2C bus consists of a number of <em>master</em> devices and a number of
   <em>slave</em> devices.  Each slave device listens to one or more <em>7-bit
   addresses</em> or <em>10-bit addresses</em>.  It is an error to connect two
   slave devices to the same bus if they listen to the same address. 
   Communication over the bus is initiated by a master, which can communicate
   with one slave device at a time.  Only one master on a bus can communicate
   at a time.
</p><p>
   Two I2C devices can communicate directly if one implements the
   <code>i2c_master_v2</code> interface and the other one implements the
   <code>i2c_slave_v2</code> interface.  An I2C bus with multiple masters or
   slaves is typically modeled using an <b>i2c-link-v2</b> object,
   where each device is connected to an endpoint object.
</p><p>
   The <b><i>start</i></b> method starts a transfer.  The
   <i>address</i> parameter is the address of the slave device, encoded
   as an 8-bit number.  To communicate with 7-bit address slave device, using 
   little-endian bit numbering, bit 0 is a read/write bit (0  master
   writes, 1  master reads) and bits 1 to 7 is the 7-bit address of
   the slave device.  The <i>address</i> parameter should normally
   be in the (inclusive) range <code>0x10 - 0xef</code>; the ranges <code>0x00 -
   0x0f</code> and <code>0xf0 - 0xff</code> are reserved for special addressing modes.
   To communicate with 10-bit address slave device, using little-endian bit 
   numbering, bit 0 is a read/write bit (same as 7-bit address), bits 1 to 2
   is part of 10-bit address, and bits 3 to 7 is 10-bit address mode 0b11110.
</p><p>
   The slave responds to <b><i>start</i></b> using the
   <b><i>acknowledge</i></b> method.  The <i>ack</i> parameter may be
   <code>I2C_ack</code> or <code>I2C_noack</code> if the start is acked
   or noacked, respectively. In a multi-master configuration, the slave may
   instead respond by calling the <b><i>start</i></b> method in the
   <code>i2c_slave_v2</code> interface of the master device; this signals
   that the master lost the bus arbitration. This is discussed further below.
</p><p>
   If a start was acked by a slave device, read/write bit in the
   <b><i>start</i></b> method was 1, the master proceeds with a sequence
   of <b><i>read</i></b> calls.  Each call is followed by a
   <b><i>read_response</i></b> call from the slave.  If the read/write bit in
   the <b><i>start</i></b> was 0, the master instead proceeds with a
   sequence of <b><i>write</i></b> calls, each one followed by an
   <b><i>acknowledge</i></b> call. The <i>ack</i> parameter of the
   <b><i>acknowledge</i></b> method may be either <code>I2C_ack</code> or
   <code>I2C_noack</code>, representing ack and noack, respectively.
</p><p>
   After sending a number of reads or writes, the master may choose to
   either call the <b><i>stop</i></b> method to issue a <em>stop condition</em>
   which terminates the transfer, or to call the <b><i>start</i></b>
   method again to issue a <em>repeated start condition</em>.  The repeated
   start condition works like a normal start condition.
</p><p>
   When 0 is passed as the <i>address</i> parameter of the
   <b><i>start</i></b> method, a <em>General Call</em> transfer is initiated. A
   General Call transfer works like a normal write transfer, except that
   multiple slave devices may acknowledge the start and write requests.  The
   master will conceive a request as acknowledged if it was acknowledged by at
   least one of the slaves.
</p><p>
   When 10-bit address pattern is passed as the <i>address</i>
   parameter of the <b><i>start</i></b> method, a <em>10-bit address</em>
   transaction is initiated. A 10-bit address transaction begins with write
   status (read/write bit should be 0). As mentioned before, bits 1 to 2 are
   the most significant bits of 10-bit address. Then following is a call
   to the <b><i>write</i></b> method with the last 8 bits of 10-bit address.
   If the transaction is slave-receiver, the next transfer works like a
   normal write transfer. If the transaction is slave-transmitter, then
   the <b><i>start</i></b> method is called again with the same address pattern
   as before, but with bit 0 (the read/write bit) set to 1. This is followed
   by calls to <b><i>read</i></b> like in a normal read transaction.
</p><p>
   The <b><i>addresses</i></b> method is used to retrieve the set of addresses a
   device currently listens to.  The method is called by the
   <b>i2c-link-v2</b> to provide an overview of the bus topology, and
   to detect address collisions early.  The method may not have any
   side-effects on the simulation.  The return value is a list containing all
   the different values of the <i>address</i> parameter in a
   <b><i>start</i></b> call that the slave would respond to with
   <code>I2C_ack</code>.  The list may also contain an element
   <code>Nil</code> to mark that the device might respond to other addresses as
   well.  If a device is configured to listen to a specific address but is
   currently disabled, then that address may still be included in the list.
</p><p>
   For example, if a slave device listens to the single 7-bit address
   <code>0x55</code>, the return value of <b><i>addresses</i></b> would be
   <code>[0xaa, 0xab]</code>, using Python list syntax.
</p><p>
   The specification of the return value may be extended in the future, to
   allow other values than <code>Nil</code> and 8-bit integers. Therefore, callers
   should not make any assumptions on how the elements are formatted in the
   return value.
</p><p>
   For most I2C devices it is sufficient to implement only one of the
   <code>i2c_slave_v2</code> and <code>i2c_master_v2</code> interfaces.  In
   some cases it may be useful for a device to implement both interfaces,
   either because the device can act both as a master and as a slave on the
   bus, or because it needs to use the <b><i>start</i></b> and
   <b><i>stop</i></b> methods to monitor start and stop conditions on the bus.
   I2C link endpoints also implement both interfaces.
</p><p>
   If multiple master devices are connected to the same i2c link, then all
   master devices need to implement the <code>i2c_slave_v2</code> interface
   in addition to <code>i2c_master_v2</code>, in order to handle bus
   arbitration correctly:
</p><p>
   </p><ul>
     <li>A master device should monitor calls to the <b><i>start</i></b> and
     <b><i>stop</i></b> functions: After a call to <b><i>start</i></b> in a master
     device, the master should not call <b><i>start</i></b> in the slave until
     after a subsequent call to <b><i>stop</i></b> in the master.</li>

     <li>When a master calls <b><i>start</i></b> in a link endpoint device, the
     endpoint may respond with a call to <b><i>start</i></b> instead of
     <b><i>acknowledge</i></b>; this means that there was bus arbitration, which
     the master lost to the given <b><i>start</i></b> request.  Note that this
     case can not happen on a latency-free connection, since all arbitration is
     handled by the master's monitoring of <b><i>start</i></b> and <b><i>stop</i></b>
     calls. Note also that user-written slave devices are required to respond
     with <b><i>acknowledge</i></b> to a <b><i>start</i></b> call; only the i2c link
     endpoint (and other i2c infrastructure objects from the Simics-Base
     package) are allowed to respond with a <b><i>start</i></b> call.</li>
   </ul>
<p>
   Note that there is no need for a master device to implement the
   <code>i2c_slave_v2</code> interface if the device only will be used in
   single-master configurations.
</p><p>
   The <b><i>start</i></b>, <b><i>write</i></b> and <b><i>read</i></b> methods in the
   <code>i2c_slave_v2</code> interface are allowed to respond synchronously;
   i.e., the <b><i>acknowledge</i></b> or <b><i>read_response</i></b> method may be
   called before the corresponding method in the slave interface has returned.
   A master that needs to connect directly to a slave device needs to take this
   into consideration; however, when communicating via an
   <b>i2c-link-v2</b> object, the link guarantees that all responses
   are asynchronous.  
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem"><table>

   <tbody><tr><td class="jdocu_noborder"><code>addresses</code></td><td class="jdocu_noborder">Global Context</td></tr>

   <tr><td class="jdocu_noborder">All other methods</td><td class="jdocu_noborder">Cell Context</td></tr>

   </tbody></table>
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_i3c_daa_snoop.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_i3c_daa_snoop.html:__rm_interface_i3c_daa_snoop">i3c_daa_snoop</a></h1>
<p>

<a id="__rm_interface_i3c_daa_snoop.html:i3c_daa_snoop"></a><a id="__rm_interface_i3c_daa_snoop.html:i3c_daa_snoop_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><pre class="jdocu_small">SIM_INTERFACE(i3c_daa_snoop) {
        void (*assigned_address)(conf_object_t *obj, uint64 id,
                                 uint8 bcr, uint8 dcr, uint8 address);
};

#define I3C_DAA_SNOOP_INTERFACE "i3c_daa_snoop"
</pre><p>
</p><p>

   During DAA process, the assigned address information will be monitored
   to devices who implement the interface <code>i3c_daa_snoop</code>.
   Whenever an address is assigned to a slave, the method
   <b><i>assigned_address</i></b> is called in all devices that implement the
   interface. The parameter <i>id</i>, <i>bcr</i> and
   <i>dcr</i> in method <b><i>assigned_address</i></b> is slave specific
   daa data which indicates who gets the assigned address. Parameter
   <i>address</i> stores the assigned address. The 7-bit address
   is represented as 8-bit number with the highest bit set to 0.
</p><p>
   Interface <code>i3c_daa_snoop</code> is mainly implemented by slave who
   may become secondary master later and needs to know the information about
   slave addresses.
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_i3c_hdr_master.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_i3c_hdr_master.html:__rm_interface_i3c_hdr_master">i3c_hdr_master</a></h1>
<p>

<a id="__rm_interface_i3c_hdr_master.html:i3c_hdr_master"></a><a id="__rm_interface_i3c_hdr_master.html:i3c_hdr_master_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><pre class="jdocu_small">SIM_INTERFACE(i3c_hdr_master) {
        void (*hdr_read_response)(conf_object_t *obj, bytes_t bytes, bool more);
        void (*hdr_acknowledge)(conf_object_t *obj, i3c_ack_t ack);
};

#define I3C_HDR_MASTER_INTERFACE "i3c_hdr_master"
</pre><p>
</p><p>
   The interfaces <code>i3c_hdr_slave</code> and <code>i3c_hdr_master</code>
   are used together to model I3C HDR communication over the bus.
   HDR modes are entered by sending one of the ENTHDRx broadcast CCCs on the bus
   through normal SDR communication.
   Slaves that support HDR shall now internally switch to HDR mode.
   The master can exit HDR mode by calling <b><i>hdr_exit</i></b> in
   the <code>i3c_hdr_slave</code> interface and
   then follow it with a <b><i>stop</i></b> call. All slaves that support HDR
   shall now internally switch back to SDR mode.
</p><p>
   All write transfers in HDR mode are done using the <b><i>hdr_write</i></b>
   method. Slaves must always respond through method <b><i>hdr_acknowledge</i></b>
   to either ACK or NACK the write. Devices not supporting active acknowledgement
   for a certain write transfer block must always respond with an ACK as it
   represents a passive acknowledgement according to MIPI I3C V1.1.1 spec.
   </p><p>
   All read transfers in HDR mode are done using the <b><i>hdr_read</i></b> method.
   Parameter <i>max_len</i> in method <b><i>hdr_read</i></b> is the maximum
   number of bytes that the slave is allowed to send in response.
   The slave shall respond with an <b><i>hdr_read_response</i></b>
   call after each <b><i>hdr_read</i></b> call. The parameter <i>more</i>
   indicates if the slave has more data to send.
   The slave is allowed to send back less than <i>max_len</i> and at the same time
   set <i>more</i> to true. This feature is an optimization in order to:
      1. Minimize the number of <b><i>hdr_read</i></b> calls needed to read a large amount of data.
      2. Avoid underflow on the slave side by allowing the slave respond with less data.
   </p><p>
   If <i>more</i> is set to false, the master has to ends it current transfer
   by either calling <b><i>hdr_restart</i></b> or exit HDR through the procedure described above.
</p><p>

   Examples of HDR write transactions:
   </p><div class="figure">

   <pre class="jdocu_small">HDR Private Write 256 bytes followed by a 64 byte write:
+-------------+-----------------+--------------------------------------------------------+
| Master      | Slave           | Arguments                                              |
+-------------+-----------------+--------------------------------------------------------+
| hdr_write   |                 | 2 bytes: RnW @ 15 |  CC @ 14:8 | Target Address @ 8:1  |
+-------------+-----------------+--------------------------------------------------------+
|             | hdr_acknowledge | ACK                                                    |
+-------------+-----------------+--------------------------------------------------------+
| hdr_write   |                 | 100-bytes                                              |
+-------------+-----------------+--------------------------------------------------------+
|             | hdr_acknowledge | ACK                                                    |
+-------------+-----------------+--------------------------------------------------------+
| hdr_write   |                 | 100-bytes                                              |
+-------------+-----------------+--------------------------------------------------------+
|             | hdr_acknowledge | ACK                                                    |
+-------------+-----------------+--------------------------------------------------------+
| hdr_write   |                 | 56-bytes                                               |
+-------------+-----------------+--------------------------------------------------------+
|             | hdr_acknowledge | ACK                                                    |
+-------------+-----------------+--------------------------------------------------------+
| hdr_restart |                 |                                                        |
+-------------+-----------------+--------------------------------------------------------+
| hdr_write   |                 | 2 bytes: RnW @ 15 |  CC @ 14:8 | Target Address @ 8:1  |
+-------------+-----------------+--------------------------------------------------------+
|             | hdr_acknowledge | ACK                                                    |
+-------------+-----------------+--------------------------------------------------------+
| hdr_write   |                 | 64-bytes                                               |
+-------------+-----------------+--------------------------------------------------------+
|             | hdr_acknowledge | ACK                                                    |
+-------------+-----------------+--------------------------------------------------------+
| hdr_exit    |                 |                                                        |
+-------------+-----------------+--------------------------------------------------------+
| stop        |                 |                                                        |
+-------------+-----------------+--------------------------------------------------------+
   </pre><p>
   </p></div>

<p>
   The sequence of hdr_write calls could be made differently. Master can send smaller or larger
   chunks of data in each hdr_write call. The main concerns are to minimize the number
   of interface calls and to avoid overflow on the slave side. A balance between the
   two should be considered in the implementation of the master.
</p><p>
   </p><div class="figure">

   <pre class="jdocu_small">HDR Private Read 256 bytes:
+-----------+-------------------+-------------------------------------------------------+
| Master    | Slave             | Arguments                                             |
+-----------+-------------------+-------------------------------------------------------+
| hdr_write |                   | 2 bytes: RnW @ 15 |  CC @ 14:8 | Target Address @ 8:1 |
+-----------+-------------------+-------------------------------------------------------+
|           | hdr_acknowledge   | ACK                                                   |
+-----------+-------------------+-------------------------------------------------------+
| hdr_read  |                   | max_len = 128                                         |
+-----------+-------------------+-------------------------------------------------------+
|           | hdr_read_response | bytes.len = 64, more = true                           |
+-----------+-------------------+-------------------------------------------------------+
| hdr_read  |                   | max_len = 128                                         |
+-----------+-------------------+-------------------------------------------------------+
|           | hdr_read_response | bytes.len = 64, more = true                           |
+-----------+-------------------+-------------------------------------------------------+
| hdr_read  |                   | max_len = 128                                         |
+-----------+-------------------+-------------------------------------------------------+
|           | hdr_read_response | bytes.len = 64, more = true                           |
+-----------+-------------------+-------------------------------------------------------+
| hdr_read  |                   | max_len = 64                                          |
+-----------+-------------------+-------------------------------------------------------+
|           | hdr_read_response | bytes.len = 64, more = false                          |
+-----------+-------------------+-------------------------------------------------------+
| hdr_exit  |                   |                                                       |
+-----------+-------------------+-------------------------------------------------------+
| stop      |                   |                                                       |
+-----------+-------------------+-------------------------------------------------------+
</pre><p>
</p></div>

<p>
   The sequence of <b><i>hdr_read</i></b> calls could be made differently. Master can read smaller
   chunks of data in each hdr_read call. The main concerns are to minimize the number
   of interface calls and to avoid underflow on the slave side. A balance between the
   two should be considered in the implementation of the master.
</p><p>
   Note: This interface is in tech-preview and may change without
   notice.
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_i3c_hdr_slave.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_i3c_hdr_slave.html:__rm_interface_i3c_hdr_slave">i3c_hdr_slave</a></h1>
<p>

<a id="__rm_interface_i3c_hdr_slave.html:i3c_hdr_slave"></a><a id="__rm_interface_i3c_hdr_slave.html:i3c_hdr_slave_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><pre class="jdocu_small">SIM_INTERFACE(i3c_hdr_slave) {
        void (*hdr_write)(conf_object_t *obj, bytes_t data);
        void (*hdr_read)(conf_object_t *obj, uint32 max_len);
        void (*hdr_restart)(conf_object_t *obj);
        void (*hdr_exit)(conf_object_t *obj);
};

#define I3C_HDR_SLAVE_INTERFACE "i3c_hdr_slave"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_i3c_master.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_i3c_master.html:__rm_interface_i3c_master">i3c_master</a></h1>
<p>

<a id="__rm_interface_i3c_master.html:i3c_master"></a><a id="__rm_interface_i3c_master.html:i3c_master_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><pre class="jdocu_small">typedef enum {
        I3C_ack = 0,
        I3C_noack
} i3c_ack_t;


SIM_INTERFACE(i3c_master) {
        void (*acknowledge)(conf_object_t *obj, i3c_ack_t ack);
        void (*read_response)(conf_object_t *obj, uint8 value, bool more);
        void (*daa_response)(conf_object_t *obj,
                             uint64 id, uint8 bcr, uint8 dcr);
        void (*ibi_request)(conf_object_t *obj);
        void (*ibi_address)(conf_object_t *obj, uint8 address);
};

#define I3C_MASTER_INTERFACE "i3c_master"
</pre><p>
</p><p>

   The interfaces <code>i3c_master</code> <code>i3c_slave</code>
   and <code>i3c_daa_snoop</code> are used together to model
   communication over an I3C bus.
   There are four kinds of devices roles on the I3C bus: Main Master,
   Secondary Master, Slave and Legacy I2C Slave. Exactly one device
   must be the Main Master; this is typically configured statically.
   Main Master should implement the <code>i3c_master</code> interface,
   while slave should implement the <code>i3c_slave</code> interface.
   Secondary Master should implement both.
   Most calls to a method in the slave device interfaces expect a response
   call to a method in the master device interfaces. One exception is the
   method <b><i>sdr_write</i></b> in the <b><i>i3c_slave</i></b> interface, master
   expects no response when calling it.
   It is up to each device to find the caller's interfaces; usually it is
   configured with attributes in both the master and slave device.
</p><p>
   Two I3C devices can communicate directly if one implements the
   <code>i3c_master</code> interface and the other one implements the
   <code>i3c_slave</code> interface. An I3C bus with multiple masters
   or slaves is typically modelled using an <b>i3c-link</b> object,
   where each device is connected to an endpoint object.
</p><p>
   An I3C bus consists of a number of <em>master</em> devices and a number
   of <em>slave</em> devices. Each I3C slave device listens to one or more
   <em>7-bit addresses</em>. The slave devices can be I3C slave devices or
   Legacy I2C slave devices. This is because I3C protocol is compatible with
   I2C protocol, so that I3C master device can communicate with I2C slave
   devices.
   For legacy I2C slave device, the address it listens to is
   pre-configured by the device, i.e. static address. For I3C slave device,
   the address it listens to can be either static address or dynamic address.
   The dynamic address is assigned by master during Dynamic Address Assignment
   process. It is an error to connect two slave devices to the same
   bus if they listen to the same address.
   In a communication, the Current Master refers to the device who now drives
   the bus. It can be Main Master, or Secondary Master.
   Usually, communication over the bus is initiated by the Current Master,
   which can communicate with one or more slave devices at a time.
   A slave device can request to initiate an communication, i.e., issue
   an ibi_request, in three cases:
   Hot-Join, In-Band Interrupt and as a Secondary Master other than the
   Current Master requesting to become Current Master.
   Only one device on a bus can communicate at a time.
</p><p>
   The <b><i>start</i></b> method starts a transfer. The <i>address</i>
   parameter is the address header combined with read/write bit encoded as an
   8-bit number. The least significant bit is the read/write bit and the other
   bits is the 7-bit address header.
   If the <b><i>start</i></b> method is called from master, the address header
   can be address pattern 0x7E for broadcast, or specific slave address (either
   I2C slave static address or I3C slave dynamic address).
</p><p>
   In I3C bus or link implementation, every start request will broadcast to
   all other devices. So does the stop request. This will monitor bus/link
   status to all devices.
</p><p>
   Normally, master starts a transfer, then the slave responds to
   <b><i>start</i></b> using the <b><i>acknowledge</i></b> method (implemented by
   master side interface). The <i>ack</i> parameter may be
   <code>I3C_ack</code> or <code>I3C_noack</code> if the start is acked or
   noacked, respectively.
</p><p>
   There are five types of different start requests:
   </p><dl><dt id="__rm_interface_i3c_master.html:dt:i3c-master-read-transaction"><a href="#__rm_interface_i3c_master.html:dt:i3c-master-read-transaction"><b>I3C master read transaction</b></a></dt><dd>If a master's start with specific slave address was acked by other
   device, and read/write bit in the <i>address</i> parameter of
   the <b><i>start</i></b> method was 1, then master proceeds with a sequence
   of <b><i>read</i></b> calls. Each call is followed by a <b><i>read_response</i></b>
   call from the slave. Parameter <i>data</i> in the method
   <b><i>read_response</i></b> is the data transferred. The procedure is no
   difference with regard to read from I3C slave or read from I2C slave.
   In hardware, the ACK/T bit is handled differently for i2c and i3c, and
   the master is supposed to know whether the slave is an i2c or i3c device.
   In the i3c case, the slave is supposed to pass the T bit in the
   <i>more</i> argument of <b><i>read_response</i></b>, while an i2c
   device always passes <i>more</i> as true. Further more, in the
   i2c case, a master sends an ACK bit, which is not represented explicitly
   in the interface. The value of this bit can be deduced from whether the
   following operation is START/STOP or READ. For i3c case, parameter
   <i>more</i> in method <b><i>read_response</i></b> indicates if
   there are still data waiting to be transferred from slave to master.
   <i>more</i> is true when there are still data left, false otherwise.
   </dd><dt id="__rm_interface_i3c_master.html:dt:i3c-master-write-transaction-write-to-i3c-slave"><a href="#__rm_interface_i3c_master.html:dt:i3c-master-write-transaction-write-to-i3c-slave"><b>I3C master write transaction (write to I3C slave)</b></a></dt><dd>If a master's start with specific slave address was acked by other
   device, and the read/write bit in the <i>address</i> parameter
   of <b><i>start</i></b> method was 0, the master proceeds with a
   <b><i>sdr_write</i></b> call, no response is expected. Parameter
   <i>data</i> in method <b><i>write</i></b> is the data transferred.
   The parity bit is not passed explicitly in sdr_write, and that the slave
   can assume the parity bit is correctly set.
   </dd><dt id="__rm_interface_i3c_master.html:dt:i3c-master-write-transaction-write-to-i2c-slave"><a href="#__rm_interface_i3c_master.html:dt:i3c-master-write-transaction-write-to-i2c-slave"><b>I3C master write transaction (write to I2C slave)</b></a></dt><dd>When the master's start request is to write to I2C slave, i.e.,
   master issues a start request to I2C slave address with read/write bit
   is 0, then master proceeds with a sequence of <b><i>write</i></b> calls,
   each call expects a response call to a method <b><i>acknowledge</i></b>.
   This is quite similar to I2C write transaction.</dd><dt id="__rm_interface_i3c_master.html:dt:i3c-broadcast-transaction"><a href="#__rm_interface_i3c_master.html:dt:i3c-broadcast-transaction"><b>I3C broadcast transaction</b></a></dt><dd>When master starts a transfer with I3C Broadcast Address 0x7E which
   is passed as address header, i.e., address 0xFC passed in the
   <i>address</i> argument of method <b><i>start</i></b>, a typical
   I3C message transfer is initiated.
<p>
   Multiple I3C slave devices may acknowledge the start request. The master
   will conceive a request as being acknowledged if it was acknowledged by
   at least one of the slaves. Note that there will be a single
   <b><i>acknowledge</i></b> call in the master; the link or bus handles
   aggregation of acks.
</p><p>
   Master sends the I3C Commands (Common Command Code, CCC) using
   <b><i>sdr_write</i></b> method after receiving ACK, showing to communicate
   with either all Slaves (Broadcast CCCs) or specific individual Slaves
   (Direct CCCs). This operation expects no response, and master will proceed.
</p><p>
   If Broadcast CCC sent previously, master calls <b><i>sdr_write</i></b> method
   to transfer data to all slaves who acked the initial access.</p></dd><dt id="__rm_interface_i3c_master.html:dt:i3c-direct-transaction"><a href="#__rm_interface_i3c_master.html:dt:i3c-direct-transaction"><b>I3C direct transaction</b></a></dt><dd>After sending a Direct CCC, master continues with a repeated start
   request along with one specific I3C slave address. The transaction goes
   on just like master is communicating with only one slave. After the
   communication with one slave, master may be issue a repeated start request
   to another slave. Further communication is routed only to the targeted
   slave device.</dd></dl><p>After sending a number of reads or a number of writes, the master may
   choose to either call the <b><i>stop</i></b> method to issue a <em>stop
   condition</em> which terminates the transfer, or to call the <b><i>start</i></b>
   method again to issue a <em>repeated start condition</em>. The repeated start
   condition works like a normal start condition.
</p><p>
   The <b><i>start</i></b> method and <b><i>read</i></b> method in the slave
   interfaces are allowed to respond synchronously; i.e., the
   <b><i>acknowledge</i></b> or <b><i>read</i></b> method may be called before the
   corresponding method in the slave interfaces has returned. A master that
   needs to connect directly to a slave device needs to take this into
   consideration; however, when communicating via an <b>i3c-link</b>
   object, the link guarantees that all responses are asynchronous.
</p><p>
   The method <b><i>daa_read</i></b> and method <b><i>daa_response</i></b> are used
   in Dynamic Address Assignment process.
   Method <b><i>daa_read</i></b> is called from master to signal a daa read request.
   Method <b><i>daa_response</i></b> is called from slave to send slave specific
   8-bytes data (48-bit Unique ID, BCR, DCR) to master. The parameter
   <i>id</i>, <i>bcr</i> and <i>dcr</i> in method
   <b><i>daa_response</i></b> represent the slave specific daa data.
   If multiple slaves response daa data, the slave with the lowest data wins
   and it will get the assigned address this time.
   Master calls method <b><i>write</i></b> in slave interfaces to send assigned
   dynamic address to the slave who wins. This operation expects a response
   call to method <b><i>acknowledge</i></b> in master side. Parameter
   <i>data</i> in method <b><i>write</i></b> stores the assigned address.
</p><p>
   Master should implement the method <b><i>stop</i></b> in the interface
   <code>i3c_slave</code> in case there is secondary master in the
   configuration which may issue start request.
</p><p>
   Slave can request to start a communication through <b><i>ibi_request</i></b>.
   The request is sent to Current Master which drives the bus now.
   If the master chooses to continue the slave request, <b><i>ibi_start</i></b>
   is called, this ibi start will broadcast to all devices in the configuration.
   Then slave can send its address header with <b><i>ibi_address</i></b>
   argument <i>address</i>. The address header can be 0x02 for Hot-Join,
   or the address of the slave itself for IBI and secondary master with
   read/write bit 1 and 0 respectively.
   If more than one slave issues <b><i>ibi_address</i></b>, arbitration occurs,
   the slave with lowest address header wins and the winning address will be
   delivered to master by link or bus.
   At that time, master issues <b><i>ibi_acknowledge</i></b> to the slave who wins.
   Other slaves which do not receive <b><i>ibi_acknowledge</i></b> will consume it
   lost arbitration already.
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_i3c_slave.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_i3c_slave.html:__rm_interface_i3c_slave">i3c_slave</a></h1>
<p>

<a id="__rm_interface_i3c_slave.html:i3c_slave"></a><a id="__rm_interface_i3c_slave.html:i3c_slave_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><pre class="jdocu_small">SIM_INTERFACE(i3c_slave) {
        void (*start)(conf_object_t *obj, uint8 address);
        void (*write)(conf_object_t *obj, uint8 value);
        void (*sdr_write)(conf_object_t *obj, bytes_t data);
        void (*read)(conf_object_t *obj);
        void (*daa_read)(conf_object_t *obj);
        void (*stop)(conf_object_t *obj);
        void (*ibi_start)(conf_object_t *obj);
        void (*ibi_acknowledge)(conf_object_t *obj, i3c_ack_t ack);
};

#define I3C_SLAVE_INTERFACE "i3c_slave"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_i8051_interrupt.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_i8051_interrupt.html:__rm_interface_i8051_interrupt">i8051_interrupt</a></h1>
<p>

<a id="__rm_interface_i8051_interrupt.html:i8051_interrupt"></a><a id="__rm_interface_i8051_interrupt.html:i8051_interrupt_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><pre class="jdocu_small">SIM_INTERFACE(i8051_interrupt) {
        int (*active_interrupt)(conf_object_t *NOTNULL obj);
        void (*reti)(conf_object_t *NOTNULL obj);
        bool (*suppress_irq)(conf_object_t *NOTNULL obj, uint32 addr);        
};
#define I8051_INTERRUPT_INTERFACE "i8051_interrupt"
</pre><p>
</p><p>

   The <b><i>active_interrupt()</i></b> function returns the interrupt vector
   address of the highest pending interrupt. This function should only be
   called when the processor should take an interrupt. This function may also
   set internal interrupt controller state, which can be cleared by the
   <b><i>reti</i></b> function call when returning from the interrupt.
</p><p>
   The <b><i>reti</i></b> function is used to notify the interrupt controller that
   the currently active interrupt has completed.
</p><p>
   The <b><i>suppress_irq</i></b> function is used to determine whether interrupt 
   should be blocked after a writing access to a memory location.
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_i8051_timer.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_i8051_timer.html:__rm_interface_i8051_timer">i8051_timer</a></h1>
<p>

<a id="__rm_interface_i8051_timer.html:i8051_timer"></a><a id="__rm_interface_i8051_timer.html:i8051_timer_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><pre class="jdocu_small">SIM_INTERFACE(i8051_timer) {
        void (*change_mode)(conf_object_t *NOTNULL obj, uint8 mode);
        void (*switch_timer)(conf_object_t *obj, uint8 caller, bool onoff);
};
#define I8051_TIMER_INTERFACE "i8051_timer"
</pre><p>
</p><p>

   The <b><i>change_mode</i></b> function is used to change the working mode (e.g.
   16bit timer, 8 bit timer or event counting etc.)
   of the timer.
</p><p>
   The <b><i>switch_timer</i></b> function is used to enable or disable
   the timer. Timers can be switched on or off by either software or hardware.
   The parameter caller is either 0 or 1, indicating the control
   is from software or hardware. Only when the timer is switched on or off
   by hardware, the third parameter onoff is used, which indicates
   whether the timer is to be enabled or disabled.
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_ieee_802_15_4_control.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_ieee_802_15_4_control.html:__rm_interface_ieee_802_15_4_control">ieee_802_15_4_control</a></h1>
<p>

<a id="__rm_interface_ieee_802_15_4_control.html:ieee_802_15_4_control"></a><a id="__rm_interface_ieee_802_15_4_control.html:ieee_802_15_4_control_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><pre class="jdocu_small">SIM_INTERFACE(ieee_802_15_4_control) {
        void (*set_rssi)(conf_object_t *NOTNULL obj,
                         uint64 tgt_ep_id,
                         uint32 rssi);
        void (*remove_rssi)(conf_object_t *NOTNULL obj,
                            uint64 tgt_ep_id);
        void (*clear_all_rssi)(conf_object_t *NOTNULL obj);
};
#define IEEE_802_15_4_CONTROL_INTERFACE "ieee_802_15_4_control"
</pre><p>
</p><p>

   The <code>ieee_802_15_4_control</code> interface is implemented by the
   IEEE 802.15.4 link endpoint objects that provide a interface for endpoint
   configuration. Simics command (Python program) calls <b><i>set_rssi</i></b>,
   <b><i>remove_rssi</i></b> and <b><i>clear_all_rssi</i></b> to update
   the RSSI table.
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_ieee_802_15_4_link.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_ieee_802_15_4_link.html:__rm_interface_ieee_802_15_4_link">ieee_802_15_4_link</a></h1>
<p>

<a id="__rm_interface_ieee_802_15_4_link.html:ieee_802_15_4_link"></a><a id="__rm_interface_ieee_802_15_4_link.html:ieee_802_15_4_link_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><pre class="jdocu_small">SIM_INTERFACE(ieee_802_15_4_link) {
        ieee_802_15_4_transmit_status_t (*transmit)(
                                conf_object_t *NOTNULL obj,
                                const frags_t *frame,
                                uint16 channel_page,
                                uint16 channel_number,
                                ieee_802_15_4_frame_crc_status_t crc_status);
};
#define IEEE_802_15_4_LINK_INTERFACE "ieee_802_15_4_link"
</pre><p>
</p><p>

   The <code>ieee_802_15_4_link</code> interface is implemented by the IEEE
   802.15.4 link endpoint objects that provide an interface for frame traffic.
</p><p>
   Transceiver calls <b><i>transmit</i></b> to send out frames. The return value
   is using one of the values in the
   <code>ieee_802_15_4_transmit_status_t</code> enum:
</p><p>
   
   </p><ul>
     <li><code>IEEE_802_15_4_Transmit_No_Error</code> means that the frame was
     sent out without error.</li>

     <li><code>IEEE_802_15_4_Transmit_Channel_Contention</code> means that there
     was collision and the frame was not sent out.</li>

     <li><code>IEEE_802_15_4_Transmit_Data_Corruption</code> means that the
     endpoint detected CRC mismatch and didn't send out the frame.</li>
   </ul>
   
<pre class="jdocu_small">typedef enum {
        IEEE_802_15_4_Transmit_No_Error = 0,
        IEEE_802_15_4_Transmit_Channel_Contention,
        IEEE_802_15_4_Transmit_Data_Corruption
} ieee_802_15_4_transmit_status_t;</pre><p>

</p><p>
   The <i>crc_status</i> parameter provides out-of-band information on
   the contents of the frame with regards to the CRC field using one of the
   values in the <code>ieee_802_15_4_frame_crc_status_t</code> enum:
</p><p>
   
   </p><ul>
     <li><code>IEEE_802_15_4_Frame_CRC_Match</code> means that to the link that,
     regardless of the actual contents of the CRC field in frame, the CRC is
     considered matching the frame contents.</li>

     <li><code>IEEE_802_15_4_Frame_CRC_Mismatch</code> means that the CRC field
     and the frame contents do not agree. Just like the Ethernet links, the
     endpoint does not really send out the packet in this case.</li>

     <li><code>IEEE_802_15_4_Frame_CRC16_Unknown/IEEE_802_15_4_Frame_CRC32_Unknown
     </code> means that the link to compute the CRC and compare it with
     FCS (Frame Check Sequence) of the MAC frame. If the CRC field and frame
     contents do not agree, the endpoint does not send out the packet.
     <code>IEEE_802_15_4_Frame_CRC32_Unknown</code> is for 802.15.4g only.</li>
   </ul>
   
<pre class="jdocu_small">typedef enum {
        IEEE_802_15_4_Frame_CRC_Match = 0,
        IEEE_802_15_4_Frame_CRC_Mismatch,
        IEEE_802_15_4_Frame_CRC16_Unknown,
        IEEE_802_15_4_Frame_CRC32_Unknown,
} ieee_802_15_4_frame_crc_status_t;</pre><p>

</p><p>
   The frequency channels are defined through a combination of channel numbers
   and channel pages. Channel page is a concept added to IEEE 802.15.4 in 2006
   to distinguish between supported PHYs. Both channel page and channel number
   must match on source and target sides for successful transmission.
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_ieee_802_15_4_probe.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_ieee_802_15_4_probe.html:__rm_interface_ieee_802_15_4_probe">ieee_802_15_4_probe</a></h1>
<p>

<a id="__rm_interface_ieee_802_15_4_probe.html:ieee_802_15_4_probe"></a><a id="__rm_interface_ieee_802_15_4_probe.html:ieee_802_15_4_probe_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><pre class="jdocu_small">typedef void (*ieee_802_15_4_probe_snoop_t)(
                                lang_void *user_data,
                                conf_object_t *probe,
                                ieee_802_15_4_probe_side_t to_side,
                                const frags_t *frame,
                                uint32 rssi,
                                uint16 channel_page,
                                uint16 channel_number,
                                ieee_802_15_4_frame_crc_status_t crc_status);</pre><p>

   
   </p><ul>
     <li><code>IEEE_802_15_4_Probe_Port_A</code> means that the frame is
     from device to link.</li>

     <li><code>IEEE_802_15_4_Probe_Port_B</code> means that the frame is
     from link to device.</li>
   </ul>
   
<pre class="jdocu_small">typedef enum {
        IEEE_802_15_4_Probe_Port_A = 0,
        IEEE_802_15_4_Probe_Port_B = 1
} ieee_802_15_4_probe_side_t;</pre><p>

   </p><pre class="jdocu_small">SIM_INTERFACE(ieee_802_15_4_probe) {
        void (*attach_snooper)(conf_object_t *NOTNULL probe,
                               ieee_802_15_4_probe_snoop_t snoop_fun,
                               lang_void *user_data);
        void (*detach)(conf_object_t *NOTNULL probe);
};
#define IEEE_802_15_4_PROBE_INTERFACE "ieee_802_15_4_probe"
</pre><p>
</p><p>

   The <code>ieee_802_15_4_probe</code> interface is implemented by the
   IEEE 802.15.4 probe devices that provide an interface for Simics users to
   register their own callback to listen to the traffic going-on in the probe.
   The <b><i>attach_snooper</i></b> attaches a snooper function. The probe will
   pass each frame to the snooper function, then forward it unchanged where it
   should be going.
   The <b><i>detach</i></b> detaches the currently registered callback from
   the probe.
</p><p>
   This interface should only be used for inspection, and never as part of
   the actual simulation. The snoop functions must not affect the simulation
   in any way.
   The user_data parameter is passed to the snoop function every time
   it is called.
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_ieee_802_15_4_receiver.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_ieee_802_15_4_receiver.html:__rm_interface_ieee_802_15_4_receiver">ieee_802_15_4_receiver</a></h1>
<p>

<a id="__rm_interface_ieee_802_15_4_receiver.html:ieee_802_15_4_receiver"></a><a id="__rm_interface_ieee_802_15_4_receiver.html:ieee_802_15_4_receiver_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><pre class="jdocu_small">SIM_INTERFACE(ieee_802_15_4_receiver) {
        void (*receive)(conf_object_t *NOTNULL obj,
                        const frags_t *frame,
                        uint32 rssi,
                        uint16 channel_page,
                        uint16 channel_number,
                        ieee_802_15_4_frame_crc_status_t crc_status);
        void (*frame_lost)(conf_object_t *NOTNULL obj,
                           uint32 rssi,
                           uint16 channel_page,
                           uint16 channel_number);
};
#define IEEE_802_15_4_RECEIVER_INTERFACE "ieee_802_15_4_receiver"
</pre><p>
</p><p>

   The <code>ieee_802_15_4_receiver</code> interface is implemented by the
   IEEE 802.15.4 transceivers that provide an interface for traffic.
   Endpoints call <b><i>receive</i></b> to deliver a frame to transceiver.
   Transceiver should check if the received frame from endpoint is in the
   channel that it is using. The channel being used is defined by channel_page
   and channel_number.
   Endpoints call <b><i>frame_lost</i></b> to notify transceivers on that a frame
   was lost because of low RSSI value.
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_ieee_802_3_mac.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_ieee_802_3_mac.html:__rm_interface_ieee_802_3_mac">ieee_802_3_mac</a></h1>
<p>

<a id="__rm_interface_ieee_802_3_mac.html:ieee_802_3_mac"></a><a id="__rm_interface_ieee_802_3_mac.html:ieee_802_3_mac_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><pre class="jdocu_small">#define IEEE_802_3_MAC_INTERFACE "ieee_802_3_mac"
SIM_INTERFACE(ieee_802_3_mac) {
        int (*receive_frame)(conf_object_t *obj, int phy,
                             dbuffer_t *buf, int crc_ok);
        void (*tx_bandwidth_available)(conf_object_t *obj, int phy);
        void (*link_status_changed)(conf_object_t *obj, int phy,
                                    ieee_802_3_link_status_t status);
};
</pre><p>
</p><p>

   
</p><pre class="jdocu_small">typedef enum {
        IEEE_link_unconnected,
        IEEE_link_down,
        IEEE_link_up
} ieee_802_3_link_status_t;</pre><p>

</p><p>
   Deprecated; use <code>ieee_802_3_mac_v3</code> instead.
</p><p>
   Interface that should be implemented by 802.3 media access control layers.
</p><p>
   The <b><i>receive_frame</i></b> function is called when a frame has
   been received by the phy.  The frame is passed as a
   <code><a id="__rm_interface_ieee_802_3_mac.html:dbuffer_t">dbuffer_t</a></code> that may not be modified without
   cloning it first. The return value have no meaning, callers should
   ignore it, and new implementations should return 0.
</p><p>
   The <b><i>tx_bandwidth_available</i></b> is called by the PHY when a
   previous call to <b><i>send_frame</i></b> or <b><i>check_tx_bandwidth</i></b>
   in the <code>ieee_802_3_phy</code> interface have returned no bandwidth
   available.
</p><p>
   <b><i>link_status_changed</i></b> is called when the phy detects a change
   of the link status.
</p><p>
   The <i>phy</i> parameter is a number that identifies this particular
   PHY, in configurations with several PHYs connected to the same MAC.
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
<p>
   
</p></dd>
</dl><p></p></section><section class="page" id="__rm_interface_ieee_802_3_mac_v3.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_ieee_802_3_mac_v3.html:__rm_interface_ieee_802_3_mac_v3">ieee_802_3_mac_v3</a></h1>
<p>

<a id="__rm_interface_ieee_802_3_mac_v3.html:ieee_802_3_mac_v3"></a><a id="__rm_interface_ieee_802_3_mac_v3.html:ieee_802_3_mac_v3_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><pre class="jdocu_small">#define IEEE_802_3_MAC_V3_INTERFACE "ieee_802_3_mac_v3"
SIM_INTERFACE(ieee_802_3_mac_v3) {
        void (*receive_frame)(
                conf_object_t *obj, int phy, const frags_t *frame, int crc_ok);
        void (*tx_bandwidth_available)(conf_object_t *obj, int phy);
        void (*link_status_changed)(
                conf_object_t *obj, int phy, ieee_802_3_link_status_t status);
};
</pre><p>
</p><p>

   
</p><pre class="jdocu_small">typedef enum {
        IEEE_link_unconnected,
        IEEE_link_down,
        IEEE_link_up
} ieee_802_3_link_status_t;</pre><p>

</p><p>
   Interface that should be implemented by 802.3 media access control layers.
</p><p>
   The <b><i>receive_frame</i></b> function is called when a frame has been
   received by the phy.  The frame is passed as a
   <code><a id="__rm_interface_ieee_802_3_mac_v3.html:frags_t">frags_t</a></code> that must not be modified. 
</p><p>
   The <i>crc_ok</i> flag is set to indicate that the frame is valid
   with regards to CRC calculations. If the <i>crc_ok</i> flag is not
   set, the frame is considered invalid. Note that in general,
   <i>crc_ok</i> does not indicate whether or not the CRC field in the
   frame can be relied upon, or whether its computation has been skipped to
   improve simulation performance. When using new-style links,
   <i>crc_ok</i> set to false indicates that the CRC field contains
   valid information that is not matching with the frame contents.
</p><p>
   The <b><i>tx_bandwidth_available</i></b> is called by the PHY when a
   previous call to <b><i>send_frame</i></b> or <b><i>check_tx_bandwidth</i></b>
   in the <code>ieee_802_3_phy_v3</code> interface have returned no bandwidth
   available.
</p><p>
   <b><i>link_status_changed</i></b> is called when the phy detects a change
   of the link status.
</p><p>
   The <i>phy</i> parameter is deprecated and should be ignored.
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
<p>
   
</p></dd>
</dl><p></p></section><section class="page" id="__rm_interface_ieee_802_3_phy.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_ieee_802_3_phy.html:__rm_interface_ieee_802_3_phy">ieee_802_3_phy</a></h1>
<p>

<a id="__rm_interface_ieee_802_3_phy.html:ieee_802_3_phy"></a><a id="__rm_interface_ieee_802_3_phy.html:ieee_802_3_phy_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><pre class="jdocu_small">#define IEEE_802_3_PHY_INTERFACE "ieee_802_3_phy"
SIM_INTERFACE(ieee_802_3_phy) {

        int (*send_frame)(conf_object_t *obj, dbuffer_t *buf, int replace_crc);
        int (*check_tx_bandwidth)(conf_object_t *obj);
#if !defined(PYWRAP)
        void (*add_mac)(conf_object_t *obj, const uint8 *mac);
        void (*del_mac)(conf_object_t *obj, const uint8 *mac);
        void (*add_mac_mask)(conf_object_t *obj, const uint8 *mac,
                             const uint8 *mask);
        void (*del_mac_mask)(conf_object_t *obj, const uint8 *mac,
                             const uint8 *mask);
#endif
        void (*set_promiscous_mode)(conf_object_t *obj, int enable);

};
</pre><p>
</p><p>

   Interface that should be implemented by 802.3 physical layers.
   Deprecated; use <code>ieee_802_3_phy_v2</code> instead.
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Undefined.
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_ieee_802_3_phy_v2.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_ieee_802_3_phy_v2.html:__rm_interface_ieee_802_3_phy_v2">ieee_802_3_phy_v2</a></h1>
<p>

<a id="__rm_interface_ieee_802_3_phy_v2.html:ieee_802_3_phy_v2"></a><a id="__rm_interface_ieee_802_3_phy_v2.html:ieee_802_3_phy_v2_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><pre class="jdocu_small">#define IEEE_802_3_PHY_V2_INTERFACE "ieee_802_3_phy_v2"
SIM_INTERFACE(ieee_802_3_phy_v2) {
        int (*send_frame)(conf_object_t *obj, dbuffer_t *buf, int replace_crc);
        int (*check_tx_bandwidth)(conf_object_t *obj);
        void (*add_mac)(conf_object_t *obj, byte_string_t mac);
        void (*del_mac)(conf_object_t *obj, byte_string_t mac);
        void (*add_mac_mask)(conf_object_t *obj, byte_string_t mac,
                             byte_string_t mask);
        void (*del_mac_mask)(conf_object_t *obj, byte_string_t mac,
                             byte_string_t mask);
        void (*set_promiscous_mode)(conf_object_t *obj, int enable);
};
</pre><p>
</p><p>

   Deprecated; use <code>ieee_802_3_phy_v3</code> instead.
</p><p>
   Interface that should be implemented by 802.3 physical layers.
</p><p>
   The <b><i>send_frame</i></b> function is used by a device to send an
   Ethernet frame. The frame should be a
   <code><a id="__rm_interface_ieee_802_3_phy_v2.html:dbuffer_t">dbuffer_t</a></code> containing a complete Ethernet frame.
   excluding the preamble and SFD, but including the CRC.  The
   <i>replace_crc</i> flag indicates whether the CRC is
   not actually calculated yet. The passed <i>buf</i> should
   not be modified by the called function.
   If the function return 0, the frame was sent to the link; In case
   -1 is returned, there was not enough bandwidth available right now,
   and the frame could not be sent. The PHY should call the
   <b><i>tx_bandwidth_available</i></b> in the <code>ieee_802_3_mac</code>
   interface at the MAC, when the frame can be sent.
</p><p>
   The <b><i>check_tx_bandwidth</i></b> can also be used to check that there
   is bandwidth available, without sending a frame. It returns 0 if there
   is no bandwidth available, and a positive value if the frame can be
   sent right away.
</p><p>
   <b><i>add_mac</i></b>, <b><i>del_mac</i></b> and <b><i>set_promiscous_mode</i></b>
   have the same functionality as the equivalent
   functions in <code>ethernet_link</code> interface. They do nothing
   if the PHY is connected to the new-style links using the
   <code>ethernet_common</code> interface.
</p><p>
   The word "promiscuous" is misspelled in the interface.
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_ieee_802_3_phy_v3.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_ieee_802_3_phy_v3.html:__rm_interface_ieee_802_3_phy_v3">ieee_802_3_phy_v3</a></h1>
<p>

<a id="__rm_interface_ieee_802_3_phy_v3.html:ieee_802_3_phy_v3"></a><a id="__rm_interface_ieee_802_3_phy_v3.html:ieee_802_3_phy_v3_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><pre class="jdocu_small">#define IEEE_802_3_PHY_V3_INTERFACE "ieee_802_3_phy_v3"
SIM_INTERFACE(ieee_802_3_phy_v3) {
        int (*send_frame)(
                conf_object_t *obj, const frags_t *frame, int replace_crc);
        int (*check_tx_bandwidth)(conf_object_t *obj);
};
</pre><p>
</p><p>

   Interface that should be implemented by 802.3 physical layers.
</p><p>
   The <b><i>send_frame</i></b> function is used by a device to send an Ethernet
   frame. The frame should be a <code><a id="__rm_interface_ieee_802_3_phy_v3.html:frags_t">frags_t</a></code> containing a
   complete Ethernet frame, excluding the preamble and SFD, but including space
   for the CRC field. The passed <i>frame</i> must not be modified by
   the called function.
</p><p>
   The <i>replace_crc</i> flag indicates whether the CRC field contents
   can be modified by the implementing object: if <i>replace_crc</i> is
   not set, the implementing object will leave the CRC field untouched; if
   <i>replace_crc</i> is set, the implementing object is free to
   rewrite the CRC field according to the link constraints. Note that in many
   cases, setting <i>replace_crc</i> to true will allow the link to
   assume the CRC field to be matching the frame contents, thus skipping CRC
   calculation and improving simulation performance. <i>replace_crc</i>
   should only be set to false when the device wants to send a frame with a CRC
   field not matching the frame contents.
</p><p>
   If the function return 0, the frame was sent to the link; In case
   -1 is returned, there was not enough bandwidth available right now,
   and the frame could not be sent. The PHY should call the
   <b><i>tx_bandwidth_available</i></b> in the <code>ieee_802_3_mac_v3</code>
   interface at the MAC, when the frame can be sent.
</p><p>
   The <b><i>check_tx_bandwidth</i></b> can also be used to check that there
   is bandwidth available, without sending a frame. It returns 0 if there
   is no bandwidth available, and a positive value if the frame can be
   sent right away.
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_interrupt_ack.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_interrupt_ack.html:__rm_interface_interrupt_ack">interrupt_ack</a></h1>
<p>

<a id="__rm_interface_interrupt_ack.html:interrupt_ack"></a><a id="__rm_interface_interrupt_ack.html:interrupt_ack_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>interrupt_ack_fn_t</code> function is called by an interrupt target
   to ack an interrupt. Returns the interrupt vector.
   <a id="__rm_interface_interrupt_ack.html:interrupt_ack_fn_t"></a>
   
<pre class="jdocu_small">typedef int (*interrupt_ack_fn_t)(conf_object_t *NOTNULL);</pre><p>

   Interface for acked interrupts. The target is typically a cpu that
   later calls the supplied ack function when the interrupt is
   actually taken.
</p><p>
   The <i>ack</i> argument in the <b><i>lower_interrupt</i></b> function
   serves no purpose and should not be used.
</p><p>
   To recover the <i>ack</i> function after a checkpoint restoration,
   read it from the <code>interrupt_cpu</code> interface.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(interrupt_ack) {
        void (*raise_interrupt)(conf_object_t *NOTNULL obj,
                                interrupt_ack_fn_t cb,
                                conf_object_t *ack_obj);
        void (*lower_interrupt)(conf_object_t *NOTNULL obj,
                                interrupt_ack_fn_t cb);
};

#define INTERRUPT_ACK_INTERFACE "interrupt_ack"
</pre><p>
</p><p>

   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_interrupt_cpu.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_interrupt_cpu.html:__rm_interface_interrupt_cpu">interrupt_cpu</a></h1>
<p>

<a id="__rm_interface_interrupt_cpu.html:interrupt_cpu"></a><a id="__rm_interface_interrupt_cpu.html:interrupt_cpu_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Interface that must be implemented by an interrupt source that
   sends interrupts through the <code>x86</code> interface. Used to
   reestablish the ack function when loading a checkpoint.
<p>
   </p><pre class="jdocu_small">SIM_INTERFACE(interrupt_cpu) {
        interrupt_ack_fn_t ack;
};

#define INTERRUPT_CPU_INTERFACE "interrupt_cpu"
</pre><p>
</p><p>

   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_interrupt_subscriber.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_interrupt_subscriber.html:__rm_interface_interrupt_subscriber">interrupt_subscriber</a></h1>
<p>

<a id="__rm_interface_interrupt_subscriber.html:interrupt_subscriber"></a><a id="__rm_interface_interrupt_subscriber.html:interrupt_subscriber_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The target is typically a CPU that reacts to the interrupt.
<p>
   The function <b><i>notify</i></b> notifies when an interrupt has occurred.
</p><p>
   The function <b><i>reset</i></b> is run when the interrupt notifier source is
   reset.
</p><p>
   </p><pre class="jdocu_small">#define INTERRUPT_SUBSCRIBER_INTERFACE "interrupt_subscriber"
SIM_INTERFACE(interrupt_subscriber) {
        void (*notify)(
                conf_object_t *NOTNULL obj,
                apic_delivery_mode_t delivery_mode,
                bool level_assert,
                apic_trigger_mode_t trigger_mode,
                uint8 vector,
                interrupt_source_t source);
        void (*reset)(conf_object_t *NOTNULL obj);
};
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Threaded Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_io_memory.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_io_memory.html:__rm_interface_io_memory">io_memory</a></h1>
<p>

<a id="__rm_interface_io_memory.html:io_memory"></a><a id="__rm_interface_io_memory.html:io_memory_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This interface is implemented by devices that can be mapped into address
   spaces (including port spaces). The <b><i>operation()</i></b> is called when
   the object is accessed through an address space.
<p>
   The <i>obj</i> argument is a pointer to the mapped object and
   <i>map_info</i> contains information about how and where
   the device is mapped into memory. The <i>mem_op</i> argument
   to <b><i>operation()</i></b> contains information about the access.
</p><p>
   The offset into the device mapping for the access is typically
   calculated in the following way:
</p><p>
   <span class="jdocu_small">
   <code>offset = SIM_get_mem_op_physical_address(mem_op)
   - map_info.base + map_info.start</code>
   </span>
</p><p>
   </p><div class="note">
<b>Note:</b>
The <b><i>map()</i></b> function is deprecated and should not be
   used. The function may be called when the object is mapped into an address
   space, but it is not guaranteed that this happens. The function can be left
   unimplemented (NULL).</div>The <code>exception_type_t</code> type, returned by the
   <b><i>operation()</i></b> function may be used to signal errors to
   Simics, but should in most cases be <code>Sim_PE_No_Exception</code>.
   If the device does not support inquiry accesses, it should return
   <code>Sim_PE_Inquiry_Unhandled</code> if <code>mem_op-&gt;inquiry</code> is 1.
<p>
   </p><div class="note">
<b>Note:</b>
This interface is legacy. New code should use the
   <code>transaction</code> interface.</div><a id="__rm_interface_io_memory.html:addr_space_t"></a>
<pre class="jdocu_small">typedef enum {
        Sim_Addr_Space_Conf,
        Sim_Addr_Space_IO,
        Sim_Addr_Space_Memory
} addr_space_t;</pre><p>

   </p><pre class="jdocu_small">SIM_INTERFACE(io_memory) {
        int (*DEPRECATED_FUNC(map))(conf_object_t *NOTNULL obj,
                                    addr_space_t memory_or_io,
                                    map_info_t map_info);
        exception_type_t (*operation)(conf_object_t *NOTNULL obj,
                generic_transaction_t *NOTNULL mem_op,
                map_info_t map_info);
};

#define IO_MEMORY_INTERFACE "io_memory"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_map_demap.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_map_demap.html:__rm_interface_map_demap">map_demap</a></h1>
<p>

<a id="__rm_interface_map_demap.html:map_demap"></a><a id="__rm_interface_map_demap.html:map_demap_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Interface used to dynamically add and remove mappings in a memory space.
   The first argument to all functions, <i>space</i> is the memory
   space to map an object in.
<p>
   The <b><i>map_simple</i></b> function adds a device/port pair to the
   memory map. The added device (port) must implement either the
   <code>ram</code>, <code>rom</code>, <code>io_memory</code>,
   <code>port_space</code>, <code>translator</code>,
   <code>transaction_translator</code>, <code>transaction</code> or
   <code>memory_space</code> interfaces.
   </p><p>
   The <b><i>map_bridge</i></b> function adds a device/port pair to the
   memory map to act as a bridge that translates memory accesses
   before passing them on to another object. The added device (port)
   must implement either the <code>translate</code> interface or the
   <code>bridge</code> interface, and the <i>target</i> and
   <i>target_port</i> parameter specifies the object behind
   the bridge. The target is typically another memory space.
   </p><p>
   The <b><i>unmap</i></b> removes an object from the memory map. The
   <i>dev</i> and <i>port</i> parameters are the same
   as those given to the <b><i>map_simple</i></b> and
   <b><i>map_bridge</i></b> functions.
   </p><p>
   The <b><i>unmap_address</i></b> removes all mappings that map
   <i>object</i> and start at the <i>base</i> address.
   </p><p>
   The <b><i>add_map</i></b>, <b><i>remove_map</i></b>,
   <b><i>add_default</i></b> and <b><i>remove_default</i></b> functions are
   deprecated and should not be used.
   Both <code>base</code> and <code>length</code> of the <code>map_info_t</code> structure
   should be 0 to map a <code>default_target</code>.
</p><p>
   All functions in the <code>map_demap</code> return 1 on success and 0 on
   failure.
</p><p>
   More information about the different kinds of memory space mappings is
   available in Simics Model Builder User's Guide.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(map_demap) {
        /* old-style */
        int (*add_map)(conf_object_t *NOTNULL space,
                       conf_object_t *NOTNULL dev,
                       conf_object_t *target,
                       map_info_t map_info);
        int (*remove_map)(conf_object_t *NOTNULL space,
                          conf_object_t *NOTNULL dev,
                          int function);
        int (*add_default)(conf_object_t *NOTNULL space,
                           conf_object_t *NOTNULL dev,
                           conf_object_t *target,
                           map_info_t map_info);
        void (*remove_default)(conf_object_t *NOTNULL space);

        /* new-style */
        int (*map_simple)(conf_object_t *NOTNULL space,
                          conf_object_t *NOTNULL dev,
                          const char *dev_port,
                          map_info_t map_info);
        int (*map_bridge)(conf_object_t *NOTNULL space,
                          conf_object_t *NOTNULL dev,
                          const char *dev_port,
                          conf_object_t *target,
                          const char *target_port,
                          map_info_t map_info);
        int (*unmap)(conf_object_t *NOTNULL space,
                     conf_object_t *NOTNULL dev,
                     const char *dev_port);
        int (*unmap_address)(conf_object_t *NOTNULL space,
                             conf_object_t *NOTNULL dev,
                             physical_address_t base,
                             const char *dev_port);
};

#define MAP_DEMAP_INTERFACE "map_demap"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_mdio45_bus.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_mdio45_bus.html:__rm_interface_mdio45_bus">mdio45_bus</a></h1>
<p>

<a id="__rm_interface_mdio45_bus.html:mdio45_bus"></a><a id="__rm_interface_mdio45_bus.html:mdio45_bus_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><pre class="jdocu_small">SIM_INTERFACE(mdio45_bus) {
        uint16 (*read_register)(conf_object_t *obj, int phy, int mmd, int reg);
        void   (*write_register)(conf_object_t *obj, int phy, int mdd, int reg,
                                 uint16 value);

};
#define MDIO45_BUS_INTERFACE "mdio45_bus"

</pre><p>
</p><p>

   Interface that should be implemented by classes that either represent
   an MDIO bus, or multi PHY devices implementing the IEEE 802.3 clause 45
   MDIO management interface.
</p><p>
   The <b><i>read_register</i></b> function should return the 16-bit value of
   the specified register. <i>phy</i> specifies the PHY address (0-31),
   <i>mmd</i> specifies the MMD (MDIO manageable device) within the PHY
   (0-31) and <i>reg</i> specifies the register number within the MMD
   (0-65535).
</p><p>
   Devices modeling a single PHY should implement the <code>mdio45_phy</code>
   interface instead.
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_mdio45_phy.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_mdio45_phy.html:__rm_interface_mdio45_phy">mdio45_phy</a></h1>
<p>

<a id="__rm_interface_mdio45_phy.html:mdio45_phy"></a><a id="__rm_interface_mdio45_phy.html:mdio45_phy_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><pre class="jdocu_small">SIM_INTERFACE(mdio45_phy) {
        uint16 (*read_register)(conf_object_t *obj, int mmd, int reg);
        void   (*write_register)(conf_object_t *obj, int mmd, int reg,
                                 uint16 value);

};
#define MDIO45_PHY_INTERFACE "mdio45_phy"

</pre><p>
</p><p>

   Interface that should be implemented by classes representing a single PHY
   implementing the IEEE 802.3 clause 45 MDIO management interface.
</p><p>
   The <b><i>read_register</i></b> function should return the 16-bit value of
   the specified register. <i>mmd</i> specifies the MMD
   (MDIO manageable device) within the PHY (0-31) and <i>reg</i>
   specifies the register number within the MMD (0-65535).
</p><p>
   Devices modeling either an MDIO bus, or multiple PHYs should implement
   the <code>mdio45_bus</code> interface instead.
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_memory_space.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_memory_space.html:__rm_interface_memory_space">memory_space</a></h1>
<p>

<a id="__rm_interface_memory_space.html:memory_space"></a><a id="__rm_interface_memory_space.html:memory_space_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><a id="__rm_interface_memory_space.html:memory_space_interface_t2"></a>
   This interface is implemented by classes that provide linear address
   spaces.
<p>
   Other objects may perform accesses in the address space using
   the <b><i>access</i></b> function or one of the simplified access functions,
   or may ask for mapped objects using <b><i>space_lookup</i></b>. Typical usage
   of this interface would be memory accesses from devices or processors.
</p><p>
   The <b><i>space_lookup</i></b> function would be used to find end-points for a
   memory request. The <i>mop</i> needs to be crafted similarly as for a
   regular read or write operation and would typically be created with
   <b><i>SIM_make_mem_op_read</i></b> or <b><i>SIM_make_mem_op_write</i></b>. The
   return value for <b><i>space_lookup</i></b> is a list of all mappings that
   match the input <i>mop</i>.
</p><p>
   The <b><i>access</i></b> function operates on a generic transaction that would
   typically be created with <b><i>SIM_make_mem_op_read</i></b> or
   <b><i>SIM_make_mem_op_write</i></b>.
   The <b><i>access_simple</i></b> function is similar to <b><i>access</i></b>
   but takes some additional arguments instead of a complete
   <code>generic_transaction_t</code> structure. An inquiry version of this
   function is available as <b><i>access_simple_inq</i></b>. Both these
   functions can perform endian conversion if the buffer pointed to by
   <i>buf</i> contains a value in host endian byte-order. To avoid endian
   conversion, <code>Sim_Endian_Target</code> should be specified as
   <i>endian</i>.
   These two functions are not available from Python.
</p><p>
   The <b><i>read</i></b> and <b><i>write</i></b> methods are primarily intended
   for use in Python. They operate on data encapsulated in attribute values
   which should be of data type; in Python, this corresponds to tuples of
   integers (bytes). These two methods signal errors by raising a frontend
   exception. They can be used to read or write up to 1024 bytes in a single
   call. The return value from <b><i>write</i></b> should be ignored.
</p><p>
   The <b><i>fill</i></b> method fills <i>size</i> bytes starting at
   <i>start</i> with <i>value</i>. It only works on memory,
   and returns the number of bytes actually written before encountering
   something that isn't RAM.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(memory_space) {
        map_list_t *(*space_lookup)(conf_object_t *NOTNULL obj,
                                    generic_transaction_t *NOTNULL mop,
                                    map_info_t mapinfo);
        exception_type_t (*access)(conf_object_t *NOTNULL obj,
                                   generic_transaction_t *NOTNULL mop);
#if !defined(PYWRAP)
        exception_type_t (*access_simple)(conf_object_t *obj,
                                          conf_object_t *initiator,
                                          physical_address_t addr,
                                          uint8 *buf,
                                          physical_address_t len,
                                          read_or_write_t type,
                                          endianness_t endian);
        exception_type_t (*access_simple_inq)(conf_object_t *obj,
                                              conf_object_t *initiator,
                                              physical_address_t addr,
                                              uint8 *buf,
                                              physical_address_t len,
                                              read_or_write_t type,
                                              endianness_t endian);
#endif /* !PYWRAP */
        attr_value_t (*read)(conf_object_t *NOTNULL obj,
                             conf_object_t *initiator,
                             physical_address_t addr,
                             int length,
                             int inquiry);
        exception_type_t (*write)(conf_object_t *NOTNULL obj,
                                  conf_object_t *initiator,
                                  physical_address_t addr,
                                  attr_value_t data,
                                  int inquiry);
        cycles_t (*DEPRECATED_FUNC(timing_model_operate))(
                conf_object_t *NOTNULL space,
                generic_transaction_t *NOTNULL mop);
        uint64 (*fill)(conf_object_t *NOTNULL obj,
                       physical_address_t start, uint64 size, uint8 value,
                       bool inquiry);
};

#define MEMORY_SPACE_INTERFACE "memory_space"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_microwire.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_microwire.html:__rm_interface_microwire">microwire</a></h1>
<p>

<a id="__rm_interface_microwire.html:microwire"></a><a id="__rm_interface_microwire.html:microwire_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This interface is used to communicate with a 3-wire
   (microwire) serial EEPROM device, for example, the 93Cxx
   series, via its pins. To set the values of the CS, SK, and
   DI pins, use the <b><i>set_cs()</i></b>, <b><i>set_sk()</i></b>,
   and <b><i>set_di()</i></b> functions, respectively. To read the
   value output on the DO pin, use the <b><i>get_do()</i></b>
   function. Zero represents low signal and non-zero high
   signal. The <b><i>read_word()</i></b> and <b><i>write_word()</i></b>
   functions are provided to shortcut high-level operations.
   They operate on 8-bit or 16-bit entities depending on the
   width of the eeprom.
<p>
   </p><pre class="jdocu_small">#define MICROWIRE_INTERFACE "microwire"

SIM_INTERFACE(microwire) {
        void (*set_cs)(conf_object_t *obj, int cs);
        void (*set_sk)(conf_object_t *obj, int sk);
        void (*set_di)(conf_object_t *obj, int di);
        int  (*get_do)(conf_object_t *obj);
        uint16 (*read_word)(conf_object_t *obj, int offset);
        void (*write_word)(conf_object_t *obj, int offset, uint16 value);
};

</pre><p>
</p><p>

   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_mii.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_mii.html:__rm_interface_mii">mii</a></h1>
<p>

<a id="__rm_interface_mii.html:mii"></a><a id="__rm_interface_mii.html:mii_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><pre class="jdocu_small">SIM_INTERFACE(mii) {
        int    (*serial_access)(conf_object_t *obj, int data_in, int clock);
        uint16 (*read_register)(conf_object_t *obj, int index);
        void   (*write_register)(conf_object_t *obj, int index, uint16 value);
};
#define MII_INTERFACE "mii"

</pre><p>
</p><p>

   Obsolete interface that is implemented by some PHY's that support the MII
   management interface.
</p><p>
   It has the same methods as the <code>mii_management</code> interface,
   but does not pass along the PHY number.
</p><p>
   To support low-level bitwise accesses via MDIO and MDC pins, the
   function <b><i>serial_access</i></b> can be used. It is recommended to
   leave this function unimplemented and let an instance of
   <b>mii-management-bus</b> convert the low-level bit operations
   to higher level read/write register calls.
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_mii_management.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_mii_management.html:__rm_interface_mii_management">mii_management</a></h1>
<p>

<a id="__rm_interface_mii_management.html:mii_management"></a><a id="__rm_interface_mii_management.html:mii_management_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><pre class="jdocu_small">SIM_INTERFACE(mii_management) {
        int    (*serial_access)(conf_object_t *obj, int data_in, int clock);
        uint16 (*read_register)(conf_object_t *obj, int phy, int reg);
        void   (*write_register)(conf_object_t *obj, int phy, int reg,
                                 uint16 value);
};
#define MII_MANAGEMENT_INTERFACE "mii_management"

</pre><p>
</p><p>

   Interface that should be implemented by classes that represents one
   or multiple PHY's that have MII management interfaces.
</p><p>
   The <b><i>read_register</i></b> function should return the 16-bit value
   of the specified register. There are 32 registers numbered 0-31. The
   phy argument indicates the PHY number (0-31). Classes that represents
   one PHY can ignore this argument.
   The <b><i>write_register</i></b> function is called when a register is
   written.
</p><p>
   To support low-level bitwise accesses via MDIO and MDC pins, the
   function <b><i>serial_access</i></b> can be used. It is recommended to
   leave this function unimplemented and let an instance of
   <b>mii-management-bus</b> convert the low-level bit operations
   to higher level read/write register calls.
   The <b><i>serial_access</i></b> function takes as argument the MDIO and MDC
   pin levels on the master, and return the MDIO pin from the slave. Note
   that <b>mii-management-bus</b> also have <code>signal</code>
   interfaces for these pins.
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_mips.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_mips.html:__rm_interface_mips">mips</a></h1>
<p>

<a id="__rm_interface_mips.html:mips"></a><a id="__rm_interface_mips.html:mips_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This interface is implemented by MIPS processors to provide various
   functionality that is specific for this class of processors.
<p>
   There are currently no MIPS-specific functions.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(mips) {
        int dummy;
};

#define MIPS_INTERFACE "mips"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Not applicable.
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_mips_cache_instruction.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_mips_cache_instruction.html:__rm_interface_mips_cache_instruction">mips_cache_instruction</a></h1>
<p>

<a id="__rm_interface_mips_cache_instruction.html:mips_cache_instruction"></a><a id="__rm_interface_mips_cache_instruction.html:mips_cache_instruction_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This <code>mips_cache_instruction</code> interface is used when
   side-effects are wanted when cache instructions are run.
<p>
   The <b><i>cache_instruction</i></b> function is called whenever the
   cache instruction is run, and the parameters <i>operation</i>
   and <i>vaddr</i> are taken directly from the instruction.
</p><p>
   The exact meaning of <i>operation</i> is processor-dependent.
</p><p>
   A non-zero return value indicates that an exception should be raised on the
   MIPS core), whereas a zero value means no exception.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(mips_cache_instruction) {
        int (*cache_instruction)(conf_object_t *NOTNULL self,
                                 conf_object_t *NOTNULL cpu,
                                 uint32 op, logical_address_t vaddr);
};
#define MIPS_CACHE_INSTRUCTION_INTERFACE "mips_cache_instruction"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_mips_coprocessor.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_mips_coprocessor.html:__rm_interface_mips_coprocessor">mips_coprocessor</a></h1>
<p>

<a id="__rm_interface_mips_coprocessor.html:mips_coprocessor"></a><a id="__rm_interface_mips_coprocessor.html:mips_coprocessor_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This <code>mips_coprocessor</code> interface is implemented by
   MIPS coprocessors. The MIPS processor cores use this interface to
   access coprocessor registers.
<p>
   The <b><i>read_register</i></b> function returns a 64-bit value from a
   coprocessor register. The return value should be zero extended if
   the coprocessor register is less than 64-bits.
</p><p>
   The <b><i>write_register</i></b> function writes a 64-bit value to a
   coprocessor register. The target register can be smaller than
   64-bits.
</p><p>
   The <i>thread_id</i> is the thread id for the calling
   processor core. The <i>reg</i> and <i>sel</i>
   selects the coprocessor register to read or write. For instructions
   that make use of the whole implementation-defined bits 15:0, that
   field is passed as <i>reg</i> and <i>sel</i> is zero.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(mips_coprocessor) {
        uint64 (*read_register)(conf_object_t *NOTNULL obj,
                                uint32 thread_id,
                                uint32 reg,
                                uint32 sel);
        void (*write_register)(conf_object_t *NOTNULL obj,
                               uint32 thread_id,
                               uint64 value,
                               uint32 reg,
                               uint32 sel);
};
#define MIPS_COPROCESSOR_INTERFACE "mips_coprocessor"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_mips_eic.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_mips_eic.html:__rm_interface_mips_eic">mips_eic</a></h1>
<p>

<a id="__rm_interface_mips_eic.html:mips_eic"></a><a id="__rm_interface_mips_eic.html:mips_eic_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>mips_eic</code> must be
   implemented by devices that acts as MIPS External Interrupt
   Controllers. After the external IRQ signal in the CPU has been raised, the
   CPU will query the registered External Interrupt Controller for information
   about the current interrupt request. When the CPU starts the interrupt
   servicing it calls the <b><i>handled</i></b> function.
<p>
   The <b><i>cpu_pending_irqs</i></b> function sends current cause register which
   stores the pending irqs for software irq, timer irq, fdci irq and pci
   irq. The external irq controller should take this information to do irq
   arbitration.
</p><p>
   <b><i>requested_ipl</i></b> should used to return the
   requested interrupt priority level.
</p><p>
   There are two options for vector offset calculation. Option 1, EIC device
   returns a vector number. This vector number will be used together with
   intctl.vs to calculate the offset. Option 2, EIC returns the offset
   directly. When using option 1, the <b><i>requested_vect_num</i></b> function
   should be used to return the vector number. When using option 2, the
   <b><i>requested_offset</i></b> should be used to return the offset of the
   requested interrupt.
</p><p>
   The <b><i>reg_set</i></b> should return the shadow register set number.
   </p><pre class="jdocu_small">SIM_INTERFACE(mips_eic) {
        void (*cpu_pending_irqs)(conf_object_t *NOTNULL obj, uint32 cause);
        uint32 (*requested_ipl)(conf_object_t *NOTNULL obj);
        uint32 (*requested_offset)(conf_object_t *NOTNULL obj);
        uint32 (*requested_vect_num)(conf_object_t *NOTNULL obj);
        uint32 (*reg_set)(conf_object_t *NOTNULL obj);
        void (*handled)(conf_object_t *NOTNULL obj);
};

#define MIPS_EIC_INTERFACE "mips_eic"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_mips_exception_query.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_mips_exception_query.html:__rm_interface_mips_exception_query">mips_exception_query</a></h1>
<p>

<a id="__rm_interface_mips_exception_query.html:mips_exception_query"></a><a id="__rm_interface_mips_exception_query.html:mips_exception_query_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Used to query information of an exception from a
   <b><i>cpu_exception_cb_t</i></b> callback.
   <pre class="jdocu_small">SIM_INTERFACE(mips_exception_query) {
        logical_address_t (*return_pc)(conf_object_t *cpu,
                                       exception_handle_t *handle);
};

#define MIPS_EXCEPTION_QUERY_INTERFACE "mips_exception_query"
</pre><p>
</p><p>
   
   <b><i>pc</i></b> is used to get the address of the faulting instruction.
   <b><i>return_pc</i></b> is used to get the return address for the exception.
   <b><i>number</i></b> is used to get the exception number.
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_mips_ite.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_mips_ite.html:__rm_interface_mips_ite">mips_ite</a></h1>
<p>

<a id="__rm_interface_mips_ite.html:mips_ite"></a><a id="__rm_interface_mips_ite.html:mips_ite_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This <code>mips_ite</code> interface is implemented by the CPU, for
   communicating with the MIPS Inter-Thread Communication Unit.
<p>
   The <b><i>set_dtag_lo</i></b> function sets the DTagLo SPR.
</p><p>
   The <b><i>get_dtag_lo</i></b> function returns the value of the DTagLo SPR.
</p><p>
   The <b><i>get_errctl</i></b> function returns the value of the ErrCtl SPR.
</p><p>
   The <b><i>block_tc</i></b> function marks the current TC as blocked on gating
   storage and swaps in another TC.
</p><p>
   The <b><i>gated_exception</i></b> function throws an immediate exception.
</p><p>
   The <b><i>current_tc_num</i></b> function returns the currently running TC
   number on the VPE.
</p><p>
   The <b><i>unblock_tc</i></b> function unblocks the specified TC if it is
   currently blocked on gating storage.
</p><p>
   The <b><i>is_big_endian</i></b> function indicates if the CPU expects
   big endian memory storage.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(mips_ite) {
        void (*set_dtag_lo)(conf_object_t *NOTNULL obj, uint32 value);
        uint32 (*get_dtag_lo)(conf_object_t *NOTNULL obj);
        uint32 (*get_errctl)(conf_object_t *NOTNULL obj);
        void (*block_tc)(conf_object_t *NOTNULL obj);
        void (*gated_exception)(conf_object_t *NOTNULL obj);
        int (*current_tc_num)(conf_object_t *NOTNULL obj);
        void (*unblock_tc)(conf_object_t *NOTNULL obj, int tc_num);
        bool (*is_big_endian)(conf_object_t *NOTNULL obj);
};
#define MIPS_ITE_INTERFACE "mips_ite"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_multi_level_signal.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_multi_level_signal.html:__rm_interface_multi_level_signal">multi_level_signal</a></h1>
<p>

<a id="__rm_interface_multi_level_signal.html:multi_level_signal"></a><a id="__rm_interface_multi_level_signal.html:multi_level_signal_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Interface to model a signal with multiple levels, such as an analog signal.
<p>
   </p><div class="note">
<b>Note:</b>
Obsoleted by the <code>uint64_state</code> interface.</div>The signal initiator (i.e. the object producing the signal) should call
   <b><i>signal_level_change</i></b> when the level changes. Multiple calls with
   the same level should be accepted by the signal receiver.
<p>
   The optional function <b><i>signal_current_level</i></b> can be called when
   a new target is connected.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(multi_level_signal) {
        void (*signal_level_change)(conf_object_t *NOTNULL obj, uint64 level);
        void (*signal_current_level)(conf_object_t *NOTNULL obj, uint64 level);
};
#define MULTI_LEVEL_SIGNAL_INTERFACE "multi_level_signal"
</pre><p>
</p><p>

   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_nand_flash.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_nand_flash.html:__rm_interface_nand_flash">nand_flash</a></h1>
<p>

<a id="__rm_interface_nand_flash.html:nand_flash"></a><a id="__rm_interface_nand_flash.html:nand_flash_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>nand_flash</code> interface is used to perform read and write
   accesses and control some pins on NAND Flash devices.
<p>
   The <b><i>read_access()</i></b> and <b><i>write_access()</i></b> functions perform
   read and write accesses.
</p><p>
   The <b><i>set_command_latch_enable()</i></b>,
   <b><i>set_address_latch_enable()</i></b>, <b><i>set_write_protect()</i></b> and
   <b><i>set_spare_area_enable()</i></b> functions set the input level of the pins
   with the same names. 0 represents low input and 1 represents high input.
</p><p>
   The chip enable and ready/busy pins are not modelled. The NAND Flash device
   assumes that chip enable is always asserted, and the device is never busy.
</p><p>
   </p><pre class="jdocu_small">#define NAND_FLASH_INTERFACE "nand_flash"

SIM_INTERFACE(nand_flash) {
        uint16 (*read_access)(conf_object_t *obj);
        void (*write_access)(conf_object_t *obj, uint16 value);

        void (*set_command_latch_enable)(conf_object_t *obj, int value);
        void (*set_address_latch_enable)(conf_object_t *obj, int value);
        void (*set_write_protect)(conf_object_t *obj, int value);
        void (*set_spare_area_enable)(conf_object_t *obj, int value);
};

</pre><p>
</p><p>

   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_network_breakpoint.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_network_breakpoint.html:__rm_interface_network_breakpoint">network_breakpoint</a></h1>
<p>

<a id="__rm_interface_network_breakpoint.html:network_breakpoint"></a><a id="__rm_interface_network_breakpoint.html:network_breakpoint_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>network_breakpoint</code> interface is implemented by
   objects that handles ethernet links to have breakpoints.
   The <b><i>add</i></b> is used to set a breakpoint on a given src mac
   address or gived dst mac address or by ether type. If they are combined
   then the criteria is that all given has to match.
   The <b><i>remove</i></b> is used to remove an existing
   breakpoint.
   <pre class="jdocu_small">SIM_INTERFACE(network_breakpoint) {
        int64 (*add)(conf_object_t *NOTNULL obj, bytes_t src_mac_addr,
                     bytes_t dst_mac_addr, int ether_type,
                     break_net_cb_t cb, bool once, int64 bp_id);
        void (*remove)(conf_object_t *NOTNULL obj, int64 bp_id);
};
#define NETWORK_BREAKPOINT_INTERFACE "network_breakpoint"
</pre><p>
 
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Global Context
   for all methods
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_nios.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_nios.html:__rm_interface_nios">nios</a></h1>
<p>

<a id="__rm_interface_nios.html:nios"></a><a id="__rm_interface_nios.html:nios_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This interface is implemented by Intel
   Nios processors to provide various functionality that is specific for
   this class of processors.
<p>
   There are currently no Nios-specific functions.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(nios) {
        int dummy;
};

#define NIOS_INTERFACE "nios"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Not applicable.
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_nios_cache.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_nios_cache.html:__rm_interface_nios_cache">nios_cache</a></h1>
<p>

<a id="__rm_interface_nios_cache.html:nios_cache"></a><a id="__rm_interface_nios_cache.html:nios_cache_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This <code>nios_cache</code> interface is used when
   the side-effects are required for cache instructions.
<p>
   Each function is called when the corresponding instruction is executed. See
   Nios II processor reference guide, section 8, for further
   information.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(nios_cache) {
        void (*flushd)(conf_object_t *NOTNULL self, logical_address_t addr);
        void (*flushda)(conf_object_t *NOTNULL self, logical_address_t addr);
        void (*flushi)(conf_object_t *NOTNULL self, logical_address_t addr);
        void (*flushp)(conf_object_t *NOTNULL self);
        void (*initd)(conf_object_t *NOTNULL self, logical_address_t addr);
        void (*initda)(conf_object_t *NOTNULL self, logical_address_t addr);
        void (*initi)(conf_object_t *NOTNULL self, logical_address_t addr);
        void (*sync)(conf_object_t *NOTNULL self);
};
#define NIOS_CACHE_INTERFACE "nios_cache"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_nios_custom.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_nios_custom.html:__rm_interface_nios_custom">nios_custom</a></h1>
<p>

<a id="__rm_interface_nios_custom.html:nios_custom"></a><a id="__rm_interface_nios_custom.html:nios_custom_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This <code>nios_custom</code> interface is used when
   the custom instruction needs to be used.
<p>
   The <b><i>custom</i></b> function is called whenever the
   custom instruction is executed.
</p><p>
   See Nios II processor reference guide page 8-35 for further
   information about the parameters.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(nios_custom) {
        uint32 (*custom)(conf_object_t *NOTNULL self, uint32 n,
                         uint32 a, uint32 b, uint32 c, uint32 rA, uint32 rB,
                         bool readra, bool readrb, bool writerc);
};
#define NIOS_CUSTOM_INTERFACE "nios_custom"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_nios_eic.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_nios_eic.html:__rm_interface_nios_eic">nios_eic</a></h1>
<p>

<a id="__rm_interface_nios_eic.html:nios_eic"></a><a id="__rm_interface_nios_eic.html:nios_eic_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>nios_eic</code> must be implemented by devices that acts as
   Nios
   External Interrupt Controllers. After the external IRQ signal in the CPU
   has been raised, the CPU will query the registered External Interrupt
   Controller for information about the current interrupt request. 
   When the CPU calls the <b><i>handled</i></b> function, it has finished 
   processing the request.
<p>
   The <b><i>handler</i></b> function should return the logical address of 
   the interrupt handler.
</p><p>
   The <b><i>level</i></b> should return the interrupt level.
</p><p>
   The <b><i>reg_set</i></b> should return the shadow register set number.
</p><p>
   The <b><i>nmi</i></b> should indicate if this is a non-maskable interrupt.
  </p><p>
   See Nios II processor reference guide page 3-41 for further
   information.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(nios_eic) {
        logical_address_t (*handler)(conf_object_t *NOTNULL obj);
        uint32 (*level)(conf_object_t *NOTNULL obj);
        uint32 (*reg_set)(conf_object_t *NOTNULL obj);
        bool (*nmi)(conf_object_t *NOTNULL obj);

        void (*handled)(conf_object_t *NOTNULL obj);
};

#define NIOS_EIC_INTERFACE "nios_eic"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_pci_bridge.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_pci_bridge.html:__rm_interface_pci_bridge">pci_bridge</a></h1>
<p>

<a id="__rm_interface_pci_bridge.html:pci_bridge"></a><a id="__rm_interface_pci_bridge.html:pci_bridge_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This interface is implemented by all PCI bridges.
   For interrupts, the initiating device is specified with a pci-bus object and
   PCI device number pair, and the pin represents PCI interrupt lines (A, B, C,
   or D) as numbers in the range of 0 to 3.
<p>
   </p><pre class="jdocu_small">SIM_INTERFACE(pci_bridge) {
        void (*system_error)(conf_object_t *obj);
        void (*raise_interrupt)(conf_object_t *obj, conf_object_t *pci_bus,
                                int device, int pin);
        void (*lower_interrupt)(conf_object_t *obj, conf_object_t *pci_bus,
                                int device, int pin);
};

#define PCI_BRIDGE_INTERFACE		"pci_bridge"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_pci_bus.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_pci_bus.html:__rm_interface_pci_bus">pci_bus</a></h1>
<p>

<a id="__rm_interface_pci_bus.html:pci_bus"></a><a id="__rm_interface_pci_bus.html:pci_bus_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This interface is implemented by all PCI buses and its functions are
   accessed by PCI devices. For further details, see <em>Model Builder
   User's Guide</em>, chapter "Modeling PCI Devices".
<p>
   </p><div class="note">
<b>Note:</b>
The <i>memory_access</i> function is deprecated and must not be
   called (as it is not implemented by Simics pci-bus object). The
   <i>interrupt_acknowledge</i>, <i>special_cycle</i>,
   <i>add_default</i> and <i>remove_default</i> functions are also
   deprecated, but they are still implemented by Simics pci-bus and thus
   callable.</div><pre class="jdocu_small">SIM_INTERFACE(pci_bus) {
        /* Deprecated; memory_access */
        exception_type_t (*memory_access)(
                conf_object_t *obj, generic_transaction_t *NOTNULL mem_op);
        void (*raise_interrupt)(conf_object_t *obj, conf_object_t *NOTNULL dev,
                                int pin);
        void (*lower_interrupt)(conf_object_t *obj, conf_object_t *NOTNULL dev,
                                int pin);
        /* Deprecated; interrupt_acknowledge */
        int (*interrupt_acknowledge)(conf_object_t *obj);
        int (*add_map)(conf_object_t *obj, conf_object_t *dev,
                       addr_space_t space, conf_object_t *target,
                       map_info_t info);
        int (*remove_map)(conf_object_t *obj, conf_object_t *dev,
                          addr_space_t space, int function);
	void (*set_bus_number)(conf_object_t *obj, int bus_id);
	void (*set_sub_bus_number)(conf_object_t *obj, int bus_id);
        /* Deprecated; add_default, remove_default */
        void (*add_default)(conf_object_t *obj, conf_object_t *dev,
                            addr_space_t space, conf_object_t *target,
                            map_info_t info);
        void (*remove_default)(conf_object_t *obj, addr_space_t space);
        void (*bus_reset)(conf_object_t *obj);
        /* Deprecated; special_cycle */
        void (*special_cycle)(conf_object_t *obj, uint32 value);
        void (*system_error)(conf_object_t *obj);

        int (*get_bus_address)(conf_object_t *obj, conf_object_t *NOTNULL dev);

        void (*set_device_status)(conf_object_t *obj, int device, int function,
                                  int enabled);

        /* Memory spaces */
        conf_object_t *(*configuration_space)(conf_object_t *obj);
        conf_object_t *(*io_space)(conf_object_t *obj);
        conf_object_t *(*memory_space)(conf_object_t *obj);
};
#define PCI_BUS_INTERFACE		"pci_bus"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_pci_device.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_pci_device.html:__rm_interface_pci_device">pci_device</a></h1>
<p>

<a id="__rm_interface_pci_device.html:pci_device"></a><a id="__rm_interface_pci_device.html:pci_device_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This interface is implemented by all PCI devices (including bridges).
<p>
   </p><div class="note">
<b>Note:</b>
The <i>interrupt_acknowledge</i> and <i>special_cycle</i>
   functions are deprecated. The functions can be left
   unimplemented (NULL).</div><pre class="jdocu_small">SIM_INTERFACE(pci_device) {
        void (*bus_reset)(conf_object_t *obj);

        /* Deprecated; interrupt_acknowledge, special_cycle */
        int (*DEPRECATED_FUNC(interrupt_acknowledge))(conf_object_t *obj);
        void (*DEPRECATED_FUNC(special_cycle))(conf_object_t *obj,
                                               uint32 value);

        /* System Error */
        void (*system_error)(conf_object_t *obj);

        /* peer-to-peer interrupt mechanism */
        void (*interrupt_raised)(conf_object_t *obj, int pin);
        void (*interrupt_lowered)(conf_object_t *obj, int pin);
};

#define PCI_DEVICE_INTERFACE "pci_device"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_pci_downstream.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_pci_downstream.html:__rm_interface_pci_downstream">pci_downstream</a></h1>
<p>

<a id="__rm_interface_pci_downstream.html:pci_downstream"></a><a id="__rm_interface_pci_downstream.html:pci_downstream_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>pci_downstream</code> interface is implemented by
   PCI(e) buses to handle downstream transactions.
   <pre class="jdocu_small">SIM_INTERFACE(pci_downstream) {
        exception_type_t (*operation)(conf_object_t *obj,
                                      generic_transaction_t *mem_op,
                                      addr_space_t space);
};
#define PCI_DOWNSTREAM_INTERFACE   "pci_downstream"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_pci_express.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_pci_express.html:__rm_interface_pci_express">pci_express</a></h1>
<p>

<a id="__rm_interface_pci_express.html:pci_express"></a><a id="__rm_interface_pci_express.html:pci_express_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Deprecated as part of the old PCIe library. Replaced by the new PCIe library.
<p>
   </p><div class="note">
<b>Note:</b>
This interface is deprecated. The <code>transaction</code> interface
   implemented by the pcie-bus (upstream and downstream ports) can be used to
   send any type of message with any type of routing by adding  related
   <i>pcie_type</i> and <i>pcie_msg_route</i> ATOMs to
   the transaction.</div>This interface can be implemented by any PCI Express device, switch or
   endpoint. It is also implemented by the pci-bus, which will pass it on
   to the other end; e.g. if the endpoint sends a message, the pci-bus will
   pass it on to the bridge (downport), and if the downport sends it, it will
   be broadcasted to all devices on the bus.
<p>
   Please note that message routing is not supported. The implications of this
   limitation is that a switch does not know if the message is intended for the
   switch itself or for some device connected to it. In addition, since the bus
   does not replace the <i>src</i> parameter when forwarding the
   message, and the bus does not support port mappings, it is impossible for a
   bus-to-bus bridge (up-port/down-port) to know from which bus the message
   originates making it impossible to forward the message to the other side.
</p><p>
   Another way of looking at this limitation is to say that the only message
   routing currently supported is the implicit routing that terminates at the
   receiver (Type[2:0] = 0b100), so bus-to-bus bridges should not try to
   forward the message to the other side.
</p><p>
   <i>src</i> is the object sending the message. <i>type</i> is
   one of:
</p><p>
   
   
</p><pre class="jdocu_small">typedef enum {
        /* Address Translation */
        PCIE_ATS_Invalidate = 0x01,
        PCIE_ATS_Invalidate_Completion = 0x02,
        PCIE_PRS_Request    = 0x04,
        PCIE_PRS_Response   = 0x05,

        PCIE_Latency_Tolerance_Reporting = 0x10,
        PCIE_Optimized_Buffer_Flush_Fill = 0x12,

        /* INTx emulation */
        PCIE_Msg_Assert_INTA       = 0x20,
        PCIE_Msg_Assert_INTB       = 0x21,
        PCIE_Msg_Assert_INTC       = 0x22,
        PCIE_Msg_Assert_INTD       = 0x23,
        PCIE_Msg_Deassert_INTA     = 0x24,
        PCIE_Msg_Deassert_INTB     = 0x25,
        PCIE_Msg_Deassert_INTC     = 0x26,
        PCIE_Msg_Deassert_INTD     = 0x27,

        /* Power Management */
        PCIE_PM_Active_State_Nak   = 0x14,
        PCIE_PM_PME                = 0x18,
        PCIE_PM_Turn_Off           = 0x19,
        PCIE_PM_PME_TO_Ack         = 0x1B,

        /* Error Messages */
        PCIE_ERR_COR               = 0x30,
        PCIE_ERR_NONFATAL          = 0x31,
        PCIE_ERR_FATAL             = 0x33,

        /* Locked Transaction */
        PCIE_Unlock                = 0x00,

        /* Slot Power Limit */
        PCIE_Set_Slot_Power_Limit  = 0x50,

        PCIE_Precision_Time_Measurement = 0x52,

        /* Hot Plug Messages */
        PCIE_HP_Power_Indicator_On        = 0x45,
        PCIE_HP_Power_Indicator_Blink     = 0x47,
        PCIE_HP_Power_Indicator_Off       = 0x44,
        PCIE_HP_Attention_Button_Pressed  = 0x48,
        PCIE_HP_Attention_Indicator_On    = 0x41,
        PCIE_HP_Attention_Indicator_Blink = 0x43,
        PCIE_HP_Attention_Indicator_Off   = 0x40,

        PCIE_Vendor_Defined_Type_0 = 0x7e,
        PCIE_Vendor_Defined_Type_1 = 0x7f,

        PCIE_Locked_Transaction    = 0x00,  // legacy name for PCIE_Unlock

        /* Data Link Layer (virtual) Messages

           NOTE: these messages only exist on Simics simulator, as they are
           normally part of the Data Link Layer which is below the level of
           abstraction for Simics PCIe models

           According to PCIe rev 2.0, when a target receives a message that it
           does not recognize or support, except for the "Vendor Defined Type
           1" message, it should treat the request as an "Unsupported Request"
           and report it accordingly (see sec 2.3.1 for reference).
    
           Hence models that comply with rev 2.0 must be updated to either
           1) handle these messages or 2) ignore these messages.

           Ideally we would like to use a new pcie_link interface to transmit
           this information - see bug 17849 for more info. */
        PCIE_DLL_Link_Down = -1,
        PCIE_DLL_Link_Up = -2,
} pcie_message_type_t;</pre><p>

</p><p>
   The contents of <i>payload</i> depends on <i>type</i>.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(pci_express) {
        int (*send_message)(conf_object_t *dst, conf_object_t *src,
                            pcie_message_type_t type, byte_string_t payload);
};
#define PCI_EXPRESS_INTERFACE "pci_express"
</pre><p>
</p><p>

   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_pci_express_hotplug.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_pci_express_hotplug.html:__rm_interface_pci_express_hotplug">pci_express_hotplug</a></h1>
<p>

<a id="__rm_interface_pci_express_hotplug.html:pci_express_hotplug"></a><a id="__rm_interface_pci_express_hotplug.html:pci_express_hotplug_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Deprecated as part of the old PCIe library. Replaced by the new PCIe library.
<p>
   This interface is intended for PCI Express switches that need to monitor the
   status of their downports. The interface should be implemented by the bridge
   object.
</p><p>
   <b><i>presence_change</i></b> is called from the pci-bus when an device is
   added or removed from the bus. <i>is_present</i> is set to 1 when
   the device is added, and 0 when it is removed.
</p><p>
   <b><i>inject_power_fault</i></b> can be used to simulate a power fault on
   the downport. It is never called automatically.
</p><p>
   <b><i>press_attention_button</i></b> can be called to simulate the attention
   button being pressed. The switch can respond to this by e.g. raising
   an interrupt and setting appropriate status bits. It is never called
   automatically.
</p><p>
   <b><i>set_mrl_state</i></b> is similar to <b><i>attention_button_press</i></b>
   but controls the Manually operated Retention Latch. Set
   <i>locked</i> to 1 to simulate it being locked/closed, and 0 to
   simulate it being unlocked/opened.
</p><p>
   Finally, <b><i>get_mrl_state</i></b> returns the state of the Manually
   operated Retention Latch.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(pci_express_hotplug) {
        /* This is sent when a device is added or removed from the bus. */
        void (*presence_change)(conf_object_t *dst, conf_object_t *NOTNULL src,
                                int is_present);
        void (*inject_power_fault)(conf_object_t *obj);
        void (*press_attention_button)(conf_object_t *obj);
        void (*set_mrl_state)(conf_object_t *obj, int locked);
        int  (*get_mrl_state)(conf_object_t *obj);
};
#define PCI_EXPRESS_HOTPLUG_INTERFACE "pci_express_hotplug"
</pre><p>
</p><p>

   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_pci_interrupt.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_pci_interrupt.html:__rm_interface_pci_interrupt">pci_interrupt</a></h1>
<p>

<a id="__rm_interface_pci_interrupt.html:pci_interrupt"></a><a id="__rm_interface_pci_interrupt.html:pci_interrupt_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This interface should only be used when a device other than the bridge
   handles PCI interrupts on the PCI bus. The initiating device is specified
   with a PCI device number, and the pin represents PCI interrupt lines
   (A, B, C, or D) as numbers in the range of 0 to 3.
<p>
   </p><pre class="jdocu_small">SIM_INTERFACE(pci_interrupt) {
        void (*raise_interrupt)(conf_object_t *obj, conf_object_t *pci_bus,
                                int device, int pin);
        void (*lower_interrupt)(conf_object_t *obj, conf_object_t *pci_bus,
                                int device, int pin);
};

#define PCI_INTERRUPT_INTERFACE		"pci_interrupt"
</pre><p>
</p><p>

   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_pci_multi_function_device.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_pci_multi_function_device.html:__rm_interface_pci_multi_function_device">pci_multi_function_device</a></h1>
<p>

<a id="__rm_interface_pci_multi_function_device.html:pci_multi_function_device"></a><a id="__rm_interface_pci_multi_function_device.html:pci_multi_function_device_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This interface is intended for PCI devices that want to have multiple
   functions implemented within the same device instance, as compared to the
   scheme of having each PCI function defined in a separate instance.
<p>
   <b><i>supported_functions</i></b> is called from the pci-bus to find out how
   many functions are supported by this device. The expected return value is a
   list of tuples, where each tuple contains the PCI function number followed
   by one or two elements controlling what to map into the bus'
   config-space. The list can consist of any number of tuples using any and all
   of the supported formats:
</p><p>
   </p><ul>

   <li>(fun, str); maps the named port-interface on the object implementing the
   current interface. For example, the name of the bank that provides the
   configuration registers for this function.</li>

   <li>(fun, obj); maps the object expecting configuration access is handled by
   io_memory implemented directly on the object.</li>

   <li>(fun, obj, str); maps the named port-interface on the provided
   object.</li>

   </ul>
<p>
   The list can contain a mix of formats, each entry corresponds to a unique
   mapping of a function.
</p><p>
   For ARI enabled PCIe devices, the device number is assumed to be zero thus
   it is an error to try to claim a function number greater than seven while
   connecting with a device number greater than zero.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(pci_multi_function_device) {
        attr_value_t (*supported_functions)(conf_object_t *obj);
};
#define PCI_MULTI_FUNCTION_DEVICE_INTERFACE "pci_multi_function_device"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Global Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_pci_upstream.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_pci_upstream.html:__rm_interface_pci_upstream">pci_upstream</a></h1>
<p>

<a id="__rm_interface_pci_upstream.html:pci_upstream"></a><a id="__rm_interface_pci_upstream.html:pci_upstream_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This interface is implemented by PCI(e) buses and
   bridges to handle upstream transactions (primarily
   memory or IO).
<p>
   A PCI(e) bus typically forwards all transactions to
   an upstream bridge.
</p><p>
   PCI(e) bridges either forward a transaction to its primary
   side bus or initiate a downstream operation
   on the secondary bus using the <code>pci_downstream</code>
   interface.
</p><p>
   It should be noted that a PCI bridge using
   this interface will see peer-to-peer traffic
   from its secondary interface; this is a difference
   compared to real hardware where such transactions
   never involve the bridge. To behave like real
   hardware, PCI bridges should send all peer-to-peer
   traffic downstream.
   </p><pre class="jdocu_small">SIM_INTERFACE(pci_upstream) {
        exception_type_t (*operation)(conf_object_t *obj,
                                      generic_transaction_t *mem_op,
                                      addr_space_t space);
};
#define PCI_UPSTREAM_INTERFACE   "pci_upstream"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_pci_upstream_operation.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_pci_upstream_operation.html:__rm_interface_pci_upstream_operation">pci_upstream_operation</a></h1>
<p>

<a id="__rm_interface_pci_upstream_operation.html:pci_upstream_operation"></a><a id="__rm_interface_pci_upstream_operation.html:pci_upstream_operation_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This interface is implemented by PCI(e) buses to handle upstream
   transactions (primarily memory or IO) from PCI(e) devices.
<p>
   The <i>initiator</i> should be the PCI device object itself. There are
   currently no requirements on this object in terms of interfaces. It is
   intended for future use and could be left NULL.
</p><p>
   The 16-bit Requester ID is provided by the <i>rid</i> parameter. This is
   the ID that uniquely identifies the initiator in a PCIe hierarchy, also more
   commonly known as the BDF (Bus/Device/Function). This ID can be left blank
   (0) by non-PCIe devices if the BDF is not known.
</p><p>
   Return value is of type <code>exception_type_t</code> and maps, just like
   all other PCI interfaces, onto PCI concepts accordingly:
   </p><dl><dt id="__rm_interface_pci_upstream_operation.html:dt:sim_pe_no_exception"><a href="#__rm_interface_pci_upstream_operation.html:dt:sim_pe_no_exception"><b>Sim_PE_No_Exception</b></a></dt><dd>OK</dd><dt id="__rm_interface_pci_upstream_operation.html:dt:sim_pe_io_not_taken"><a href="#__rm_interface_pci_upstream_operation.html:dt:sim_pe_io_not_taken"><b>Sim_PE_IO_Not_Taken</b></a></dt><dd>Master Abort</dd><dt id="__rm_interface_pci_upstream_operation.html:dt:sim_pe_io_error"><a href="#__rm_interface_pci_upstream_operation.html:dt:sim_pe_io_error"><b>Sim_PE_IO_Error</b></a></dt><dd>Target Abort</dd></dl><p>Other return values are currently unexpected.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(pci_upstream_operation) {
        exception_type_t (*read)(conf_object_t *obj,
                                 conf_object_t *initiator,
                                 uint16 rid,
                                 addr_space_t space,
                                 physical_address_t address,
                                 buffer_t buffer);
        exception_type_t (*write)(conf_object_t *obj,
                                  conf_object_t *initiator,
                                  uint16 rid,
                                  addr_space_t space,
                                  physical_address_t address,
                                  bytes_t buffer);
};
#define PCI_UPSTREAM_OPERATION_INTERFACE   "pci_upstream_operation"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_pcie_adapter_compat.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_pcie_adapter_compat.html:__rm_interface_pcie_adapter_compat">pcie_adapter_compat</a></h1>
<p>

<a id="__rm_interface_pcie_adapter_compat.html:pcie_adapter_compat"></a><a id="__rm_interface_pcie_adapter_compat.html:pcie_adapter_compat_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Deprecated as part of the old PCIe library. Replaced by the new PCIe library.
<p>
   This interface is used by PCI buses that want to be compatible
   with PCIe devices created with the new PCIe library. This interface is
   implemented by the legacy-pcie-upstream-adapter.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(pcie_adapter_compat) {
        void (*set_secondary_bus_number)(conf_object_t *obj,
                                         int secondary_bus_number);
};
#define PCIE_ADAPTER_COMPAT_INTERFACE		"pcie_adapter_compat"


</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_pcie_device.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_pcie_device.html:__rm_interface_pcie_device">pcie_device</a></h1>
<p>

<a id="__rm_interface_pcie_device.html:pcie_device"></a><a id="__rm_interface_pcie_device.html:pcie_device_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This interface must be implemented by all PCIe devices that can receive
   downstream transactions.
<p>
   <b><i>connected</i></b> and <b><i>disconnected</i></b> are used to indicate that
   the device is (dis)connected to <i>port_obj</i> with device id
   <i>device_id</i> and may use the <code>pcie_map</code> interface to
   add/remove functions and claim/release other resources. These functions
   should only be called once for each (dis)connected physical device no matter
   how many physical or virtual functions it has. The <i>device_id</i>
   contains the device number (D part of B:D:F) and should use 0 as the function
   number (F part of B:D:F).
</p><p>
   <b><i>hot_reset</i></b> is used to indicate that a Hot Reset has been signaled
   on the PCIe link to which the device is connected. It is up to the device to
   reset functions and other resources mapped using the <code>pcie_map</code>
   interface.
</p><p>
   Note: This interface is considered tech-preview and may change without
   notice.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(pcie_device) {
        void (*connected)(conf_object_t *obj, conf_object_t *port_obj,
                          uint16 device_id);
        void (*disconnected)(conf_object_t *obj, conf_object_t *port_obj,
                             uint16 device_id);
        void (*hot_reset)(conf_object_t *obj);
};

#define PCIE_DEVICE_INTERFACE "pcie_device"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Global Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_pcie_hotplug_events.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_pcie_hotplug_events.html:__rm_interface_pcie_hotplug_events">pcie_hotplug_events</a></h1>
<p>

<a id="__rm_interface_pcie_hotplug_events.html:pcie_hotplug_events"></a><a id="__rm_interface_pcie_hotplug_events.html:pcie_hotplug_events_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This interface should be implemented by Hot-Plug capable Downstream Ports.
   Such devices should be either a Downstream Port of a PCI Express Switch or a
   Root Port of PCI Express Root Complex.
<p>
   The device that implements this interface should on the invocation of any
   of the methods in this interface should do the following:
</p><p>
   1. If the applicable Hot-Plug capability has been enabled, set the new value
      of the corresponding Hot-Plug event in the applicable register.
   2. If the value changed from its previous value, set the changed register
      value for the applicable Hot-Plug event.
   3. If the value changed from its previous value, notify software using an
      interrupt if notifications are enabled for the applicable Hot-Plug event
      and an interrupt mechanism has been configured by the software (MSI/MSI-X
      or PCI-compatible INTx Emulation).
</p><p>
   The <b><i>presence_change()</i></b> method is called by the pcie-downstream-port
   (if its upstream target implements this interface) when it goes from having
   no adapter present to having an adapter present and vice versa.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(pcie_hotplug_events) {
        void (*presence_change)(conf_object_t *obj, pcie_hotplug_pd_t state);
        void (*power_fault)(conf_object_t *obj);
        void (*attention_button_pressed)(conf_object_t *obj);
        void (*mrl_sensor)(conf_object_t *obj, pcie_hotplug_mrl_t state);
        void (*data_link_layer)(conf_object_t *obj, bool is_active);
};

#define PCIE_HOTPLUG_EVENTS_INTERFACE "pcie_hotplug_events"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_pcie_link_training.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_pcie_link_training.html:__rm_interface_pcie_link_training">pcie_link_training</a></h1>
<p>

<a id="__rm_interface_pcie_link_training.html:pcie_link_training"></a><a id="__rm_interface_pcie_link_training.html:pcie_link_training_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Trigger link training on <i>obj</i>. <i>device_id</i>
   provides the device id of device connected to <i>obj</i> which will
   be the link training target.
<p>
   </p><pre class="jdocu_small">SIM_INTERFACE(pcie_link_training) {
        bool (*trigger)(conf_object_t *obj, uint16 device_id);
};

#define PCIE_LINK_TRAINING_INTERFACE "pcie_link_training"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_pcie_map.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_pcie_map.html:__rm_interface_pcie_map">pcie_map</a></h1>
<p>

<a id="__rm_interface_pcie_map.html:pcie_map"></a><a id="__rm_interface_pcie_map.html:pcie_map_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This interface is used to claim ranges in PCIe address spaces and to manage
   virtual functions.
<p>
   Functions <b><i>add_map</i></b> and <b><i>del_map</i></b> are used to add and
   remove maps, <i>map_obj</i> will be mapped in the address space
   indicated by <i>type</i> according to the information in <i>info</i>.
</p><p>
   Functions <b><i>add_function</i></b>, <b><i>del_function</i></b>,
   <b><i>enable_function</i></b> and <b><i>disable_function</i></b> are used to add,
   delete, enable and disable functions, both virtual and physical. The
   supplied <i>map_obj</i> must be a valid map-target, it will receive both
   Config and Message transactions. For Message transactions, the device id (not
   including bus number) will be in bits 55:48 of the 64-bit address. For
   Config transactions, the device id is not part of the address. The supplied
   <i>device_and_function</i> passed to these methods should contain the
   device and function number (D:F part of B:D:F).
</p><p>
   The function <b><i>get_device_id</i></b> returns the current device id of
   <i>dev_obj</i>, as a 16 bit number. Note that the bus number part is
   saved immediately after the RC/Switch sets it, even if no successful
   Config-Write has been made.
</p><p>
   Note: This interface is considered tech-preview and may change without
   notice.
</p><p>
   </p><pre class="jdocu_small">typedef enum {
        PCIE_Type_Not_Set,
        PCIE_Type_Mem,
        PCIE_Type_IO,
        PCIE_Type_Cfg,
        PCIE_Type_Msg,
        PCIE_Type_Other,
} pcie_type_t;

SIM_INTERFACE(pcie_map) {
        void (*add_map)(conf_object_t *obj, conf_object_t *map_obj,
                        map_info_t info, pcie_type_t type);
        void (*del_map)(conf_object_t *obj, conf_object_t *map_obj,
                        physical_address_t base, pcie_type_t type);
        void (*add_function)(conf_object_t *obj, conf_object_t *map_obj,
                             uint16 device_and_function);
        void (*del_function)(conf_object_t *obj, conf_object_t *map_obj,
                             uint16 device_and_function);
        void (*enable_function)(conf_object_t *obj, uint16 device_and_function);
        void (*disable_function)(conf_object_t *obj,
                                 uint16 device_and_function);
        uint16 (*get_device_id)(conf_object_t *obj, conf_object_t *dev_obj);
};

#define PCIE_MAP_INTERFACE "pcie_map"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_pcie_port_control.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_pcie_port_control.html:__rm_interface_pcie_port_control">pcie_port_control</a></h1>
<p>

<a id="__rm_interface_pcie_port_control.html:pcie_port_control"></a><a id="__rm_interface_pcie_port_control.html:pcie_port_control_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This interface is used to configure instances of the
   <b>pcie-downstream-port</b>
<p>
   The <b><i>set_secondary_bus_number</i></b> method should be called whenever the
   Secondary Bus Number register in the Type 1 Configuration Header of this
   downstream port changes.
</p><p>
   The <b><i>hot_reset</i></b> method sends a hot reset to all downstream devices
</p><p>
   Note: This interface is considered tech-preview and may change without
   notice.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(pcie_port_control) {
        void (*set_secondary_bus_number)(conf_object_t *obj, uint64 value);
        void (*hot_reset)(conf_object_t *obj);
};

#define PCIE_PORT_CONTROL_INTERFACE "pcie_port_control"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_pmr.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_pmr.html:__rm_interface_pmr">pmr</a></h1>
<p>

<a id="__rm_interface_pmr.html:pmr"></a><a id="__rm_interface_pmr.html:pmr_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><pre class="jdocu_small">SIM_INTERFACE(pmr) {
        uint64 (*get)(
                conf_object_t *obj,
                int pmr_number,
                bool instruction_read);
        void (*set)(
                conf_object_t *obj,
                int pmr_number,
                uint64 value,
                bool instruction_write);
};
#define PMR_INTERFACE "pmr"
</pre><p>
</p><p>

   This interface provides a way for a user to write their own handler for the
   performance monitor register bank. The processor's <code>pmr_handler</code>
   attribute should be set point at the to the module, which implements the pmr
   interface. When set, all reads and writes toward the defined PMR registers
   will be forwarded to the user module instead. Simics CPU module will perform
   all the privilege checks and only forward the read/write if it is permitted.
</p><p>
   The supervisor registers are checkpointed by the CPU module and the register
   content for the PMR registers is distributed to the user module in the
   finalize phase, after the pmr_handler has been set.
</p><p>
   The function <b><i>get</i></b> is used for attribute reads, int_register reads
   or for <code>mfpmr</code> instructions. The value for the PMR register should be
   returned. The <i>instruction_read</i> will be true only for
   <code>mfpmr</code> instructions, allowing distinction between register reads by
   the user and instructions which could have side-effects.
</p><p>
   Similar, the <b><i>set</i></b> function is used for attribute writes,
   int_register writes or for <code>mtpmr</code> instructions. The
   <i>instruction_write</i> will be true only for <code>mtpmr</code>
   instructions. The <i>value</i> indicates the value written to the
   PMR register.
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_port_space.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_port_space.html:__rm_interface_port_space">port_space</a></h1>
<p>

<a id="__rm_interface_port_space.html:port_space"></a><a id="__rm_interface_port_space.html:port_space_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">I/O port interface.
   <pre class="jdocu_small">SIM_INTERFACE(port_space) {
        exception_type_t (*port_operation)(conf_object_t *NOTNULL pspace_obj,
                                           generic_transaction_t *NOTNULL mop,
                                           map_info_t map_info);
        attr_value_t (*read)(conf_object_t *NOTNULL obj,
                             conf_object_t *initiator,
                             physical_address_t addr,
                             int length,
                             int inquiry);
        exception_type_t (*write)(conf_object_t *NOTNULL obj,
                                  conf_object_t *initiator,
                                  physical_address_t addr,
                                  attr_value_t data,
                                  int inquiry);
};

#define PORT_SPACE_INTERFACE "port_space"
</pre><p>
</p><p>

   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_ppc.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_ppc.html:__rm_interface_ppc">ppc</a></h1>
<p>

<a id="__rm_interface_ppc.html:ppc"></a><a id="__rm_interface_ppc.html:ppc_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><pre class="jdocu_small">SIM_INTERFACE(ppc) {
        void (*PYTHON_METHOD clear_atomic_reservation_bit)(conf_object_t *cpu);
        void (*PYTHON_METHOD raise_machine_check_exception)(conf_object_t *cpu,
                                                            ppc_mc_exc_t exc);

        /* Timebase */
        unsigned (*PYTHON_METHOD get_timebase_enabled)(conf_object_t *cpu);
        void     (*PYTHON_METHOD set_timebase_enabled)(conf_object_t *cpu,
                                                       unsigned enabled);
        /* Power mode */
        ppc_sleep_state_t (*PYTHON_METHOD get_sleep_state)(conf_object_t *cpu);
        void (*PYTHON_METHOD set_sleep_state)(conf_object_t *cpu,
                                              ppc_sleep_state_t state);
};

#define PPC_INTERFACE "ppc"
</pre><p>
</p><p>

   The <b><i>clear_atomic_reservation_bit()</i></b> function clears the
   reservation bit which is set by an <code>lwarx</code> instruction.  Clearing the
   reservation will cause a following <code>stwcx.</code> instruction to fail.
   This function is typically used by a cache hierarchy supporting SMP.
</p><p>
   The <b><i>raise_machine_check_exception()</i></b> function raises a machine
   check exception. The <i>exc</i> argument is of the following type:
</p><p>
   <a id="__rm_interface_ppc.html:ppc_mc_exc_t"></a>
</p><pre class="jdocu_small">typedef enum {
        Sim_PPC_Generic_MC,

        Sim_PPC_MC_TEA,
        Sim_PPC_MC_MCP,
        Sim_PPC_Bus_Address_Parity,
        Sim_PPC_Bus_Data_Parity,
        Sim_PPC_Instruction_Cache_Parity,
        Sim_PPC_Data_Cache_Parity,
        Sim_PPC_L2_Data_Parity,
        Sim_PPC_L3_Data_Parity,
        Sim_PPC_L3_Address_Parity,
        
        Sim_PPC970_Data_Cache_Parity,
        Sim_PPC970_Data_Cache_Tag_Parity,
        Sim_PPC970_D_ERAT_Parity,
        Sim_PPC970_TLB_Parity,
        Sim_PPC970_SLB_Parity,
        Sim_PPC970_L2_Load_ECC_Parity,
        Sim_PPC970_L2_Page_Table_ECC_Parity,
        Sim_PPC970_Uncacheable_Load_Parity,
        Sim_PPC970_MC_External
} ppc_mc_exc_t;</pre><p>

</p><p>
   The <b><i>get_timebase_enabled</i></b> and <b><i>set_timebase_enabled</i></b>
   functions can be used to query and set the enabled state of the timebase.
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_pulse.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_pulse.html:__rm_interface_pulse">pulse</a></h1>
<p>

<a id="__rm_interface_pulse.html:pulse"></a><a id="__rm_interface_pulse.html:pulse_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Interface to model a pulse, meaning an event that triggers.
<p>
   </p><pre class="jdocu_small">SIM_INTERFACE(pulse) {
        void (*pulse)(conf_object_t *NOTNULL obj);
};

#define PULSE_INTERFACE "pulse"
</pre><p>
</p><p>

   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_ram.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_ram.html:__rm_interface_ram">ram</a></h1>
<p>

<a id="__rm_interface_ram.html:ram"></a><a id="__rm_interface_ram.html:ram_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><a id="__rm_interface_ram.html:ram_operation_flags_t"></a>
<p>
     The <code>ram</code> interface is implemented by classes that provide
     random access read/write memory. The <code>rom</code> interface is
     identical to <code>ram</code> but provides read only memory (writes are
     dropped by the memory system).
</p><p>
     Both the ram and rom interfaces are Simics internal, and should not be used
     by user-defined classes.
</p><p>
     The <b><i>get_page</i></b> method is obsolete and should not be implemented.
</p><p>
     The <b><i>fill</i></b> method fills a range with a specified byte value.
</p><p>
     The <b><i>read</i></b> method reads a number of bytes from address
     <i>addr</i> into the buffer <i>data</i>. The number of
     bytes read is given by the buffer size.
</p><p>
     The <b><i>write</i></b> method writes the bytes in <i>data</i> to
     address <i>addr</i>.
</p><p>
     The <b><i>touch</i></b> method is similar to the <b><i>read</i></b> and
     <b><i>write</i></b> methods, except that no data is actually transferred; the
     method triggers side effects like revoking conflicting direct-memory
     permissions from affected pages. The <i>rw</i> argument determines
     whether the operation is a handled as a read or as a write.
</p><p>
     The <i>flags</i> argument is a bitmask which modify the behavior
     of <b><i>read</i></b>, <b><i>write</i></b> and <b><i>touch</i></b> operations in
     various ways.
</p><p>
     The <b><i>size</i></b> method returns the memory size in bytes; that is, the
     highest usable address plus one.
</p><p>
     </p><pre class="jdocu_small">typedef enum {
        Sim_Ram_Op_Fetch = 1,           /* Read is an instruction fetch. */
        Sim_Ram_Op_Non_Coherent = 2,    /* Operation should not cause
                                           atomic reservations to be lost. */
} ram_operation_flags_t;

SIM_INTERFACE(ram) {
#ifndef PYWRAP
        /* The get_page is method is obsolete and should be left
           unimplemented. */
        page_t *(*get_page)(conf_object_t *NOTNULL obj,
                            physical_address_t addr);
#endif
        void (*fill)(conf_object_t *NOTNULL obj,
                     physical_address_t start, uint64 length, uint8 value);

        exception_type_t (*read)(conf_object_t *NOTNULL obj,
                                 conf_object_t *initiator,
                                 uint64 addr, buffer_t data,
                                 ram_operation_flags_t flags);
        
        exception_type_t (*write)(conf_object_t *NOTNULL obj,
                                  conf_object_t *initiator,
                                  uint64 addr, bytes_t data,
                                  ram_operation_flags_t flags);
        
        exception_type_t (*touch)(conf_object_t *NOTNULL obj,
                                  conf_object_t *initiator,
                                  uint64 addr, uint64 size,
                                  read_or_write_t rw,
                                  ram_operation_flags_t flags);

        uint64 (*size)(conf_object_t *NOTNULL obj);
};
#define RAM_INTERFACE "ram"
#define ROM_INTERFACE "rom"

typedef ram_interface_t rom_interface_t;
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_riscv_coprocessor.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_riscv_coprocessor.html:__rm_interface_riscv_coprocessor">riscv_coprocessor</a></h1>
<p>

<a id="__rm_interface_riscv_coprocessor.html:riscv_coprocessor"></a><a id="__rm_interface_riscv_coprocessor.html:riscv_coprocessor_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>riscv_coprocessor</code> interface makes it possible for RISC-V
    processors to read and write Control and Status Registers (CSRs) like
    <i>mtime</i>
<p>
   </p><pre class="jdocu_small">SIM_INTERFACE(riscv_coprocessor) {
        uint64 (*read_register)(conf_object_t *obj, uint64 number);
        void (*write_register)(conf_object_t *obj, uint64 number, uint64 value);
};

#define RISCV_COPROCESSOR_INTERFACE "riscv_coprocessor"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_riscv_custom_csr.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_riscv_custom_csr.html:__rm_interface_riscv_custom_csr">riscv_custom_csr</a></h1>
<p>

<a id="__rm_interface_riscv_custom_csr.html:riscv_custom_csr"></a><a id="__rm_interface_riscv_custom_csr.html:riscv_custom_csr_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>riscv_custom_csr</code> interface lets other Simics objects
    implement custom CSR-registers and get callback for each access.
<p>
    For the methods below, <i>cpu</i> is the RISC-V CPU model that is
    extended and <i>ext_obj</i> is the extension object.
</p><p>
    The <b><i>register_csr</i></b> method registers a custom CSR at
    <i>csr_address</i>.
    The arguments <i>name</i> and <i>description</i> are for
    disassembly and int_register interface.
    The argument <i>access</i> is the function implementing the CSR access.
    Return true if CSR is successfully registered.
</p><p>
    
</p><pre class="jdocu_small">typedef enum {
        /* Access through csr/csri instruction */
        Riscv_CSR_Instruction_Access = Sim_Gen_Spr_Instruction_Access,

        /* Access through attribute */
        Riscv_Attribute_Access = Sim_Gen_Spr_Attribute_Access,

        /* Access through int_register_interface */
        Riscv_Int_Register_Access = Sim_Gen_Spr_Int_Register_Access,
} riscv_csr_access_type_t;</pre><p>

</p><p>
    
</p><pre class="jdocu_small">typedef uint64 (*riscv_csr_access_cb_t)(conf_object_t *obj,
                                        conf_object_t *cpu,
                                        uint32 csr_address,
                                        uint64 value,
                                        uint64 write_mask,
                                        riscv_csr_access_type_t type);</pre><p>

</p><p>
    The <b><i>register_reset</i></b> method registers a reset callback for the
    extension. The <i>reset_func</i> callback will be called in connection
    with the core CPU reset flow.
</p><p>
    
</p><pre class="jdocu_small">typedef uint64 (*riscv_reset_cb_t)(conf_object_t *obj,
                                   conf_object_t *cpu);</pre><p>

</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(riscv_custom_csr) {

        bool (*register_csr)(conf_object_t *cpu,
                             conf_object_t *ext_obj,
                             uint32 csr_address,
                             const char *name,
                             const char *description,
                             riscv_csr_access_cb_t access);

        void (*register_reset)(conf_object_t *cpu,
                               conf_object_t *csr_obj,
                               riscv_reset_cb_t reset_func);
};

#define RISCV_CUSTOM_CSR_INTERFACE "riscv_custom_csr"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Global Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_riscv_imsic.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_riscv_imsic.html:__rm_interface_riscv_imsic">riscv_imsic</a></h1>
<p>

<a id="__rm_interface_riscv_imsic.html:riscv_imsic"></a><a id="__rm_interface_riscv_imsic.html:riscv_imsic_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">RISC-V Internal interface.
<p>
   </p><pre class="jdocu_small">SIM_INTERFACE(riscv_imsic) {
        // GEILEN
        uint32 (*num_guest_files)(conf_object_t *obj);

        // id is either one of the standard files, machine or supervisor,
        // or one of the guest files (vgein).

        uint64 (*read_irq_file)(conf_object_t *obj, riscv_imsic_file_id_t id, uint32 offset);
        uint64 (*read_and_write_irq_file)(conf_object_t *obj, riscv_imsic_file_id_t id,
                                          uint32 offset, uint64 new_value, uint64 mask);

        uint64 (*read_xtopei)(conf_object_t *obj, riscv_imsic_file_id_t id);
        uint64 (*read_and_write_xtopei)(conf_object_t *obj, riscv_imsic_file_id_t id,
                                        uint64 value, uint64 mask);
};

#define RISCV_IMSIC_INTERFACE "riscv_imsic"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_riscv_instruction_action.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_riscv_instruction_action.html:__rm_interface_riscv_instruction_action">riscv_instruction_action</a></h1>
<p>

<a id="__rm_interface_riscv_instruction_action.html:riscv_instruction_action"></a><a id="__rm_interface_riscv_instruction_action.html:riscv_instruction_action_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>riscv_instruction_action</code> interface helps with
    implementing semantics for user defined instruction.
<p>
    The <i>cpu</i> argument in all methods below is the processor object
    implementing this interface.
</p><p>
    <b>X registers</b>
    <b><i>read_X_register</i></b> return the current value of X register <code>number</code>.
    <b><i>write_X_register</i></b> updates the value of X register <code>number</code> to
    <code>value</code>.
    To help with disassembly <b><i>name_X_register</i></b> returns the name of the X
    register <code>number</code>.
</p><p>
    <b>Control and status registers, CSRs</b>
    These accesses are not seen as instruction accesses, all access checks are
    bypassed and no exception will be thrown.
    <b><i>read_CSR</i></b> returns current value of the CSR at <code>address</code>.
    <b><i>write_CSR</i></b> updates the value of the CSR at <code>address</code> to
    <code>value</code>. Not all bits of all CSRs is writable.
</p><p>
    <b>Memory accesses using logical address</b>
    A logical address is passed through MMU based on current mode. This means that
    an access can raise exception for page fault or illegal access.
    <b><i>read_memory</i></b> returns a value of <i>size&gt;</i> bytes zero extended to
    64 bits from memory at <code>address</code>/
    <b><i>write_memory</i></b> writes <i>size</i> bytes to memory at <i>address</i>.
    Both read_memory and write_memory can raise exception for unaligned data access if
    the core does not support unaligned accesses.
</p><p>
    <b><i>load_memory_buf</i></b> loads <code>buf.len</code> bytes from <i>address</i>
    to <i>buf</i>.
    <b><i>store_memory_buf</i></b> writes <code>buf.len</code> bytes from <i>buf</i> to
    <i>address</i>.
    These methods do not raise exception for unaligned accesses, instead large and/or
    unaligned accesses are broken down to multiple smaller aligned accesses.
</p><p>
    <b>Other</b>
    <b><i>get_current_cpu_mode</i></b> returns current cpu mode.
    <b><i>raise_exception</i></b> raises exception with <i>code</i> put in th xCAUSE CSR
    and <i>tval</i> put in the xTVAL CSR.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(riscv_instruction_action) {
        uint64 (*read_x_register)(conf_object_t *cpu, uint32 number);
        void (*write_x_register)(conf_object_t *cpu, uint32 number, uint64 value);
        const char * (*name_x_register)(conf_object_t *cpu, uint32 number);

        uint64 (*read_csr)(conf_object_t *cpu, uint32 address);
        void (*write_csr)(conf_object_t *cpu, uint32 address, uint64 value);

        // Logical address
        uint64 (*read_memory)(conf_object_t *cpu, uint64 address,
                              uint32 size);
        void (*write_memory)(conf_object_t *cpu, uint64 address,
                             uint32 size, uint64 value);

        void (*load_memory_buf)(conf_object_t *cpu, uint64 address, buffer_t buf);
        void (*store_memory_buf)(conf_object_t *cpu, uint64 address, bytes_t buf);

        riscv_cpu_mode_t (*get_current_cpu_mode)(conf_object_t *cpu);

        void (*raise_exception)(conf_object_t *cpu, uint64 code, uint64 tval);
};

#define RISCV_INSTRUCTION_ACTION_INTERFACE "riscv_instruction_action"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Threaded Context for all methods.
   Must be only called from within an instruction emulation callback registered
   using the cpu_instruction_decoder interface.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_riscv_signal_sgeip.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_riscv_signal_sgeip.html:__rm_interface_riscv_signal_sgeip">riscv_signal_sgeip</a></h1>
<p>

<a id="__rm_interface_riscv_signal_sgeip.html:riscv_signal_sgeip"></a><a id="__rm_interface_riscv_signal_sgeip.html:riscv_signal_sgeip_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>riscv_signal_sgeip</code> interface makes it possible to signal
    Supervisor Guest External (SGE) interrupts with a corresponding vgein.
    This is used together with an IMSIC and signaled from the IMSIC.
   <pre class="jdocu_small">SIM_INTERFACE(riscv_signal_sgeip) {
        void (*signal_raise)(conf_object_t *NOTNULL obj, uint64 vgein);
        void (*signal_lower)(conf_object_t *NOTNULL obj, uint64 vgein);
};

#define RISCV_SIGNAL_SGEIP_INTERFACE "riscv_signal_sgeip"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_rs232_console.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_rs232_console.html:__rm_interface_rs232_console">rs232_console</a></h1>
<p>

<a id="__rm_interface_rs232_console.html:rs232_console"></a><a id="__rm_interface_rs232_console.html:rs232_console_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Currently Simics internal.
<p>
   </p><pre class="jdocu_small">typedef enum {
        Stop_Bits_1,
        Stop_Bits_1p5,
        Stop_Bits_2
} stop_bits_t;

typedef enum {
        Parity_None,
        Parity_Even,
        Parity_Odd
} parity_mode_t;


SIM_INTERFACE(rs232_console) {
        /* Set line parameters */
        void (*set_baudrate)(conf_object_t *obj, int rate, int commit);
        void (*set_data_bits)(conf_object_t *obj, int bits, int commit);
        void (*set_stop_bits)(conf_object_t *obj, stop_bits_t stop_bits,
                              int commit);
        void (*set_parity_mode)(conf_object_t *obj, parity_mode_t parity_mode,
                                int commit);

        /* Flow control lines */
        void (*set_dtr)(conf_object_t *obj, int status);
        void (*set_rts)(conf_object_t *obj, int status);

        /* Break */
        void (*set_break)(conf_object_t *obj, int status);
};

#define RS232_CONSOLE_INTERFACE "rs232_console"
</pre><p>
</p><p>

   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_rs232_device.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_rs232_device.html:__rm_interface_rs232_device">rs232_device</a></h1>
<p>

<a id="__rm_interface_rs232_device.html:rs232_device"></a><a id="__rm_interface_rs232_device.html:rs232_device_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Currently Simics internal.
<p>
   </p><pre class="jdocu_small">SIM_INTERFACE(rs232_device) {
        /* Flow control lines */
        void (*cts)(conf_object_t *obj, int status);
        void (*dsr)(conf_object_t *obj, int status);

        /* Ring indicator */
        void (*ring)(conf_object_t *obj, int status);

        /* Carrier detect */
        void (*carrier)(conf_object_t *obj, int status);

        /* Break */
        void (*got_break)(conf_object_t *obj);

        /* Frame error */
        void (*got_frame_error)(conf_object_t *obj);
};

#define RS232_DEVICE_INTERFACE "rs232_device"
</pre><p>
</p><p>

   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_sata.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_sata.html:__rm_interface_sata">sata</a></h1>
<p>

<a id="__rm_interface_sata.html:sata"></a><a id="__rm_interface_sata.html:sata_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><pre class="jdocu_small">SIM_INTERFACE(sata) {
        void (*receive_fis)(conf_object_t *obj, const bytes_t fis);
};

#define SATA_INTERFACE "sata"
</pre><p>
</p><p>

   This interface is implemented by SATA objects that provide
   an interface for serial data delivery.
</p><p>
   This interface can be used in both direction in SATA communication.
   The <b><i>receive_fis</i></b> function is used by a device to send 
   a SATA FIS to the SATA controller(HBA). The same function is used
   when sending a SATA FIS from HBA to SATA device. The FIS should be
   a <code><a id="__rm_interface_sata.html:bytes_t">bytes_t</a></code> containing a complete SATA FIS.
   Different types of FIS may have different length. Please follow
   SATA specification when determine the length and content of the FIS.
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_scale_factor_listener.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_scale_factor_listener.html:__rm_interface_scale_factor_listener">scale_factor_listener</a></h1>
<p>

<a id="__rm_interface_scale_factor_listener.html:scale_factor_listener"></a><a id="__rm_interface_scale_factor_listener.html:scale_factor_listener_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>scale_factor_listener</code> interface is used for
   modeling changes in scale factors. It is mainly used by the
   <b>frequency_bus</b> device, to allow an external device to
   affect how much the bus scales its input frequency.
<p>
   The <code>scale_factor_listener</code> has exactly the same
   semantics as the <code>frequency_listener</code> interface, the
   two interfaces only differ in convention: The parameters to
   <b><i>scale_factor_listener.set()</i></b> are typically a scale factor
   rather close to 1, while the parameters of
   <b><i>frequency_listener</i></b> represent a base frequency in Hz,
   which is typically significantly larger than 1000000.
</p><p>
   See the documentation on the <a class="jdocu" href="#__rm_interface_frequency_listener.html">frequency_listener</a>
   interface for more information.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(scale_factor_listener) {
        void (*set)(conf_object_t *NOTNULL obj, uint64 numerator,
                    uint64 denominator);
};

#define SCALE_FACTOR_LISTENER_INTERFACE "scale_factor_listener"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_serial_device.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_serial_device.html:__rm_interface_serial_device">serial_device</a></h1>
<p>

<a id="__rm_interface_serial_device.html:serial_device"></a><a id="__rm_interface_serial_device.html:serial_device_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Interface used to connect serial devices together. It can be implemented
   both by devices such as UARTs and text consoles, and by links.
<p>
   A character (byte) is sent with the <b><i>write()</i></b> function;
   <i>obj</i> is the receiving device or link, and <i>value</i> is
   either a data byte, or the out-of-band value <code>TTY_ABORT</code>.
</p><p>
   The receiver will return the number of characters accepted; i.e. 1 on
   success and 0 if it could not handle the new byte. If the receiver returns
   0, it must later call <b><i>receive_ready()</i></b> in the sender's
   <code>serial_device</code> interface to signal that new bytes can now be
   accepted. A serial device must handle the case where the
   <b><i>receive_ready()</i></b> function is called although it has no more bytes
   to send.
</p><p>
   </p><pre class="jdocu_small">#define TTY_ABORT   0x100

SIM_INTERFACE(serial_device) {
        int (*write)(conf_object_t *obj, int value);
        void (*receive_ready)(conf_object_t *obj);
};

#define SERIAL_DEVICE_INTERFACE "serial_device"
</pre><p>
</p><p>

   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_serial_peripheral_interface_master.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_serial_peripheral_interface_master.html:__rm_interface_serial_peripheral_interface_master">serial_peripheral_interface_master</a></h1>
<p>

<a id="__rm_interface_serial_peripheral_interface_master.html:serial_peripheral_interface_master"></a><a id="__rm_interface_serial_peripheral_interface_master.html:serial_peripheral_interface_master_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><pre class="jdocu_small">SIM_INTERFACE(serial_peripheral_interface_master) {
        void (*spi_response)(conf_object_t *obj, int bits, dbuffer_t *payload);
};

#define SERIAL_PERIPHERAL_INTERFACE_MASTER_INTERFACE \
        "serial_peripheral_interface_master"
</pre><p>
</p><p>

   The <code>serial_peripheral_interface_master</code> interface is
   implemented by all SPI master devices. The interface contains a
   single function <b><i>spi_response</i></b>, called by the slave device
   in response to a <b><i>spi_request</i></b> call. The parameters
   <i>bits</i> and <i>payload</i> have the same
   meaning as in the <b><i>spi_request</i></b> call, and a SPI response
   should always have the same length in bits as the corresponding request.
</p><p>
   </p></dd><dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
     </a><code>serial_peripheral_interface_slave_interface_t</code>
   </dd>


<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
<p>
   
</p></dd>
</dl><p></p></section><section class="page" id="__rm_interface_serial_peripheral_interface_slave.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_serial_peripheral_interface_slave.html:__rm_interface_serial_peripheral_interface_slave">serial_peripheral_interface_slave</a></h1>
<p>

<a id="__rm_interface_serial_peripheral_interface_slave.html:serial_peripheral_interface_slave"></a><a id="__rm_interface_serial_peripheral_interface_slave.html:serial_peripheral_interface_slave_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><pre class="jdocu_small">SIM_INTERFACE(serial_peripheral_interface_slave) {
        void (*spi_request)(conf_object_t *obj, int first, int last,
                            int bits, dbuffer_t *payload);
        void (*connect_master)(conf_object_t *obj, conf_object_t *master,
                               const char *port,
                               serial_peripheral_interface_flags_t flags);
        void (*disconnect_master)(conf_object_t *obj, conf_object_t *master);
};

#define SERIAL_PERIPHERAL_INTERFACE_SLAVE_INTERFACE \
        "serial_peripheral_interface_slave"
</pre><p>
</p><p>

   The <code>serial_peripheral_interface_slave</code> interface is
   implemented by all SPI slave devices.
</p><p>
   The <b><i>connect_master</i></b> and <b><i>disconnect_master</i></b>
   functions are used to select which master device is connected. At
   most one master device can be connected to a slave device at once.
   The <i>flags</i> parameter to <b><i>connect_master</i></b>
   should be set according to the documentation of the
   <code>serial_peripheral_interface_flags_t</code> type.
</p><p>
   An SPI transfer consists of a number of consecutive calls to the
   <b><i>spi_request</i></b> function. The parameters
   <i>first</i> and <i>last</i> represent the rise and
   fall of the Slave Select (SS) pin: <i>first</i> is
   <code>true</code> on the first <b><i>spi_request</i></b> call of a
   transfer, while <i>last</i> is <code>true</code> on the
   last call of a transfer.
</p><p>
   The <i>bits</i> and <i>payload</i> parameters
   describe the data sent by the master device. <i>bits</i>
   defines the number of bits to send, while <i>payload</i>
   defines the data to transfer. The size of the
   <i>payload</i> buffer should be <code>ceil(bits / 8)</code>
   bytes. The first byte corresponds to the first 8 sent bits, and the
   least significant bit in each byte corresponds to the first sent
   bit.  For example, the 11-bit sequence (first) <code>11011111101</code>
   (last) will be represented as two bytes, <code>0xfb</code> followed by
   <code>0x5</code>.
</p><p>
   </p></dd><dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
     </a><code>serial_peripheral_interface_master_interface_t</code>,
     <code>serial_peripheral_interface_flags_t</code>
   </dd>


<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_signal.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_signal.html:__rm_interface_signal">signal</a></h1>
<p>

<a id="__rm_interface_signal.html:signal"></a><a id="__rm_interface_signal.html:signal_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>signal</code> interface is for modeling a logical signal, such
   as a reset or interrupt. Signals are always active high in Simics with
   respect to their function. This may not correspond to the actual electrical
   level in a real system.
<p>
   A signal connection has one initiator and one target object, where the
   initiator calls methods the interface implemented by the target.
</p><p>
   The initiator object should have a configuration attribute that pointing to
   the target object or to an interface port of the target. This attribute,
   like all other attributes representing object connections, should be of the
   object kind, or a list of two entries where the first is
   an object and the second a string representing the name of the port.
</p><p>
   The initiator should call <b><i>signal_raise()</i></b> to raise the signal
   level to its active level in the target. Once raised, the same initiator may
   not call <b><i>signal_raise()</i></b> again without an intervening call to
   <b><i>signal_lower()</i></b>. Similarly, an already low signal may not be
   lowered again by a <b><i>signal_lower()</i></b> call from the same initiator.
   The two functions represent the rising and the falling edge of the signal.
</p><p>
   The target should handle the case where a signal is lowered directly after
   it has been raised and treat this call sequence as a valid pulse even within
   a single clock cycle. The target should also allow the signal to remain
   raised for some time before it is lowered.
</p><p>
   While a target is disconnected, the input signal level is assumed to be low.
   When an initiator connects to a target by hot plugging,
   <b><i>signal_raise()</i></b> should be called if the output signal from the
   initiator was high. If the signal was low, then no function in the target
   should be called.
</p><p>
   If the signal level is high on disconnect, then the initiator has to call
   <b><i>signal_lower()</i></b> before disconnecting from the target. Connect and
   disconnect is typically done by changing the attribute in the initiator
   that identifies the target object.
</p><p>
   When an initiator is reset, it should call <b><i>signal_lower()</i></b> if the
   actual hardware also lowers the output signal on a reset. The target, on the
   other hand, should not reset its remembered value of the input.
</p><p>
   When a connection attribute is restored from a checkpoint or during reverse
   execution, no function should be called in the <code>signal</code>
   interface of the target since the actual signal level does not change. The
   attribute setter code can distinguish between hot-plugging and state
   restoring by using <b><i>SIM_object_is_configured()</i></b> and
   <b><i>SIM_is_restoring_state</i></b>. See the latter of the two for more
   documentation.
</p><p>
   When an object is first created and the initial signal level is high, the
   initiator has to call the <b><i>signal_raise()</i></b> function in the target.
   This can not be done earlier than in <b><i>finalize_instance</i></b> (C/C++) or
   in <b><i>post_init()</i></b> (DML) since the target has to be fully configured.
   Again, this should not be done when restoring a checkpoint.
</p><p>
   There must only be a single initiator connected to a target, with the
   exception of the <b>signal-bus</b> that may have several initiators.
</p><p>
   A target that needs more than one input signal should use ports to implement
   several <code>signal</code> interfaces.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(signal) {
        void (*signal_raise)(conf_object_t *NOTNULL obj);
        void (*signal_lower)(conf_object_t *NOTNULL obj);
};

#define SIGNAL_INTERFACE "signal"
</pre><p>
</p><p>

   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_simple_dispatcher.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_simple_dispatcher.html:__rm_interface_simple_dispatcher">simple_dispatcher</a></h1>
<p>

<a id="__rm_interface_simple_dispatcher.html:simple_dispatcher"></a><a id="__rm_interface_simple_dispatcher.html:simple_dispatcher_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>simple_dispatcher</code> interface is used for
   subscribing to changes of some monitored state. The interface is
   currently used for subscribing to changes in frequencies and to
   changes in frequency scale factors, via the interfaces
   <code>frequency_listener</code> and
   <code>scale_factor_listener</code>, respectively.
<p>
   A device subscribes with the <b><i>subscribe</i></b> function.  Before
   this function returns, it should send a signal to the calling
   object, telling the current state. After this, signals should be
   sent whenever the monitored state changes.
</p><p>
   The function <b><i>unsubscribe</i></b> should be used to unsubscribe
   from monitored changes. A listener may not subscribe or unsubscribe
   twice on the same port.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(simple_dispatcher) {
        void (*subscribe)(conf_object_t *NOTNULL bus,
                          conf_object_t *NOTNULL listener,
                          const char *listener_port);
        void (*unsubscribe)(conf_object_t *NOTNULL bus,
                            conf_object_t *NOTNULL listener,
                            const char *listener_port);
};

#define SIMPLE_DISPATCHER_INTERFACE "simple_dispatcher"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Global Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_simple_interrupt.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_simple_interrupt.html:__rm_interface_simple_interrupt">simple_interrupt</a></h1>
<p>

<a id="__rm_interface_simple_interrupt.html:simple_interrupt"></a><a id="__rm_interface_simple_interrupt.html:simple_interrupt_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">A device calls <b><i>interrupt()</i></b> to logically raise an interrupt and
   <b><i>interrupt_clear()</i></b> to lower an interrupt.
<p>
   The first argument is the object to interrupt, usually a cpu. The
   integer argument to both functions may indicate an interrupt level
   or interrupt pin depending on the receiving device.
</p><p>
   On ARM the integer argument indicates whether the interrupt is normal or
   fast, by being either ARM_INT_IRQ or ARM_INT_FIQ defined by the ARM API
   (by including <code>&lt;simics/arch/arm.h&gt;</code>).
</p><p>
   </p><div class="note">
<b>Note:</b>
Obsoleted by the <code>signal</code> interface.</div><pre class="jdocu_small">SIM_INTERFACE(simple_interrupt) {
        void (*interrupt)(conf_object_t *NOTNULL obj, int value);
        void (*interrupt_clear)(conf_object_t *NOTNULL obj, int value);
};

#define SIMPLE_INTERRUPT_INTERFACE "simple_interrupt"
</pre><p>
</p><p>

   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_smm_instrumentation_subscribe.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_smm_instrumentation_subscribe.html:__rm_interface_smm_instrumentation_subscribe">smm_instrumentation_subscribe</a></h1>
<p>

<a id="__rm_interface_smm_instrumentation_subscribe.html:smm_instrumentation_subscribe"></a><a id="__rm_interface_smm_instrumentation_subscribe.html:smm_instrumentation_subscribe_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This interface allows a user to keept track of System Management Mode
   switches in the processor.
<p>
   The <b><i>register_smm_enter_before_cb</i></b> registers a callback of type
   <code>smm_switch_cb_t</code> that will be called before the processor
   enters System Management Mode.
</p><p>
   The <b><i>register_smm_enter_after_cb</i></b> registers a callback of type
   <code>smm_switch_cb_t</code> that will be called after the processor
   has entered System Management Mode.
</p><p>
   The <b><i>register_smm_leave_before_cb</i></b> registers a callback of type
   <code>smm_switch_cb_t</code> that will be called before the processor
   leaves System Management Mode.
</p><p>
   The <b><i>register_smm_leave_after_cb</i></b> registers a callback of type
   <code>smm_switch_cb_t</code> that will be called after the processor
   has left System Management Mode.
</p><p>
   The callback in all cases looks like this:
   
   This callback type is used by the
   <code>smm_instrumentation_subscribe</code> to implement instrumentation.

</p><pre class="jdocu_small">typedef void (*smm_switch_cb_t)(
        conf_object_t *obj, conf_object_t *cpu,
        lang_void *user_data);</pre><p>

</p><p>
   The <i>obj</i> argument is the user object that registered the
   callback, or NULL if no such object exists.
</p><p>
   The <i>cpu</i> argument is the processor that enters/leaves System
   Management Mode.
</p><p>
   The <i>user_data</i> argument is the callback user data, passed to the
   register methods.
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Global Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_sparc_v8.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_sparc_v8.html:__rm_interface_sparc_v8">sparc_v8</a></h1>
<p>

<a id="__rm_interface_sparc_v8.html:sparc_v8"></a><a id="__rm_interface_sparc_v8.html:sparc_v8_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><pre class="jdocu_small">SIM_INTERFACE(sparc_v8) {
        uint64 (*read_window_register)(conf_object_t *cpu, int window, int reg);

        void (*write_window_register)(conf_object_t *cpu,
                                      int window, int reg, uint64 value);
        void (*power_down)(conf_object_t *cpu);
};
#define SPARC_V8_INTERFACE "sparc_v8"
</pre><p>
</p><p>
   SPARC V8 specific functions.
   </p><p>
   This interface is implemented by SPARC V8 processors to provide
   various functionality that is specific for this class of processors.
   </p><p>
   The <b><i>read_window_register</i></b> and <b><i>write_window_register</i></b>
   functions can be used to access registers in any register window.
   </p><p>
   The register number when accessing windowed registers is 0 - 7 for accesses
   to the global registers, 8 - 15 for the out registers of the selected
   window, 16 - 23 for the local registers, and 24 - 31 for the in registers.
   </p><p>
   The <b><i>power_down</i></b> function is used to command the processor to enter
   power down mode. During power down mode, the processor will not execute any
   instructions, it will instead fast forward the execution to the next event.
   If the event is an external interrupt the power down mode is exited and
   execution resumed, in other cases the event will be handled and the
   processor will remain in power down mode and fast forward to the next event.
   </p><p>
   One use for the <b><i>power_down</i></b> function is for example to have an
   external device such as an memory mapped PMU force the processor into power
   down mode.
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_sparc_v8_ecc_fault_injection.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_sparc_v8_ecc_fault_injection.html:__rm_interface_sparc_v8_ecc_fault_injection">sparc_v8_ecc_fault_injection</a></h1>
<p>

<a id="__rm_interface_sparc_v8_ecc_fault_injection.html:sparc_v8_ecc_fault_injection"></a><a id="__rm_interface_sparc_v8_ecc_fault_injection.html:sparc_v8_ecc_fault_injection_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><pre class="jdocu_small">SIM_INTERFACE(sparc_v8_ecc_fault_injection) {
        void (*inject_instr_access_exception)(conf_object_t *cpu);
        void (*inject_data_access_exception)(conf_object_t *cpu);
        void (*inject_reg_access_error)(conf_object_t *cpu);        
};
#define SPARC_V8_ECC_FAULT_INJECTION_INTERFACE "sparc_v8_ecc_fault_injection"
</pre><p>
</p><p>

   Support the injection of uncorrectable ECC faults. It can be used to
   inject (1) V8_Exc_Data_Access_Exception,
   (2) V8_Exc_Instruction_Access_Exception, and
   (3) V8_Exc_R_Register_Access_Error. The functions in this interface
   can only be called by breakpoint callback functions. Once an ecc
   fault is injected, new ecc faults can not be injected until the current
   one is handled.
   </p><p>
   The <b><i>inject_data_access_exception</i></b> plants an
   V8_Exc_Data_Access_Error for memory access on a location. The fault is
   injected when the breakpoint callback function of the location is called.
</p><p>
   The <b><i>inject_instr_access_exception</i></b> plants an
   V8_Exc_Instruction_Access_Exception for an instruction, and this fault is
   injected when the breakpoint callback function of the instruction location
   is called.
</p><p>
   The <b><i>inject_data_access_exception</i></b> is used for injecting
   V8_Exc_R_Register_Access_Error for a register access. It is right now not
   implemented.
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_spr.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_spr.html:__rm_interface_spr">spr</a></h1>
<p>

<a id="__rm_interface_spr.html:spr"></a><a id="__rm_interface_spr.html:spr_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><pre class="jdocu_small">SIM_INTERFACE(spr) {
        void (*register_user_handlers)(
                conf_object_t *cpu,
                int64 spr_number,
                gen_spr_user_getter_func_t getter,
                lang_void *user_getter_data,
                gen_spr_user_setter_func_t setter,
                lang_void *user_setter_data,
                int privilege_checks);
        void (*unregister_user_handlers)(
                conf_object_t *cpu,
                int64 spr_number);

        void (*set_target_value)(
                conf_object_t *cpu,
                uint64 value);

        void (*stash_value)(
                conf_object_t *cpu,
                int64 spr_number,
                uint64 value);
        uint64 (*fetch_value)(
                conf_object_t *cpu,
                int64 spr_number);

        gen_spr_ret_t (*default_getter)(
                conf_object_t *cpu,
                int64 spr_number,
                gen_spr_access_type_t type);
        gen_spr_ret_t (*default_setter)(
                conf_object_t *cpu,
                int64 spr_number,
                uint64 value,
                gen_spr_access_type_t type);

        const char *(*get_name)(
                conf_object_t *cpu,
                int64 spr_number);
        int64 (*get_number)(
                conf_object_t *cpu,
                const char *spr_name);

};
#define SPR_INTERFACE "spr"
</pre><p>
</p><p>

   The <b><i>register_spr_user_handlers</i></b> function will register user
   implemented get and set functions that will be called every time a
   read or write access is made to the SPR with number <i>spr</i>.
   The <i>getter</i> and <i>setter</i> function is of the
   following type:
</p><p>
   
</p><pre class="jdocu_small">typedef gen_spr_ret_t (*gen_spr_user_getter_func_t)(
        conf_object_t *cpu,
        int64 spr_number,
        gen_spr_access_type_t type,
        lang_void *user_data);</pre><p>

</p><p>
   The <i>type</i> parameter in the get and set functions is one of
   the following, depending on where from the access originated:
</p><p>
   
</p><pre class="jdocu_small">typedef enum {
        /* Access from a mfspr/mtspr instruction */
        Sim_Gen_Spr_Instruction_Access,

        /* Access through attribute */
        Sim_Gen_Spr_Attribute_Access,

        /* Access through int_register interface */
        Sim_Gen_Spr_Int_Register_Access,

        /* For compatibility with former PPC-only implementation */
        Sim_PPC_Spr_Instruction_Access  = Sim_Gen_Spr_Instruction_Access,
        Sim_PPC_Spr_Attribute_Access    = Sim_Gen_Spr_Attribute_Access,
        Sim_PPC_Spr_Int_Register_Access = Sim_Gen_Spr_Int_Register_Access
} gen_spr_access_type_t;</pre><p>

</p><p>
   Both the get and the set functions must return one of these enum values:
</p><p>
   
</p><pre class="jdocu_small">typedef enum {
        Sim_Gen_Spr_Ok,        /* SPR access was OK */
        Sim_Gen_Spr_Illegal,   /* SPR access should trigger illegal insn exc */
        Sim_Gen_Spr_Privilege, /* SPR access should trigger privilege exc */

        Sim_Gen_Spr_Processor_Sleeps, /* SPR access suspends the processor */

        /* For compatibility with former PPC-only implementation */
        Sim_PPC_Spr_Ok        = Sim_Gen_Spr_Ok,
        Sim_PPC_Spr_Illegal   = Sim_Gen_Spr_Illegal,
        Sim_PPC_Spr_Privilege = Sim_Gen_Spr_Privilege
} gen_spr_ret_t;</pre><p>

</p><p>
   If <i>privilege_checks</i> is not zero, Simics will do privilege
   checks when a mfspr/mtspr instruction is executed. If this does not produce
   the desired results, you can register the SPR handlers with
   <i>privilege_checks</i> set to zero, and do you own checks in your
   handlers.
</p><p>
   The function <b><i>unregister_spr_user_handlers</i></b> will remove any
   registered user handlers for a particular SPR.
</p><p>
   The function <b><i>spr_set_target_value</i></b> should be called from the get
   function. The <i>value</i> will be written to the target register
   for instruction accesses, and returned for attribute and int register
   interface accesses. If this function is not called, the target register is
   not changed for instruction accesses (and the mfspr thus acts as a nop).
</p><p>
   The functions <b><i>spr_stash_value</i></b> and <b><i>spr_fetch_value</i></b> can
   be used to store a SPR value in the processor. This is useful if only the
   getter (or only the setter) has been overridden with a user handler.
</p><p>
   Sometimes it may be desirable to let the processor take care of the access.
   The functions <b><i>spr_default_getter</i></b> and
   <b><i>spr_default_setter</i></b> exist for this purpose.
</p><p>
   The function <b><i>spr_get_name</i></b> takes <i>spr_number</i>
   as parameter and returns the name of the SPR.
</p><p>
   The function <b><i>spr_get_number</i></b> takes the <i>spr_name</i>
   and returns the SPR number, or -1 if the register does not exist.
</p><p>
   Note that the following registers cannot be overridden with user handlers:
   <em>xer</em>, <em>lr</em> and <em>ctr</em>.
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem"><table>

   <tbody><tr><td class="jdocu_noborder"><code>register_user_handlers</code></td>
       <td class="jdocu_noborder">Global Context</td></tr>

   <tr><td class="jdocu_noborder"><code>unregister_user_handlers</code></td>
       <td class="jdocu_noborder">Global Context</td></tr>

   <tr><td class="jdocu_noborder"><code>set_target_value</code></td><td class="jdocu_noborder">Cell Context</td></tr>

   <tr><td class="jdocu_noborder"><code>stash_value</code></td><td class="jdocu_noborder">Cell Context</td></tr>

   <tr><td class="jdocu_noborder"><code>fetch_value</code></td><td class="jdocu_noborder">Cell Context</td></tr>

   <tr><td class="jdocu_noborder"><code>default_getter</code></td><td class="jdocu_noborder">Cell Context</td></tr>

   <tr><td class="jdocu_noborder"><code>default_setter</code></td><td class="jdocu_noborder">Cell Context</td></tr>

   <tr><td class="jdocu_noborder"><code>get_name</code></td><td class="jdocu_noborder">Cell Context</td></tr>

   <tr><td class="jdocu_noborder"><code>get_number</code></td><td class="jdocu_noborder">Cell Context</td></tr>

   </tbody></table>
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_telemetry.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_telemetry.html:__rm_interface_telemetry">telemetry</a></h1>
<p>

<a id="__rm_interface_telemetry.html:telemetry"></a><a id="__rm_interface_telemetry.html:telemetry_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>telemetry</code> interface is used to fetch telemetry
  data.
<p>
  A model implements one or more telemetry-classes.
  These are identified by an identifier (class ID) and a name.
  The telemetries also has a name and an identifier (telemetry ID).
</p><p>
  This layout forms a two level hierarchy with classes and their telemetries.
  The class and telemetry ID's are represented as integers and must be part of a
  contiguous range starting from zero, i.e., the hierarchy can be viewed as a table
  with telemetries, where the row numbers (&gt;= 0), represents the class ID's, and the
  column numbers (&gt;=0) represents the telemetry ID's.
  For unknown ID's NULL should be returned.
</p><p>
  Both telemetry_class_id and telemetry_id can be enumerated using the functions
  get_telemetry_class_name and get_telemetry_name by starting with an ID
  of zero and go upp until NULL is returned.
  A model should not log an error when an invalid ID is presented (but logging
  info on level 3 makes sense for debug purposes).
  Error handling for missing expected telemetry IDs should be handled in the model
  requesting and retrieving the telemetry value.
</p><p>
  The <b><i>get_telemetry_class_id</i></b> function returns the telemetry_class_id
  for the telemetry class with name <i>telemetry_class_name</i>.
  If no telemetry class with that name is found or that telemetry class is not enabled
  a negative number is returned.
</p><p>
  The <b><i>get_telemetry_class_name</i></b> returns the name of the corresponding
  <i>telemetry_class_id</i>. If no telemetry class is found with that id the value
  NULL is returned.
</p><p>
  The <b><i>get_telemetry_class_description</i></b> can return a description string for the
  <i>telemetry_class_id</i>. If no telemetry class is found with that id the value
  NULL is returned.
</p><p>
  The <b><i>get_telemetry_id</i></b> function returns the telemetry_id for the telemetry
  with name <i>telemetry_name</i> belonging to <i>telemetry_class_id</i>.
  If no telemetry with that name is found in the telemetry class a negative number is
  returned.
</p><p>
  The <b><i>get_telemetry_name</i></b> returns the name of the corresponding
  <i>telemetry_id</i> belonging to <i>telemetry_class_id</i>. If no telemetry
  with that id is found in the telemetry class the value NULL is returned.
</p><p>
  The <b><i>get_telemetry_description</i></b> can return a description string for the
  <i>telemetry_id</i> belonging to <i>telemetry_class_id</i>. If no telemetry
  with that id the value is found NULL is returned.
</p><p>
  The <b><i>get_value</i></b> function returns the value for the <i>telemetry_id</i>
  within <i>telemetry_class_id</i>.
</p><p>
  Note all known telemetry_classes are not always enabled in all models,
  i.e. <b><i>get_telemetry_class_name</i></b> can return a valid name for some
  <i>telemetry_class_id</i> but <b><i>get_telemetry_id</i></b> on that name may still
  return an invalid identifier if that telemetry_class is not enabled in the model.
</p><p>
  Note that the identifiers may vary between invocations of the model and must not be
  stored between runs.
</p><p>
  The command <b>list-telemetry-classes</b> can be helpful while developing with
  the telemetry-interface.
</p><p>
   
</p><pre class="jdocu_small">typedef int telemetry_class_id_t;</pre><p>

   
</p><pre class="jdocu_small">typedef int telemetry_id_t;</pre><p>

  </p><pre class="jdocu_small">SIM_INTERFACE(telemetry) {
        telemetry_class_id_t (*get_telemetry_class_id)(conf_object_t *obj,
                                                       const char *telemetry_class_name);
        const char *(*get_telemetry_class_name)(conf_object_t *obj,
                                                telemetry_class_id_t telemetry_class_id);
        const char *(*get_telemetry_class_description)(conf_object_t *obj,
                                                      telemetry_class_id_t telemetry_class_id);
        telemetry_id_t (*get_telemetry_id)(conf_object_t *obj,
                                           telemetry_class_id_t telemetry_class_id,
                                           const char *telemetry_name);
        const char *(*get_telemetry_name)(conf_object_t *obj,
                                          telemetry_class_id_t telemetry_class_id,
                                          telemetry_id_t telemetry_id);
        const char *(*get_telemetry_description)(conf_object_t *obj,
                                                 telemetry_class_id_t telemetry_class_id,
                                                 telemetry_id_t telemetry_id);
        attr_value_t (*get_value)(conf_object_t *obj,
                                  telemetry_class_id_t telemetry_class_id,
                                  telemetry_id_t telemetry_id);
};

#define TELEMETRY_INTERFACE "telemetry"

</pre><p>
</p><p>

  
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Global Context for all methods.
  
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_transaction_translator.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_transaction_translator.html:__rm_interface_transaction_translator">transaction_translator</a></h1>
<p>

<a id="__rm_interface_transaction_translator.html:transaction_translator"></a><a id="__rm_interface_transaction_translator.html:transaction_translator_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>transaction_translator</code> interface is implemented by
   objects which would like to inspect and/or modify transactions
   before forwarding them to devices or address spaces. In Simics documentation,
   such objects are usually called translator objects or, simply, translators.
   In comparison with the simpler <code>translator</code> interface,
   the <code>transaction_translator</code> interface provides
   an opportunity to inspect/modify transactions. We recommend
   using the <code>translator</code> interface when the additional
   functionality is not needed.
<p>
   The interface has one method called <b><i>translate</i></b>. The arguments
   passed to this method describe the access and thus allow
   a translator to perform a proper translation. Here is a short description of
   the <b><i>translate</i></b> method's parameters:<br>
   - <i>addr</i> is an address of the access;<br>
   - <i>access</i> is a bitmask specifying all requested
   access types;<br>
   - <i>t</i> is a transaction;<br>
   - <i>callback</i> is a callback that should be called by
   the object implementing the interface;<br>
   - <i>data</i> should be passed to <i>callback</i>
   as it is when the callback is invoked by the translator object.<br>
   All these arguments are described in detail below.
</p><p>
   The transactions done by the translators may be cached by Simics.
   To ensure efficient flushing of Simics internal caches we recommend
   that the objects implementing the <code>transaction_translator</code>
   interface implement also the <code>translation_flush</code> interface.
   The absence of the <code>translation_flush</code> interface may lead to
   a substantial decrease of simulation speed.
</p><p>
   Whenever a previously returned translation becomes invalid the translator
   objects are expected to use either <b><i>SIM_map_target_flush</i></b>
   (preferably) or <b><i>SIM_translation_changed</i></b> function to ensure that
   Simics will flush any cached translations. Please refer to the documentation
   of these functions for the information about how they should be used.
</p><p>
   An object implementing the <code>transaction_translator</code> interface
   should invoke <i>callback</i> passing to it tree arguments:
   <i>translation</i>, <i>transaction</i>
   and <i>data</i>. The <i>translation</i> argument
   describes the translation that was done, i.e. the transaction destination.
   Please refer to the <code>translation_t</code> documentation
   for the complete description.
   The <i>transaction</i> argument is either the original
   transaction passed to the <code>transaction_translator</code> interface
   or, if a translator object wants to append atoms to the <i>t</i>
   transaction, a new transaction created via transaction chaining.
   The transaction chaining is described in detail in the "Transaction Chaining"
   chapter of the <em>Model Builder's User Guide</em>. Finally, the
   <i>data</i> argument is a parameter which should be passed as it is
   when <i>callback</i> is invoked by the translator object.
   Simics will report an error if a translator object doesn't invoke
   <i>callback</i> from the <b><i>translate</i></b> method
   of the <code>transaction_translator</code>.
</p><p>
   If it is needed, a translator may route transactions based on the value of
   certain <i>transaction</i>'s atoms. The <code>initiator</code> atom
   is a good example of such an atom. Please note that not all atoms are suited
   for routing transactions based on their value. This should be checked
   in the documentation for the specific atom.
</p><p>
   The <i>callback</i> function returns transaction completion status.
   This status should be usually returned as it is by the <b><i>translate</i></b>
   method. The status value is also needed in the case when a translator object
   appends atoms via transaction chaining with a non-zero
   <code>completion</code> atom. In that case the returned status should be used
   when the <b><i>SIM_monitor_chained_transaction</i></b> function is called.
</p><p>
   Please note that memory accesses in Simics are not always issued with
   the transactions of the <code>transaction_t</code> type.
   For example, memory access can be done with the use of
   the legacy <code>generic_transaction_t</code> type.
   One more such example is lookup accesses which are done
   via the <code>direct_memory_lookup</code> interface. All such accesses
   are converted, if it is needed, and presented to the translator object via
   the <i>t</i> parameter.
</p><p>
   The <i>access</i> parameter specifies access
   types in the form of a bitmask. Its value may be of interest
   if a translation is done differently based on whether it is
   a read, write or instruction fetch transaction. It can be noted
   that a transaction itself already contains information
   whether it is a read, write or an instruction fetch.
   Usually, the <i>access</i> parameter just reflects that value.
   However, for lookup accesses done via
   the <code>direct_memory_lookup</code> interface
   the <i>access</i> argument may have more bits set. If a translation
   which are valid for all requested accesses cannot be performed, then
   a null value should be set in the <i>target</i> of
   the <i>translation</i>
   argument passed to <i>callback</i>. In this case, the requestor is
   expected to repeat the interface call with just a single bit set
   in the access mask, e.g. <code>Sim_Access_Read</code>.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(transaction_translator) {
        exception_type_t (*translate)(
                conf_object_t *NOTNULL obj,
                uint64 addr,
                access_t access,
                transaction_t *t,
                exception_type_t (*NOTNULL callback)(
                        translation_t translation,
                        transaction_t *transaction,
                        cbdata_call_t data),
                cbdata_register_t data);
};

#define TRANSACTION_TRANSLATOR_INTERFACE "transaction_translator"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_translate.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_translate.html:__rm_interface_translate">translate</a></h1>
<p>

<a id="__rm_interface_translate.html:translate"></a><a id="__rm_interface_translate.html:translate_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>translate</code> interface is implemented by objects
   that bridge between memory spaces.
<p>
   </p><div class="note">
<b>Note:</b>
There is the <code>translator</code> interface
   which is a more restricted version
   of the <code>translate</code> interface and should be used when possible.
   It allows for better control of memory operations in the Simics core and can
   therefore allow optimizations in the memory handling.  </div>The return value of the <b><i>translate</i></b> method should be
   a memory space, to which the
   access is translated at the offset given by the physical address of
   <i>mem_op</i>. If the return value is <code>NULL</code>, then the access
   is translated to the <em>default target</em> provided in the configuration
   (in a <b>memory-space</b> object, this is the 6th index,
   <em>target</em>, of an entry in the <i>map</i> attribute).
<p>
   If the translator marks <i>mem_op</i> as ignored before returning
   <code>NULL</code> (using the function <b><i>SIM_set_mem_op_ignore</i></b>), then
   the return value is ignored, and the transaction is instead terminated in
   the translator and handled as an ordinary I/O access.
</p><p>
   During a translation, the translator may modify the physical address of
   <i>mem_op</i>, but may have no other side-effects. This is because
   the caller can choose to cache the translation, in which case the translator
   is bypassed in subsequent accesses.
</p><p>
   The translator can use <b><i>SIM_mem_op_ensure_future_visibility</i></b> to
   inhibit caching. Inhibiting caching can be useful for debugging, but
   typically comes with a significant performance cost if there is RAM behind
   the translator.
</p><p>
   The addition of the <code>direct_memory</code> interface in Simics 5
   results in new typical access patterns for the <code>translate</code>
   interface. Where previously non-inquiry accesses of any size would result in
   caching in initiating CPU objects, with the use of
   <code>direct_memory</code> no such implicit caching ever takes
   place. Instead, caching requests are separate and fed through the
   <b><i>translate</i></b> method as inquiry accesses of the size that is intended
   to be cached. This means that for a <code>translate</code> object to work
   properly in a configuration with CPUs using <code>direct_memory</code>,
   inquiry accesses must be properly handled. Routing such inquiry accesses to
   non-memory, terminating them in the translator (which is not an allowed
   behavior for a <code>translate</code> object), or calling
   <b><i>SIM_mem_op_ensure_future_visibility</i></b> on them results in the
   requesting CPU not being able to cache the requested memory region.
</p><p>
   Using the <code>translate</code> interface in models is error prone
   and usually not recommended unless all alternatives have been
   exhausted. Explicit map and demap operations in a memory space avoid the
   problems with <code>translate</code> interface implementation
   correctness.
</p><p>
   The usage of the <code>translate</code> interface is by necessity
   less optimal than the usage of the <b>memory-space</b> class as
   a call out from the simulation kernel should be made. That said when
   the <b><i>translate()</i></b> method is called the transaction may be cached
   in the STC if the user code does not explicitly block such caching, though
   depending on a number of factors it may not always be cached. If the
   translation is cached in the STC then performance is the same as with a
   memory-space.
</p><p>
   There are two reasons to use the translate interface rather than a simple 
   memory-space: 1) To implement something that the memory-space does not
   support, such as different read and write translations, or manipulation of
   the transaction, or 2) the translation is accessed infrequently, but updated
   on most accesses.
</p><p>
   </p><div class="note">
<b>Note:</b>
Up to and including Simics 4.8, inhibiting caching for the instruction
   stream did not prevent Simics-provided CPU models from caching. Models
   therefore had to use <b><i>flush</i></b> or <b><i>SIM_flush_cell_caches</i></b> on
   mapping changes to get the desired effect. This is no longer needed since
   Simics 5.</div>Up to and including Simics 4.8, CPU models would cache memory for
   transactions that pass through a translator in blocks that are larger than
   the size provided in the transaction. This meant that a translator needed to
   invalidate caches even if a translation changed that had strictly not passed
   through the interface. For correctness, when any state that had an effect on
   the translation logic changed, the translator would therefore invalidate all
   mappings in all initiators, even for mappings that are outside of what has
   passed through the translator. These types of workarounds are no longer
   required since Simics 5.
<p>
   </p><pre class="jdocu_small">SIM_INTERFACE(translate) {
        conf_object_t *(*translate)(conf_object_t *NOTNULL obj,
                                    generic_transaction_t *NOTNULL mem_op,
                                    map_info_t mapinfo);
};

#define TRANSLATE_INTERFACE "translate"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_translation_flush.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_translation_flush.html:__rm_interface_translation_flush">translation_flush</a></h1>
<p>

<a id="__rm_interface_translation_flush.html:translation_flush"></a><a id="__rm_interface_translation_flush.html:translation_flush_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>translation_flush</code> interface is an optional interface
   which can be implemented by objects implementing the
   <code>transaction_translator</code> or <code>translator</code> interface.
   The interface is used
   by Simics an optimization when Simics flushes its simulation caches.
   Simics caches translations returned by translators but
   quite often this cache needs to be invalidated, usually, due to
   the changes in the memory map of the target system. In such cases
   Simics may use this interface (if it is available) to do a fine-grain
   invalidation of its simulation caches.
<p>
   The <code>translation_flush</code> interface has one method
   - <b><i>flush_range</i></b> - which will be called whenever there is
   a need to flush simulation caches. The <b><i>flush_range</i></b> method
   has the following parameters:<br>
   - <i>base</i> is the start of the region to flush;<br>
   - <i>size</i> is the size of the region to flush;<br>
   - <i>access</i> is a bitmask which specifies targets
   for what access types should be flushed;<br>
   - <i>default_target</i> is only used for translators implementing
   the <code>translator</code> interface and has the same as value as
   the <i>default_target</i> parameter of
   the <b><i>translate</i></b> method of the <code>translator</code> interface.
   Please see the documentation of the <code>translator</code> for more
   information about the parameter.
</p><p>
   In the <b><i>flush_range</i></b> method, the translator object is expected
   to flush all previously returned destinations of the translation requests
   that the translator did for
   the [<i>base</i>, <i>base</i>+<i>size</i>) range.
   The flushing is done by calling the <b><i>SIM_map_target_flush</i></b> function
   for the destination map target(s). If no translation requests were processed
   to the range since the last invocation of the <b><i>flush_range</i></b> method
   then no flushing is needed, and the <b><i>flush_range</i></b> may immediately
   return the <code>true</code> value.
</p><p>
   Please note that there is no need to call
   the <b><i>SIM_map_target_flush</i></b> function for the translations which
   were tagged with the <code>Sim_Translation_Dynamic</code> flag. Either,
   no invalidation is needed for the parts of the range where nothing is mapped.
</p><p>
   The return value is used to report whether the invalidation request
   completed successfully, i.e. whether all calls to
   the <b><i>SIM_map_target_flush</i></b> function succeeded (i.e. returned
   the <code>true</code> value). If a call to
   the <b><i>SIM_map_target_flush</i></b> fails (i.e.
   the <code>false</code> value is returned) then
   the <b><i>flush_range</i></b> function is expected to
   return immediately with the <code>false</code> return value. If, for
   some reason, the translator cannot invalidate all possible destinations,
   then it can just immediately return the <code>false</code> value.
</p><p>
   If <code>false</code> is returned, then all translations in the simulator
   will typically be flushed, which could be an expensive operation.
</p><p>
   </p></dd><dt class="jdocu_descitem">EXAMPLE</dt><dd>
Here is pseudo code providing a sample implementation of
   the flush_range method:
   <pre class="jdocu_small">   bool flush_range(obj, base, size, access):
       for (map_target, start, size) in destinations(obj, base, size, access):
           if not SIM_map_target_flush(map_target, start, size, access):
               return False
       return True
   </pre><p>
   </p></dd>
<pre class="jdocu_small">SIM_INTERFACE(translation_flush) {
        bool (*flush_range)(
                conf_object_t *obj,
                uint64 base,
                uint64 size,
                access_t access,
                const map_target_t *default_target);
};

#define TRANSLATION_FLUSH_INTERFACE "translation_flush"
</pre><p>
</p><p>
   

</p><dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_translator.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_translator.html:__rm_interface_translator">translator</a></h1>
<p>

<a id="__rm_interface_translator.html:translator"></a><a id="__rm_interface_translator.html:translator_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>translator</code> interface is implemented by
   objects which perform address translations or map
   memory transactions to devices or address spaces.
<p>
   The <b><i>translate</i></b> method takes a physical address
   <i>addr</i> and returns a value of the type
   <code>translation_t</code> which describes the translation for
   an address range which must include <i>addr</i>. Please
   refer to the <code>translation_t</code> documentation for a complete
   description of the return value and more information regarding
   the implementation of translator objects.
</p><p>
   A translator can translate read transactions, write transactions
   and instruction fetches differently. The <i>access</i> parameter
   is set to all requested access types in the form of a bitmask.
   The translator should return null in the <i>target</i> field
   if a translation valid for all requested accesses cannot be performed;
   when this happens, the requestor is expected to repeat the interface call
   with just a single bit set in the access mask,
   e.g. <code>Sim_Access_Read</code>.
</p><p>
   The <i>default_target</i> parameter is a default target,
   which can be NULL, of the translator mapping (i.e.,
   the <i>target</i> field of the respective <b>memory-space</b>'s
   map entry specifying mapping).
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(translator) {
        translation_t (*translate)(conf_object_t *NOTNULL obj,
                                   physical_address_t addr,
                                   access_t access,
                                   const map_target_t *default_target);
};

#define TRANSLATOR_INTERFACE "translator"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_usb.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_usb.html:__rm_interface_usb">usb</a></h1>
<p>

<a id="__rm_interface_usb.html:usb"></a><a id="__rm_interface_usb.html:usb_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>usb_interface_t</code> interface is implemented by all
   USB hosts. USB devices use the interface to communicate with the
   USB host.  The interface is Simics internal, and may be changed in
   future versions of Simics.  It should not be used by user-defined
   classes.
<p>
   The <b><i>connect_device()</i></b> function is called by the USB device to
   connect to the USB. The host returns the physical port to which the device
   is connected, or <code>-1</code> on connection error (for example, if all ports
   are occupied). Parameter to <b><i>connect_device()</i></b> is the maximum
   data speed for the USB device.
</p><p>
   The <b><i>disconnect_device()</i></b> function is called by the USB device when
   it wants to disconnect from the USB. The host returns <code>0</code> on success.
</p><p>
   The <b><i>complete_transfer()</i></b> function is called by a USB device when
   it has completed a transfer. Refer to the <code>usb_device_t</code>
   interface documentation to know more about how a transfer is sent to the USB
   device.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(usb) {
        int (*connect_device)(conf_object_t *bus_obj,
                              conf_object_t *NOTNULL dev_obj,
                              usb_speed_t speed);
        int (*disconnect_device)(conf_object_t *bus_obj,
                                 conf_object_t *NOTNULL dev_obj);
        void (*complete_transfer)(conf_object_t *bus_obj,
                                  conf_object_t *NOTNULL dev_obj,
                                  usb_transfer_t *NOTNULL transfer);
};

#define USB_INTERFACE "usb"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem"><table>

   <tbody><tr><td class="jdocu_noborder"><b><i>connect_device</i></b></td><td class="jdocu_noborder">Global Context</td></tr>

   <tr><td class="jdocu_noborder"><b><i>disconnect_device</i></b></td>
       <td class="jdocu_noborder">Global Context</td></tr>

   <tr><td class="jdocu_noborder"><b><i>complete_transfer</i></b></td><td class="jdocu_noborder">Cell Context</td></tr>

   </tbody></table>
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_usb_device.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_usb_device.html:__rm_interface_usb_device">usb_device</a></h1>
<p>

<a id="__rm_interface_usb_device.html:usb_device"></a><a id="__rm_interface_usb_device.html:usb_device_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>usb_device_interface_t</code> interface is implemented
   by all USB devices. It is used by the USB host to communicate with
   the USB devices.  The interface is Simics internal, and may be
   changed in future versions of Simics.  It should not be used by
   user-defined classes.
<p>
   The <b><i>submit_transfer()</i></b> function is used by the USB host controller
   to send a new transfer to a USB device. Transfers are the basic means of
   communication between the USB host controller and the USB devices. A
   transfer contains all information needed to handle control, bulk, interrupt,
   and isochronous transfers. A transfer to a USB device simply moves the
   control from the USB host to the USB device. The USB device can then
   decide when to send back any useful data to the USB host.  The USB device
   receives a pointer to the transfer to handle. It can either handle the
   transfer immediately or send the transfer back later using the
   <b><i>complete_transfer()</i></b> function in the
   <code>usb_interface_t</code> interface, which is implemented by the USB
   host.
</p><p>
   The USB device must return <code>USB_Transfer_Completed</code> when it
   handles the transfer immediately, i.e., it has filled the required fields in
   the transfer structure. The USB device must return
   <code>USB_Transfer_Not_Ready</code> for unfinished transfers, i.e., the
   USB device does not have any interesting data to deliver at this point. The
   isochronous and interrupt transfers contain a field indicating how long time
   the USB host expects the USB device to wait before returning the
   transfer. Note that it is just an indication on how often this transfer is
   scheduled in the periodic list and USB devices can complete the transfers at
   any time. A value of <code>0</code> means that the USB host does have any
   expectations about the return time.
</p><p>
   The <b><i>abort_transfer()</i></b> function tells the USB device to abort a
   transfer previously issued by the USB host. The USB device should not call
   the <b><i>complete_transfer()</i></b> function for a request that has been
   aborted.
</p><p>
   The <b><i>reset()</i></b> function is used by the USB host to reset the USB
   device.
</p><p>
   The USB host expects the device to return the same transfer pointer it
   received when completing, i.e., the transfer pointer is used to identify
   uniquely a transfer.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(usb_device) {
        usb_transfer_completion_t (*submit_transfer)(conf_object_t *dev_obj,
                                                     usb_transfer_t *transfer);
        void (*abort_transfer)(conf_object_t *dev_obj,
                               usb_transfer_t *transfer);
        void (*reset)(conf_object_t *dev_obj);
};

#define USB_DEVICE_INTERFACE "usb_device"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_vectored_interrupt.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_vectored_interrupt.html:__rm_interface_vectored_interrupt">vectored_interrupt</a></h1>
<p>

<a id="__rm_interface_vectored_interrupt.html:vectored_interrupt"></a><a id="__rm_interface_vectored_interrupt.html:vectored_interrupt_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This interface is typically implemented by processors with interrupts
   that have vectors and priorities supplied by their sources.
<p>
   The <b><i>set_level()</i></b> method sets the interrupt level on the target
   object; zero indicates that no interrupt is requested. The interrupt source
   should implement the <code>vectored_interrupt_source</code> interface.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(vectored_interrupt) {
        void (*set_level)(conf_object_t *NOTNULL obj,
                          conf_object_t *NOTNULL source, int level);
};
#define VECTORED_INTERRUPT_INTERFACE "vectored_interrupt"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_vectored_interrupt_source.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_vectored_interrupt_source.html:__rm_interface_vectored_interrupt_source">vectored_interrupt_source</a></h1>
<p>

<a id="__rm_interface_vectored_interrupt_source.html:vectored_interrupt_source"></a><a id="__rm_interface_vectored_interrupt_source.html:vectored_interrupt_source_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This interface is implemented by interrupt sources that use the
   <code>vectored_interrupt</code> interface.
<p>
   The <b><i>acknowledge()</i></b> method is called to acknowledge a requested
   interrupt of the given level on the interrupt target. It should return
   an interrupt vector number, -1 if no vector is supplied, or -2 if
   the object does not accept the acknowledgement.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(vectored_interrupt_source) {
        int (*acknowledge)(conf_object_t *NOTNULL obj,
                           conf_object_t *NOTNULL target, int level);
};
#define VECTORED_INTERRUPT_SOURCE_INTERFACE "vectored_interrupt_source"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_virtiofs_fuse.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_virtiofs_fuse.html:__rm_interface_virtiofs_fuse">virtiofs_fuse</a></h1>
<p>

<a id="__rm_interface_virtiofs_fuse.html:virtiofs_fuse"></a><a id="__rm_interface_virtiofs_fuse.html:virtiofs_fuse_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This interface is intended for implementing a FUSE request handler.
<p>
   <b><i>handle_request</i></b> This method takes a FUSE request in <i>req
   </i>. It then returns a buffer_t object with the FUSE response. The
   caller of handle_request must free the data field in the returned buffer_t
   object.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(virtiofs_fuse)
{
        buffer_t (*handle_request)(conf_object_t * obj, bytes_t req);
};

#define VIRTIOFS_FUSE_INTERFACE "virtiofs_fuse"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_vmp.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_vmp.html:__rm_interface_vmp">vmp</a></h1>
<p>

<a id="__rm_interface_vmp.html:vmp"></a><a id="__rm_interface_vmp.html:vmp_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>vmp</code> interface is used to control enabling of VMP and VMP
   features from a user perspective. Models should use
   <code>x86_vmp_control</code> for potential blocking of VMP.
<p>
   This is an internal interface between VMP and the Simics Base package, and
   it may change at any time without notice.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(vmp) {
        bool (*class_has_support)(conf_object_t *obj);
        bool (*host_support)(conf_object_t *obj);
        bool (*compatible_config)(conf_object_t *obj);
        bool (*enable)(conf_object_t *obj);
        void (*disable)(conf_object_t *obj);
        bool (*enabled)(conf_object_t *obj);
        void (*set_threshold)(conf_object_t *obj, int threshold);
        bool (*get_feature)(conf_object_t *obj, vmp_feature_t feature);
        bool (*set_feature)(conf_object_t *obj, vmp_feature_t feature, bool val);
        uint64 (*get_info)(conf_object_t *obj, vmp_info_t info);
};
#define VMP_INTERFACE "vmp"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_vmx_instrumentation_subscribe.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_vmx_instrumentation_subscribe.html:__rm_interface_vmx_instrumentation_subscribe">vmx_instrumentation_subscribe</a></h1>
<p>

<a id="__rm_interface_vmx_instrumentation_subscribe.html:vmx_instrumentation_subscribe"></a><a id="__rm_interface_vmx_instrumentation_subscribe.html:vmx_instrumentation_subscribe_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This x86 specific interface allows a user to keept track of VMX mode
   switches in the processor.
<p>
   The <b><i>register_vmx_mode_leave_cb</i></b> registers a callback of type
   <code>vmx_mode_switch_cb_t</code> that will be called before the processor
   leaves a particular VMX mode.
</p><p>
   The <b><i>register_vmx_mode_enter_cb</i></b> registers a callback of type
   <code>vmx_mode_switch_cb_t</code> that will be called after the processor
   enters a particular VMX mode.
</p><p>
   The callback in both cases looks like this:
   
   This callback type is used by the
   <code>vmx_instrumentation_subscribe</code> to implements VMX mode switch
   instrumentation.
   
</p><pre class="jdocu_small">typedef void (*vmx_mode_switch_cb_t)(
        conf_object_t *obj, conf_object_t *cpu,
        vmx_mode_t mode,
        physical_address_t vmcs_address,
        lang_void *user_data);</pre><p>

</p><p>
   The <i>obj</i> argument is the user object that registered the
   callback, or NULL if no such object exists.
</p><p>
   The <i>cpu</i> argument is the processor that switches VMX mode.
</p><p>
   The mode that will be left or entered is passed in the
   <i>mode</i> argument in the callback.
</p><p>
   The different VMX modes are defined in the following type:
    This enum is used to distinguish VMX modes. It is
   used by the <code>vmx_mode_switch_cb_t</code>.
   
</p><pre class="jdocu_small">typedef enum {
        Vmx_Off = 0,
        Vmx_Root = 1,
        Vmx_Non_Root = 2
} vmx_mode_t;</pre><p>

</p><p>
   The <i>vmcs_address</i> argument specifies the Virtual Machine Control
   Structure address that is currently being used. If not available, it will be
   passed as (physical_address_t)(-1).
</p><p>
   When leaving a mode and then entering another mode, the mode can actually be
   reported as to be the same in certain situations. This is not a bug, it is a
   consequent of how Simics is implemented. It would require a lot of extra code
   to filter those out.
</p><p>
   The <i>user_data</i> argument is the callback user data, passed to the
   register methods.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(vmx_instrumentation_subscribe) {
        cpu_cb_handle_t *(*register_vmx_mode_leave_cb)(
                conf_object_t *cpu,
                conf_object_t *connection,
                vmx_mode_switch_cb_t cb,
                lang_void *user_data);
        cpu_cb_handle_t *(*register_vmx_mode_enter_cb)(
                conf_object_t *cpu,
                conf_object_t *connection,
                vmx_mode_switch_cb_t cb,
                lang_void *user_data);
};

#define VMX_INSTRUMENTATION_SUBSCRIBE_INTERFACE \
        "vmx_instrumentation_subscribe"
</pre><p>
</p><p>

   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Global Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_x86.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_x86.html:__rm_interface_x86">x86</a></h1>
<p>

<a id="__rm_interface_x86.html:x86"></a><a id="__rm_interface_x86.html:x86_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The x86 interface exports functionality used by several other objects to
   interact with the processor. The <b><i>set_pin_status</i></b> function is used
   to set/clear certain processor pins.
<p>
   <a id="__rm_interface_x86.html:x86_pin_t"></a>
    
</p><pre class="jdocu_small">typedef enum {
        Pin_Init,
        Pin_Smi,
        Pin_Nmi,
        Pin_Ignne,
        Pin_Mcerr,
        Pin_Cmci
        /* Do not add new pins. Instead, define individual signal ports */
} x86_pin_t;</pre><p>

</p><p>
   The <b><i>start_up</i></b> function is used by the local APIC to bring the
   processor <i>obj</i> out of the waiting for start-up IPI state, with a
   start address of <i>start_address</i>.
</p><p>
   The <b><i>interrupt</i></b> function tells the CPU that an interrupt is
   waiting. The interrupt vector number is given by the <i>ack</i> callback
   function. It is not allowed to call the <i>ack</i> callback during the
   <b><i>interrupt</i></b> call itself. The <i>data</i> object should
   implement the <code>interrupt_cpu</code> interface. Note that the
   <code>interrupt_cpu</code> interface defines the <i>ack</i> function,
   which should be the same as the <i>ack</i> argument. It is recommended
   that new implementations does not use rely on the <i>ack</i> argument,
   but rather looks up the callback through the <code>interrupt_cpu</code>
   interface from the object given by the <i>data</i> argument. The
   <b><i>interrupt</i></b> function returns 1 if the interrupt is accepted, and 0
   if it is not accepted because there is already an interrupt queued up to be
   processed. If 0 is returned, the caller should retry the call after one
   step. It should wait one step since the handling of an interrupt takes one
   step.
</p><p>
   If a checkpoint was taken when an interrupt was waiting, the acknowledge
   callback function can be recovered by looking up the
   <code>interrupt_cpu</code> interface at the APIC object given in the
   <i>data</i> parameter.
</p><p>
   If the interrupt was cancelled before it was acknowledged, the
   <b><i>uninterrupt</i></b> function is used. It is also called by the
   acknowledge callback. Thus, each invocation of <b><i>interrupt</i></b> is
   followed by exactly one call to <b><i>uninterrupt</i></b> at all times.  The
   <i>ack</i> parameter is unused and should be ignored. When the processor
   is reset, it forgets a waiting interrupt so it is not necessary to call
   <b><i>uninterrupt</i></b> during a reset.
</p><p>
   The functions in the <code>interrupt_ack</code> interface provides almost
   the same functionality as the <b><i>interrupt</i></b> and
   <b><i>uninterrupt</i></b> functions in this interface. The only difference is
   that the <b><i>interrupt</i></b> function in this interface returns 0 when the
   interrupt cannot be handled which allows the device to retry later.
</p><p>
   The <b><i>has_pending_interrupt</i></b> and <b><i>has_waiting_interrupt</i></b>
   calls should return information about interrupts in progress. An interrupt
   is said to be pending if it is acked by the processor and will be taken
   before execution of the next instruction. An interrupt is waiting if the
   logical interrupt line is high, but the interrupt has not yet been
   acked. These functions are used for sanity checks by the APIC. The APIC
   should keep track of posted interrupts by itself. These functions return 1
   if an interrupt is pending/waiting, and 0 otherwise.
</p><p>
   The <b><i>logical_to_linear</i></b> function returns the translated linear
   address from the given logical address and segment register number. The
   function uses the current content of control registers and segment registers
   to calculate the linear address. The tagged return value is marked invalid
   if no valid translation exists, for example if the passed logical address is
   beyond the segment limit of the passed segment or if it is
   non-canonical. The encoding of <i>segment</i> is 0 for ES, 1 for CS, 2
   for SS, 3 for DS, 4 for FS, and 5 for GS.
</p><p>
   The <b><i>linear_to_physical</i></b> function returns the physical address
   corresponding to the given linear <i>address</i>. The function uses the
   current content of control registers, TLBs and possibly page tables to
   calculate the physical address. A return value of -1 signals that no valid
   mapping exists.
</p><p>
   <b><i>enter_acpi_c2_state</i></b> is called from the chipset power module to
   request the CPU to enter an energy-saving state.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(x86) {
        void (*set_pin_status)(conf_object_t *obj,
                               x86_pin_t pin, int status);
        void (*start_up)(conf_object_t *obj, uint32 start_address);
        int  (*interrupt)(conf_object_t *obj,
                          int (*ack)(conf_object_t *obj),
                          conf_object_t *data);
        void (*uninterrupt)(conf_object_t *obj,
                            int (*ack)(conf_object_t *obj));
        int  (*has_pending_interrupt)(conf_object_t *obj);
        int  (*has_waiting_interrupt)(conf_object_t *obj);
        tagged_linear_address_t (*logical_to_linear)(conf_object_t *obj,
                                                     int segment,
                                                     logical_address_t addr);
        physical_address_t (*linear_to_physical)(conf_object_t *obj,
                                                 data_or_instr_t d_or_i,
                                                 linear_address_t addr);
        void (*enter_acpi_c2_state)(conf_object_t *obj);
};

#define X86_INTERFACE "x86"
</pre><p>
</p><p>

   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_x86_access_type.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_x86_access_type.html:__rm_interface_x86_access_type">x86_access_type</a></h1>
<p>

<a id="__rm_interface_x86_access_type.html:x86_access_type"></a><a id="__rm_interface_x86_access_type.html:x86_access_type_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This interface is used to query information about the
   <code>x86_access_type_t</code> enum. The <b><i>get_enum_name</i></b> method
   returns the C enum name for the access type. <b><i>get_short_name</i></b>
   returns a corresponding short name. More than one access type may have the
   same short name.  The <b><i>get_description</i></b> returns a longer
   description of the access type.  The <b><i>implicit</i></b> function returns
   true if the access type is considered implicit or false if it is considered
   explicit. This information is used by the
   <code>cpu_instrumentation_subscribe</code> interface to separate accesses
   in the two different categories.
<p>
   </p><pre class="jdocu_small">SIM_INTERFACE(x86_access_type) {
        const char *(*get_enum_name)(conf_object_t *obj, x86_access_type_t at);
        const char *(*get_short_name)(conf_object_t *obj, x86_access_type_t at);
        const char *(*get_description)(conf_object_t *obj, x86_access_type_t at);
        bool (*implicit)(conf_object_t *obj, x86_access_type_t at);
};

#define X86_ACCESS_TYPE_INTERFACE "x86_access_type"
</pre><p>
</p><p>

   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_x86_address_query.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_x86_address_query.html:__rm_interface_x86_address_query">x86_address_query</a></h1>
<p>

<a id="__rm_interface_x86_address_query.html:x86_address_query"></a><a id="__rm_interface_x86_address_query.html:x86_address_query_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>x86_address_query</code> interface is used to query information
   about an address for the x86 architecture and should be used from a
   <b><i>cpu_memory_address_cb_t</i></b> callback.
<p>
   </p><pre class="jdocu_small">SIM_INTERFACE(x86_address_query) {
        x86_seg_t (*segment)(
                conf_object_t *cpu, address_handle_t *handle);
        page_crossing_info_t (*get_page_crossing_info)(
                conf_object_t *cpu, address_handle_t *handle);
};
#define X86_ADDRESS_QUERY_INTERFACE "x86_address_query"        
</pre><p>
</p><p>

   The <b><i>segment</i></b> is used to get the segment register used in the
   address calculation. The <i>handle</i> is the address handle passed to
   <b><i>cpu_memory_address_cb_t</i></b>.
</p><p>
   If the access crosses a page boundary the access will be split into two
   calls. The <b><i>get_page_crossing_info</i></b> can be used to distinguish the
   different cases from each other. The value returned is of type
   <code>page_crossing_info_t</code> and is one of:
   <code>Sim_Page_Crossing_None</code> (no crossing access),
   <code>Sim_Page_Crossing_First</code> (first part of a crossing access),
   <code>Sim_Page_Crossing_Second</code> (second part of a crossing access).
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods, but must be called from a callback
   receiving a handle of type <code>address_handle_t</code>.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_x86_cache_flush.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_x86_cache_flush.html:__rm_interface_x86_cache_flush">x86_cache_flush</a></h1>
<p>

<a id="__rm_interface_x86_cache_flush.html:x86_cache_flush"></a><a id="__rm_interface_x86_cache_flush.html:x86_cache_flush_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The x86 cache flush interface is implemented by objects
   which need to do some special handling when the cpu
   flushes the cache.
<p>
   The <b>flush</b> method is invoked when the cpu 
   executes an <b>invd</b> or a <b>wbinvd</b> instruction.
   The <i>writeback</i> parameter is set for the later instruction.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(x86_cache_flush) {
        void (*flush)(conf_object_t *obj, conf_object_t *cpu, bool writeback);
};
#define X86_CACHE_FLUSH_INTERFACE "x86_cache_flush"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_x86_cpuid.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_x86_cpuid.html:__rm_interface_x86_cpuid">x86_cpuid</a></h1>
<p>

<a id="__rm_interface_x86_cpuid.html:x86_cpuid"></a><a id="__rm_interface_x86_cpuid.html:x86_cpuid_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><pre class="jdocu_small">SIM_INTERFACE(x86_cpuid) {
	cpuid_ret_t (*cpuid)(conf_object_t *obj, conf_object_t *cpu,
                             uint32 in_eax, uint32 in_ebx, uint32 in_ecx,
                             uint32 in_edx);
};
#define X86_CPUID_INTERFACE "x86_cpuid"
</pre><p>
</p><p>

   The CPUID interface makes it possible to customize responses to CPUID
   requests. The <b><i>cpuid</i></b> method should set taken to nonzero if it
   managed to handle the request, zero otherwise. When taken is non-zero,
   then the returned values in out_a, out_b, out_c, and out_d will be
   written to the first four general purpose registers.
   Assigning external handlers to the leaf range reserved for MAGIC instruction
   implementation has no effect, because the MAGIC implementation always takes
   priority.
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_x86_cpuid_query.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_x86_cpuid_query.html:__rm_interface_x86_cpuid_query">x86_cpuid_query</a></h1>
<p>

<a id="__rm_interface_x86_cpuid_query.html:x86_cpuid_query"></a><a id="__rm_interface_x86_cpuid_query.html:x86_cpuid_query_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This interface is implemented by CPUs and can be used to query the values
   that would be returned by the CPUID instruction. The interface calculates
   the return value both from built in default values and from any handlers
   that would be installed using the <code>x86_cpuid</code> interface.
<p>
   This is a preliminary interface. Based on feedback, this interface can and
   will be changed without regard for the usual ABI compatibility rules.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(x86_cpuid_query) {
        cpuid_value_t (*cpuid_query)(conf_object_t *obj, uint32 leaf,
                                     uint32 subleaf);
};
#define X86_CPUID_QUERY_INTERFACE "x86_cpuid_query"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_x86_cstate.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_x86_cstate.html:__rm_interface_x86_cstate">x86_cstate</a></h1>
<p>

<a id="__rm_interface_x86_cstate.html:x86_cstate"></a><a id="__rm_interface_x86_cstate.html:x86_cstate_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The methods in this interface can be used to read or change the current
   power state the CPU is in. A state value of 0 corresponds to C0, a value of
   1 corresponds to C1, etc. HLT will be reported as state 1, substate 0.
   MWAIT will reported based upon the eax hint, decoded as state = (eax[7:4] +
   1) mod 16, substate = eax[3:0].
<p>
   <b><i>set_cstate</i></b> will perform side-effects such as putting the
   processor to sleep or waking it up, and call the registered cstate
   listeners.
</p><p>
   </p><pre class="jdocu_small">typedef struct {
        uint32 state;
        uint32 sub_state;
} x86_cstate_t;

SIM_INTERFACE(x86_cstate) {
        x86_cstate_t (*get_cstate)(conf_object_t *cpu_obj);
        void (*set_cstate)(conf_object_t *cpu_obj,
                           uint32 state, uint32 sub_state);
};

#define X86_CSTATE_INTERFACE "x86_cstate"
</pre><p>
</p><p>

   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_x86_cstate_notification.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_x86_cstate_notification.html:__rm_interface_x86_cstate_notification">x86_cstate_notification</a></h1>
<p>

<a id="__rm_interface_x86_cstate_notification.html:x86_cstate_notification"></a><a id="__rm_interface_x86_cstate_notification.html:x86_cstate_notification_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Objects registered in the CPU's <i>cstate_listeners</i> attribute will
   be called via the <b><i>notification</i></b> method whenever the CPU's cstate
   changes. Only changes caused by instruction execution or calls to the
   <b><i>x86_cstate.set_cstate</i></b> function will trigger a notification, not
   attribute accesses. See the <code>x86_cstate</code> interface for how
   the C-state is encoded in the parameters.
<p>
   </p><pre class="jdocu_small">SIM_INTERFACE(x86_cstate_notification) {
        void (*notification)(conf_object_t *listener, conf_object_t *cpu,
                             uint32 state, uint32 sub_state);
};

#define X86_CSTATE_NOTIFICATION_INTERFACE "x86_cstate_notification"
</pre><p>
</p><p>

   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_x86_ept.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_x86_ept.html:__rm_interface_x86_ept">x86_ept</a></h1>
<p>

<a id="__rm_interface_x86_ept.html:x86_ept"></a><a id="__rm_interface_x86_ept.html:x86_ept_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The interface provides insight into the Extended Page Table (EPT) address
   translation performed by target processors for virtual machine operations.
   It takes a result of the first level translation (the classical paging),
   called a guest physical address, and returns matching host physical address.
<p>
   The <b><i>guest_physical_to_physical</i></b> function translates a guest
   physical <i>address</i> to a host physical address. The
   <i>cpu_mode</i> argument sets the processor mode for the lookup.
   Access type is defined by <i>access</i>. The function returns a
   <em>physical_block_t</em> struct with <i>valid</i> bit and the
   <i>address</i>. The host physical address is valid when the valid
   flag is not 0. The function also returns <i>block_start</i> and
   <i>block_end</i>. The start and end of a block has the same linear
   mapping as the translated address. The range is inclusive, so block_end
   should be the address of the last byte of the block. This information can
   be used to figure out how often the function needs to be called for
   traversing larger address ranges.
</p><p>
   If the chosen processor's current mode does not use EPT translation,
   the function should use the identity mapping between guest and host physical
   addresses. An example of such situation would be an x86 processor outside
   of VMX non-root mode or with EPT controls disabled.
</p><p>
   To check if the processor's current VMCS state has EPT enabled,
   <b><i>is_ept_active</i></b> function should be used.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(x86_ept) {
        physical_block_t (*guest_physical_to_physical)(
                conf_object_t *obj,
                generic_address_t address,
                x86_processor_mode_t cpu_mode,
                access_t access);
        bool (*is_ept_active)(conf_object_t* obj);
};

#define X86_EPT_INTERFACE "x86_ept"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_x86_exception.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_x86_exception.html:__rm_interface_x86_exception">x86_exception</a></h1>
<p>

<a id="__rm_interface_x86_exception.html:x86_exception"></a><a id="__rm_interface_x86_exception.html:x86_exception_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The methods in this interface is used to raise exceptions
   from the instrumentation replace or user decoder functionality (it is illegal
   to invoke these methods from any other context). The
   methods perform longjmps and do not return.
<p>
   This interface is internal and may change without notice.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(x86_exception) {
        void (*DE_fault)(conf_object_t *cpu);

        void (*BR_fault)(conf_object_t *cpu);
        void (*UD_fault)(conf_object_t *cpu);
        void (*NM_fault)(conf_object_t *cpu);
        void (*DF_abort)(conf_object_t *cpu, const char *desc);

        void (*TS_fault)(conf_object_t *cpu, uint16 sel);
        void (*NP_fault)(conf_object_t *cpu, uint16 sel_vec, bool is_vec);

        void (*SS_fault)(conf_object_t *cpu, uint16 sel);
        void (*GP_fault)(conf_object_t *cpu, uint16 sel_vec, bool is_vec,
                         const char *desc);
        void (*PF_fault)(conf_object_t *cpu, linear_address_t laddr,
                         uint32 ecode);
        void (*MF_fault)(conf_object_t *cpu);
        void (*AC_fault)(conf_object_t *cpu);
        void (*XM_fault)(conf_object_t *cpu);
};
#define X86_EXCEPTION_INTERFACE "x86_exception"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">The methods in this interface may only be called from
   user decoder service routines. 
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_x86_exception_query.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_x86_exception_query.html:__rm_interface_x86_exception_query">x86_exception_query</a></h1>
<p>

<a id="__rm_interface_x86_exception_query.html:x86_exception_query"></a><a id="__rm_interface_x86_exception_query.html:x86_exception_query_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>x86_exception_query</code> interface is used to query information
   about an exception for the x86 architecture and should be used from a
   <b><i>cpu_exception_cb_t</i></b> callback.
<p>
   </p><pre class="jdocu_small">SIM_INTERFACE(x86_exception_query) {
        uint8 (*vector)(
                conf_object_t *cpu, exception_handle_t *handle);
        x86_exception_source_t (*source)(
                conf_object_t *cpu, exception_handle_t *handle);
        uint32 (*error_code)(
                conf_object_t *cpu, exception_handle_t *handle);
};
#define X86_EXCEPTION_QUERY_INTERFACE "x86_exception_query"        
</pre><p>
</p><p>

   The <b><i>vector</i></b> method is used to get the exception vector.  The
   <b><i>source</i></b> method is used to get the source of the exception and the
   <b><i>error_code</i></b> method is used to get the error code of the exception.
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods, but must be called from a callback
   receiving a handle of type <code>exception_handle_t</code>.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_x86_instruction_query.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_x86_instruction_query.html:__rm_interface_x86_instruction_query">x86_instruction_query</a></h1>
<p>

<a id="__rm_interface_x86_instruction_query.html:x86_instruction_query"></a><a id="__rm_interface_x86_instruction_query.html:x86_instruction_query_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>x86_instruction_query</code> interface is used to query
   additional information about an instruction for the x86 architecture and is a
   complement to the <code>cpu_instruction_query</code> interface.
<p>
   </p><pre class="jdocu_small">SIM_INTERFACE(x86_instruction_query) {
        linear_address_t (*linear_address)(conf_object_t *cpu,
                                           instruction_handle_t *handle);
};

#define X86_INSTRUCTION_QUERY_INTERFACE "x86_instruction_query"
</pre><p>
</p><p>

   The <b><i>linear_address</i></b> is used to get the linear address of the
   instruction.
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Threaded Context for all methods, but must be called from a callback
   receiving a handle of type <code>instruction_handle_t</code>.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_x86_instrumentation_subscribe.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_x86_instrumentation_subscribe.html:__rm_interface_x86_instrumentation_subscribe">x86_instrumentation_subscribe</a></h1>
<p>

<a id="__rm_interface_x86_instrumentation_subscribe.html:x86_instrumentation_subscribe"></a><a id="__rm_interface_x86_instrumentation_subscribe.html:x86_instrumentation_subscribe_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>x86_instrumentation_subscribe</code> interface is an x86
   specific complement to the <code>cpu_instrumentation_subscribe</code>
   interface. It is implemented by processor objects that support
   instrumentation. It has the same requirements as the
   <code>cpu_instrumentation_subscribe</code> interface.
<p>
   </p><pre class="jdocu_small">SIM_INTERFACE(x86_instrumentation_subscribe) {
        cpu_cb_handle_t *(*register_mode_switch_cb)(
                conf_object_t *cpu, conf_object_t *connection,
                x86_mode_switch_cb_t cb,
                lang_void *user_data);
        cpu_cb_handle_t *(*register_illegal_instruction_cb)(
                conf_object_t *NOTNULL cpu,
                conf_object_t *connection,
                cpu_instruction_decoder_cb_t cb,
                cpu_instruction_disassemble_cb_t disass_cb,
                lang_void *data);
};
#define X86_INSTRUMENTATION_SUBSCRIBE_INTERFACE \
        "x86_instrumentation_subscribe"
</pre><p>
</p><p>

   The <b><i>register_mode_switch_cb</i></b> method is used to register a callback
   that is called whenever the processor <i>cpu</i> changes execution
   mode. The <i>connection</i> argument is the user object that
   registers the callback. This object will be passed to the callback when it
   is called. <i>cb</i> is the callback and <i>user_data</i> is user data
   for the callback. The signature of the callback looks like this:
   </p><p>
   
</p><pre class="jdocu_small">typedef void (*x86_mode_switch_cb_t)(
        conf_object_t *obj, conf_object_t *cpu,
        x86_detailed_exec_mode_t mode,
        lang_void *user_data);</pre><p>

</p><p>
   The <i>obj</i> is the connection object that registered the
   callback. <i>new_mode</i> argument contains the new mode. The possible
   modes available are captured in the <code>x86_detailed_exec_mode_t</code>
   type:
</p><p>
    
</p><pre class="jdocu_small">typedef enum {
        X86_Detailed_Exec_Mode_Real_16,
        X86_Detailed_Exec_Mode_Real_32,
        X86_Detailed_Exec_Mode_V86,
        X86_Detailed_Exec_Mode_Protected_16,
        X86_Detailed_Exec_Mode_Protected_32,
        X86_Detailed_Exec_Mode_Protected_64,
        X86_Detailed_Exec_Mode_Compatibility_16,
        X86_Detailed_Exec_Mode_Compatibility_32,
} x86_detailed_exec_mode_t;</pre><p>

</p><p>
   The <i>user_data</i> is the user data associated with the callback.
</p><p>
   <b><i>register_illegal_instruction_cb</i></b> lets a user to implement new
   instructions. The <i>cb</i> argument is a callback function that will be
   called every time Simics does not decode an instruction. Allows new x86
   instructions to be implemented which otherwise cause illegal instruction
   exception. Compared to <b><i>register_instruction_decoder_cb</i></b> method of
   <code>cpu_instrumentation_subscribe</code> interface this interface cannot
   change any instruction that correctly decodes according to the existing
   instruction set architecture. From this callback the user can accept the
   instruction or deny it. In most cases this only happens once per instruction
   address since Simics usually caches decoding results in the internal
   instruction cache. If the cache is flushed the callback may be called again.
   This instrumentation feature (if used alone) does not prevent VMP execution
   since illegal instructions cause exit while running inside VMP mode.
</p><p>
   The callback signature looks like this:
</p><p>
   
</p><pre class="jdocu_small">typedef int (*cpu_instruction_decoder_cb_t)(
        conf_object_t *obj, conf_object_t *cpu,
        decoder_handle_t *decoder_handle,
        instruction_handle_t *iq_handle,
        lang_void *user_data);</pre><p>

</p><p>
   The instruction bytes are read by using the <b><i>get_instruction_bytes</i></b>
   method of the <code>cpu_instruction_query</code> interface together with
   the <i>iq_handle</i>. The returned value is of a
   <code>cpu_bytes_t</code> type. To access the bytes use the <code>data</code> and
   the <code>size</code> members in the returned value.
</p><p>
   If the decoder requires more bytes (i.e., because the new instruction is
   longer), a negative integer value should be returned by the <i>cb</i>
   function, indicating the number of bytes needed. For example, if the
   available bytes are 3 but the decoder need at least 4 bytes, -4 should be
   returned. The callback will then be called again with more available bytes
   (this can be repeated if the new instruction requires even more bytes at
   this point). Note that requesting more data than actual needed can cause
   spurious page faults if the data crosses a page boundary.
</p><p>
   If the instruction is accepted by the callback a positive integer number
   should be returned corresponding to the length of the instruction. In this
   case the <b><i>register_emulation_cb</i></b> method of the
   <code>cpu_instruction_decoder</code> interface should be called to set the
   actual (user) function that Simics will call each time the instruction is
   executed.
</p><p>
   If the <i>cb</i> callback should ignore the instruction the number 0
   should be returned. This means that any other registered decoder will have a
   chance to decode the instruction. If no decoder accepts it, Simics will
   generate illegal instruction exception.
</p><p>
   The <b><i>register_emulation_cb</i></b> method also needs the
   <i>decoder_handle</i> which is available in the dedoder callback. For
   more information, see the documentation of the
   <code>cpu_instruction_decoder</code> interface.
</p><p>
   A <i>disass_cb</i> argument should also be passed to the
   <b><i>register_illegal_instruction_cb</i></b> method. This function is called
   every time Simics wants to disassemble an instruction. For every accepted
   instruction a corresponding disassembly string should be returned by this
   function. It has the following signature:
</p><p>
   
</p><pre class="jdocu_small">typedef tuple_int_string_t (*cpu_instruction_disassemble_cb_t)(
        conf_object_t *obj, conf_object_t *cpu,
        generic_address_t addr,
        cpu_bytes_t bytes);</pre><p>

</p><p>
   <i>obj</i> is the object registering the
   <b><i>register_illegal_instruction_cb</i></b> and <i>cpu</i> is the
   processor disassembling the instruction. <b><i>addr</i></b> is the address of
   the instruction in a generic form. This means that it is typically a
   physical address or a logical address depending on the context of the
   disassembling. The address can be used for offset calculations, i.e.,
   displaying an absolute address instead of a relative one, for example in a
   branch instruction. The <i>bytes</i> argument should be used to read
   instruction bytes. The return value is of type
   <code>tuple_int_string_t</code> and should be filled with the instruction
   length and an allocated (e.g., malloc) string representing the disassembly
   of the instruction. The ownership of the string is transferred to the
   calling environment which will free it when it is no longer needed.
</p><p>
   If too few bytes are passed for the instruction to be disassembled a
   negative value should be returned for the length indicating the needed
   bytes. The <i>disass_cb</i> is then called again with more bytes. If the
   instruction is rejected a length of 0 should be returned and the string
   should be set to NULL.
</p><p>
   To remove the callback used one of the methods <b><i>remove_callback</i></b> or
   <b><i>remove_connection_callbacks</i></b> in the
   <code>cpu_instrumentation_subscribe</code> interface.
</p><p>
   The callback can also be enabled and disabled with the corresponding methods
   in the <code>cpu_instrumentation_subscribe</code> interface.
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Global Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_x86_instrumentation_subscribe_v2.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_x86_instrumentation_subscribe_v2.html:__rm_interface_x86_instrumentation_subscribe_v2">x86_instrumentation_subscribe_v2</a></h1>
<p>

<a id="__rm_interface_x86_instrumentation_subscribe_v2.html:x86_instrumentation_subscribe_v2"></a><a id="__rm_interface_x86_instrumentation_subscribe_v2.html:x86_instrumentation_subscribe_v2_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>x86_instrumentation_subscribe_v2</code> interface is an x86
   specific complement to the <code>cpu_instrumentation_subscribe</code>
   interface. It is implemented by x86 processor objects that support
   instrumentation. It works in the same way as the
   <code>cpu_instrumentation_subscribe</code> interface, and the methods
   <b><i>remove/enabled/disable_callback</i></b> and
   <b><i>remove/enabled/disable_connection_callbacks</i></b> in that interface
   should be used to operate on callbacks in this interface as well, using the
   <code>cpu_cb_handle_t</code> handle.
<p>
   The v2 variant fixes some problems with the
   <code>x86_instrumentation_subscribe</code>. In that interface, the
   <b><i>register_mode_switch_cb</i></b> method was invoked when the new mode had
   already been set up. This means that if you need to do some bookkeeping
   when leaving a mode, that mode had already been switched out in the callback.
   For instance, descriptor registers has already been changed.
</p><p>
   This interface adds two methods to handle this,
   <b><i>register_mode_leave_cb</i></b> and <b><i>register_mode_enter_cb</i></b>. The
   leave variant is called when the processor still is located in the previous
   mode, but about to enter a new mode, and the enter variant is called when
   the processor has switched to the new mode (corresponds to the
   <b><i>register_mode_switch_cb</i></b> in the old
   <code>x86_instrumentation_subscribe</code> interface).
</p><p>
   The <b><i>register_illegal_instruction_cb</i></b> works as in the
   <code>x86_instrumentation_subscribe</code> interface.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(x86_instrumentation_subscribe_v2) {
        cpu_cb_handle_t *(*register_mode_enter_cb)(
                conf_object_t *cpu, conf_object_t *connection,
                x86_mode_switch_cb_t cb,
                lang_void *user_data);
        cpu_cb_handle_t *(*register_mode_leave_cb)(
                conf_object_t *cpu, conf_object_t *connection,
                x86_mode_switch_cb_t cb,
                lang_void *user_data);
        cpu_cb_handle_t *(*register_illegal_instruction_cb)(
                conf_object_t *NOTNULL cpu,
                conf_object_t *connection,
                cpu_instruction_decoder_cb_t cb,
                cpu_instruction_disassemble_cb_t disass_cb,
                lang_void *data);
};

#define X86_INSTRUMENTATION_SUBSCRIBE_V2_INTERFACE \
        "x86_instrumentation_subscribe_v2"
</pre><p>
</p><p>

   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Global Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_x86_memory_access.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_x86_memory_access.html:__rm_interface_x86_memory_access">x86_memory_access</a></h1>
<p>

<a id="__rm_interface_x86_memory_access.html:x86_memory_access"></a><a id="__rm_interface_x86_memory_access.html:x86_memory_access_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>x86_memory_access</code> interface is used to access memory
   from user decoder service routines. If an exception condition
   occurs, a longjmp is taken. The interface methods may only be invoked from
   user decoder service routines.
<p>
   This interface is internal and may change without notice.
   </p><pre class="jdocu_small">SIM_INTERFACE(x86_memory_access) {
        uint64 (*read_logical)(
                conf_object_t *cpu,
                logical_address_t offs,
                x86_seg_t seg,
                unsigned len,
                x86_processor_mode_t mode,
                x86_access_type_t access_type);
#if !defined(PYWRAP)
        void (*read_logical_buf)(
                conf_object_t *cpu, 
                logical_address_t offs,
                x86_seg_t seg,
                unsigned len,
                void *p,
                x86_processor_mode_t mode,
                x86_access_type_t access_type,
                x86_alignment_t alignment);
#endif
        void (*write_logical)(
                conf_object_t *cpu,
                logical_address_t offs,
                x86_seg_t seg,
                unsigned len,
                uint64 val,
                x86_processor_mode_t mode,
                x86_access_type_t access_type);
#if !defined(PYWRAP)
        void (*write_logical_buf)(
                conf_object_t *cpu,
                logical_address_t offs,
                x86_seg_t seg,
                unsigned len,
                const void *p,
                x86_processor_mode_t mode,
                x86_access_type_t access_type,
                x86_alignment_t alignment);
#endif
};
#define X86_MEMORY_ACCESS_INTERFACE "x86_memory_access"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">The methods in this interface may only be called from
   user decoder service routines. 
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_x86_memory_operation.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_x86_memory_operation.html:__rm_interface_x86_memory_operation">x86_memory_operation</a></h1>
<p>

<a id="__rm_interface_x86_memory_operation.html:x86_memory_operation"></a><a id="__rm_interface_x86_memory_operation.html:x86_memory_operation_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>x86_memory_operation</code> interface is used to access memory
   from a user instruction. See the
   <code>cpu_instrumentation_subscribe</code> and
   <code>cpu_instruction_decoder</code> for more information. It is designed
   to be more efficient than the <code>x86_memory_access</code>. If an
   exception condition occurs, a longjmp is taken. The interface methods may
   only be invoked from user instruction.
<p>
   </p><pre class="jdocu_small">SIM_INTERFACE(x86_memory_operation) {
        uint64 (*read_logical)(
                conf_object_t *cpu,
                x86_seg_t seg,
                logical_address_t offs,
                unsigned size,
                x86_processor_mode_t mode,
                x86_access_type_t access_type);
#if !defined(PYWRAP)
        void (*read_logical_buf)(
                conf_object_t *cpu,
                uint8 *dst,
                x86_seg_t seg,
                logical_address_t offs,
                unsigned size,
                x86_processor_mode_t mode,
                x86_access_type_t access_type);
#endif
        void (*write_logical)(
                conf_object_t *cpu,
                uint64 val,
                x86_seg_t seg,
                logical_address_t offs,
                unsigned size,
                x86_processor_mode_t mode,
                x86_access_type_t access_type);
#if !defined(PYWRAP)
        void (*write_logical_buf)(
                conf_object_t *cpu,
                const uint8 *src,
                x86_seg_t seg,
                logical_address_t offs,
                unsigned size,
                x86_processor_mode_t mode,
                x86_access_type_t access_type);
#endif
        x86_read_physical_ret_t (*read_physical)(
                conf_object_t *cpu,
                physical_address_t address,
                unsigned size,
                x86_access_type_t access_type);
#if !defined(PYWRAP)
        exception_type_t (*read_physical_buf)(
                conf_object_t *cpu,
                uint8 *dst,
                physical_address_t address,
                unsigned size,
                x86_access_type_t access_type);
#endif
        exception_type_t (*write_physical)(
                conf_object_t *cpu,
                uint64 val,
                physical_address_t address,
                unsigned size,
                x86_access_type_t access_type);
#if !defined(PYWRAP)  
        exception_type_t (*write_physical_buf)(
                conf_object_t *cpu,
                const uint8 *src,
                physical_address_t address,
                unsigned size,
                x86_access_type_t access_type);
#endif
};

#define X86_MEMORY_OPERATION_INTERFACE "x86_memory_operation"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods, but must be called from an invoke
   function set by the <code>instrumentation_replace</code> interface.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_x86_memory_query.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_x86_memory_query.html:__rm_interface_x86_memory_query">x86_memory_query</a></h1>
<p>

<a id="__rm_interface_x86_memory_query.html:x86_memory_query"></a><a id="__rm_interface_x86_memory_query.html:x86_memory_query_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>x86_memory_query</code> interface is used to query additional
   information about an instruction for the x86 architecture and is a complement
   to the <code>cpu_memory_query</code> interface.
<p>
   </p><pre class="jdocu_small">SIM_INTERFACE(x86_memory_query) {
        linear_address_t (*linear_address)(conf_object_t *cpu,
                                           memory_handle_t *handle);
        x86_seg_t (*segment)(conf_object_t *cpu, memory_handle_t *handle);
        x86_access_type_t (*access_type)(conf_object_t *obj,
                                         memory_handle_t *handle);
        x86_memory_type_t (*memory_type)(conf_object_t *obj,
                                         memory_handle_t *handle);
};

#define X86_MEMORY_QUERY_INTERFACE "x86_memory_query"        

</pre><p>
</p><p>

   The <b><i>linear_address</i></b> is used to get the linear address of the
   access.
</p><p>
   The <b><i>segment</i></b> function is used to get the segment register used
   in the access.
</p><p>
   The <b><i>access_type</i></b> returns the <code>x86_access_type_t</code> of the
   access and the <b><i>memory_type</i></b> returns the
   <code>x86_memory_type_t</code> of the access.
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods, but must be called from a callback
   receiving a handle of type <code>memory_handle_t</code>.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_x86_msr.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_x86_msr.html:__rm_interface_x86_msr">x86_msr</a></h1>
<p>

<a id="__rm_interface_x86_msr.html:x86_msr"></a><a id="__rm_interface_x86_msr.html:x86_msr_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><pre class="jdocu_small">SIM_INTERFACE(x86_msr) {
        void (*register_handlers)(
                conf_object_t *cpu,
                int64 number,
                x86_msr_getter_func_t getter,
                lang_void *getter_data,
                x86_msr_setter_func_t setter,
                lang_void *setter_data,
                const char *name);
        void (*unregister_handlers)(
                conf_object_t *cpu,
                int64 number);
        x86_msr_getter_ret_t (*get)(
                conf_object_t *cpu,
                int64 number,
                x86_msr_access_type_t type);
        x86_msr_ret_t (*set)(
                conf_object_t *cpu,
                int64 number,
                uint64 value,
                x86_msr_access_type_t type);
        const char *(*get_name)(
                conf_object_t *cpu,
                int64 number);
        int64 (*get_number)(
                conf_object_t *cpu,
                const char *name);
        attr_value_t (*get_all_valid_numbers)(
                conf_object_t *cpu);
};
#define X86_MSR_INTERFACE "x86_msr"
</pre><p>
</p><p>

   The <b><i>register_handlers</i></b> function will register get and set
   functions that will be called every time a read or write access is made to
   the MSR with number <i>msr</i>.
</p><p>
   
</p><pre class="jdocu_small">typedef struct {
        x86_msr_ret_t status;
        uint64 value;
} x86_msr_getter_ret_t;</pre><p>

   
</p><pre class="jdocu_small">typedef enum {
        Sim_X86_Msr_Ok = Sim_Gen_Spr_Ok,        /* Access was OK */
        Sim_X86_Msr_GP_Fault,                   /* Raise #GP fault */
        Sim_X86_Msr_Not_Handled                 /* Pass on to next handler */
} x86_msr_ret_t;</pre><p>

   
</p><pre class="jdocu_small">typedef x86_msr_getter_ret_t (*x86_msr_getter_func_t)(
        conf_object_t *cpu,
        int64 number,
        x86_msr_access_type_t type,
        lang_void *user_data);</pre><p>

   
</p><pre class="jdocu_small">typedef x86_msr_ret_t (*x86_msr_setter_func_t)(
        conf_object_t *cpu,
        int64 spr_number,
        uint64 value,
        x86_msr_access_type_t type,
        lang_void *user_data);</pre><p>

</p><p>
   The <i>type</i> parameter in the get and set functions is one of
   the following, depending on where from the access originated:
</p><p>
   
</p><pre class="jdocu_small">typedef enum {
        /* Access from a rdmsr/wrmsr instruction */
        Sim_X86_Msr_Instruction_Access = Sim_Gen_Spr_Instruction_Access,

        /* Access through attribute */
        Sim_X86_Msr_Attribute_Access = Sim_Gen_Spr_Attribute_Access,

        /* Access through int_register interface */
        Sim_X86_Msr_Int_Register_Access = Sim_Gen_Spr_Int_Register_Access,

        /* Access during VMX entry/exit */
        Sim_X86_Msr_VMX_Access,

        /* Architectural access without side effects within the CPU model, only
           reads or writes the register value. However, if it is sent to the
           platform as a non-inquiry access, that may cause side effects. */
        Sim_X86_Msr_Architectural_Access
} x86_msr_access_type_t;</pre><p>

</p><p>
   The getter function returns the status just like the setter together with
   the read MSR value. A getter or setter may return the
   Sim_X86_MSR_Not_Handled return code, in which case the access will pass
   through to the earlier registered handler (or the default handler if there
   is no earlier registered handler).
</p><p>
   The function <b><i>unregister_handlers</i></b> will remove any
   non-default handlers for a particular MSR.
</p><p>
   The <b><i>get</i></b> and <b><i>set</i></b> functions get and set MSRs, using both
   model default MSR handlers and handlers installed through this interface.
</p><p>
   The function <b><i>get_name</i></b> takes <i>number</i>
   as parameter and returns the name of the MSR.
</p><p>
   The function <b><i>get_number</i></b> takes the <i>name</i>
   and returns the MSR number.
</p><p>
   The function <b><i>get_all_valid_numbers</i></b> returns a list of integers
   corresponding to all the valid MSRs, including both model default MSRs and
   MSRs installed through this interface.
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_x86_pkg_cstate.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_x86_pkg_cstate.html:__rm_interface_x86_pkg_cstate">x86_pkg_cstate</a></h1>
<p>

<a id="__rm_interface_x86_pkg_cstate.html:x86_pkg_cstate"></a><a id="__rm_interface_x86_pkg_cstate.html:x86_pkg_cstate_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The methods in this interface can be used to read or change the current
   power state the CPU is in. A state value of 0 corresponds to C0, a value of
   1 corresponds to C1, etc. HLT will be reported as state 1, substate 0.
   MWAIT will reported based upon the eax hint, decoded as state = (eax[7:4] +
   1) mod 16, substate = eax[3:0].
<p>
   <b><i>pkg_cstate_update</i></b> will perform side-effects such as putting the
   processor to sleep or waking it up, and call the cstate notification
   listeners.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(x86_pkg_cstate) {
        x86_cstate_t (*get_pkg_cstate)(conf_object_t *cpu_obj);
        void (*set_pkg_cstate)(conf_object_t *cpu_obj,
                           uint32 state, uint32 sub_state);
        void (*pkg_cstate_update)(conf_object_t *cpu_obj,
                           bool notify);
};

#define X86_PKG_CSTATE_INTERFACE "x86_pkg_cstate"
</pre><p>
</p><p>

   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_x86_reg_access.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_x86_reg_access.html:__rm_interface_x86_reg_access">x86_reg_access</a></h1>
<p>

<a id="__rm_interface_x86_reg_access.html:x86_reg_access"></a><a id="__rm_interface_x86_reg_access.html:x86_reg_access_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>x86_reg_acc_access</code> interface can be
   used to access x86 register state in an efficient manner.
   The interface is intended to be used from user decoder
   service routines.
<p>
   This interface is internal and may change without notice.
   </p><pre class="jdocu_small">SIM_INTERFACE(x86_reg_access) {
        uint64 (*get_gpr)(conf_object_t *cpu, unsigned index);
        void (*set_gpr)(conf_object_t *cpu, unsigned index, uint64 val);

        uint64 (*get_rip)(conf_object_t *cpu);
        void (*set_rip)(conf_object_t *cpu, uint64 rip);

        uint64 (*get_rflags)(conf_object_t *cpu);
        void (*set_rflags)(conf_object_t *cpu, uint64 rflags);

        /* Possibly faster method for setting only cf,pf,af,zf,sf,of */
        void (*set_status_flags)(conf_object_t *cpu, uint16 flags);

        /* Regular segment registers */
        x86_seg_reg_t (*get_seg)(conf_object_t *cpu, x86_seg_t n);
        void (*set_seg)(conf_object_t *cpu, x86_seg_t n, x86_seg_reg_t seg);

        /* IDTR and GDTR */
        x86_system_seg_reg_t (*get_system_seg)(conf_object_t *cpu,
                                               x86_system_seg_t n);
        void (*set_system_seg)(conf_object_t *cpu, x86_system_seg_t n,
                               x86_system_seg_reg_t seg);

        /* Control registers */
        uint64 (*get_cr)(conf_object_t *cpu, x86_cr_t n);
        void (*set_cr)(conf_object_t *cpu, x86_cr_t n, uint64 val);
        uint64 (*get_efer)(conf_object_t *cpu);
        void (*set_efer)(conf_object_t *cpu, uint64 efer);
        uint64 (*get_xcr)(conf_object_t *cpu, x86_xcr_t n);
        void (*set_xcr)(conf_object_t *cpu, x86_xcr_t n, uint64 val);

        /* x87 FPU */
        x86_fpu_reg_t (*get_freg)(conf_object_t *cpu, unsigned index);
        void (*set_freg)(conf_object_t *cpu, unsigned index, x86_fpu_reg_t freg);
        x86_fpu_env_t (*get_fpu_env)(conf_object_t *cpu);
        void (*set_fpu_env)(conf_object_t *cpu, x86_fpu_env_t state);

        /* SIMD */
        xmm_reg_t (*get_xmm)(conf_object_t *cpu, unsigned index);
        void (*set_xmm)(conf_object_t *cpu, unsigned index, xmm_reg_t val);
        ymm_reg_t (*get_ymm)(conf_object_t *cpu, unsigned index);
        void (*set_ymm)(conf_object_t *cpu, unsigned index, ymm_reg_t val);
        uint32 (*get_mxcsr)(conf_object_t *cpu);
        void (*set_mxcsr)(conf_object_t *cpu, uint32 mxcsr);

        /* Debug registers */
        uint64 (*get_dr)(conf_object_t *cpu, x86_dr_t n);
        void (*set_dr)(conf_object_t *cpu, x86_dr_t n, uint64 val);

        /* SMM */
        bool (*get_in_smm)(conf_object_t *cpu);
        void (*set_in_smm)(conf_object_t *cpu, bool val);
        uint64 (*get_smm_base)(conf_object_t *cpu);
        void (*set_smm_base)(conf_object_t *cpu, uint64 val);

        /* Monitor/Mwait */
        x86_monitor_info_t (*get_monitor_info)(conf_object_t *cpu);
        void (*set_monitor_info)(conf_object_t *cpu, x86_monitor_info_t val);
        x86_mwait_info_t (*get_mwait_info)(conf_object_t *cpu);
        void (*set_mwait_info)(conf_object_t *cpu, x86_mwait_info_t val);

        /* Non-register state */
        x86_activity_t (*get_activity_state)(conf_object_t *cpu);
        void (*set_activity_state)(conf_object_t *cpu, x86_activity_t val);
        x86_intstate_t (*get_interruptibility_state)(conf_object_t *cpu);
        void (*set_interruptibility_state)(conf_object_t *cpu,
                                           x86_intstate_t val);

        /* A debug exception is pending if triggered by the last instruction,
           but not yet taken. */
        x86_pending_debug_exc_t (*get_pending_debug_exc)(conf_object_t *cpu);
        void (*set_pending_debug_exc)(conf_object_t *cpu,
                                      x86_pending_debug_exc_t val);

        /* Derived state for fast/easy access */
        x86_xmode_info_t (*get_xmode_info)(conf_object_t *cpu);
        x86_exec_mode_t (*get_exec_mode)(conf_object_t *cpu);

        /* This is configuration info. No need for a set method. */
        uint32 (*get_mxcsr_mask)(conf_object_t *cpu);

        /* Extension state dirty bit modification (for XSAVE) */
        uint64 (*get_ext_state_dirty_bits)(conf_object_t *cpu);
        void (*or_ext_state_dirty_bits)(conf_object_t *cpu, uint64 dirty_bits);
        void (*and_ext_state_dirty_bits)(conf_object_t *cpu, uint64 dirty_bits);

        /* PDPTE registers used in PAE paging mode */
        uint64 (*get_pdpte)(conf_object_t *cpu, int num);
        void (*set_pdpte)(conf_object_t *cpu, int num, uint64 val);

        uint32 (*get_vmx_mode)(conf_object_t *cpu);
};
#define X86_REG_ACCESS_INTERFACE "x86_reg_access"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_x86_smm.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_x86_smm.html:__rm_interface_x86_smm">x86_smm</a></h1>
<p>

<a id="__rm_interface_x86_smm.html:x86_smm"></a><a id="__rm_interface_x86_smm.html:x86_smm_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The smm interface is used to implement a custom SMRAM
   state save map.
<p>
   The <b>save_state</b> method is invoked when SMM mode
   is entered before any cpu state has been modified.
   The method should save the current cpu state
   to the SMRAM state save map.
</p><p>
   The <b>restore_state</b> method is invoked during execution
   of the <b>rsm</b> instruction. The method should
   restore the cpu state from the SMRAM state save map.
</p><p>
   The <code>x86_smm_state</code> interface implemented by
   the cpu can be used to facilitate cpu state changes and
   SMRAM access.
</p><p>
   This interface is internal and may change without notice.
   </p><pre class="jdocu_small">SIM_INTERFACE(x86_smm) {
        void (*save_state)(conf_object_t *obj, conf_object_t *cpu);
        void (*restore_state)(conf_object_t *obj, conf_object_t *cpu);
};
#define X86_SMM_INTERFACE "x86_smm"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_x86_smm_state.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_x86_smm_state.html:__rm_interface_x86_smm_state">x86_smm_state</a></h1>
<p>

<a id="__rm_interface_x86_smm_state.html:x86_smm_state"></a><a id="__rm_interface_x86_smm_state.html:x86_smm_state_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The smm state interface is implemented by the cpu
   and is typically used by objects implementing the
   <code>x86_smm</code> interface.
<p>
   The <b>get_state</b> method saves the cpu state in the
   <i>state</i> struct. This method is intended to be
   used during SMM entry.
</p><p>
   The <b>set_state</b> method restores the cpu state 
   from the <i>state</i> struct. This method is intended
   to be used during SMM exit.
</p><p>
   The <b>smram_read</b> and <b>smram_write</b> methods
   can be used to access the SMRAM during SMM entry/exit.
</p><p>
   This interface is internal and may change without notice.
   </p><pre class="jdocu_small">SIM_INTERFACE(x86_smm_state) {
        void (*get_state)(conf_object_t *cpu, smm_reg_state_t *state);
        void (*set_state)(conf_object_t *cpu, const smm_reg_state_t *state);

        uint64 (*smram_read)(conf_object_t *obj,
                             unsigned smram_offs, unsigned len);
        void (*smram_write)(conf_object_t *obj,
                            unsigned smram_offs, unsigned len, uint64 val);
};
#define X86_SMM_STATE_INTERFACE "x86_smm_state"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_x86_tlb.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_x86_tlb.html:__rm_interface_x86_tlb">x86_tlb</a></h1>
<p>

<a id="__rm_interface_x86_tlb.html:x86_tlb"></a><a id="__rm_interface_x86_tlb.html:x86_tlb_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The x86 tlb interface is used for communication between an x86 cpu
   and its TLB. The TLB is implemented as a separate class for greater
   flexibility. The TLB object does no memory operations itself.
<p>
   <a id="__rm_interface_x86_tlb.html:tagged_physical_address_t"></a>
   </p><pre class="jdocu_small">typedef struct {
        int                  valid;
        physical_address_t   paddr;
} tagged_physical_address_t;

SIM_INTERFACE(x86_tlb) {
        void (*flush_all)(conf_object_t *obj,
                            int keep_global_entries);
        void (*flush_page)(conf_object_t *obj,
                           linear_address_t laddr);
        int (*lookup)(conf_object_t *obj,
                      x86_memory_transaction_t *mem_tr);
        void (*add)(conf_object_t *obj,
                    processor_mode_t mode,
                    read_or_write_t read_or_write,
                    data_or_instr_t data_or_instr,
                    int global_page,
                    x86_memory_type_t pat_type,
                    x86_memory_type_t mtrr_type,
                    linear_address_t laddr,
                    physical_address_t paddr,
                    int page_size);
        tagged_physical_address_t (*itlb_lookup)(conf_object_t *obj,
                                                 linear_address_t laddr,
                                                 processor_mode_t mode);
        void (*set_pae_mode)(conf_object_t *obj, bool pae_mode);
};

#define X86_TLB_INTERFACE "x86_tlb"
</pre><p>
</p><p>

   All functions in the interface get the <i>object</i> implementing
   the interface as their first parameter.
</p><p>
   <b>flush_all</b> is called when all TLB entries should be
   flushed. If <i>keep_global_entries</i> is set, then TLB entries
   with their global bit set should not be flushed.
</p><p>
   <b>flush_page</b> is invoked when pages containing <i>laddr</i> are
   to be removed from the TLB.
</p><p>
   <b>lookup</b> is used by the CPU when a memory access misses the
   STC. It must return true (non-zero) if and only if the memory
   operation specified by <i>mem_tr</i> hits the TLB and does not
   raise an exception. The <i>mode</i>, <i>linear_address</i> are valid when
   the method is invoked. The other fields passed through <i>mem_tr</i>
   are undefined. If the method returns true, the
   <i>s.physical_address</i>, <i>pat_type</i>, and <i>mtrr_type</i>
   fields of <i>mem_tr</i> must be updated by <b>lookup</b>.
</p><p>
   An access that misses in <b>lookup</b> but does not raise a fault
   is inserted into the TLB with <b>add</b>. The <i>page_size</i>
   encoding is 0 for 4 kb pages, 1 for 2 Mb pages, and 2 for 4 Mb
   pages.
</p><p>
   <b>itlb_lookup</b> is a simplified version of <b>lookup</b> used
   only for instruction TLB lookups. If the lookup is successful
   <i>valid</i> and <i>paddr</i> should be set, otherwise <i>valid</i>
   should be cleared.
</p><p>
   <b>set_pae_mode</b> is invoked when the cpu changes the
   PAE enable bit.
</p><p>
   It class implementing the interface must make sure that only
   addresses mapped in the TLB are present in the STCs.
</p><p>
   This interface may be changed or replaced with an architecture
   independent interface in future versions of Simics.
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_x86_tlb_v2.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_x86_tlb_v2.html:__rm_interface_x86_tlb_v2">x86_tlb_v2</a></h1>
<p>

<a id="__rm_interface_x86_tlb_v2.html:x86_tlb_v2"></a><a id="__rm_interface_x86_tlb_v2.html:x86_tlb_v2_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The x86_tlb_v2 interface is used for communication between an x86 cpu
   and its TLB. The TLB is implemented as a separate class for greater
   flexibility. The TLB object does no memory operations itself.
<p>
   <b><i>flush_all</i></b> is called when all TLB entries should be flushed. If
   <i>keep_global_entries</i> is set, then TLB entries with their global
   bit set should not be flushed.
</p><p>
   <b><i>flush_page</i></b> is invoked when pages containing <i>laddr</i> are
   to be removed from the TLB.
</p><p>
   <b><i>lookup</i></b> is used by the CPU when a memory access misses the STC. It
   returns the matching TLB entry if the memory operation specified in
   <i>mem_tr</i> hits the TLB and does not raise an exception. Otherwise
   NULL is returned. The <i>mode</i>, <i>linear_address</i>, and
   <i>type</i> fields in <i>mem_tr</i> need to be valid when the method
   is invoked. The other fields passed through <i>mem_tr</i> are not to be
   used by the method and can carry any value. If the method returns true, the
   <i>s.physical_address</i>, <i>pat_type</i>, and <i>mtrr_type</i>
   fields of <i>mem_tr</i> must be updated by <b><i>lookup</i></b>.
</p><p>
   Pages are added to the TLB with <b><i>add</i></b>. The
   <i>supervisor_access</i> field in <i>attrs</i> argument specifies
   the allowed access types in supervisor mode and <i>user_access</i> in
   <i>attrs</i> specifies the allowed access types in user mode.
</p><p>
   <b><i>itlb_lookup</i></b> is a simplified version of <b><i>lookup</i></b> used
   only for instruction TLB lookups. If the lookup is successful
   <i>valid</i> and <i>paddr</i> should be set, otherwise
   <i>valid</i> should be cleared.
</p><p>
   The class implementing the interface must make sure that only addresses
   mapped in the TLB are present in the STCs.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(x86_tlb_v2) {
        void (*flush_all)(conf_object_t *obj,
                          int keep_global_entries);
        void (*flush_page)(conf_object_t *obj,
                           linear_address_t laddr);
        const x86_tlb_entry_t *(*lookup)(conf_object_t *obj,
                                         x86_memory_transaction_t *mem_tr);
        void (*add)(conf_object_t *obj,
                    linear_address_t laddr,
                    physical_address_t paddr,
                    x86_tlb_attrs_t attrs);
        tagged_physical_address_t (*itlb_lookup)(conf_object_t *obj,
                                                 linear_address_t laddr,
                                                 processor_mode_t mode);
};

#define X86_TLB_V2_INTERFACE "x86_tlb_v2"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_x86_tlb_v3.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_x86_tlb_v3.html:__rm_interface_x86_tlb_v3">x86_tlb_v3</a></h1>
<p>

<a id="__rm_interface_x86_tlb_v3.html:x86_tlb_v3"></a><a id="__rm_interface_x86_tlb_v3.html:x86_tlb_v3_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The x86_tlb_v3 interface is used for communication between an x86 cpu
   and its TLB. The TLB is implemented as a separate class for greater
   flexibility. The TLB object does no memory operations itself.
<p>
   Pages are added to the TLB with <b><i>add</i></b>. Process context identifier,
   linear and physical address for translation specified using arguments
   <i>hint</i>, <i>laddr</i> and <i>paddr</i> correspondingly.
   The fields in <i>attrs</i> argument used for specification of
   allowed access types and additional page attributes.
</p><p>
   <b><i>lookup</i></b> is used by the CPU when a memory access misses the STC.
   It returns the matching TLB entry if the memory operation specified in
   <i>mem_tr</i> hits the TLB and does not raise an exception. Otherwise
   NULL is returned. The <i>hint</i> argument specifies process context
   identifier. The <i>mode</i>, <i>linear_address</i>, and
   <i>type</i> fields in <i>mem_tr</i> need to be valid when the method
   is invoked. The other fields passed through <i>mem_tr</i> are not to be
   used by the method and can carry any value. If the method returns not NULL,
   the <i>s.physical_address</i>, <i>pat_type</i>, and
   <i>mtrr_type</i> fields of <i>mem_tr</i> must be updated by
   <b><i>lookup</i></b>.
</p><p>
   <b><i>itlb_lookup</i></b> is a simplified version of <b><i>lookup</i></b> used
   only for instruction TLB lookups. If the lookup is successful
   <i>valid</i> and <i>paddr</i> should be set, otherwise
   <i>valid</i> should be cleared.
</p><p>
   <b><i>invalidate_page</i></b> is used to remove from TLB page corresponding to
   given linear address specified by argument <i>laddr</i> in process
   context with identifier from argument <i>hint</i>.
</p><p>
   <b><i>invalidate</i></b> is invoked when value of CR4.PCIDE bit set and CPU
   executes INVPCID instruction. Direct and indirect operands of instruction
   transferred in <i>hint</i>, <i>la</i> and <i>type</i>
   arguments. TLB entries flushed according to INVPCID instruction description.
   New invalidation type X86_Tlb_Invalidate_Address_Space added to implement
   flush_all function from previous interfaces. The method also can be used to
   flush required TLB entries in any required cases.
</p><p>
   The class implementing the interface must make sure that only addresses
   mapped in the TLB are present in the STCs.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(x86_tlb_v3) {
        void (*add)(conf_object_t *obj,
                    uint64 hint,
                    linear_address_t laddr,
                    physical_address_t paddr,
                    x86_tlb_attrs_v3_t attrs);
        const x86_tlb_entry_v3_t *(*lookup)(conf_object_t *obj,
                                            uint64 hint,
                                            x86_memory_transaction_t *mem_tr);
        tagged_physical_address_t (*itlb_lookup)(conf_object_t *obj,
                                                 uint64 hint,
                                                 linear_address_t laddr,
                                                 processor_mode_t mode);
        void    (*invalidate_page)(conf_object_t *obj,
                                   uint64 hint,
                                   linear_address_t laddr);
        void    (*invalidate)(conf_object_t *obj,
                              uint32 type,
                              uint64 hint,
                              linear_address_t la);
};

#define X86_TLB_V3_INTERFACE "x86_tlb_v3"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_x86_vmp_control.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_x86_vmp_control.html:__rm_interface_x86_vmp_control">x86_vmp_control</a></h1>
<p>

<a id="__rm_interface_x86_vmp_control.html:x86_vmp_control"></a><a id="__rm_interface_x86_vmp_control.html:x86_vmp_control_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>x86_vmp_control</code> interface can be
   used to prevent VMP from being used.
<p>
   The <b>set_block_count</b> method sets the VMP block
   count. If the VMP block count is non-zero, VMP will not be
   used for simulation.
</p><p>
   The <b>get_block_count</b> method returns VMP block count.
</p><p>
   This interface is internal and may change without notice.
   </p><pre class="jdocu_small">SIM_INTERFACE(x86_vmp_control) {
        unsigned (*get_block_count)(conf_object_t *cpu);
        void (*set_block_count)(conf_object_t *cpu, unsigned cnt);
};
#define X86_VMP_CONTROL_INTERFACE "x86_vmp_control"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_xed_access.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_xed_access.html:__rm_interface_xed_access">xed_access</a></h1>
<p>

<a id="__rm_interface_xed_access.html:xed_access"></a><a id="__rm_interface_xed_access.html:xed_access_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>xed_access</code> interface is implemented by a processor model.
   The interface can be used to call Intel X86 Encoder Decoder (Intel\reg;
   XED) library built into the processor model.
<p>
   This interface is internal and may change at any time without notice.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(xed_access) {
        int (*get_last)(conf_object_t *obj, xed_data_type_t type);
        int (*decode)(conf_object_t *obj, xed_data_type_t type, bytes_t bytes);
        const char *(*to_string)(conf_object_t *obj, xed_data_type_t type,
                                 int value);
};

#define XED_ACCESS_INTERFACE "xed_access"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_xtensa_export_state.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_xtensa_export_state.html:__rm_interface_xtensa_export_state">xtensa_export_state</a></h1>
<p>

<a id="__rm_interface_xtensa_export_state.html:xtensa_export_state"></a><a id="__rm_interface_xtensa_export_state.html:xtensa_export_state_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">OBSOLETE!
   External Xtensa TIE interface for the export state
   type. <i>user_object</i> is the user object to use in the
   <i>export_state_func</i> callback.
<p>
   The type of the export_state_func is defined in the
   <code>xtensa/tie/cstub-extif.h</code> file in the Xtensa model build
   directory.
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_xtensa_import_wire.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_xtensa_import_wire.html:__rm_interface_xtensa_import_wire">xtensa_import_wire</a></h1>
<p>

<a id="__rm_interface_xtensa_import_wire.html:xtensa_import_wire"></a><a id="__rm_interface_xtensa_import_wire.html:xtensa_import_wire_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">External Xtensa TIE interface for the import wire type. A callback should be
   registered in order to send data to the object <i>obj</i> that
   implements the interface, typically a processor. The callback is called when
   the wire is accessed. The <i>user_object</i> is the user object to use
   in the <i>import_wire_func</i> callback.
<p>
   The type of the import_wire_func is defined in the
   <code>xtensa/tie/cstub-extif.h</code> file in the Xtensa model build
   directory.
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_xtensa_input_queue.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_xtensa_input_queue.html:__rm_interface_xtensa_input_queue">xtensa_input_queue</a></h1>
<p>

<a id="__rm_interface_xtensa_input_queue.html:xtensa_input_queue"></a><a id="__rm_interface_xtensa_input_queue.html:xtensa_input_queue_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">OBSOLETE!
   External Xtensa TIE interface for the input queue type. Two callbacks should
   be registered in order to send data to the object <i>obj</i> that
   implements the interface, typically a processor. When the queue is accessed
   the callbacks are called. <i>user_object</i> is the user object to use
   in the <i>empty_callback</i> and <i>data_callback</i> callbacks.
<p>
   The types of the empty_callback callback and data_callback are defined in
   the <code>xtensa/tie/cstub-extif.h</code> file in the Xtensa model build
   directory. The empty_callback should return 1 if the queue is empty,
   otherwise 0. The data_callback is used for sending the data.
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_xtensa_internal_memories.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_xtensa_internal_memories.html:__rm_interface_xtensa_internal_memories">xtensa_internal_memories</a></h1>
<p>

<a id="__rm_interface_xtensa_internal_memories.html:xtensa_internal_memories"></a><a id="__rm_interface_xtensa_internal_memories.html:xtensa_internal_memories_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This interface is implemented by all Xtensa cores.
   The methods correspond to the <code>iram</code>, <code>irom</code>,
   <code>dram</code> and <code>drom</code> attributes, reporting where
   the internal memories are located, in the form of:
   <code>[[paddr_start, paddr_stop]*]</code>.
   This is static and will never change, but is differently
   configured for each Xtensa cores.
   
</dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_xtensa_lookup.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_xtensa_lookup.html:__rm_interface_xtensa_lookup">xtensa_lookup</a></h1>
<p>

<a id="__rm_interface_xtensa_lookup.html:xtensa_lookup"></a><a id="__rm_interface_xtensa_lookup.html:xtensa_lookup_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">OBSOLETE!
   External Xtensa TIE interface for the lookup type. <i>user_object</i> is
   the user object to use in the <i>lookup_func</i> callback.
<p>
   The type of the lookup_func is defined in the
   <code>xtensa/tie/cstub-extif.h</code> file in the Xtensa model build
   directory.
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_xtensa_mpu_lookup.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_xtensa_mpu_lookup.html:__rm_interface_xtensa_mpu_lookup">xtensa_mpu_lookup</a></h1>
<p>

<a id="__rm_interface_xtensa_mpu_lookup.html:xtensa_mpu_lookup"></a><a id="__rm_interface_xtensa_mpu_lookup.html:xtensa_mpu_lookup_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This interface is implemented by the Xtensa core which is configured with an
   MPU. The primary use of this interface, is the iDMA device which will need
   to do various protection checks for the DMA transfers.
<p>
   The <code>mpu_region</code> returns region data that hits for
   the specified address. If the address hits in a background
   mapping, the end address will be when a foreground mapping
   overrides the background mapping.
   </p><pre class="jdocu_small">typedef struct xtensa_mpu_lookup {
        bool background;                 /* If false, a foreground hit */
        uint16 region;                   /* The foreground/background region */
        uint32 start;
        uint32 end;
        /* Permissions */
        bool sr;                             /* supervisor-read */
        bool sw;                             /* supervisor-write */
        bool sx;                             /* supervisor-execute */
        bool ur;                             /* user-read */
        bool uw;                             /* user-write */
        bool ux;                             /* user-execute */
} xtensa_mpu_lookup_t;

SIM_INTERFACE(xtensa_mpu_lookup) {
        xtensa_mpu_lookup_t (*mpu_region)(conf_object_t *obj, uint32 address);
};
#define XTENSA_MPU_LOOKUP_INTERFACE "xtensa_mpu_lookup"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_xtensa_output_queue.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_xtensa_output_queue.html:__rm_interface_xtensa_output_queue">xtensa_output_queue</a></h1>
<p>

<a id="__rm_interface_xtensa_output_queue.html:xtensa_output_queue"></a><a id="__rm_interface_xtensa_output_queue.html:xtensa_output_queue_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">OBSOLETE!
   External Xtensa TIE interface for the output queue type. Two callbacks
   should be registered in order to receive data from the object <i>obj</i>
   that implements the interface, typically a processor. When the queue is
   accessed the callbacks are called. <i>user_object</i> is the user object
   to use in the <i>full_callback</i> and <i>data_callback</i>
   callbacks.
<p>
   The types of the full_callback and data_callback are defined in the
   <code>xtensa/tie/cstub-extif.h</code> file in the Xtensa model build
   directory. The full_callback should return 1 if the queue is full, otherwise
   0. The data_callback is used for receiving the data.
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_xtensa_tie_export_state.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_xtensa_tie_export_state.html:__rm_interface_xtensa_tie_export_state">xtensa_tie_export_state</a></h1>
<p>

<a id="__rm_interface_xtensa_tie_export_state.html:xtensa_tie_export_state"></a><a id="__rm_interface_xtensa_tie_export_state.html:xtensa_tie_export_state_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">An <code>export_state</code> is a way for the Xtensa core to push data
   to a device implementing this interface.
<p>
   The <code>data</code> method contains the transferred data out from the
   Xtensa CPU. The <code>out_data</code> pointer holds the data that can be read,
   but only <code>bit_width</code> bits should be examined.
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_xtensa_tie_import_wire.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_xtensa_tie_import_wire.html:__rm_interface_xtensa_tie_import_wire">xtensa_tie_import_wire</a></h1>
<p>

<a id="__rm_interface_xtensa_tie_import_wire.html:xtensa_tie_import_wire"></a><a id="__rm_interface_xtensa_tie_import_wire.html:xtensa_tie_import_wire_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>import_wire</code> supports reading data from a device implementing this
   interface.
<p>
   The <code>data</code> method requests a <code>in_data</code> pointer to be filled with
   <code>bit_width</code> of data by the device.
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_xtensa_tie_input_queue.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_xtensa_tie_input_queue.html:__rm_interface_xtensa_tie_input_queue">xtensa_tie_input_queue</a></h1>
<p>

<a id="__rm_interface_xtensa_tie_input_queue.html:xtensa_tie_input_queue"></a><a id="__rm_interface_xtensa_tie_input_queue.html:xtensa_tie_input_queue_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>input_queue</code> represents a way for the Xtensa CPU to read data from
   a queue implemented in a device.
<p>
   The <code>empty</code> method indicates if there is anything to read in the queue or not.
</p><p>
   The <code>data</code> method is used to read data from the input queue implemented in
   the device, the device should write the next data in queue to the <code>in_data</code>
   pointer and fill it with <code>bit_width</code> bits of data.
</p><p>
   If <code>is_peek</code> is true, the data should be returned, but not removed from
   the queue.
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_xtensa_tie_lookup.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_xtensa_tie_lookup.html:__rm_interface_xtensa_tie_lookup">xtensa_tie_lookup</a></h1>
<p>

<a id="__rm_interface_xtensa_tie_lookup.html:xtensa_tie_lookup"></a><a id="__rm_interface_xtensa_tie_lookup.html:xtensa_tie_lookup_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">A <code>lookup</code> is a bidirectional communication between the Xtensa and
   the device implementing this interface. When the <code>data</code> method is
   received by the device, the <code>out_data</code> pointer contains
   <code>out_width</code> bits of data (from the Xtensa core) that the device
   should read and take action upon.
   As a response, the device should fill in <code>in_width</code> of bits in
   the <code>in_data</code> buffer, providing the result of the lookup
   back to the Xtensa instruction.
   
</dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_xtensa_tie_output_queue.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_xtensa_tie_output_queue.html:__rm_interface_xtensa_tie_output_queue">xtensa_tie_output_queue</a></h1>
<p>

<a id="__rm_interface_xtensa_tie_output_queue.html:xtensa_tie_output_queue"></a><a id="__rm_interface_xtensa_tie_output_queue.html:xtensa_tie_output_queue_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>output_queue</code> allows the Xtensa to push data on a queue
   which the device needs to implement.
<p>
   With the <code>full</code> method the Xtensa CPU might ask if the queue
   is currently full or not.
</p><p>
   To <code>data</code> method is used to push data on the output queue
   of the device. <code>out_data</code> is a pointer to the pushed data
   and <code>bit_width</code> how many bits that is pushed on the queue.
   If <code>reserve_only</code> is true, no data is present but the device
   should just allocate space for the data.
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_xtensa_wwdt_config.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_xtensa_wwdt_config.html:__rm_interface_xtensa_wwdt_config">xtensa_wwdt_config</a></h1>
<p>

<a id="__rm_interface_xtensa_wwdt_config.html:xtensa_wwdt_config"></a><a id="__rm_interface_xtensa_wwdt_config.html:xtensa_wwdt_config_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This interface is implemented by the Xtensa core which holds the
   configuration of the Windowed Watchdog Timer. The device itself is not part
   of the core, but implemented as an external device which fetches these
   values for correct device simulation, making the wwdt device generic
   for all configurations.
<p>
   The <code>has_wwdt</code> method reports if the wwdt option is included in the
   core at all. The rest of the member functions extract configuration details
   from the core, if the core does not have wwdt enabled, all are zeros.
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_xtensa_wwdt_faultinfo.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_xtensa_wwdt_faultinfo.html:__rm_interface_xtensa_wwdt_faultinfo">xtensa_wwdt_faultinfo</a></h1>
<p>

<a id="__rm_interface_xtensa_wwdt_faultinfo.html:xtensa_wwdt_faultinfo"></a><a id="__rm_interface_xtensa_wwdt_faultinfo.html:xtensa_wwdt_faultinfo_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This interface is implemented by the wwdt timer allowing the SoC device to
   read out the status register.  On real hardware the Wwdt_faultInfo is an
   eight bit <b>output</b> towards the device. However, in a simulator it makes
   more sense to allow the SoC-device to read the status when needed, instead
   of pushing out the new contents when bits changes. The uint8 value returned
   is a bitmask with the bits defined in <code>xtensa_wwdt_fault_info_t</code>.
   
<pre class="jdocu_small">typedef enum {
        Wwdt_Info_Derr_Inj_Dis = 1 &lt;&lt; 7,
        Wwdt_Info_Tfv_Err      = 1 &lt;&lt; 6,
        Wwdt_Info_Err_Inj      = 1 &lt;&lt; 5,
        Wwdt_Info_Oor_Exp      = 1 &lt;&lt; 4,
        Wwdt_Info_Oor_Kick     = 1 &lt;&lt; 3,
        Wwdt_Info_Ill_Kick     = 1 &lt;&lt; 2,
        Wwdt_Info_Cnt_Exp      = 1 &lt;&lt; 1,
        Wwdt_Fault_Asserted    = 1 &lt;&lt; 0,
} xtensa_wwdt_faultinfo_t;</pre><p>

   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="model-to-simulator-interfaces.html"><h1 class="jdocu"><a id="model-to-simulator-interfaces.html:Model-to-Simulator-Interfaces">5 Model-to-Simulator Interfaces</a></h1>
<p>

    







































































































</p></section><section class="page" id="__rm_interface_abs_pointer.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_abs_pointer.html:__rm_interface_abs_pointer">abs_pointer</a></h1>
<p>

<a id="__rm_interface_abs_pointer.html:abs_pointer"></a><a id="__rm_interface_abs_pointer.html:abs_pointer_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Interface implemented by tablet devices. Used by consoles to send touchpad
   events to the controller. The <b><i>set_state</i></b> function is called when
   something changes in the console. The coordinates are given as scaled
   absolute scaled values, where (0, 0) is the upper-left corner and (0xffff,
   0xffff) is the lower-right corner.
<p>
   </p><pre class="jdocu_small">typedef enum {
        Abs_Pointer_Button_Left   = 0x20,
        Abs_Pointer_Button_Right  = 0x10,
        Abs_Pointer_Button_Middle = 0x08
} abs_pointer_buttons_t;

typedef struct {
        abs_pointer_buttons_t buttons;
        uint16 x;
        uint16 y;
        uint16 z;
} abs_pointer_state_t;

SIM_INTERFACE(abs_pointer) {
        void (*set_state)(conf_object_t *obj, abs_pointer_state_t state);
};

#define ABS_POINTER_INTERFACE "abs_pointer"
</pre><p>
</p><p>

   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_abs_pointer_activate.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_abs_pointer_activate.html:__rm_interface_abs_pointer_activate">abs_pointer_activate</a></h1>
<p>

<a id="__rm_interface_abs_pointer_activate.html:abs_pointer_activate"></a><a id="__rm_interface_abs_pointer_activate.html:abs_pointer_activate_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Interface used by tablet controllers to temporary turn off and on the
   tracking of absolute pointer locations. Implemented by consoles. When
   disabled, no calls will be made to the controller's
   <code>abs_pointer</code> interface.
<p>
   </p><pre class="jdocu_small">SIM_INTERFACE(abs_pointer_activate) {
        void (*enable)(conf_object_t *obj);
        void (*disable)(conf_object_t *obj);
};

#define ABS_POINTER_ACTIVATE_INTERFACE "abs_pointer_activate"
</pre><p>
</p><p>

   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_apic_bus_v2.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_apic_bus_v2.html:__rm_interface_apic_bus_v2">apic_bus_v2</a></h1>
<p>

<a id="__rm_interface_apic_bus_v2.html:apic_bus_v2"></a><a id="__rm_interface_apic_bus_v2.html:apic_bus_v2_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The interface is used to handle extended 32-bit addressing mode supported
    by x2APIC. See <b>apic_bus</b> documentation.
<pre class="jdocu_small">SIM_INTERFACE(apic_bus_v2) {
        apic_bus_status_t (*interrupt)(conf_object_t *obj,
                apic_destination_mode_t dest_mode,
                apic_delivery_mode_t delivery_mode,
                int level_assert,
                apic_trigger_mode_t trigger_mode,
                uint8 vector,
                uint32 destination);
};
#define APIC_BUS_V2_INTERFACE "apic_bus_v2"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_bank_after_read.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_bank_after_read.html:__rm_interface_bank_after_read">bank_after_read</a></h1>
<p>

<a id="__rm_interface_bank_after_read.html:bank_after_read"></a><a id="__rm_interface_bank_after_read.html:bank_after_read_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>bank_after_read</code> interface is used to monitor and modify
   the state of read accesses from the <b><i>after_read_callback_t</i></b>
   callback.
<p>
   </p><pre class="jdocu_small">SIM_INTERFACE(bank_after_read) {
        physical_address_t (*offset)(bank_access_t *handle);
        physical_address_t (*size)(bank_access_t *handle);
        bool (*missed)(bank_access_t *handle);
        uint64 (*value)(bank_access_t *handle);

        void (*set_missed)(bank_access_t *handle, bool missed);
        void (*set_value)(bank_access_t *handle, uint64 value);
        conf_object_t *(*initiator)(bank_access_t *handle);
};
#define BANK_AFTER_READ_INTERFACE "bank_after_read"
</pre><p>
</p><p>

   <b><i>offset</i></b> retrieves the address of the access.
</p><p>
   <b><i>size</i></b> gets the size of the access.
</p><p>
   <b><i>missed</i></b> tells you whether or not the access succeeded.
</p><p>
   <b><i>value</i></b> provides the read value. May not be invoked if
   <b><i>missed</i></b> is true.
</p><p>
   <b><i>set_missed</i></b> can be used to inject or forgive an access miss.
</p><p>
   <b><i>set_value</i></b> can change the read value.
</p><p>
   <b><i>initiator</i></b> returns the initiator of the access. This method may be
   <code>NULL</code>, although this is deprecated. If the interface was implemented
   by a DML/C/C++ bank, then the method may only be accessed if the bank was
   compiled with Simics Base 6.0.129 or newer.
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods, but must be called from an
   <b><i>after_read_callback_t</i></b> callback with a valid handle of type
   <code>bank_access_t</code>.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_bank_after_write.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_bank_after_write.html:__rm_interface_bank_after_write">bank_after_write</a></h1>
<p>

<a id="__rm_interface_bank_after_write.html:bank_after_write"></a><a id="__rm_interface_bank_after_write.html:bank_after_write_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>bank_after_write</code> interface is used to monitor and modify
   the state of write accesses from the <b><i>after_write_callback_t</i></b>
   callback.
<p>
   </p><pre class="jdocu_small">SIM_INTERFACE(bank_after_write) {
        physical_address_t (*offset)(bank_access_t *handle);
        physical_address_t (*size)(bank_access_t *handle);
        bool (*missed)(bank_access_t *handle);

        void (*set_missed)(bank_access_t *handle, bool missed);
        conf_object_t *(*initiator)(bank_access_t *handle);
};
#define BANK_AFTER_WRITE_INTERFACE "bank_after_write"
</pre><p>
</p><p>

   <b><i>offset</i></b> retrieves the address of the access.
</p><p>
   <b><i>size</i></b> gets the size of the access.
</p><p>
   <b><i>missed</i></b> tells you whether or not the access succeeded.
</p><p>
   <b><i>set_missed</i></b> can be used to inject or forgive an access miss.
</p><p>
   <b><i>initiator</i></b> returns the initiator of the access. This method may be
   <code>NULL</code>, although this is deprecated. If the interface was implemented
   by a DML/C/C++ bank, then the method may only be accessed if the bank was
   compiled with Simics Base 6.0.129 or newer.
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods, but must be called from an
   <b><i>after_write_callback_t</i></b> callback with a valid handle of type
   <code>bank_access_t</code>.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_bank_before_read.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_bank_before_read.html:__rm_interface_bank_before_read">bank_before_read</a></h1>
<p>

<a id="__rm_interface_bank_before_read.html:bank_before_read"></a><a id="__rm_interface_bank_before_read.html:bank_before_read_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>bank_before_read</code> interface is used to monitor and modify
   the state of read accesses from the <b><i>before_read_callback_t</i></b>
   callback.
<p>
   </p><pre class="jdocu_small">SIM_INTERFACE(bank_before_read) {
        physical_address_t (*offset)(bank_access_t *handle);
        physical_address_t (*size)(bank_access_t *handle);

        void (*set_offset)(bank_access_t *handle, physical_address_t offset);
        void (*inquire)(bank_access_t *handle);
        conf_object_t *(*initiator)(bank_access_t *handle);
};
#define BANK_BEFORE_READ_INTERFACE "bank_before_read"
</pre><p>
</p><p>

   <b><i>offset</i></b> retrieves the address of the access.
</p><p>
   <b><i>size</i></b> gets the size of the access.
</p><p>
   <b><i>set_offset</i></b> can be used to redirect the access to another address.
</p><p>
   <b><i>inquire</i></b> can turn the access into an inquiry
   access. Subsequent and corresponding after_read callbacks are
   invoked regardless.
</p><p>
   <b><i>initiator</i></b> returns the initiator of the access. This method may be
   <code>NULL</code>, although this is deprecated. If the interface was implemented
   by a DML/C/C++ bank, then the method may only be accessed if the bank was
   compiled with Simics Base 6.0.129 or newer.
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods, but must be called from a
   <b><i>before_read_callback_t</i></b> callback with a valid handle of type
   <code>bank_access_t</code>.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_bank_before_write.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_bank_before_write.html:__rm_interface_bank_before_write">bank_before_write</a></h1>
<p>

<a id="__rm_interface_bank_before_write.html:bank_before_write"></a><a id="__rm_interface_bank_before_write.html:bank_before_write_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>bank_before_write</code> interface is used to monitor and modify
   the state of write accesses from the <b><i>before_write_callback_t</i></b>
   callback.
<p>
   </p><pre class="jdocu_small">SIM_INTERFACE(bank_before_write) {
        physical_address_t (*offset)(bank_access_t *handle);
        physical_address_t (*size)(bank_access_t *handle);
        uint64 (*value)(bank_access_t *handle);

        void (*suppress)(bank_access_t *handle);
        void (*set_offset)(bank_access_t *handle, physical_address_t offset);
        void (*set_value)(bank_access_t *handle, uint64 value);
        conf_object_t *(*initiator)(bank_access_t *handle);
};
#define BANK_BEFORE_WRITE_INTERFACE "bank_before_write"
</pre><p>
</p><p>

   <b><i>offset</i></b> retrieves the address of the access.
</p><p>
   <b><i>size</i></b> gets the size of the access.
</p><p>
   <b><i>value</i></b> provides the write value.
</p><p>
   <b><i>suppress</i></b> may be used to prevent the write. Subsequent
   and corresponding after_write callbacks are invoked regardless.
</p><p>
   <b><i>set_offset</i></b> can be used to redirect the write to an another
   address.
</p><p>
   <b><i>set_value</i></b> can change the write value.
</p><p>
   <b><i>initiator</i></b> returns the initiator of the access. This method may be
   <code>NULL</code>, although this is deprecated. If the interface was implemented
   by a DML/C/C++ bank, then the method may only be accessed if the bank was
   compiled with Simics Base 6.0.129 or newer.
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods, but must be called from a
   <b><i>before_write_callback_t</i></b> callback with a valid handle of type
   <code>bank_access_t</code>.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_bank_instrumentation_subscribe.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_bank_instrumentation_subscribe.html:__rm_interface_bank_instrumentation_subscribe">bank_instrumentation_subscribe</a></h1>
<p>

<a id="__rm_interface_bank_instrumentation_subscribe.html:bank_instrumentation_subscribe"></a><a id="__rm_interface_bank_instrumentation_subscribe.html:bank_instrumentation_subscribe_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>bank_instrumentation_subscribe</code> interface is implemented
   by non-anonymous register banks. The interface may be used to monitor and
   modify register accesses using callbacks.
<p>
   Similar to the CPU instrumentation framework, a bank that implements the
   interface is considered an instrumentation provider and is typically used by
   an instrumentation tool. The tool registers callbacks using this interface
   and performs its actions once they are called. Using this interface, tools
   may also group registered callbacks using connection objects. This can be
   useful to enforce a certain evaluation order of grouped callbacks.
</p><p>
   The <i>bank</i> argument in all methods is the register bank object
   implementing this interface.
</p><p>
   The <i>connection</i> can be used to group registered callbacks
   together, so that their order may be changed or their registered
   callbacks be enabled, disabled, or removed collectively. If
   <i>connection</i> is NULL when registering a callback, the callback is
   considered anonymous. Anonymous callbacks are evaluated before any other
   callbacks in the order of creation. See <code>instrumentation_order</code>
   interface for more details on the callback order.
</p><p>
   Each registration method installs a callback which is called at a
   particular time, before or after, read and write register
   accesses. Callbacks are not invoked during inquiry accesses. Using
   the <i>offset</i> and <i>size</i> arguments, a user may
   install the callback only for a particular range. If
   <i>offset</i> and <i>size</i> are 0 the callback is
   installed for the entire bank.
</p><p>
   The <i>user_data</i> is used to associate user defined data with every
   callback. Every time the callback is invoked the data is provided as an
   argument to the callback.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(bank_instrumentation_subscribe) {
        bank_callback_handle_t (*register_before_read)(
                conf_object_t *NOTNULL bank,
                conf_object_t *connection,
                uint64 offset,
                uint64 size,
                before_read_callback_t before_read,
                lang_void *user_data);
        bank_callback_handle_t (*register_after_read)(
                conf_object_t *NOTNULL bank,
                conf_object_t *connection,
                uint64 offset,
                uint64 size,
                after_read_callback_t after_read,
                lang_void *user_data);

        bank_callback_handle_t (*register_before_write)(
                conf_object_t *NOTNULL bank,
                conf_object_t *connection,
                uint64 offset,
                uint64 size,
                before_write_callback_t before_write,
                lang_void *user_data);
        bank_callback_handle_t (*register_after_write)(
                conf_object_t *NOTNULL bank,
                conf_object_t *connection,
                uint64 offset,
                uint64 size,
                after_write_callback_t after_write,
                lang_void *user_data);

        void (*remove_callback)(conf_object_t *NOTNULL bank,
                                bank_callback_handle_t callback);

        void (*remove_connection_callbacks)(conf_object_t *NOTNULL bank,
                                            conf_object_t *NOTNULL connection);
        void (*enable_connection_callbacks)(conf_object_t *NOTNULL bank,
                                            conf_object_t *NOTNULL connection);
        void (*disable_connection_callbacks)(conf_object_t *NOTNULL bank,
                                             conf_object_t *NOTNULL connection);

};
#define BANK_INSTRUMENTATION_SUBSCRIBE_INTERFACE \
        "bank_instrumentation_subscribe"
</pre><p>
</p><p>

   Every function that registers a callback returns a unique handle of type
   <code>bank_callback_handle_t</code>. The <b><i>remove_callback</i></b> method
   uninstalls the callback associated with the handle.  The
   <b><i>remove_connection_callbacks</i></b> uninstalls all callbacks associated
   with a connection object. Similarly, the
   <b><i>enable_connection_callbacks</i></b> and
   <b><i>disable_connection_callbacks</i></b> methods are used to temporarily
   enable or disable a group of callbacks.
</p><p>
   Callback functions registered through the
   <code>bank_instrumentation_subscribe</code> interface are called before or
   after read and write accesses, like so:
</p><p>
   
</p><pre class="jdocu_small">typedef void (*before_read_callback_t)(conf_object_t *connection,
                                       bank_before_read_interface_t *access,
                                       bank_access_t *handle,
                                       lang_void *user_data);</pre><p>

   
</p><pre class="jdocu_small">typedef void (*after_read_callback_t)(conf_object_t *connection,
                                      bank_after_read_interface_t *access,
                                      bank_access_t *handle,
                                      lang_void *user_data);</pre><p>

   
</p><pre class="jdocu_small">typedef void (*before_write_callback_t)(conf_object_t *connection,
                                        bank_before_write_interface_t *access,
                                        bank_access_t *handle,
                                        lang_void *user_data);</pre><p>

   
</p><pre class="jdocu_small">typedef void (*after_write_callback_t)(conf_object_t *connection,
                                       bank_after_write_interface_t *access,
                                       bank_access_t *handle,
                                       lang_void *user_data);</pre><p>

</p><p>
   The <i>connection</i> is the object used to group the callback with
   any other callbacks, which may be NULL. The <i>access</i> object
   provides a number of methods which may be used along with the
   <i>handle</i> to perform a certain set of actions at the particular
   point of the access. The <i>user_data</i> is the custom data
   which was associated with the callback at registration.
</p><p>
   For every callback, additional information may be accessed using a specific
   interface which is passed as a parameter to the callback. See
   <code>bank_before_read</code>, <code>bank_after_read</code>,
   <code>bank_before_write</code>, and <code>bank_after_write</code> for
   details.
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_branch_recorder_handler.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_branch_recorder_handler.html:__rm_interface_branch_recorder_handler">branch_recorder_handler</a></h1>
<p>

<a id="__rm_interface_branch_recorder_handler.html:branch_recorder_handler"></a><a id="__rm_interface_branch_recorder_handler.html:branch_recorder_handler_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">An internal interface. Can be changed at any time.
   
</dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Internal.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_breakpoint.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_breakpoint.html:__rm_interface_breakpoint">breakpoint</a></h1>
<p>

<a id="__rm_interface_breakpoint.html:breakpoint"></a><a id="__rm_interface_breakpoint.html:breakpoint_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The breakpoint interface is implemented by any object that supports breaking
   on an address range.
<p>
   </p><pre class="jdocu_small">SIM_INTERFACE(breakpoint) {
        void (*insert_breakpoint)(conf_object_t *object,
                                  conf_object_t *caller,
                                  breakpoint_handle_t handle,
                                  access_t access,
                                  generic_address_t start,
                                  generic_address_t end);
        void (*remove_breakpoint)(conf_object_t *object,
                                  breakpoint_handle_t handle);
        breakpoint_info_t (*get_breakpoint)(conf_object_t *obj,
                                            breakpoint_handle_t handle);
};

#define BREAKPOINT_INTERFACE "breakpoint"
</pre><p>
</p><p>

   The <b><i>insert_breakpoint</i></b> function is called when adding a
   breakpoint on <i>object</i>. The <i>handle</i> identified the
   breakpoint and is to be used when triggering the breakpoint and when
   breakpoints are removed. The <i>access</i> parameter specifies the types
   of accesses that the breakpoint is set for. The breakpoint range is from
   <i>start</i> to <i>end</i> and includes both ends.
</p><p>
   The implementer of this interface should call <i>caller</i> through the
   <code>breakpoint_trigger</code> interface to trigger the breakpoint.
</p><p>
   <b>remove_breakpoint</b> should remove the breakpoint and further accesses
   to the address range should not trigger that breakpoint.
</p><p>
   This interface is only to be used by the Simics core. Other uses of
   breakpoints should go through the available breakpoint API calls such as
   <b><i>SIM_breakpoint</i></b>.
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_breakpoint_change.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_breakpoint_change.html:__rm_interface_breakpoint_change">breakpoint_change</a></h1>
<p>

<a id="__rm_interface_breakpoint_change.html:breakpoint_change"></a><a id="__rm_interface_breakpoint_change.html:breakpoint_change_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>breakpoint_change</code> interface is implemented by
   objects that wish to get notified when breakpoints are added,
   removed, or changed in some way.
<p>
   The object that wants to get notified of changes to breakpoints in
   a another object would use the <code>simple_dispatcher</code> in
   the breakpoint_change port of that other object. The other object
   will then lookup the <code>breakpoint_change</code> interface in
   the object to notify and use that when breakpoint updates occur.
</p><p>
   The breakpoint_change port is implemented by objects of the
   <b>cell</b> class, and a listener that registers on a cell with get
   notified on any breakpoint changes in that cell.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(breakpoint_change) {
        void (*breakpoint_added)(conf_object_t *obj,
                                 conf_object_t *bp_obj,
                                 breakpoint_handle_t handle);
        void (*breakpoint_removed)(conf_object_t *obj,
                                   conf_object_t *bp_obj,
                                   breakpoint_handle_t handle);
};

#define BREAKPOINT_CHANGE_INTERFACE "breakpoint_change"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_breakpoint_query_v2.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_breakpoint_query_v2.html:__rm_interface_breakpoint_query_v2">breakpoint_query_v2</a></h1>
<p>

<a id="__rm_interface_breakpoint_query_v2.html:breakpoint_query_v2"></a><a id="__rm_interface_breakpoint_query_v2.html:breakpoint_query_v2_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Objects of the <b>context</b> and <b>memory-space</b>
   classes implement the <code>breakpoint_query_v2</code> interface. It is
   used by processors to check for breakpoints.
<p>
   Implementors of this interface should use
   <b><i>SIM_register_compatible_interfaces</i></b> after
   <b><i>SIM_register_interface</i></b> to also register earlier versions of the
   interface.
</p><p>
   The <b><i>get_breakpoints</i></b> function returns a set of
   breakpoints that intersect the range given in <i>start</i> and
   <i>end</i>, including both start and end in the range. Only
   breakpoints set on access types with bits set in
   <i>read_write_execute</i> will be returned.
</p><p>
   When information from <b><i>get_breakpoints</i></b> has been processed, the
   breakpoints array in the breakpoint_set_t structure should be freed with
   MM_FREE.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(breakpoint_query_v2) {
        breakpoint_set_t (*get_breakpoints)(conf_object_t *obj,
                                            access_t read_write_execute,
                                            generic_address_t start,
                                            generic_address_t end);
};

#define BREAKPOINT_QUERY_V2_INTERFACE "breakpoint_query_v2"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_breakpoint_trigger.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_breakpoint_trigger.html:__rm_interface_breakpoint_trigger">breakpoint_trigger</a></h1>
<p>

<a id="__rm_interface_breakpoint_trigger.html:breakpoint_trigger"></a><a id="__rm_interface_breakpoint_trigger.html:breakpoint_trigger_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Objects implementing the <code>breakpoint</code> interface
   typically also implement the <code>breakpoint_trigger</code>
   interface. Processors call the <b><i>trigger_breakpoint</i></b>
   function to signal that a memory access intersects a
   breakpoint. The <b><i>trigger_breakpoint</i></b> function will raise
   the appropriate haps and the currently scheduled execute object may
   receive a <b><i>stop</i></b> call during the call to
   <b><i>trigger_breakpoint</i></b>.
<p>
   The <i>obj</i> argument is the object that holds the
   breakpoint, typically a memory space or a context
   object. <i>initiator_obj</i> is the source of the memory
   operation that triggers the breakpoint. The <i>handle</i>
   argument identifies the breakpoint to trigger. A value of
   <i>BREAKPOINT_HANDLE_ANY</i> can be passed as
   <i>handle</i>, in which case all the breakpoints that match the
   given <i>address</i>, <i>size</i>, and <i>access</i>
   will be triggered. The <i>address</i>, <i>size</i>, and
   <i>access</i> arguments specify information about the access
   that triggers the breakpoint. The <i>data</i> argument points
   to a buffer where the data for the access is kept.
</p><p>
   If a <b><i>stop</i></b> is received during a call to
   <b><i>trigger_breakpoint</i></b>, then it is recommended that any
   software visible actions carried out after the breakpoint are
   logged. That could for example be to notify the user if the entire
   instruction that triggers a breakpoint will complete, and that the
   instruction will then not be re-executed when the simulation
   restarts.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(breakpoint_trigger) {
        void (*trigger_breakpoint)(conf_object_t *obj,
                                   conf_object_t *initiator_obj,
                                   breakpoint_handle_t handle,
                                   generic_address_t address,
                                   generic_address_t size,
                                   access_t access,
                                   uint8 *data);
};

#define BREAKPOINT_TRIGGER_INTERFACE "breakpoint_trigger"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_callback_info.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_callback_info.html:__rm_interface_callback_info">callback_info</a></h1>
<p>

<a id="__rm_interface_callback_info.html:callback_info"></a><a id="__rm_interface_callback_info.html:callback_info_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This interface can be implemented by any object that can issue callbacks.
   The <i>get_callbacks</i> method returns a <code>attr_value_t</code> list
   of type <code>[[(o|n)sss*]]</code> where <code>o</code> is the object that installed
   the callback (if applicable, otherwise NIL). The <code>sss</code> strings are:
<p>
   </p><ul>
   <li>A one liner description about the callback. Could for example contain the
   interface method that installed the callback, if such one exist.</li>
   <li>The function name.</li>
   <li>A string describing the user data.</li>
   </ul>
<p>
   </p><pre class="jdocu_small">SIM_INTERFACE(callback_info) {
        attr_value_t (*get_callbacks)(conf_object_t *obj);
};
#define CALLBACK_INFO_INTERFACE "callback_info"
</pre><p>
</p><p>

   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods, but must be called from a callback
   receiving a handle of type <code>instruction_handle_t</code>.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_cell_inspection.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_cell_inspection.html:__rm_interface_cell_inspection">cell_inspection</a></h1>
<p>

<a id="__rm_interface_cell_inspection.html:cell_inspection"></a><a id="__rm_interface_cell_inspection.html:cell_inspection_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>cell_inspection</code> interface is implemented by
   objects of the cell class. It is used by objects implementing the
   <code>execute</code> interface to update the currently executing
   objects when control is transferred outside of the execute object.
<p>
   The current object implementing <code>processor_info</code> is set with
   <b><i>set_current_processor_obj()</i></b>. Similarly, the current object
   implementing <code>step</code> is set with
   <b><i>set_current_step_obj()</i></b>.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(cell_inspection) {
        void (*set_current_processor_obj)(conf_object_t *obj,
                                          conf_object_t *cpu_obj);
        void (*set_current_step_obj)(conf_object_t *obj,
                                     conf_object_t *step_obj);
};

#define CELL_INSPECTION_INTERFACE "cell_inspection"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_co_execute.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_co_execute.html:__rm_interface_co_execute">co_execute</a></h1>
<p>

<a id="__rm_interface_co_execute.html:co_execute"></a><a id="__rm_interface_co_execute.html:co_execute_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Experimental, may change without notice.
<p>
   </p><pre class="jdocu_small">SIM_INTERFACE(co_execute) {
        void (*start_thread)(conf_object_t *NOTNULL obj,
                             void (*entry)(lang_void *arg), lang_void *arg);
        void (*yield)(conf_object_t *NOTNULL obj);
};
#define CO_EXECUTE_INTERFACE "co_execute"
</pre><p>
</p><p>

   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_component.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_component.html:__rm_interface_component">component</a></h1>
<p>

<a id="__rm_interface_component.html:component"></a><a id="__rm_interface_component.html:component_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">All component classes must implement the <code>component</code>
   interface. All functions in the interface must be implemented.
<p>
   The <b><i>pre_instantiate</i></b> function is called before the
   component is instantiated. The function returns <code>true</code> if the
   component can be instantiated, or <code>false</code> if not.
</p><p>
   The component might need to do some extra work after the component
   has been instantiated. This should be done when called via the
   <b><i>post_instantiate</i></b> function.
</p><p>
   The <b><i>create_cell</i></b> function returns <code>true</code> if the
   configuration system can create a default cell object for the
   component, or <code>false</code> if not. Both
   <b><i>pre_instantiate</i></b> and <b><i>create_cell</i></b> typically
   return <code>true</code>.
</p><p>
   Component has slots. A slot has key and value. The key is the slot
   name as a string. The value is a conf object, a pre conf object, or
   None, or nested lists of such types.
</p><p>
   Slots are either defined in the component or added after the
   component has been created. Slots defined in the component are
   static slots which can not be deleted, but the slot value can be
   changed. Slots added to the component after creation are
   dynamic slots and they can be removed when wanted.
</p><p>
   The <b><i>get_slots</i></b> function returns a dictionary with slot
   names as dictionary keys and slot values as dictionary values.
</p><p>
   The <b><i>get_slot_objects</i></b> function returns a list of all conf
   objects and pre conf objects extracted from all slot values.
</p><p>
   The <b><i>get_slot_value</i></b> returns the slot value. The slot name
   is passed as <i>slot</i> argument. A slot value is set using
   the <b><i>set_slot_value</i></b> function. The <i>value</i>
   argument should be a conf object, pre conf object, or None, or
   nested lists of such types. The get function returns NULL on failure.
   The set function does not return anything to indicate failure.
</p><p>
   The <b><i>has_slot</i></b> function returns <code>true</code> if the
   <i>slot</i> exists, otherwise <code>false</code>. The slot can
   either be a static slot or a dynamic slot. The <b><i>add_slot</i></b>
   function adds the slot named <i>slot</i>. Adding a slot can
   fail if the slot already exist. The added slot will be a dynamic
   slot. A dynamic slot can be deleted. The <b><i>del_slot</i></b>
   function deletes a dynamic slot. Deleting a slot will fail if the
   slot does not exist or if the slot is static. Both
   <b><i>add_slot</i></b> and <b><i>del_slot</i></b> returns <code>true</code>
   on success or <code>false</code> on failure.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(component) {
        bool (*pre_instantiate)(conf_object_t *obj);
        void (*post_instantiate)(conf_object_t *obj);
        bool (*create_cell)(conf_object_t *obj);

        attr_value_t (*get_slots)(conf_object_t *obj);
        attr_value_t (*get_slot_objects)(conf_object_t *obj);

        attr_value_t (*get_slot_value)(conf_object_t *obj,
                                 const char *NOTNULL slot);
        void (*set_slot_value)(conf_object_t *obj,
                         const char *NOTNULL slot,
                         attr_value_t value);

        bool (*has_slot)(conf_object_t *obj,
                         const char *NOTNULL slot);
        bool (*add_slot)(conf_object_t *obj,
                         const char *NOTNULL slot);
        bool (*del_slot)(conf_object_t *obj,
                         const char *NOTNULL slot);
};
#define COMPONENT_INTERFACE "component"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem"><table>

   <tbody><tr><td class="jdocu_noborder"><b><i>post_instantiate</i></b></td><td class="jdocu_noborder">Global Context
           </td></tr>

   <tr><td class="jdocu_noborder"><b><i>pre_instantiate</i></b></td><td class="jdocu_noborder">Global Context
           </td></tr>

   <tr><td class="jdocu_noborder"><b><i>create_cell</i></b></td><td class="jdocu_noborder">Global Context</td></tr>

   <tr><td class="jdocu_noborder"><b><i>get_slots</i></b></td><td class="jdocu_noborder">Cell Context</td></tr>

   <tr><td class="jdocu_noborder"><b><i>get_objects</i></b></td><td class="jdocu_noborder">Cell Context</td></tr>

   <tr><td class="jdocu_noborder"><b><i>get_slot_value</i></b></td><td class="jdocu_noborder">Global Context</td></tr>

   <tr><td class="jdocu_noborder"><b><i>set_slot_value</i></b></td><td class="jdocu_noborder">Global Context</td></tr>

   <tr><td class="jdocu_noborder"><b><i>add_slot</i></b></td><td class="jdocu_noborder">Global Context</td></tr>

   <tr><td class="jdocu_noborder"><b><i>del_slot</i></b></td><td class="jdocu_noborder">Global Context</td></tr>

   </tbody></table>
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_component_connector.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_component_connector.html:__rm_interface_component_connector">component_connector</a></h1>
<p>

<a id="__rm_interface_component_connector.html:component_connector"></a><a id="__rm_interface_component_connector.html:component_connector_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>component_connector</code> is implemented by components
  that use connector objects for handling connections between components.
<p>
  The connection setup is made in two stages, the check stage and the
  connect stage. The check stage is often not needed, but it can be
  used to make sure that the later connect step will not fail. Each
  connection is handled by a connector object. The connector object
  will both handle the connection in both direction, i.e. sending
  connect information and receiving connector information. Two
  components that should be connected must implement one connector
  object each.
</p><p>
  The <b><i>get_check_data</i></b> and <b><i>get_connect_data</i></b> will
  be called from the connector object to get connection data to send
  to the other part of the connection, i.e. to the destination. The
  data sent must be an <code>attr_value_t</code> type.
</p><p>
  The <b><i>check</i></b>, <b><i>connect</i></b>, and <b><i>disconnect</i></b>
  functions are called from the connector object when another
  connector wants to connect to this connection. The connection data
  is passed as the <i>attr</i> argument.
</p><p>
  </p><pre class="jdocu_small">SIM_INTERFACE(component_connector) {
        attr_value_t (*get_check_data)(conf_object_t *obj,
                                       conf_object_t *NOTNULL connector);
        attr_value_t (*get_connect_data)(conf_object_t *obj,
                                         conf_object_t *NOTNULL connector);
        bool (*check)(conf_object_t *obj, conf_object_t *NOTNULL connector,
                      attr_value_t attr);
        void (*connect)(conf_object_t *obj, conf_object_t *NOTNULL connector,
                        attr_value_t attr);
        void (*disconnect)(conf_object_t *obj,
                           conf_object_t *NOTNULL connector);
};

#define COMPONENT_CONNECTOR_INTERFACE "component_connector"
</pre><p>
</p><p>
  
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Global Context for all methods.
  
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_concurrency_group.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_concurrency_group.html:__rm_interface_concurrency_group">concurrency_group</a></h1>
<p>

<a id="__rm_interface_concurrency_group.html:concurrency_group"></a><a id="__rm_interface_concurrency_group.html:concurrency_group_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>concurrency_group</code> interface is used to ensure
   that groups of objects are placed in the same thread domain.
<p>
   The <b><i>serialized_memory_group</i></b> method returns a list with objects
   that should be placed in the same thread domain when the models
   run in <code>Sim_Concurrency_Mode_Serialized_Memory</code>.
</p><p>
   The <b><i>execution_group</i></b> method returns a list with objects that
   should always be placed in the same thread domain.
</p><p>
   Both methods take a <i>group_index</i> argument, allowing
   multiple lists to be returned. The index argument is 0-based,
   and a nil attribute for the first unsupported index. Note that
   returned lists do not necessarily contain the object implementing
   the interface; the interface can be used to group other objects.
</p><p>
   When Simics forms the thread domain groups, all objects implementing the
   <code>concurrency_group</code> are queried, and the constraints
   are combined. For instance, the groups [A, B] and [A, C]
   are combined into the group [A, B, C]. That is, the objects
   A, B and C will be put in the same thread domain.
</p><p>
   Refer to the threading chapter in the <em>API Reference Manual</em>
   for more details.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(concurrency_group) {
        attr_value_t (*serialized_memory_group)(conf_object_t *NOTNULL obj,
                                                unsigned group_index);
        attr_value_t (*execution_group)(conf_object_t *NOTNULL obj,
                                        unsigned group_index);
};
#define CONCURRENCY_GROUP_INTERFACE "concurrency_group"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Global Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_concurrency_mode.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_concurrency_mode.html:__rm_interface_concurrency_mode">concurrency_mode</a></h1>
<p>

<a id="__rm_interface_concurrency_mode.html:concurrency_mode"></a><a id="__rm_interface_concurrency_mode.html:concurrency_mode_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><a id="__rm_interface_concurrency_mode.html:concurrency_mode_t"></a>
<p>
   The <code>concurrency_mode</code> interface allows a model to
   support a concurrency mode other than the default
   <code>Sim_Concurrency_Mode_Serialized</code>.
</p><p>
   The <b><i>supported_modes</i></b> method returns a bitmask
   with all the supported modes.
</p><p>
   The <b><i>current_mode</i></b> method returns the currently active
   mode. Note that the model should normally checkpoint this setting.
</p><p>
   The <b><i>switch_mode</i></b> method is invoked by Simics to notify
   a model that a different concurrency mode has been selected by the user.
   This typically happens when the user switches threading mode using
   the <b>set-threading-mode</b> command. The object will typically
   be placed in a different thread domain shortly after the call to this
   method.
</p><p>
   A model will be placed in the cell thread domain if it uses
   the <code>Sim_Concurrency_Mode_Serialized</code> mode and
   in a separate thread domain otherwise. The <code>concurrency_group</code>
   interface can be used to ensure that multiple objects are placed in the
   same thread domain.
</p><p>
   Refer to the chapter about threading in the
   <em>API Reference Manual</em> for details about thread domains,
   the Standard Device Model and the Threaded Device Model.
</p><p>
   
</p><pre class="jdocu_small">typedef enum {
        /* Model uses the Standard Device Model */
        Sim_Concurrency_Mode_Serialized = 1,

        /* Model uses the Threaded Device Model.
           Direct memory pages are protected against concurrency. */
        Sim_Concurrency_Mode_Serialized_Memory = 2,

        /* Model uses the Threaded Device Model.
           Concurrency can be observed on direct memory pages */
        Sim_Concurrency_Mode_Full = 4,
} concurrency_mode_t;</pre><p>

   </p><pre class="jdocu_small">SIM_INTERFACE(concurrency_mode) {
        concurrency_mode_t (*supported_modes)(conf_object_t *NOTNULL obj);
        concurrency_mode_t (*current_mode)(conf_object_t *NOTNULL obj);
        void (*switch_mode)(conf_object_t *NOTNULL obj,
                            concurrency_mode_t mode);
};
#define CONCURRENCY_MODE_INTERFACE "concurrency_mode"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Global Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_connector.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_connector.html:__rm_interface_connector">connector</a></h1>
<p>

<a id="__rm_interface_connector.html:connector"></a><a id="__rm_interface_connector.html:connector_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>connector</code> interface must be implemented by
   connector objects. The interface describes the connector and how it
   can be connected to other connectors. A connector is used for
   connecting component objects. The connector is just a proxy for the
   connection, the connector uses the <code>component_connector</code>
   interface in the components to setup the connection.
<p>
   The <b><i>type</i></b> function returns the connector type as a
   string. Two connectors can only be connected if the type is
   identical.
</p><p>
   A hotpluggable connector returns <code>true</code> when calling the
   <b><i>hotpluggable</i></b> function, otherwise <code>false</code>. A
   hotpluggable connector can be connected before or after the
   component is instantiated, an non hotpluggable connector must be
   connected before the component is instantiated.
</p><p>
   The <b><i>required</i></b> function returns <code>true</code> if the
   connector must be connected before instantiated, otherwise
   <code>false</code>.
</p><p>
   A connector can be connected to many connectors, but it is only
   supported if the <b><i>multi</i></b> function return <code>true</code>. It
   is not recommended that a connector support multi connections. A
   component can instead dynamically create connectors when needed.
</p><p>
   A connector has a direction; <em>up</em>, <em>down</em> or
   <em>any</em>. The direction decides in which order the connectors
   in a component tree are connected and the structure of the tree.
</p><p>
   Connections are setup in two steps. The first step is to add the
   connection, which is done using the <b><i>add_destination</i></b>
   function. Adding a connection can fail for several reasons and it
   is implementation dependent how the connection can fail. A
   connection can for instance fail because the destination object
   requires something that the source component did not pass when
   checking the connection. Just adding a connection does not mean
   that the components actually connect. The components have to save
   the data given with the <b><i>add_destination</i></b> function. The
   actual setup of the connection is made in the second step when the
   <b><i>update</i></b> function is called, which finalizes the
   connection.
</p><p>
   The <b><i>add_destination</i></b> and <b><i>remove_destination</i></b>
   functions sets the state of the connection. It is first when the
   <b><i>update</i></b> function is called when the connection is
   finalized. Both <b><i>add_destination</i></b> and
   <b><i>remove_destination</i></b> returns <code>true</code> if the call was
   successful otherwise they return <code>false</code>.
</p><p>
   Parameters to the <b><i>add_destination</i></b> function are the own
   object <i>obj</i> and the destination object
   <i>dst_obj</i>. The destination object must be a port
   object and it must implement the <code>connector</code>
   interface.
</p><p>
   The <b><i>update</i></b> function is called when the component should
   update its current connection status. The status of the connection
   has previously been set using the <b><i>add_destination</i></b>
   or/and <b><i>remove_destination</i></b> functions.
</p><p>
   The <b><i>destination</i></b> function returns a list of port objects
   that the its connected to. The <b><i>destination</i></b> function
   returns the state of the connection not the finalized state,
   i.e. the state of the connection before <b><i>update</i></b>
   functional call.
</p><p>
   The <b><i>check</i></b>, <b><i>connect</i></b>, and <b><i>disconnect</i></b>
   functions initiates a connection setup via the connector object. The
   connector will forward the setup to the components affected by the
   connection via the <code>component_connector</code> interface.
</p><p>
   The <b><i>deletion_requested</i></b> function is called after disconnecting
   components. A dynamic connector might want to return True in order to be
   deleted just after the disconnection.
</p><p>
   </p><pre class="jdocu_small">typedef enum {
        Sim_Connector_Direction_Up,
        Sim_Connector_Direction_Down,
        Sim_Connector_Direction_Any
} connector_direction_t;

SIM_INTERFACE(connector) {
        char *(*type)(conf_object_t *obj);
        bool (*hotpluggable)(conf_object_t *obj);
        bool (*required)(conf_object_t *obj);
        bool (*multi)(conf_object_t *obj);
        connector_direction_t (*direction)(conf_object_t *obj);

        bool (*add_destination)(conf_object_t *obj, conf_object_t *connector);
        bool (*remove_destination)(conf_object_t *obj,
                                   conf_object_t *connector);
        attr_value_t (*destination)(conf_object_t *obj); /* list of
                                                            connector objects */
        void (*update)(conf_object_t *obj);

        bool (*check)(conf_object_t *obj, attr_value_t attr);
        void (*connect)(conf_object_t *obj, attr_value_t attr);
        void (*disconnect)(conf_object_t *obj);
        bool (*deletion_requested)(conf_object_t *obj);
};
#define CONNECTOR_INTERFACE "connector"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Global Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_cpu_cached_instruction.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_cpu_cached_instruction.html:__rm_interface_cpu_cached_instruction">cpu_cached_instruction</a></h1>
<p>

<a id="__rm_interface_cpu_cached_instruction.html:cpu_cached_instruction"></a><a id="__rm_interface_cpu_cached_instruction.html:cpu_cached_instruction_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This interface allows registration of callbacks for individual instructions,
   i.e., instructions at a specific address.  This interface can only be used
   inside a <code>cpu_cached_instruction_cb_t</code> callback where there is a
   valid <i>ci_handle</i>. The callback is installed by calling the
   <b><i>register_cached_instruction_cb</i></b> method in the
   <code>cpu_instrumentation_subscribe</code> interface. The signature of the
   callback function looks like this:
<p>
   
</p><pre class="jdocu_small">typedef void (*cpu_cached_instruction_cb_t)(
        conf_object_t *obj, conf_object_t *cpu,
        cached_instruction_handle_t *ci_handle,
        instruction_handle_t *iq_handle,
        lang_void *user_data);</pre><p>

</p><p>
   When the callback is installed Simics will call it every time an instruction
   is put into the internal instruction cache, which might have different
   entries for different execution modes. For example, in an unlikely case
   where the same instruction is executed in 32-bit mode and later in 64-bit
   mode (running an x86 processor for instance), this callback will be called
   twice, one time for each mode. This allows the user to install specific
   callbacks for this specific instruction and apply filtering based on
   instruction types, etc. This approach is more efficient than doing dynamic
   filtering in the instruction and read/write callbacks installed by the
   <b><i>cpu_instrumentation_subscribe</i></b> interface.
</p><p>
   The <i>iq_handle</i> together with the
   <code>cpu_instruction_query</code> interface let a user examine
   instruction properties. The <i>user_data</i> is the user data for the
   callback.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(cpu_cached_instruction) {
        void (*register_instruction_before_cb)(
                conf_object_t *cpu,
                cached_instruction_handle_t *ci_handle,
                cpu_instruction_cb_t cb,
                lang_void *user_data,
                cpu_callback_free_user_data_cb_t free_cb);
        void (*register_instruction_after_cb)(
                conf_object_t *obj,
                cached_instruction_handle_t *ci_handle,
                cpu_instruction_cb_t cb,
                lang_void *user_data,
                cpu_callback_free_user_data_cb_t free_cb);
        void (*register_read_before_cb)(
                conf_object_t *obj,
                cached_instruction_handle_t *ci_handle,
                cpu_memory_cb_t cb,
                lang_void *user_data,
                cpu_callback_free_user_data_cb_t free_cb);
        void (*register_read_after_cb)(
                conf_object_t *obj,
                cached_instruction_handle_t *ci_handle,
                cpu_memory_cb_t cb,
                lang_void *user_data,
                cpu_callback_free_user_data_cb_t free_cb);
        void (*register_write_before_cb)(
                conf_object_t *obj,
                cached_instruction_handle_t *ci_handle,
                cpu_memory_cb_t cb,
                lang_void *user_data,
                cpu_callback_free_user_data_cb_t free_cb);
        void (*register_write_after_cb)(
                conf_object_t *obj,
                cached_instruction_handle_t *ci_handle,
                cpu_memory_cb_t cb,
                lang_void *user_data,
                cpu_callback_free_user_data_cb_t free_cb);
#ifndef PYWRAP
        void (*add_counter)(
                conf_object_t *obj,
                cached_instruction_handle_t *ci_handle,
                uint64 *counter,
                bool use_atomic_increment);
#endif
};

#define CPU_CACHED_INSTRUCTION_INTERFACE "cpu_cached_instruction"
</pre><p>
</p><p>

   The method <b><i>register_instruction_before_cb</i></b> installs a callback
   that is called before the cached instruction is executed. The
   <i>ci_handle</i> is used to bind the callback to the cached instruction.
   The <i>user_data</i> is the callback's user data, and a callback for
   freeing the data is also available. The <i>free_cb</i> looks like this:
</p><p>
   
</p><pre class="jdocu_small">typedef void (*cpu_callback_free_user_data_cb_t)(
        conf_object_t *obj, conf_object_t *cpu, lang_void *user_data);</pre><p>

</p><p>
   It is called when Simics wants to free cached instructions, which can happen
   in various situations. <i>obj</i> is the connection object that should
   free the data. The callback may be NULL if not needed.
</p><p>
   The <i>cb</i> callback type is the same as used for instructions in the
   <code>cpu_instrumentation_subscribe</code> interface:
   </p><p>
   
</p><pre class="jdocu_small">typedef void (*cpu_instruction_cb_t)(
        conf_object_t *obj, conf_object_t *cpu,
        instruction_handle_t *handle,
        lang_void *user_data);</pre><p>
 
</p><p>
   The object <i>obj</i> is the user object that registers the callback and
   <i>cpu</i> is the processor object executing the instruction. The
   <i>handle</i> can be used to query more data about the instruction. See
   the <code>cpu_instruction_query</code> interface for more information. The
   <i>user_data</i> is the user data associated with the callback.
</p><p>
   The user data is a convenient location for storing information about the
   instruction, such as user specific decode information, etc. The user data is
   private for each installed callback.
</p><p>
   The cached information about the instruction is bound to its physical
   address so the logical address cannot typically be saved since it may vary
   between calls (if the MMU-mapping has changed).
</p><p>
   <b><i>register_instruction_after_cb</i></b> installs a callback that is called
   after a cached instruction is executed. Otherwise it works in the same as
   the before variant.
   However, reading the program counter register for a control flow instruction
   in this callback will reflect the new location, whereas using the
   <code>cpu_instruction_query</code> for reading out the instruction address
   will still return the address of the control flow instruction.
</p><p>
   <b><i>register_read_before_cb</i></b> installs a callback that is called before
   each read operation in the cached instruction. The callback is the
   same as used for read and writes in the
   <code>cpu_instrumentation_subscribe</code> interface:
</p><p>
   
</p><pre class="jdocu_small">typedef void (*cpu_memory_cb_t)(
        conf_object_t *obj, conf_object_t *cpu,
        memory_handle_t *handle,
        lang_void *user_data);</pre><p>
 
   </p><p>
   As for instructions, <i>obj</i> is the object that registered the
   callback and <i>cpu</i> is the processor doing the access.  The
   <i>handle</i> can be used to further operate on the access by using the
   <code>cpu_memory_query</code> interface. The
   <i>user_data</i> and the <i>free_cb</i> arguments to
   <b><i>register_read_before_cb</i></b> can be used to store user data for the
   read operations in the cached instruction. The user data is private for each
   installed callback but is shared between all read before operations in the
   instruction. 
</p><p>
   <b><i>register_read_after_cb</i></b> installs a callback that is called after
   each read operation in the cached instruction. The user data is private for
   each installed callback but is shared between all read after operations in
   the instruction. Otherwise it works in the same way as the before variant.
</p><p>
   <b><i>register_write_before_cb</i></b> and <b><i>register_write_after_cb</i></b>
   installs callbacks that is called before and after each write operation in
   the cached instructions. Otherwise they work in the same way as the read
   variants.
</p><p>
   Note that installing a read or write callback on an instruction without any
   memory operations will be useless.
</p><p>
   The <b><i>add_counter</i></b> method can be used to add simple counters for
   this particular instruction. The <i>counter</i> argument is a pointer to
   a 64 bit counter value that will be incremented each time the instruction is
   executed. This is the same thing (but more efficient) as registering a
   callback through the <b><i>register_instruction_before_cb</i></b> method and
   increasing the counter each time it is called.
</p><p>
   Passing true for the argument <i>use_atomic_increment</i> makes the
   increment of the counter atomic, which may be useful if the tool cannot have
   an instrumentation connection per processor. This will however be slower due
   to the nature of atomic instructions.
</p><p>
   The location of the counter value can only be removed/deallocated after a
   call to either the <b><i>remove_callback</i></b> method (passing the
   <code>cpu_cb_handle_t</code> returned by
   <b><i>register_cached_instruction_cb</i></b>), or to the
   <b><i>remove_connection_callbacks</i></b> method (with the connection object as
   the argument) in the <code>cpu_instrumentation_subscribe interface</code>.
</p><p>
   This method is not available in Python.
</p><p>
   The <code>instrumentation_order</code> interface cannot be used to
   reorder callbacks installed with the <code>cpu_cached_instruction</code>
   interface. The cached callbacks are always called in same order as the 
   <b><i>cpu_cached_instruction_cb_t</i></b> callback that installed them, 
   and before any callback installed by the corresponding methods in the 
   <code>cpu_instrumentation_subscribe</code>.
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Threaded Context for all methods, but must be called from a callback
   registered by the <b><i>register_cached_instruction_cb</i></b> method in the
   <code>cpu_instrumentation_subscribe</code> interface.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_cpu_cached_instruction_once.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_cpu_cached_instruction_once.html:__rm_interface_cpu_cached_instruction_once">cpu_cached_instruction_once</a></h1>
<p>

<a id="__rm_interface_cpu_cached_instruction_once.html:cpu_cached_instruction_once"></a><a id="__rm_interface_cpu_cached_instruction_once.html:cpu_cached_instruction_once_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This interface extends the <code>cpu_cached_instruction</code> interface
   and allows callbacks to be installed that trigger only once, i.e., after
   the first time they have been invoked they are automatically
   removed. Otherwise they are identical to the corresponding methods in the
   <code>cpu_cached_instruction</code> interface.
<p>
   </p><pre class="jdocu_small">SIM_INTERFACE(cpu_cached_instruction_once) {
        void (*register_instruction_before_once_cb)(
                conf_object_t *cpu,
                cached_instruction_handle_t *ci_handle,
                cpu_instruction_cb_t cb,
                lang_void *user_data,
                cpu_callback_free_user_data_cb_t free_cb);
        void (*register_instruction_after_once_cb)(
                conf_object_t *cpu,
                cached_instruction_handle_t *ci_handle,
                cpu_instruction_cb_t cb,
                lang_void *user_data,
                cpu_callback_free_user_data_cb_t free_cb);
};

#define CPU_CACHED_INSTRUCTION_ONCE_INTERFACE "cpu_cached_instruction_once"
</pre><p>

</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Threaded Context for all methods, but must be called from a callback
   registered by the <b><i>register_cached_instruction_cb</i></b> method in the
   <code>cpu_instrumentation_subscribe</code> interface.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_cpu_cached_stream.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_cpu_cached_stream.html:__rm_interface_cpu_cached_stream">cpu_cached_stream</a></h1>
<p>

<a id="__rm_interface_cpu_cached_stream.html:cpu_cached_stream"></a><a id="__rm_interface_cpu_cached_stream.html:cpu_cached_stream_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This interface is internal.
   
</dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Threaded Context for all methods, but must be called from a callback
   registered by the <b><i>register_cached_instruction_cb</i></b> method in the
   <code>cpu_instrumentation_subscribe</code> interface.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_cpu_exception_query.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_cpu_exception_query.html:__rm_interface_cpu_exception_query">cpu_exception_query</a></h1>
<p>

<a id="__rm_interface_cpu_exception_query.html:cpu_exception_query"></a><a id="__rm_interface_cpu_exception_query.html:cpu_exception_query_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>cpu_exception_query</code> interface is used to query information
   about an exception for the a generic cpu architecture and should be used from
   a <b><i>cpu_exception_cb_t</i></b> callback.
<p>
   </p><pre class="jdocu_small">SIM_INTERFACE(cpu_exception_query) {
        int (*exception_number)(conf_object_t *cpu, exception_handle_t *handle);
        logical_address_t (*fault_pc)(conf_object_t *cpu,
                                      exception_handle_t *handle);
};
#define CPU_EXCEPTION_QUERY_INTERFACE "cpu_exception_query"
</pre><p>
</p><p>

   <b><i>exception_number</i></b> is used to get the vector for the exception.
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Threaded Context for all methods, but must be called from a callback
   receiving a handle of type <code>exception_handle_t</code>.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_cpu_instruction_decoder.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_cpu_instruction_decoder.html:__rm_interface_cpu_instruction_decoder">cpu_instruction_decoder</a></h1>
<p>

<a id="__rm_interface_cpu_instruction_decoder.html:cpu_instruction_decoder"></a><a id="__rm_interface_cpu_instruction_decoder.html:cpu_instruction_decoder_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This interface is used to replace an existing instruction with a user
   defined one or add new instructions to the simulation. The interface can
   only be used from a <b><i>cpu_instruction_decoder_cb_t</i></b> callback
   registered by the <b><i>register_instruction_decoder_cb</i></b> method in the
   <code>cpu_instrumentation_subscribe</code> interface.
<p>
   The interface consist of just one method and looks like this:
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(cpu_instruction_decoder) {
        void (*register_emulation_cb)(conf_object_t *cpu,
                                      cpu_emulation_cb_t cb,
                                      decoder_handle_t *handle,
                                      lang_void *user_data,
                                      cpu_callback_free_user_data_cb_t free_cb);
};

#define CPU_INSTRUCTION_DECODER_INTERFACE "cpu_instruction_decoder"
</pre><p>
</p><p>

   <b><i>register_emulation_cb</i></b> is used to set a callback function that
   implements the semantics of the new or changed instruction.  Every time the
   instructions is executed on the <i>cpu</i> this function will be called
   instead of the build-in implementation. The <i>handle</i> is the
   <code>decoder_handle_t</code> handle passed to the
   <b><i>cpu_instruction_decoder_cb_t</i></b> callback. The <i>user_data</i>
   argument is user data for the callback. The <i>free_cb</i> is a clean-up
   callback function that Simics calls when the instruction is overwritten or
   if Simics wants to flush decoding caches. This function should deallocate
   any the user data if present. Can be NULL if not used.
</p><p>
   The signature of the emulation callback looks like this:
</p><p>
   
</p><pre class="jdocu_small">typedef cpu_emulation_t (*cpu_emulation_cb_t)(
        conf_object_t *obj, conf_object_t *cpu,
        lang_void *user_data);</pre><p>

</p><p>
   <i>obj</i> is the connection object, the same object as passed to the
   cpu_instruction_decoder_cb_t callback. <i>cpu</i> is the processor
   executing the replaced instruction. <i>user_data</i> is user data for
   the emulation callback. This is a useful place for storing immediate or
   register values for the new instruction. In the emulation function the whole
   Cell Context API is available for use.
</p><p>
   <code>CPU_Emulation_Fall_Through</code> should be returned from the emulation
   callback if replaced one is a fall through instruction.  The program counter
   does not need to be updated. If the replaced instruction is doing any
   control flow then <code>CPU_Emulation_Control_Flow</code> should be returned and
   the program counter should be set to the destination address. This can be
   done for fall through instruction as well but is less efficient.
</p><p>
   <code>CPU_Emulation_Default_Semantics</code> can also be returned to indicate that
   the default semantics should be used instead of the user defined. This can
   be useful if the instruction only should be replaced under certain
   circumstances.
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Threaded Context for all methods, but must be called from a callback
   registered by the <b><i>register_instruction_decoder_cb</i></b> method in the
   <code>cpu_instrumentation_subscribe</code> interface.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_cpu_instruction_query.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_cpu_instruction_query.html:__rm_interface_cpu_instruction_query">cpu_instruction_query</a></h1>
<p>

<a id="__rm_interface_cpu_instruction_query.html:cpu_instruction_query"></a><a id="__rm_interface_cpu_instruction_query.html:cpu_instruction_query_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>cpu_instruction_query</code> interface can be used in functions
   of the following types:
<p>
   </p><ul>
   <li><code>cpu_instruction_cb_t</code></li>
   <li><code>cpu_cached_instruction_cb_t</code></li>
   <li><code>cpu_instruction_decoder_cb_t</code></li>
   </ul>
<p>
   where an <code>instruction_handle_t</code> pointer is available. The
   handle is only valid in the callback. The interface is used to request
   information about the instruction being executed by the processor
   <i>cpu</i>.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(cpu_instruction_query) {
        logical_address_t (*logical_address)(
                conf_object_t *cpu, instruction_handle_t *handle);
        physical_address_t (*physical_address)(
                conf_object_t *cpu, instruction_handle_t *handle);
        cpu_bytes_t (*get_instruction_bytes)(
                conf_object_t *cpu, instruction_handle_t *handle);
};

#define CPU_INSTRUCTION_QUERY_INTERFACE "cpu_instruction_query"
</pre><p>
</p><p>

   The <b><i>logical_address</i></b> and <b><i>physical_address</i></b> is used to
   get the different addresses of the instruction being executed.
</p><p>
   Note that if the instruction crosses a page boundary the last part of the
   instruction will have a different mapping for the physical address than
   returned by <b><i>physical_address</i></b>. To get hold of the physical address
   on the second page, use the <b><i>logical_to_physical</i></b> method of the
   <code>processor_info(_v2)</code> and provide the logical address of the
   first byte on the second page.
</p><p>
   The <b><i>get_instruction_bytes</i></b> method is used to read the instruction
   bytes. The returned data is of a cpu_bytes_t type that contains the data and
   the size. The data member is only available during the execution of the
   callback. The data cannot be changed. Corresponding type in Python is a
   string of bytes.
</p><p>
   
</p><pre class="jdocu_small">typedef struct cpu_bytes {
        size_t size;
#ifndef PYWRAP
        const uint8 *data;
#endif
} cpu_bytes_t;</pre><p>

</p><p>
   Additional information can be read out with an architectural specific query
   interface, see <code>x86_instruction_query</code> for details.
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Threaded Context for all methods, but must be called from a callback
   receiving a handle of type <code>instruction_handle_t</code>.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_cpu_instrumentation_subscribe.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_cpu_instrumentation_subscribe.html:__rm_interface_cpu_instrumentation_subscribe">cpu_instrumentation_subscribe</a></h1>
<p>

<a id="__rm_interface_cpu_instrumentation_subscribe.html:cpu_instrumentation_subscribe"></a><a id="__rm_interface_cpu_instrumentation_subscribe.html:cpu_instrumentation_subscribe_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>cpu_instrumentation_subscribe</code> interface is implemented by
   processor classes that support CPU instrumentation. The interface can be
   used to monitor and instrument various actions through callbacks. It is
   designed for being more efficient than haps and will not synchronize any
   threads. This means that any user of the interface must assume that
   registered callbacks can be called in parallel by multiple threads if any of
   the multi-threaded execution modes are used in Simics.
<p>
   A processor implementing the interface is regarded as a provider of
   instrumentation and is typically used by an instrumentation tool object. The
   tool object is supposed to register callbacks in this interface and act when
   they are called. To handle different threads it is recommended that the
   tools uses a connection object (a sub-object created by the tool) that
   registers these callbacks for each processor that it monitors. Then, any
   data collected can be stored in these connection objects and will thus not
   be subject to concurrent access from different threads that hosts the
   processors. The data can than be aggregated by the tool when
   appropriate. This approach needs no synchronization locks and allows for
   efficient simulation.
</p><p>
   See <code>instrumentation_order</code> interface for more details on the
   callback order.
</p><p>
   The <i>cpu</i> argument in all methods below is the processor object
   implementing this interface.
</p><p>
   The <i>connection</i> argument is the "user" object of this interface,
   typically a connection object as described above. However, it can be any
   object and even NULL if there is no suitable object to pass. For instance,
   if the callback is registered by a Python script. In this case
   synchronization will be handled by the Python layer.
</p><p>
   All registration methods in the interface install at least one callback, the
   <i>cb</i> argument, that will be called at a particular instrumentation
   point in the processor object. The Simics Cell Context API is
   available for use in these callbacks. The callbacks have different
   signatures depending on their use case. The <i>data</i>
   argument is user defined data that can be associated with each
   callback. Every time the callback is called this data will be passed as an
   argument to the callback. The data can be unique for each registration, even
   though the same callback pointer is used.
</p><p>
   </p><div class="note">
<b>Note:</b>
Note, not all CPU models implement all parts of the instrumentation API.
   Register methods not implemented in this interface will be NULL.
   </div><pre class="jdocu_small">SIM_INTERFACE(cpu_instrumentation_subscribe) {
        /* Callback specific methods */
        void (*remove_callback)(
                conf_object_t *NOTNULL cpu,
                cpu_cb_handle_t *handle);
        void (*enable_callback)(
                conf_object_t *NOTNULL cpu,
                cpu_cb_handle_t *handle);
        void (*disable_callback)(
                conf_object_t *NOTNULL cpu,
                cpu_cb_handle_t *handle);

        /* Callback groups methods, operating on several callbacks 
           associated to a connection. */
        void (*remove_connection_callbacks)(
                conf_object_t *NOTNULL cpu,
                conf_object_t *NOTNULL connection);
        void (*enable_connection_callbacks)(
                conf_object_t *NOTNULL cpu,
                conf_object_t *NOTNULL connection);
        void (*disable_connection_callbacks)(
                conf_object_t *NOTNULL cpu,
                conf_object_t *NOTNULL connection);

        /* Subscribe methods */
        cpu_cb_handle_t *(*register_instruction_before_cb)(
                conf_object_t *NOTNULL cpu,
                conf_object_t *connection,
                cpu_instruction_cb_t cb,
                lang_void *data);
        cpu_cb_handle_t *(*register_instruction_after_cb)(
                conf_object_t *NOTNULL cpu,
                conf_object_t *connection,
                cpu_instruction_cb_t cb,
                lang_void *data);
        cpu_cb_handle_t *(*register_read_before_cb)(
                conf_object_t *NOTNULL cpu,
                conf_object_t *connection,
                cpu_access_scope_t scope,
                cpu_memory_cb_t cb,
                lang_void *data);
        cpu_cb_handle_t *(*register_read_after_cb)(
                conf_object_t *NOTNULL cpu,
                conf_object_t *connection,
                cpu_access_scope_t scope,
                cpu_memory_cb_t cb,
                lang_void *data);
        cpu_cb_handle_t *(*register_write_before_cb)(
                conf_object_t *NOTNULL cpu,
                conf_object_t *connection,
                cpu_access_scope_t scope,
                cpu_memory_cb_t cb,
                lang_void *data);
        cpu_cb_handle_t *(*register_write_after_cb)(
                conf_object_t *NOTNULL cpu,
                conf_object_t *connection,
                cpu_access_scope_t scope,
                cpu_memory_cb_t cb,
                lang_void *data);
        cpu_cb_handle_t *(*register_address_before_cb)(
                conf_object_t *NOTNULL cpu,
                conf_object_t *connection,
                cpu_address_cb_t cb,
                lang_void *data);
        cpu_cb_handle_t *(*register_cached_instruction_cb)(
                conf_object_t *NOTNULL cpu,
                conf_object_t *connection,
                cpu_cached_instruction_cb_t cb,
                lang_void *data);
        cpu_cb_handle_t *(*register_instruction_decoder_cb)(
                conf_object_t *NOTNULL cpu,
                conf_object_t *connection,
                cpu_instruction_decoder_cb_t cb,
                cpu_instruction_disassemble_cb_t disass_cb,
                lang_void *data);
        cpu_cb_handle_t *(*register_exception_before_cb)(
                conf_object_t *NOTNULL cpu,
                conf_object_t *connection,
                int exception_number,
                cpu_exception_cb_t cb,
                lang_void *data);
        cpu_cb_handle_t *(*register_exception_after_cb)(
                conf_object_t *NOTNULL cpu,
                conf_object_t *connection,
                int exception_number,
                cpu_exception_cb_t cb,
                lang_void *data);
        cpu_cb_handle_t *(*register_exception_return_before_cb)(
                conf_object_t *NOTNULL cpu,
                conf_object_t *connection,
                cpu_exception_return_cb_t cb,
                lang_void *data);
        cpu_cb_handle_t *(*register_exception_return_after_cb)(
                conf_object_t *NOTNULL cpu,
                conf_object_t *connection,
                cpu_exception_return_cb_t cb,
                lang_void *data);
        cpu_cb_handle_t *(*register_mode_change_cb)(
                conf_object_t *NOTNULL cpu,
                conf_object_t *connection,
                cpu_mode_change_cb_t cb,
                lang_void *data);
        cpu_cb_handle_t *(*register_control_register_read_before_cb)(
                conf_object_t *NOTNULL cpu,
                conf_object_t *connection,
                int register_number,
                cpu_control_register_read_cb_t cb,
                lang_void *data);
        cpu_cb_handle_t *(*register_control_register_write_before_cb)(
                conf_object_t *NOTNULL cpu,
                conf_object_t *connection,
                int register_number,
                cpu_control_register_write_cb_t cb,
                lang_void *data);
};
        
#define CPU_INSTRUMENTATION_SUBSCRIBE_INTERFACE \
        "cpu_instrumentation_subscribe"
</pre><p>
 </p><p>

   <b>Callback Related Methods</b>
</p><p>
   Every function in this interface that registers a callback returns a unique
   handle of type <code>cpu_cb_handle_t</code>. The <b><i>remove_callback</i></b>
   method removes the callback associated with the handle. The
   <b><i>enable_callback</i></b> and <b><i>disable_callback</i></b> methods can be
   used to temporarily enable and disable a callback. 
</p><p>
   The <b><i>remove_connection_callbacks</i></b> removes all callbacks associated
   with a connection object, i.e., all the callbacks that was registered with
   the same connection object. The <b><i>enable_connection_callbacks</i></b> and
   <b><i>disable_connection_callbacks</i></b> enables and disables all callbacks
   associated with a connection object. NULL cannot be passed to these methods
   to handle callbacks installed without any connection object.
</p><p>
   The design philosophy is that registering and removing a callback can be
   relatively expensive, whereas enable and disable a callback should be
   cheap. On the other hand, a disabled callback can slow down the simulation
   speed a bit more compared to running without callbacks.
</p><p>
   <b>Instruction Related Methods</b>
</p><p>
   The method <b><i>register_instruction_before_cb</i></b> installs a callback
   that is called before an instruction is executed. The callback type is as
   follows:
   </p><p>
   
</p><pre class="jdocu_small">typedef void (*cpu_instruction_cb_t)(
        conf_object_t *obj, conf_object_t *cpu,
        instruction_handle_t *handle,
        lang_void *user_data);</pre><p>
 
</p><p>
   The object <i>obj</i> is the connection or the user object that
   registers the callback (or NULL if there is no object) and <i>cpu</i> is
   the processor object executing the instruction. If a dedicated connection
   object associated with each processor is used, the object's private data can
   store the interface pointers needed to access processor state.  This is a
   useful trick to speed up the simulation speed. Otherwise such interface
   pointers need to be acquired each time the callback is called. If no
   connection object is used the pointers can be saved in the callback's user
   data. The <i>handle</i> can be used to query more data about
   the instruction, using the <code>cpu_instruction_query</code>
   interface. The <i>user_data</i> is the user data associated with the
   callback.
</p><p>
   The registered callback is called for every instruction type. Use the
   <b><i>register_cached_instruction_cb</i></b> method to control which type
   of instructions that should be instrumented.
</p><p>
   <b><i>register_instruction_after_cb</i></b> installs a callback that is called
   after an instruction is executed. The callback is of the same type as for
   the before variant and is called for every instruction type. Use the
   <b><i>register_cached_instruction_cb</i></b> method to control which type
   of instructions that should be instrumented. Reading the program counter
   register for a control flow instruction in this callback will reflect the
   new location, whereas using the <code>cpu_instruction_query</code> for
   reading out the instruction address will still return the address of the
   control flow instruction.
</p><p>
   None: When an exception occurs the instruction is aborted and any
   installed callbacks by the <b><i>register_instruction_after_cb</i></b> method
   are not called.
</p><p>
   <br>
   <b>Memory Related Methods</b>
</p><p>
   <b><i>register_read_before_cb</i></b> installs a callback that is called before
   a memory read operation is performed. The callback type is as follows:
</p><p>
   
</p><pre class="jdocu_small">typedef void (*cpu_memory_cb_t)(
        conf_object_t *obj, conf_object_t *cpu,
        memory_handle_t *handle,
        lang_void *user_data);</pre><p>
 
   </p><p>
   As for instructions, <i>obj</i> is the object that registered the
   callback and <i>cpu</i> is the processor doing the access.  The
   <i>handle</i> can be used to further operate on the
   access by using the <code>cpu_memory_query</code> interface. The interface
   can for instance be used to read the data of the memory operation. For more
   information, see the documentation for the <code>cpu_memory_query</code>
   interface.
</p><p>
   The <i>scope</i> argument defines the access scope for the
   callback. There are two defined scopes: <code>CPU_Access_Scope_Explicit</code>
   and <code>CPU_Access_Scope_Implicit</code>. The explicit scope installs a
   callback for every operation done explicitly by an instruction, such as
   loading or storing a value. The implicit scope installs a callback for every
   implicit access, such as table walks or memory accesses performed by
   exception and interrupt handling. If all accesses are requested the same
   callback function can be registered for both scopes by registering the
   callback twice, one for each scope. 
</p><p>
   If a memory access crosses a page boundary the access will be split into two
   separate calls, one for the first part covering the first page, and one for
   the second part covering the second page. See the <b><i>get_page_crossing_info</i></b>
   method in the <code>cpu_memory_query</code> interface for a way to
   distinguish the different cases.
</p><p>
   The <i>user_data</i> is the data associated with the callback.
</p><p>
   Similar to <b><i>register_read_before_cb</i></b>, the following three methods
   work in the same way:
</p><p>
   <b><i>register_read_after_cb</i></b> installs a callback that is called after
   a memory read operation is performed. 
</p><p>
   <b><i>register_write_before_cb</i></b> installs a callback that is called before
   a memory write operation is performed.
</p><p>
   <b><i>register_write_after_cb</i></b> installs a callback that is called after
   a memory write operation is performed.
</p><p>
   Memory accesses of prefetch types or any other control operation calls the
   read callbacks. To distinguish them from reads an architecture specific
   interface can be used to lookup the access type. See the
   <code>x86_memory_query</code> interface for example.
</p><p>
   None: When an exception occurs the instruction is aborted and any
   installed memory callbacks after this point are not called.
</p><p>
   <br>
   <b>Addresses</b>
</p><p>
   </p><div class="note">
<b>Note:</b>
Only available on x86 targets.</div><b><i>register_address_before_cb</i></b> can be used to register a callback
   that will be called each time a logical address is generated by an
   instruction for an explicit read or a write operation. This occurs before
   the actual memory operation takes place. This allows a user to inspect and
   change the target address for the operation. The callback has the following
   signature:
<p>
   
</p><pre class="jdocu_small">typedef logical_address_t (*cpu_address_cb_t)(
        conf_object_t *obj, conf_object_t *cpu,
        logical_address_t address,
        address_handle_t *handle,
        lang_void *user_data);</pre><p>

</p><p>
   The argument <i>obj</i> is the object installing the callback and the
   <i>cpu</i> is the processor generating the logical
   <i>address</i>. The <i>handle</i> can be used to
   extract more information about the address by using an architecture specific
   interface. See the <code>x86_address_query</code> for details.
</p><p>
   The new logical address should be returned by the callback.
</p><p>
   <br>
   <b>Cached Instructions</b>
</p><p>
   <b><i>register_cached_instruction_cb</i></b> is used for installing a callback
   that is called every time Simics inserts the instruction into an internal
   instruction cache, i.e., executing from a specific address with a specific
   execution mode for the first time. Executing the instruction again will
   typically not invoke the callback since the instruction is already placed in
   the instruction cache. However, if the cache is flushed and the instruction
   is executed again the callback will once again be called. The callback has
   the following signature:
</p><p>
   
</p><pre class="jdocu_small">typedef void (*cpu_cached_instruction_cb_t)(
        conf_object_t *obj, conf_object_t *cpu,
        cached_instruction_handle_t *ci_handle,
        instruction_handle_t *iq_handle,
        lang_void *user_data);</pre><p>

</p><p>
   From this callback one can use the <i>cpu_cached_instruction</i>
   interface and <i>ci_handle</i> to register instrumentation callbacks for
   this specific instruction alone. The installed callbacks will be called
   every time the instruction is executed (even the first time just after the
   <code>cpu_cached_instruction_cb_t</code> callback has returned).  
   This means that the
   user can filter out certain instructions of interest and instrument only
   those. The <i>iq_handle</i> and the <code>cpu_instruction_query</code>
   interface can be use to do the filtering by examining the instruction. The
   <i>user_data</i> is the callback user data for the callback.
</p><p>
   For callbacks registered for memory operations only those in the explicit
   scope issued by the instruction will be instrumented, e.g., hardware table
   walks and exceptions will not be considered by this method. To instrument
   these operations use the <b><i>register_(read/write)_(before/after)_cb</i></b>
   with the implicit scope instead.
</p><p>
   If no callbacks are registered by calling the
   <i>cpu_cached_instruction</i> interface, the instruction will not be
   instrumented.
</p><p>
   <br>
   <b>Instruction Set Augmentation</b>
 </p><p>
   <b><i>register_instruction_decoder_cb</i></b> lets the user redefine
   instruction semantics in Simics, or implement new instructions. The
   <i>cb</i> argument is a callback function that will be called every time
   Simics decodes an instruction. From this callback the user can accept the
   instruction or deny it. In most cases this only happens once per instruction
   address since Simics usually caches decoding results in the internal
   instruction cache. If the cache is flushed the callback may be called again.
 </p><p>
   The callback signature looks like this:
   </p><p>
   
</p><pre class="jdocu_small">typedef int (*cpu_instruction_decoder_cb_t)(
        conf_object_t *obj, conf_object_t *cpu,
        decoder_handle_t *decoder_handle,
        instruction_handle_t *iq_handle,
        lang_void *user_data);</pre><p>

</p><p>
   The instruction bytes are read by using the <b><i>get_instruction_bytes</i></b>
   method of the <code>cpu_instruction_query</code> interface together with
   the <i>iq_handle</i>. The returned value is of a
   <code>cpu_bytes_t</code> type. To access the bytes use the <code>data</code> and
   the <code>size</code> members in the returned value.
</p><p>
   If the decoder requires more bytes (i.e., because the new instruction is
   longer), a negative integer value should be returned by the <i>cb</i>
   function, indicating the number of bytes needed. For example, if the
   available bytes are 3 but the decoder need at least 4 bytes, -4 should be
   returned. The callback will then be called again with more available bytes
   (this can be repeated if the new instruction requires even more bytes at
   this point). Note that requesting more data than actual needed can cause
   spurious page faults if the data crosses a page boundary. 
</p><p>
   If the instruction is accepted by the callback a positive integer number
   should be returned corresponding to the length of the instruction. In this
   case the <b><i>register_emulation_cb</i></b> method of the
   <code>cpu_instruction_decoder</code> interface should be called to set the
   actual (user) function that Simics will call each time the instruction is
   executed. 
</p><p>
   If the <i>cb</i> callback should ignore the instruction the number 0
   should be returned. This means that any other registered decoder will have a
   chance to decode the instruction. If no decoder accepts it, Simics' default
   implementation will be used.
</p><p>
   The <b><i>register_emulation_cb</i></b> method also needs the
   <i>decoder_handle</i> which is available in the dedoder callback. For
   more information, see the documentation of the
   <code>cpu_instruction_decoder</code> interface.
</p><p>
   A <i>disass_cb</i> argument should also be passed to the
   <b><i>register_instruction_decoder_cb</i></b> method. This function is called
   every time Simics wants to disassemble an instruction. For every accepted
   instruction a corresponding disassembly string should be returned by this
   function. It has the following signature:
</p><p>
   
</p><pre class="jdocu_small">typedef tuple_int_string_t (*cpu_instruction_disassemble_cb_t)(
        conf_object_t *obj, conf_object_t *cpu,
        generic_address_t addr,
        cpu_bytes_t bytes);</pre><p>

</p><p>
   <i>obj</i> is the object registering the
   <b><i>register_instruction_decoder_cb</i></b> and <i>cpu</i> is the
   processor disassembling the instruction. <b><i>addr</i></b> is the address of
   the instruction in a generic form. This means that it is typically a
   physical address or a logical address depending on the context of the
   disassembling. The address can be used for offset calculations, i.e.,
   displaying an absolute address instead of a relative one, for example in a
   branch instruction. The <i>bytes</i> argument should be used to read
   instruction bytes. The return value is of type
   <code>tuple_int_string_t</code> and should be filled with the instruction
   length and an allocated (e.g., malloc) string representing the disassembly
   of the instruction. The ownership of the string is transferred to the
   calling environment which will free it when it is no longer needed.
</p><p>
   If too few bytes are passed for the instruction to be disassembled a
   negative value should be returned for the length indicating the needed
   bytes. The <i>disass_cb</i> is then called again with more bytes. If the
   instruction is rejected a length of 0 should be returned and the string
   should be set to NULL. 
</p><p>
   <br>
   <b>Exception Related Methods</b>
</p><p>
   <b><i>register_exception_before_cb</i></b> is used to register a callback that
   will be called before an exception or interrupt is taken.  The
   <i>exception_number</i> can be used to select a callback on a specific
   exception, with the same number as used in the <code>exception</code>
   interface. If all exceptions should be subscribed to, the
   <code>CPU_Exception_All</code> constant can be used.
   The callback signature looks like this:
</p><p>
   
</p><pre class="jdocu_small">typedef void (*cpu_exception_cb_t)(
        conf_object_t *obj, conf_object_t *cpu,
        exception_handle_t *exception_handle,
        lang_void *user_data);</pre><p>

   </p><p>
   The <i>obj</i> is the object registering the callback and <i>cpu</i>
   is the processor that takes the exception or receives the interrupt. The
   handle is used to get more architectural information about the exception,
   for example, see the <code>x86_exception_query</code> for details. The
   <i>user_data</i> is the callback user data.
</p><p>
   No architectural state has been changed in this callback to reflect the
   exception or interrupt, e.g., the program counter will still be at the
   faulting instruction. Since an exception can occur while handling an
   exception it is not always the case that this callback corresponds to the
   final taken exception. Recursive exception will result in another call to
   this callback.
  </p><p>
   <b><i>register_exception_after_cb</i></b> is used to register a callback that
   will be called after an exception was taken. It takes the same arguments as
   <b><i>register_exception_before_cb</i></b>. In this callback the architectural
   state has been updated, e.g., the program counter points to the first
   instruction of the exception handler. The callback is of the same type as
   for the before variant.
</p><p>
   <b><i>register_exception_return_before_cb</i></b> is used to register a
   callback that will be called just before an exception handler is done and
   resumes execution of the normal program code.  The callback signature looks
   like this:
</p><p>
   
</p><pre class="jdocu_small">typedef void (*cpu_exception_return_cb_t)(
        conf_object_t *obj, conf_object_t *cpu,
        exception_return_handle_t *exception_handle,
        lang_void *user_data);</pre><p>

   </p><p>
   The <i>obj</i> is the object registering the callback and <i>cpu</i>
   is the processor that takes the exception or receives an interrupt. The
   handle is used to get more architectural information about the
   exception. Currently there is no interface available for this.
   </p><p>
   <b><i>register_exception_return_after_cb</i></b> is used to register a callback
   that will be called after an exception has been executed, e.g., the program
   counter points to the normal program where execution will continue.
</p><p>
   <br>
   <b>Execution Mode</b>
</p><p>
   <b><i>register_mode_change_cb</i></b> is used to register a callback that will
   be called every time the processor changes mode. The supported modes are:
   user, supervisor, and hypervisor.
</p><p>
   The callback signature looks lite this:
</p><p>
   
</p><pre class="jdocu_small">typedef void (*cpu_mode_change_cb_t)(
        conf_object_t *obj, conf_object_t *cpu,
        processor_mode_t old_mode, processor_mode_t new_mode,
        lang_void *user_data);</pre><p>

</p><p>
   The <i>obj</i> is the object registering the callback and <i>cpu</i>
   is the processor that changes mode. The <i>old_mode</i> is the mode
   before the change and new_mode is the mode after the change.
</p><p>
   <br>
   <b>Control Registers</b>
</p><p>
   <b><i>register_control_register_read_before_cb</i></b> is used to register a
   callback that will be called before every control register read. The
   <i>register_number</i> is the control register number to install the
   callback on. It is the same number which is used in the
   <code>int_register</code> interface. The constant
   <code>CPU_Control_Register_All</code> can be used to subscribe to all control
   registers.
</p><p>
   The callback signature looks like this:
</p><p>
   
</p><pre class="jdocu_small">typedef void (*cpu_control_register_read_cb_t)(
        conf_object_t *obj, conf_object_t *cpu,
        int register_number,
        lang_void *user_data);</pre><p>

</p><p>
   The <i>obj</i> is the object registering the callback and <i>cpu</i>
   is the processor that reads the control register <i>register_number</i>.
   The <i>user_data</i> is the user data for the callback.
</p><p>
   <b><i>register_control_register_write_before_cb</i></b> is used to register a
   callback that will be called before every control register write. The
   <i>register_number</i> is the control register number to install the
   callback on. It is the same number which is used in the
   <code>int_register</code> interface. The constant
   <code>CPU_Control_Register_All</code> can be used to subscribe to all control
   registers. 
</p><p>
   The callback signature looks like this:
</p><p>
   
</p><pre class="jdocu_small">typedef void (*cpu_control_register_write_cb_t)(
        conf_object_t *obj, conf_object_t *cpu,
        int register_number,
        uint64 value,
        lang_void *user_data);</pre><p>

</p><p>
   The <i>obj</i> is the object registering the callback and <i>cpu</i>
   is the processor that writes to the control register
   <i>register_number</i>.  The <i>value</i> is the value that will be
   written.  The <i>user_data</i> is the user data for the callback.
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Global Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_cpu_memory_query.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_cpu_memory_query.html:__rm_interface_cpu_memory_query">cpu_memory_query</a></h1>
<p>

<a id="__rm_interface_cpu_memory_query.html:cpu_memory_query"></a><a id="__rm_interface_cpu_memory_query.html:cpu_memory_query_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>cpu_memory_query</code> interface is used by
   callbacks of the <code>cpu_memory_cb_t</code> type and requires a
   valid <code>memory_handle_t</code> handle. The handle is only valid during
   the call of the callback. It is used to request information about the memory
   operation being issued by the processor <i>cpu</i>.
<p>
   </p><pre class="jdocu_small">SIM_INTERFACE(cpu_memory_query) {
        logical_address_t (*logical_address)(
                conf_object_t *cpu, memory_handle_t *handle);
        physical_address_t (*physical_address)(
                conf_object_t *cpu, memory_handle_t *handle);
#ifndef PYWRAP
        void (*set_host_ptr)(
                conf_object_t *cpu, memory_handle_t *handle,
                void *p);
#endif
        cpu_bytes_t (*get_bytes)(conf_object_t *cpu,
                                 memory_handle_t *handle);

        void (*set_bytes)(
                conf_object_t *cpu, memory_handle_t *handle,
                cpu_bytes_t bytes);

        bool (*atomic)(
                conf_object_t *obj, memory_handle_t *handle);
        ini_type_t (*arch)(
                conf_object_t *obj, memory_handle_t *handle);
        page_crossing_info_t (*get_page_crossing_info)(
                conf_object_t *obj, memory_handle_t *handle);
        buffer_t (*get_surrounding_bytes)(
                conf_object_t *cpu, memory_handle_t *handle,
                unsigned granularity_log2);
        
};

#define CPU_MEMORY_QUERY_INTERFACE "cpu_memory_query"        
</pre><p>
</p><p>

   The <b><i>logical_address</i></b> and <b><i>physical_address</i></b> methods are
   used to get the different addresses of the memory operation.
</p><p>
   Below, callbacks registered by the <b><i>register_read_before_cb</i></b> or the
   <b><i>register_write_before_cb</i></b> in the
   <code>cpu_instrumentation_subscribe</code> interface or in the
   <code>cpu_cached_instruction</code> interface are referred to as being
   in <i>before</i> context. Callbacks registered by the
   <b><i>register_read_after_cb</i></b> or the <b><i>register_write_after_cb</i></b>
   in the <code>cpu_instrumentation_subscribe</code> interface or in the
   <code>cpu_cached_instruction</code> interface are referred to as being
   in <i>after</i> context.
</p><p>
   The <b><i>set_host_ptr</i></b> method can be used to redirect where data should
   be read from or written to depending on if it is a read or a write
   operation.  The method is only useful for callbacks registered in
   <i>before</i> context. The data pointer <i>p</i> needs to be valid
   during the execution of the instruction and must point to enough space to
   carry out the operation. This method is not available in Python.
</p><p>
   The <b><i>get_bytes</i></b> method is used to retrieve the bytes that is going
   to be read/written if called in a <i>before</i> context and is used to read
   out value that was read/written in <i>after</i> context. The value is
   returned as <code>cpu_bytes_t</code>:
</p><p>
   
</p><pre class="jdocu_small">typedef struct cpu_bytes {
        size_t size;
#ifndef PYWRAP
        const uint8 *data;
#endif
} cpu_bytes_t;</pre><p>

</p><p>
   The member <code>data</code> contains the data pointer, and the member
   <code>size</code> contains tha size of the data. It is illegal to access beyond
   the limit. For such access, see the <b><i>get_surrounding_bytes</i></b> below.
</p><p>
   The read value in <i>before</i> context may not be
   available (a device access for example) and in this case the data member
   will be NULL.
</p><p>
   The <b><i>set_bytes</i></b> method is used to override the bytes to be read or
   written. The method is only valid in the <i>before</i> context. This method
   can be used instead of the <b><i>set_host_ptr</i></b> to change the value of
   the operation. The value is passed as <code>cpu_bytes_t</code> and the
   supplied data in the data member need not to be valid after the callback
   returns since the data is copied. The length of the data cannot be changes
   and must be the same as returned by the <b><i>get_bytes</i></b> method.
        </p><p>
   The <b><i>atomic</i></b> method returned true if the operation is considered
   atomic, false otherwise.
</p><p>
   The <b><i>arch</i></b> method returns the <code>ini_type_t</code> of the memory
   operation.
</p><p>
   Accesses that cross a page boundary are split into two subsequent accesses,
   one for the first page and one for the second page. The
   <b><i>get_page_crossing_info</i></b> method can be used to distinguish the
   different cases from each other. The returned value from the method is of
   type <code>page_crossing_info_t</code> and can be one of:
   <code>Sim_Page_Crossing_None</code> (no crossing access),
   <code>Sim_Page_Crossing_First</code> (first part of a crossing access), or
   <code>Sim_Page_Crossing_Second</code> (second part of a crossing access).
</p><p>
   The <b><i>get_surrounding_bytes</i></b> method provides quick access to the
   data surrounding the access. The <i>granularity_log2</i> specifies the
   size and alignment of the buffer being returned. For example using 6 for
   <i>granularity_log2</i>, will fetch 64 aligned bytes around the
   address of the access. Typically, the largest supported granularity_log2
   size is 12, meaning a 4 KiB page. The returned value is of type buffer_t and
   is only valid in the <code>cpu_memory_cb_t</code> callback. The
   data can be accessed by using the <code>buffer_t.data</code> member in the
   returned value. Data can only be read up to the size of the buffer, which is
   stored in the <code>buffer_t.len</code> member. Valid memory is only returned if
   the access terminates in simulator cached memory.  If not, the 
   <code>buffer_t.len</code> will be is 0, <code>buffer_t.data</code> cannot be used.
</p><p>
   Additional information can be read out with an architectural specific
   query interface, see <code>x86_memory_query</code> interface for details.
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Threaded Context for all methods, but must be called from a callback
   receiving a handle of type <code>memory_handle_t</code>.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_cycle.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_cycle.html:__rm_interface_cycle">cycle</a></h1>
<p>

<a id="__rm_interface_cycle.html:cycle"></a><a id="__rm_interface_cycle.html:cycle_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><dl><dt id="__rm_interface_cycle.html:dt:interface-methods"><a href="#__rm_interface_cycle.html:dt:interface-methods"><b>Interface Methods</b></a></dt><dd>The <code>cycle</code> interface is typically implemented by
  processors, but can be implemented by other objects as well. Its purpose is
  to handle events based on time. The cycle queue has a cycle as the smallest
  time unit. The cycle queue also has an associated frequency which makes it
  possible to define events based on seconds or picoseconds.
<p>
  The <b><i>get_frequency</i></b> function returns the frequency in Hertz for
  the <i>queue</i>. Most objects implementing <code>cycle</code> also
  have a notification mechanism for frequency changes through the
  <code>simple_dispatcher</code> interface in the <i>cpu_frequency</i>
  port. It is recommended that such a notification mechanism is used to get
  updates rather than polling with <b><i>get_frequency</i></b>.
</p><p>
  The current number of cycles executed by the <i>queue</i> is returned
  by <b><i>get_cycle_count</i></b>. Time elapsed since the queue was created is
  returned by <b><i>get_time</i></b> (in seconds) and <b><i>get_time_in_ps</i></b>
  (in picoseconds); this will be equal to the value returned
  by <b><i>get_cycle_count</i></b> divided by the value returned
  by <b><i>get_frequency</i></b> if the frequency has been constant since time
  zero.
</p><p>
  The <b><i>cycles_delta</i></b> function returns the highest number of cycles
  <i>obj</i> can run <em>before</em> it passes the absolute local time
  <i>when</i>, assuming no frequency change occurs in the
  meantime. Note that <b><i>cycles_delta</i></b> can raise an exception if
  <i>when</i> was too far ahead in the future. The
  <b><i>cycles_delta_from_ps</i></b> function performs the same function, for an
  absolute local time expressed in picoseconds.
</p><p>
  The <b><i>post_cycle</i></b> function will schedule an event that will occur
  after <i>cycles</i> counted from local current time at
  <i>queue</i>. The <b><i>post_time</i></b> function is similar but takes
  <i>seconds</i> as argument, while <b><i>post_time_in_ps</i></b> takes
  a number of <i>picoseconds</i>. The arguments
  <i>cycles</i>, <i>seconds</i> and
  <i>picoseconds</i> must be nonnegative.
</p><p>
  An event previously posted can be removed by calling <b><i>cancel</i></b>. The
  <b><i>cancel</i></b> function takes a function <i>pred</i> as argument
  which is called when a matching event is found. The event is only removed if
  <i>pred</i> returns <code>1</code>. 
</p><p>
  The <b><i>find_next_cycle</i></b>, <b><i>find_next_time</i></b> and
  <b><i>find_next_time_as_ps</i></b> functions take the same arguments as
  <b><i>cancel</i></b> but only return the number of cycles, seconds or
  picoseconds before the event occur. The <i>evclass</i> is the event
  class, <i>obj</i> is the object posting the event, and
  <i>user_data</i> is pointer to data used as a parameter when calling
  the callback function defined in the <i>evclass</i>.
  If no matching event was found, <b><i>find_next_cycle</i></b> and
  <b><i>find_next_time</i></b> return 1;
  <b><i>find_next_time_as_ps</i></b> returns <code>ILLEGAL_DURATION</code>.
</p><p>
  The <b><i>events</i></b> method returns a list of all pending events in
  expiration order. Each element is a four-element list containing the event
  object, the event class name, the expiration time counted in cycles as an
  integer and the event description as given by the event class
  <b><i>describe</i></b> method, or NIL for events whose event class does not
  define that method.
</p><p>
  What happens to already posted events when a frequency change occurs is
  implementation dependent. Simics processors will scale the cycle queue to
  keep the time left before triggering events equal across the frequency
  change. Note that the new times will be rounded to entire cycles during the
  scaling, so approximations may occur when switching between high and low
  frequencies.</p></dd><dt id="__rm_interface_cycle.html:dt:implementation"><a href="#__rm_interface_cycle.html:dt:implementation"><b>Implementation</b></a></dt><dd>It is implementation dependent how the queue is implemented, whether
  cycles or seconds are used as underlying time unit, and what happens when the
  frequency is changed.
<p>
  Objects implementing the cycle interface are usually meant to be scheduled by
  Simics itself. For this to happen, a number of conditions must be fulfilled:
</p><p>
  </p><ul>

  <li>Each schedulable object implementing the <code>cycle</code> interface
  must be controlled by an object implementing the <code>execute</code>
  interface. It can be the same object that implements the
  <code>execute</code> interface. The object implementing the
  <code>execute</code> interface points to the object implementing the
  <code>cycle</code> interface via its <i>queue</i> attribute.</li>

  <li>Any schedulable object implementing the <code>cycle</code> interface
  must inform Simics about changes in frequency by calling the
  <b><i>VT_clock_frequency_change</i></b> function. That also applies to the
  initial frequency set when the object is created.</li>

  <li>For schedulable objects, the <code>cycle</code> interface must be
  registered with <b><i>SIM_register_clock</i></b>, which will also add some
  Simics specific attributes to the corresponding class. Beyond those, the
  implementor of the <code>cycle</code> can use any checkpoint
  representation. The <i>name</i> field in the event class data
  structure is unique, and the attribute setter function for checkpoint restore
  can use <b><i>SIM_get_event_class</i></b> to get the event class structure
  corresponding to an event class name.</li>

  </ul></dd></dl><p></p><pre class="jdocu_small">SIM_INTERFACE(cycle) {

        cycles_t (*get_cycle_count)(conf_object_t *queue);
        double (*get_time)(conf_object_t *queue);
        cycles_t (*cycles_delta)(conf_object_t *NOTNULL clock,
                                 double when);

        uint64 (*get_frequency)(conf_object_t *queue);

        void (*post_cycle)(
                conf_object_t *NOTNULL queue,
                event_class_t *NOTNULL evclass,
                conf_object_t *NOTNULL obj,
                cycles_t cycles,
                lang_void *user_data);
        void (*post_time)(
                conf_object_t *NOTNULL queue,
                event_class_t *NOTNULL evclass,
                conf_object_t *NOTNULL obj,
                double seconds,
                lang_void *user_data);

        void (*cancel)(
                conf_object_t *NOTNULL queue,
                event_class_t *NOTNULL evclass,
                conf_object_t *NOTNULL obj,
                int (*pred)(lang_void *data, lang_void *match_data),
                lang_void *match_data);

        cycles_t (*find_next_cycle)(
                conf_object_t *NOTNULL queue,
                event_class_t *NOTNULL evclass,
                conf_object_t *NOTNULL obj,
                int (*pred)(lang_void *data, lang_void *match_data),
                lang_void *match_data);

        double (*find_next_time)(
                conf_object_t *NOTNULL queue,
                event_class_t *NOTNULL evclass,
                conf_object_t *NOTNULL obj,
                int (*pred)(lang_void *data, lang_void *match_data),
                lang_void *match_data);

        attr_value_t (*events)(conf_object_t *NOTNULL obj);

        /* new picoseconds based functions */
        local_time_t (*get_time_in_ps)(conf_object_t *queue);
        cycles_t (*cycles_delta_from_ps)(conf_object_t *NOTNULL clock,
                                         local_time_t when);
        void (*post_time_in_ps)(
                conf_object_t *NOTNULL queue,
                event_class_t *NOTNULL evclass,
                conf_object_t *NOTNULL obj,
                duration_t picoseconds,
                lang_void *user_data);

        duration_t (*find_next_time_in_ps)(
                conf_object_t *NOTNULL queue,
                event_class_t *NOTNULL evclass,
                conf_object_t *NOTNULL obj,
                int (*pred)(lang_void *data, lang_void *match_data),
                lang_void *match_data);
};

#define CYCLE_INTERFACE "cycle"
</pre><p>
</p><p>
  
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
  
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_cycle_control.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_cycle_control.html:__rm_interface_cycle_control">cycle_control</a></h1>
<p>

<a id="__rm_interface_cycle_control.html:cycle_control"></a><a id="__rm_interface_cycle_control.html:cycle_control_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>cycle_control</code> interface is typically for
   controlling a cycle counter with event posting capabilities.
<p>
   The initiator object should call <b><i>start</i></b> or
   <b><i>stop</i></b> to start/stop the counting of cycles. And use
   <b><i>set_cycle_count</i></b> is used to configure the current
   cycle count at the target object.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(cycle_control) {
        void (*stop)(conf_object_t *NOTNULL obj);
        void (*start)(conf_object_t *NOTNULL obj);
        void (*set_cycle_count)(conf_object_t *NOTNULL obj,
                                cycles_t cycle_count);
};
#define CYCLE_CONTROL_INTERFACE "cycle_control"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_cycle_event.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_cycle_event.html:__rm_interface_cycle_event">cycle_event</a></h1>
<p>

<a id="__rm_interface_cycle_event.html:cycle_event"></a><a id="__rm_interface_cycle_event.html:cycle_event_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">TODO: document the <code>cycle_event</code> interface.
<p>
   </p><pre class="jdocu_small">SIM_INTERFACE(cycle_event) {
        cycles_t (*cycles)(conf_object_t *NOTNULL obj);
        void (*post)(conf_object_t *NOTNULL obj,
                     const event_class_t *NOTNULL evclass,
                     conf_object_t *NOTNULL ev_obj,
                     cycles_t cycles,
                     lang_void *param);

        void (*cancel)(conf_object_t *NOTNULL obj,
                       const event_class_t *NOTNULL evclass,
                       conf_object_t *NOTNULL ev_obj,
                       int (*pred)(lang_void *data, lang_void *match_data),
                       lang_void *match_data);

        cycles_t (*lookup)(conf_object_t *NOTNULL obj,
                           const event_class_t *NOTNULL evclass,
                           conf_object_t *NOTNULL ev_obj,
                           int (*pred)(lang_void *data, lang_void *match_data),
                           lang_void *match_data);

        attr_value_t (*events)(conf_object_t *NOTNULL obj);
};
#define CYCLE_EVENT_INTERFACE "cycle_event"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_cycle_event_instrumentation.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_cycle_event_instrumentation.html:__rm_interface_cycle_event_instrumentation">cycle_event_instrumentation</a></h1>
<p>

<a id="__rm_interface_cycle_event_instrumentation.html:cycle_event_instrumentation"></a><a id="__rm_interface_cycle_event_instrumentation.html:cycle_event_instrumentation_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This interface is internal.
   
</dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Global Context.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_decoder.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_decoder.html:__rm_interface_decoder">decoder</a></h1>
<p>

<a id="__rm_interface_decoder.html:decoder"></a><a id="__rm_interface_decoder.html:decoder_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><a id="__rm_interface_decoder.html:decoder_interface_t2"></a>
<p>
   </p><pre class="jdocu_small">SIM_INTERFACE(decoder) {
        void (*register_decoder)(conf_object_t *obj, 
                                 decoder_t *NOTNULL decoder);
        void (*unregister_decoder)(conf_object_t *obj, 
                                   decoder_t *NOTNULL decoder);
};</pre><p>
</p><p>

   The <code>decoder</code> interface is implemented by processors
   that allows connecting user decoders. This allows a user to
   implement the semantics of instructions that are not available in
   the standard Simics model or change the semantics of instructions
   implemented by Simics. This interface replaces
   <b><i>SIM_register_arch_decoder</i></b> and
   <b><i>SIM_unregister_arch_decoder</i></b> functions.
</p><p>
   The <b><i>register_decoder</i></b> function adds a decoder and
   <b><i>unregister_decoder</i></b> removes a decoder.
</p><p>
   The decoder is installed/removed for every object of the same class as the
   <i>obj</i> argument which must be the same object from
   which the interface was fetched.
</p><p>
   When Simics decodes an instruction, it will first see if any
   instruction decoders are registered for the current CPU class.
   For any decoders it finds, Simics will let it try to decode the
   instruction.  The decoders are called in order, starting with the
   last registered decoder, and if one decoder accepts the instruction,
   the rest of the decoders will not be called.
</p><p>
   The decoder is specified by the <code>decoder_t</code> data structure that the 
   user supplies:
</p><p>
   
   </p><pre class="jdocu_small">typedef struct {
        void *user_data;
        int (*NOTNULL decode)(uint8 *code,
                              int valid_bytes,
                              conf_object_t *cpu,
                              instruction_info_t *ii,
                              void *user_data);
        tuple_int_string_t (*NOTNULL disassemble)(uint8 *code,
                                                  int valid_bytes,
                                                  conf_object_t *cpu,
                                                  void *user_data);
        int (*NOTNULL flush)(instruction_info_t *ii,
                             void *user_data);
} decoder_t;</pre><p>
</p><p>
   <a id="__rm_interface_decoder.html:decoder_t"></a>
</p><p>
   The <b><i>decode</i></b> function is called to decode an instruction
   pointed to by <i>code</i>.  The first byte corresponds to
   the lowest address of the instruction in the simulated
   memory. <i>valid_bytes</i> tells how many bytes can be
   read. The CPU is given in the <i>cpu</i> parameter.  When
   the decoder has successfully decoded an instruction, it should set
   the <i>ii_ServiceRoutine</i>, the <i>ii_Arg</i>, and the
   <i>ii_Type</i> members of the <i>ii</i> structure (see
   below), and returns the number of bytes used in the decoding.  If
   it does not apply to the given instruction, it should return zero.
   If the decoder needs more data than <i>valid_bytes</i> it
   should return a negative number corresponding to the total number
   of bytes it will need to continue the decoding. The underlying
   architecture limits the number of bytes that can be requested,
   e.g. no more than 4 bytes can be requested on most RISC
   architectures. Simics will call the decoder again when more bytes
   are available. This process is repeated until the decoder accepts
   or rejects the instruction.  A decoder should never request more
   data than it needs. For example, if an instructions can be rejected
   by looking at the first byte, the decoder should never ask for more
   bytes.
</p><p>
   The <code>instruction_info_t</code> is defined as follows:
</p><p>
   
   </p><pre class="jdocu_small">typedef struct instruction_info {
        service_routine_t  ii_ServiceRoutine;
        uint64             ii_Arg;
        unsigned int       ii_Type;
        lang_void         *ii_UserData;
        logical_address_t  ii_LogicalAddress;
        physical_address_t ii_PhysicalAddress;
} instruction_info_t;</pre><p>
</p><p>
   <a id="__rm_interface_decoder.html:instruction_info_t"></a>
</p><p>
   <i>ii_ServiceRoutine</i> is a pointer to a function that will
   be called by Simics every time the instruction is executed. It has
   the following prototype:
   </p><p>
   
   </p><pre class="jdocu_small">typedef exception_type_t (*service_routine_t)(conf_object_t *cpu, 
                                              uint64 arg,
                                              lang_void *user_data);</pre><p>
<a id="__rm_interface_decoder.html:service_routine_t"></a>
    
</p><p>
   The service routine function should return an exception when it is
   finished to signal its status. If no exception occurs
   <code>Sim_PE_No_Exception</code> should be returned.
</p><p>
   See <code>exception_type_t</code> in
   <code>src/include/simics/base/memory.h</code> for the different
   exceptions available.
</p><p>
   A special return value, <code>Sim_PE_Default_Semantics</code>, can be
   returned; this signals Simics to run the default semantics for the
   instruction. This is useful if the semantics of an instruction
   should be changed but the user routine does not want to handle it all
   the time.
</p><p>
   Note that in a shared memory multiprocessor, the CPU
   used in decoding may differ from the CPU that executes the
   instruction, since the decoded instructions may be cached.
</p><p>
   <i>ii_Arg</i> is the argument <i>arg</i> that will be
   passed on to the service routine function. Op code bit-fields for
   the instruction such as register numbers or intermediate values can
   be stored here. The <i>ii_UserData</i> field can also be used
   to pass information to the service routine if more data is needed.
</p><p>
   <i>ii_Type</i> is either <code>UD_IT_SEQUENTIAL</code> or
   <code>UD_IT_CONTROL_FLOW</code>.  A sequential type means that the
   instruction does not perform any branches and the update of the
   program counter(s) is handled by Simics. In a control flow
   instruction on the other hand it is up to the user to set the
   program counter(s).
</p><p>
   <i>ii_LogicalAddress</i> and <i>ii_PhysicalAddress</i>
   holds the logical and physical addresses of the instruction to be
   decoded.
</p><p>
   
</p><p>
   The <b><i>disassemble</i></b> function is called to disassemble an
   instruction.  It uses the same <i>code</i>,
   <i>valid_bytes</i>, and <i>cpu</i> parameters as
   the <b><i>decode</i></b> function. If the disassembly is valid, then
   the string part of the returned <code>tuple_int_string_t</code> struct
   should be a MALLOCed string with the disassembly and the integer
   part should be its length in bytes.  The caller is responsible for
   freeing the disassembly string. The string member should be NULL
   and the integer part should be zero if the disassembly is not
   valid.  If the disassemble function needs more data than
   <i>valid_bytes</i> it should return a negative number in
   the integer part in the same way as the <b><i>decode</i></b> function,
   and set the string part to NULL.
</p><p>
   The <b><i>flush</i></b> function is called to free any memory
   allocated when decoding an instruction and any user data associated
   with the instruction.  It should return zero if it does not
   recognize the instruction, and non-zero if it has accepted it.
   Usually, the way to recognize if a decoded instruction is the right
   one to flush is to compare <code>ii-&gt;ii_ServiceRoutine</code> with the
   function that was set in the <i>decode</i> function. Note
   that the <i>cpu</i> parameter is the processor that caused
   the flush. It is more or less an arbitrary processor and should be
   ignored.
</p><p>
   In addition to the function pointers, the
   <code>decoder_t</code> structure contains a
   <i>user_data</i> pointer that is passed to all the
   functions.  This can be used for passing any data to the decoder
   functions.
</p><p>
   
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_describe_registers.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_describe_registers.html:__rm_interface_describe_registers">describe_registers</a></h1>
<p>

<a id="__rm_interface_describe_registers.html:describe_registers"></a><a id="__rm_interface_describe_registers.html:describe_registers_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This interface is used by the Simics debugger to get certain information from
  a processor.
<p>
  The <b><i>first_child</i></b> function returns the first description in the
  sequence of child descriptions of parent or NULL if parent has no
  children. Groups can have both registers and groups as children, registers
  can only have fields as children and fields cannot have any children. If
  parent is NULL, return the first description in the sequence of top-level
  descriptions.
</p><p>
  Use <b><i>next_description</i></b> to deallocate the previous description and
  return the next description in the sequence or NULL if there are no more
  descriptions in the current sequence.
</p><p>
  The <b><i>free_description</i></b> function is used to free the description
  without returning the next one in the sequence.
</p><p>
  The <b><i>first_named_value</i></b> function returns the first named value in
  the sequence of named values for parent or NULL if there are no named values
  for parent. Only fields and registers can have named values.
</p><p>
  Use <b><i>next_named_value</i></b> to deallocate the previous named value and
  return the next named value or NULL if there are no more named values in this
  sequence.
</p><p>
  Use <b><i>free_named_value</i></b> to free the named value without returning the
  next one in the sequence.
</p><p>
  The <b><i>get</i></b> and <b><i>set</i></b> functions are used to get and set the
  value of the register. To set the value pass in a bytes_t for the value. The
  value passed in must be long enough to contain the full value of the
  register. If the bytes_t is too long it will be truncated. To get the value
  pass in a buffer_t which is long enough to contain the register's value. The
  value is encoded in little endian byte order.
</p><p>
  <a id="__rm_interface_describe_registers.html:description_type_t"></a>
</p><pre class="jdocu_small">typedef enum {
        Description_Type_Group,

        Description_Type_Int_Reg,
        Description_Type_Float_Reg,
        Description_Type_Fields_Reg,

        Description_Type_Int_Field,
        Description_Type_Float_Field,
} description_type_t;</pre><p>

  <a id="__rm_interface_describe_registers.html:reg_role_t"></a>
</p><pre class="jdocu_small">typedef enum {
        Reg_Role_None, /* No special role for the register. */
        Reg_Role_Program_Counter /* The register is the program counter. */
} reg_role_t;</pre><p>

  <a id="__rm_interface_describe_registers.html:reg_bitorder_t"></a>
</p><pre class="jdocu_small">typedef enum {
        Reg_Bitorder_Little_Endian,
        Reg_Bitorder_Big_Endian
} reg_bitorder_t;</pre><p>

  <a id="__rm_interface_describe_registers.html:named_value_t"></a>
</p><pre class="jdocu_small">typedef struct {
        const char *name;
        const char *description;
        const bytes_t value; /* Little endian byte order */
} named_value_t;</pre><p>

  <a id="__rm_interface_describe_registers.html:description_t"></a>
</p><pre class="jdocu_small">typedef struct {
        /* Common fields */
        description_type_t type;
        const char *name;
        const char *description;

        /* Register and field fields */
        int16 dwarf_id;            /* id used by dwarf for this register
                                      or -1 if no such id is defined. This
                                      is ABI specific, but the CPU will
                                      give the ids for the most common ABI
                                      for that architecture. */
        reg_bitorder_t bitorder;   /* Bitorder convention used in the
                                      documentation for this register or
                                      field. */
        reg_role_t role;           /* Role of this register in the ABI/HW. */
        bool memory_mapped;        /* True if the register is memory mapped. */
        uint64 offset;             /* Offset into the bank for memory mapped
                                      registers. */
        bool catchable;            /* True if Core_Control_Register_Write and
                                      Core_Control_Register_Read are triggered
                                      when this register is written or read. */
        int msb, lsb;              /* Most and least significant bit of the
                                      register or field. Always given in le
                                      bitorder. For groups msb == -1 and
                                      lsb == 0. */
        int regsize;               /* Number of bits in the register, or the
                                      register this field is a part of. */
        int reg_id;                /* For registers and fields the id to pass
                                      to the get and set methods to access the
                                      register's value. Fields have the same
                                      reg_id as the register they are a part
                                      of. Not valid for groups.*/
} description_t;</pre><p>

  </p><pre class="jdocu_small">SIM_INTERFACE(describe_registers) {
        const description_t *(*first_child)(
                conf_object_t *NOTNULL obj, const description_t *parent);
        const description_t *(*next_description)(
                conf_object_t *NOTNULL obj, const description_t *prev);
        void (*free_description)(conf_object_t *NOTNULL obj,
                                 const description_t *desc);
        const named_value_t *(*first_named_value)(
                conf_object_t *NOTNULL obj, const description_t *parent);
        const named_value_t *(*next_named_value)(
                conf_object_t *NOTNULL obj, const named_value_t *prev);
        void (*free_named_value)(conf_object_t *NOTNULL obj,
                                 const named_value_t *nv);
        void (*get)(conf_object_t *NOTNULL obj, int reg_id, buffer_t dest);
        void (*set)(conf_object_t *NOTNULL obj, int reg_id, bytes_t value);
};

#define DESCRIBE_REGISTERS_INTERFACE "describe_registers"
</pre><p>
</p><p>
  
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
  
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_device_identification.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_device_identification.html:__rm_interface_device_identification">device_identification</a></h1>
<p>

<a id="__rm_interface_device_identification.html:device_identification"></a><a id="__rm_interface_device_identification.html:device_identification_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The
   <code>device_identification</code> interface is used to identify device
   type such as product, stepping etc.
<p>
   <b><i>get_id</i></b> returns the identifier for the given <i>key</i>.
   Existing keys can be retrieved using the <b><i>get_key</i></b> function. All
   existing keys should return a valid identifier string. For unknown keys the
   returned value is NULL.
</p><p>
   <b><i>get_key</i></b> returns the key at the specified <i>index</i> or NULL
   starting at 0, to get the key at that index. At the <i>index</i> where
   NULL is returned there are no more keys.
</p><p>
   <b><i>get_key</i></b> returns the key at the specified <i>index</i>, or
   NULL if the <i>index</i> does not correspond to a key. To get the
   complete list of keys, call <b><i>get_key</i></b> using an <i>index</i>
   starting at zero, and increase the <i>index</i> for each call until
   <b><i>get_key</i></b> returns NULL.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(device_identification) {
        const char *(*get_id)(conf_object_t *NOTNULL obj, const char *key);
        const char *(*get_key)(conf_object_t *NOTNULL obj, unsigned int index);
};

#define DEVICE_IDENTIFICATION_INTERFACE "device_identification"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_direct_memory.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_direct_memory.html:__rm_interface_direct_memory">direct_memory</a></h1>
<p>

<a id="__rm_interface_direct_memory.html:direct_memory"></a><a id="__rm_interface_direct_memory.html:direct_memory_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><a id="__rm_interface_direct_memory.html:direct_memory_handle_t"></a>
   <a id="__rm_interface_direct_memory.html:direct_memory_ack_id_t"></a>
   <a id="__rm_interface_direct_memory.html:direct_memory_t"></a>
<p>
   The <code>direct_memory</code> interface is implemented by objects that
   model memory, such as RAM and ROM objects. These are called direct-memory
   objects. A user of the interface is called a memory user and is
   typically a processor that wants to do fast accesses to memory. The
   direct-memory object corresponding to a particular physical address
   can be obtained using the <b><i>lookup</i></b> method of the
   <code>direct_memory_lookup</code> interface.
   See the documentation for the
   <code>direct_memory_lookup</code> interface for more information.
</p><p>
   A memory user using the <code>direct_memory</code> interface 
   must implement the <code>direct_memory_update</code> interface.
</p><p>
   The <b><i>get_handle</i></b> method is used by a memory user
   to create or retrieve a handle to the memory region starting
   at offset <i>offs</i> with size <i>size</i>.
   The handle is typically used later on to request access permissions
   and to retrieve a direct pointer to the region.
   The handle returned by <b><i>get_handle</i></b> is private to the
   memory user specified in the <i>requester</i> parameter.
</p><p>
   If <b><i>get_handle</i></b> is invoked multiple times for the same
   range, and with identical <i>requester</i> and
   <i>subsystem</i> arguments, then the same handle will
   be returned each time, assuming the original handle is still valid.
   Note that the original handle is only returned if the range
   matches exactly. A single memory user can obtain multiple
   distinct handles for the same memory range by using different values for the
   <i>subsystem</i> parameter.
</p><p>
   For RAM and ROM, <i>offs</i> and <i>size</i> must
   specify a region which does not intersect a naturally aligned
   8192 byte boundary, or the request will fail with a NULL return
   value. Other direct-memory objects might have different requirements.   
</p><p>
   The <b><i>request</i></b> method is used to request a host pointer to simulated
   memory. This pointer can be used to carry out fast memory operations without
   having to involve the Simics API. The <i>handle</i> argument is the
   handle obtained using <b><i>get_handle</i></b>.
</p><p>
   Both the <i>permission</i> argument and the <i>inhibit</i> argument
   are <code>access_t</code> type bit fields. The <i>permission</i>
   argument is used to specify what kind of memory operations the memory user
   will perform. For example, if a memory user wants to read memory, the
   <i>permission</i> argument must include the Sim_Access_Read value.  The
   <i>inhibit</i> argument specifies what other memory users are not
   allowed to do. For example, if <i>inhibit</i> is set to Sim_Access_Write
   other memory users are not allowed to write to the memory range.  This
   protection mechanism can be used to create caches of simulated memory,
   request exclusive permissions to a memory range in order to carry out atomic
   operations, and similar.  When a memory user is requesting permission to a
   memory range that another memory user has protected with conflicting inhibit
   bits, the direct-memory object will inform the other memory user of
   the lost permissions and protection through the
   <code>direct_memory_update</code> interface.  A user can lose both the
   permission and protection for a memory range in this way. When this happens,
   a memory user may re-request permissions and inhibit protection.
</p><p>
   Note: if a memory user has multiple handles which overlaps, then
   each handle is considered to be a distinct memory user. For example,
   if a memory user holds two handles, and requests write inhibit on
   one of them, then write permission will be revoked from the second
   handle (if such permission had been granted).
</p><p>
   The <b><i>request</i></b> method returns a <code>direct_memory_t</code> value
   with information about the retrieved permissions and inhibit bits. These
   bits can be a super set of the bits that actually were requested. The
   returned data pointer can be used to access the memory range. Accesses are
   valid from the data pointer and up to the end of the range, i.e., addresses
   up to data pointer + <i>size</i> - 1, where size is the size valid for
   the handle. A call to <b><i>request</i></b> always succeeds and the
   corresponding memory range is valid until the permissions or the handle are
   revoked by the <code>direct_memory_update</code> interface.  Note that the
   data pointer may change each time <b><i>request</i></b> is called (with the
   same handle) since Simics may move simulated memory. If the pointer
   changes, then the old pointer must not be used.
</p><p>
   With <b><i>set_user_data</i></b>, a memory user can associate 
   a user-defined pointer with a specific handle. The pointer can
   be retrieved using the <b><i>get_user_data</i></b> method, which takes
   a <i>handle</i> as an argument.
</p><p>
   A memory user can use the <b><i>release</i></b> function to notify the
   direct-memory object when it is no longer interested in the memory
   region corresponding to <i>handle</i>. The handle is invalid
   and must not be used for anything after being released.
   </p><p>
   The <b><i>ack</i></b> method is used by a memory user to inform the 
   direct-memory object that it has given up the corresponding permission and
   inhibit rights for a memory range when called by a method in the
   <code>direct_memory_update</code> interface.
</p><p>
   Permissions can be revoked from all memory users by invoking the
   <b><i>revoke</i></b> method. The <i>permission</i> parameter
   specifies the permissions which will be revoked from all memory users.
   Similarly, <i>inhibit</i> specifies the inhibit privileges which
   will be revoked. For instance, calling <b><i>revoke</i></b> with
   <i>permission</i>
   set to <code>Sim_Access_Write</code> will ensure that nobody has
   write permissions to the direct-memory object.
</p><p>
   
</p><pre class="jdocu_small">typedef granted_mem_t *direct_memory_handle_t;</pre><p>

   
   <a id="__rm_interface_direct_memory.html:direct_memory_t2"></a>
   </p><pre class="jdocu_small">typedef struct {
#ifndef PYWRAP
        uint8                 *data;
#endif
        access_t               permission;
        access_t               inhibit;
} direct_memory_t;</pre><p>
</p><p>
   
   
</p><pre class="jdocu_small">typedef uint64 direct_memory_ack_id_t;</pre><p>

   </p><pre class="jdocu_small">SIM_INTERFACE(direct_memory) {
        direct_memory_handle_t (*get_handle)(conf_object_t *NOTNULL obj,
                                             conf_object_t *NOTNULL requester,
                                             uint64 subsystem,
                                             uint64 offs,
                                             unsigned size);
        direct_memory_t (*request)(conf_object_t *NOTNULL obj,
                                   direct_memory_handle_t handle,
                                   access_t permission,
                                   access_t inhibit);
        void (*revoke)(conf_object_t *NOTNULL obj,
                       access_t access,
                       access_t permission,
                       access_t inhibit);
#ifndef PYWRAP
        void *(*get_user_data)(conf_object_t *NOTNULL obj,
                                    direct_memory_handle_t handle);
        void (*set_user_data)(conf_object_t *NOTNULL obj,
                              direct_memory_handle_t handle,
                              void *user_data);
#endif
        void (*release)(conf_object_t *NOTNULL obj,
                        direct_memory_handle_t handle);
        void (*ack)(conf_object_t *NOTNULL obj,
                    direct_memory_ack_id_t id);
};

#define DIRECT_MEMORY_INTERFACE "direct_memory"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_direct_memory_flush.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_direct_memory_flush.html:__rm_interface_direct_memory_flush">direct_memory_flush</a></h1>
<p>

<a id="__rm_interface_direct_memory_flush.html:direct_memory_flush"></a><a id="__rm_interface_direct_memory_flush.html:direct_memory_flush_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>direct_memory_flush</code> interface is implemented by objects
     that model memory, such as RAM and ROM objects, and is used for flushing
     granted rights and for managing access rights.
<p>
     The <b><i>revoke</i></b> method revokes granted access, permissions and
     inhibit rights from memory-user regions intersecting
     [<i>base</i>, <i>base</i> + <i>size</i>).
</p><p>
     The <b><i>set_access_bits</i></b> method grants access rights
     <i>access</i> for the region [<i>base</i>,
     <i>base</i> + <i>size</i>) to the memory user
     <i>requester</i>. If <i>requester</i> is NULL, then
     access rights are granted to all memory users. If the set succeeds, true is
     returned, otherwise false.
</p><p>
     </p><pre class="jdocu_small">SIM_INTERFACE(direct_memory_flush) {
        void (*revoke)(conf_object_t *NOTNULL obj,
                       uint64 base, uint64 size,
                       access_t access, access_t perm, access_t inhibit);
        bool (*set_access_bits)(conf_object_t *NOTNULL obj,
                                conf_object_t *requester,
                                uint64 base, uint64 size,
                                access_t access);
};
#define DIRECT_MEMORY_FLUSH_INTERFACE "direct_memory_flush"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_direct_memory_lookup.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_direct_memory_lookup.html:__rm_interface_direct_memory_lookup">direct_memory_lookup</a></h1>
<p>

<a id="__rm_interface_direct_memory_lookup.html:direct_memory_lookup"></a><a id="__rm_interface_direct_memory_lookup.html:direct_memory_lookup_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><a id="__rm_interface_direct_memory_lookup.html:direct_memory_lookup_t"></a>
<p>
   The <code>direct_memory_lookup</code> interface is implemented by Simics
   memory-spaces. The interface is used by simulator objects that want to do
   fast accesses to memory and/or want to build up a cached representation of
   memory. These objects are referred to as memory users, e.g., processors.
   Fast accesses are done via host pointers to simulated memory. The
   <code>direct_memory_lookup</code> interface is used in conjunction with
   the <code>direct_memory</code> interface which is implemented by objects
   that own the actual data storage, e.g., RAM/ROM objects. These objects are
   called direct-memory objects.
</p><p>
   To access data, a memory-user object first calls the <b><i>lookup</i></b>
   method on the memory space <i>obj</i>. The
   <i>requester</i> is the memory-user doing the lookup.
   The <b><i>lookup</i></b> method traces the range specified by
   <i>addr</i> and <i>size</i>
   through memory spaces and translators until a direct-memory object
   is reached. The direct-memory object is returned in the
   <i>target</i> field and the offset into this object
   corresponding to <i>addr</i> is returned in the
   <i>offs</i> field.
</p><p>
   The call to <b><i>lookup</i></b> fails if the specified range does
   not map continuously to a direct-memory object. A lookup failure
   is indicated by returning NULL in the <i>target</i> field.
</p><p>
   The <i>access</i> argument is a bit field of at least one
   <code>access_t</code> value specifying what kind of accesses the memory user
   is interested in. All specified access types must reach the same
   direct-memory object and range for the lookup to succeed. If the memory
   space, for example, redirects reads and writes to different memory ranges or
   direct-memory objects, a lookup would fail if <i>access</i>
   specified both read and write. Note that the actual access permissions
   needed to access the real data must be requested from
   the direct-memory object using the <b><i>request</i></b> method of
   the <code>direct_memory</code> interface. The <i>access</i>
   argument is only used to locate the direct-memory object.
</p><p>
   The return field <i>access</i> contains at least the access
   bits requested used in the lookup request, but may as an optimization
   contain a superset, indicating that the lookup result is valid for this
   superset. However, there is no guarantee that this optimization
   takes place.
</p><p>
   Once a direct-memory object has been found, the <code>direct_memory</code>
   interface can be used to obtain a direct pointer to the contents
   of the direct-memory object.
</p><p>
   The <i>tracers</i> and <i>breakpoints</i> fields in the
   return value contain information about installed tracers and breakpoints
   that intersect the range. Examples of tracers are timing models
   and snoop objects. In order to trigger breakpoints and invoke any tracers,
   the memory user should perform memory operations using the
   <code>memory_space</code> interface. Only breakpoints and tracers that
   overlap (binary and) with the provided <i>access</i> argument need to be
   considered.
</p><p>
   
   <a id="__rm_interface_direct_memory_lookup.html:direct_memory_t"></a>
   </p><pre class="jdocu_small">typedef struct {
        conf_object_t     *target;
        uint64             offs;

        access_t           breakpoints;      // conflicting breakpoints
        access_t           tracers;          // conflicting tracers
        access_t           access;           // handle valid for access
} direct_memory_lookup_t;</pre><p>
</p><p>
   
   </p><pre class="jdocu_small">SIM_INTERFACE(direct_memory_lookup) {
        direct_memory_lookup_t (*lookup)(conf_object_t *NOTNULL obj,
                                         conf_object_t *requester,
                                         physical_address_t addr,
                                         unsigned size,
                                         access_t access);
};

#define DIRECT_MEMORY_LOOKUP_INTERFACE "direct_memory_lookup"
</pre><p>
</p><p>

   The <code>direct_memory_lookup</code> and <code>direct_memory</code>
   interfaces replace the <code>memory_page</code> interface of Simics 4.8.
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_direct_memory_lookup_v2.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_direct_memory_lookup_v2.html:__rm_interface_direct_memory_lookup_v2">direct_memory_lookup_v2</a></h1>
<p>

<a id="__rm_interface_direct_memory_lookup_v2.html:direct_memory_lookup_v2"></a><a id="__rm_interface_direct_memory_lookup_v2.html:direct_memory_lookup_v2_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><a id="__rm_interface_direct_memory_lookup_v2.html:direct_memory_lookup_v2_t"></a>
<p>
   The <code>direct_memory_lookup_v2</code> interface is implemented by
   Simics memory-spaces. Its functionality is identical to the
   <code>direct_memory_lookup</code> interface except that it takes a
   <code>transaction_t</code> argument instead of a requester object and
   size. It must be used instead of <code>direct_memory_lookup</code> in
   cases when memory mappings may depend on atoms of the transaction in
   addition to the physical address.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(direct_memory_lookup_v2) {
        direct_memory_lookup_t (*lookup)(conf_object_t *NOTNULL obj,
                                         transaction_t *NOTNULL transaction,
                                         physical_address_t addr,
                                         access_t access);
};

#define DIRECT_MEMORY_LOOKUP_V2_INTERFACE "direct_memory_lookup_v2"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_direct_memory_tags.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_direct_memory_tags.html:__rm_interface_direct_memory_tags">direct_memory_tags</a></h1>
<p>

<a id="__rm_interface_direct_memory_tags.html:direct_memory_tags"></a><a id="__rm_interface_direct_memory_tags.html:direct_memory_tags_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><a id="__rm_interface_direct_memory_tags.html:direct_memory_tags_t"></a>
<p>
   The <code>direct_memory_tags</code> interface is implemented by objects
   that model RAM memory with support for auxiliary RAM bits.
</p><p>
   The <b><i>get_tags_data</i></b> method returns a 
   <code>direct_memory_tags_t</code> value which contains 
   a direct pointer to the memory used to store the tags bits.
   The <i>handle</i> argument should be a handle for a region of memory
   previously obtained from the <b><i>get_handle</i></b> method of
   the <code>direct_memory</code> interface. 
</p><p>
   NOTE: The memory region specified indirectly by the <i>handle</i>
   argument will be enlarged, if necessary, to have a natural 128-byte
   alignment. This is done to ensure that the tags mapping is unambiguous.
</p><p>
   The returned data pointer points to tag bits for the region
   specified by <i>handle</i>. The least significant bit of the
   first byte corresponds to the first 16 bytes of the (aligned) region.
</p><p>
   The <i>len</i> field is set to the number of bytes holding
   tags data that may be accessed and it equals the size of the
   (aligned) region divided by 128.
</p><p>
   The augmented memory bits may be read or modified using the
   returned pointer, provided that the user has corresponding
   read or write permissions to the region specified by <i>handle</i>.
</p><p>
   The returned pointer will remain valid until the corresponding
   permissions to the direct memory region are lost, which usually
   happens through a call to the <b><i>update_permission</i></b> method of the
   <code>direct_memory_update</code> interface. The returned pointer
   must also be considered invalid when additional permissions
   for the region are requested using the <b><i>request</i></b> method of
   the <code>direct_memory</code> interface. This is necessary since
   e.g. a write request could trigger copy-on-write behavior and
   reallocation of the underlying storage.
   </p><p>
   
   <a id="__rm_interface_direct_memory_tags.html:direct_memory_tags_t2"></a>
   </p><pre class="jdocu_small">typedef struct {
#ifndef PYWRAP
        uint8 *data;
#endif
        unsigned len;
} direct_memory_tags_t;</pre><p>
</p><p>
   
   </p><pre class="jdocu_small">SIM_INTERFACE(direct_memory_tags) {
        direct_memory_tags_t (*get_tags_data)(conf_object_t *NOTNULL obj,
                                              direct_memory_handle_t handle);
};
#define DIRECT_MEMORY_TAGS_INTERFACE "direct_memory_tags"        
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_direct_memory_update.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_direct_memory_update.html:__rm_interface_direct_memory_update">direct_memory_update</a></h1>
<p>

<a id="__rm_interface_direct_memory_update.html:direct_memory_update"></a><a id="__rm_interface_direct_memory_update.html:direct_memory_update_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>direct_memory_update</code> interface must be implemented by
   memory-user objects that use the <code>direct_memory</code> interface.
<p>
   The <code>direct_memory_update</code> interface replaces the
   <code>memory_page_update</code> interface from Simics 4.8.
</p><p>
   Accesses to memory are controlled by a handle that the memory-user object
   requests by calling the <b><i>get_handle</i></b> method of the
   <code>direct_memory</code> interface. The object implementing the
   <code>direct_memory</code> interface through which the handle was
   established is passed to the functions in
   <code>direct_memory_update</code> as <i>target</i>.
</p><p>
   If the <b><i>release</i></b> method is called, the corresponding
   <i>handle</i> and all the permissions and inhibit protections are
   recalled. The memory-user object must stop using the handle and
   associated data pointers and then call the acknowledge method
   <b><i>ack</i></b> in the <code>direct_memory</code> interface from
   which the handle was granted.
</p><p>
   A call to the <b><i>update_permission</i></b> method revokes earlier requested
   rights for a handle. The <i>lost_access</i> argument recalls rights to
   use the handle for the given access bits. This means that the handle needs
   to be re-fetched (by a call to the <b><i>lookup</i></b> method of the
   <code>direct_memory_lookup</code> interface followed by a call to the
   <b><i>get_handle</i></b> method of the <code>direct_memory</code> interface)
   before the handle can be used again for the particular access. This typically
   happens if a new breakpoint is inserted or a remap of the memory system is
   done. In case of a remap it is possible that the same handle will never be
   returned again which means that any user data associated with the handle
   should be reclaimed. 
</p><p>
   The <i>lost_permission</i> and the <i>lost_inhibit</i> arguments
   describe which permission rights and inhibit protection that are
   revoked. However, in contrast to the <i>lost_access</i>, the
   <i>handle</i> is still valid and can be used to re-request permission
   rights and inhibit protection.
</p><p>
   A call to the <b><i>conflicting_access</i></b> method informs a memory-user
   object that a conflicting memory operation will be performed. Hence, if the
   memory-user object have some protected representation of memory (such as
   decoded instructions in an internal cache), that representation of memory
   has to be flushed (or written back to memory in case of dirty data). Note
   however that the memory-user object does not lose any permission rights or
   any inhibit protection. 
</p><p>
   There is no mechanism for locking simulated memory in host memory.
</p><p>
   All methods in this interface receive a <code>direct_memory_ack_id_t</code>
   value as an argument. The <b><i>ack</i></b> method of the
   <code>direct_memory</code> interface must be called with this
   <i>id</i> as an argument when the corresponding operation has been
   carried out. The <b><i>ack</i></b> method may be called after the
   <code>direct_memory_update</code> interface function has returned, which
   allows for queueing of update requests. This may be valuable if multiple
   simulator threads are used.
</p><p>
   An exception to the allowed queueing of update requests is for update
   requests that are received while calling <b><i>request</i></b> in the
   <code>direct_memory</code> interface. Such requests must be handled
   immediately with <b><i>ack</i></b> being called before the return of the
   <code>direct_memory_update</code> interface function. This requirement
   avoids a dead-lock that would otherwise happen if <b><i>request</i></b> would
   wait for <b><i>ack</i></b> before returning, but <b><i>ack</i></b> is
   queued to be handled at some time after <b><i>request</i></b> has returned.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(direct_memory_update) {
        void (*release)(conf_object_t *NOTNULL obj,
                        conf_object_t *NOTNULL target,
                        direct_memory_handle_t handle,
                        direct_memory_ack_id_t id);
        void (*update_permission)(conf_object_t *NOTNULL obj,
                                  conf_object_t *NOTNULL target,
                                  direct_memory_handle_t handle,
                                  access_t lost_access,
                                  access_t lost_permission,
                                  access_t lost_inhibit,
                                  direct_memory_ack_id_t id);
        void (*conflicting_access)(conf_object_t *NOTNULL obj,
                                   conf_object_t *NOTNULL target,
                                   direct_memory_handle_t handle,
                                   access_t conflicting_permission,
                                   direct_memory_ack_id_t id);
};

#define DIRECT_MEMORY_UPDATE_INTERFACE "direct_memory_update"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_disk_component.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_disk_component.html:__rm_interface_disk_component">disk_component</a></h1>
<p>

<a id="__rm_interface_disk_component.html:disk_component"></a><a id="__rm_interface_disk_component.html:disk_component_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>disk_component</code> interface is implemented by components
   that provide disk storage. The <b><i>size()</i></b> member function should
   return the total disk size provided by the component, once configured.
<p>
   </p><pre class="jdocu_small">SIM_INTERFACE(disk_component) {
        uint64 (*size)(conf_object_t *obj);
};
#define DISK_COMPONENT_INTERFACE "disk_component"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Global Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_event_delta.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_event_delta.html:__rm_interface_event_delta">event_delta</a></h1>
<p>

<a id="__rm_interface_event_delta.html:event_delta"></a><a id="__rm_interface_event_delta.html:event_delta_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>event_delta</code> interface is implemented by CPUs and
   clocks that advance time.
<p>
   The <b><i>set_delta</i></b> method notifies the CPU about
   the number of cycles the CPU should run before the next event
   should be dispatched by a call to the <b><i>handle_event</i></b>
   method of the <code>event_handler</code> interface.
   </p><p>
   The <b><i>get_delta</i></b> queries the CPU for the current count
   of remaning cycles to the next event. The returned number should
   always be smaller or equal to the number of cycles established by
   a previous call to <b><i>set_delta</i></b>.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(event_delta) {
        uint64 (*set_delta)(conf_object_t *NOTNULL obj,
                            conf_object_t *NOTNULL event_handler_obj,
                            const event_class_t *next_event_ec,
                            uint64 delta);
        uint64 (*get_delta)(conf_object_t *NOTNULL obj,
                            conf_object_t *NOTNULL event_handler_obj);
};
#define EVENT_DELTA_INTERFACE "event_delta"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_event_handler.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_event_handler.html:__rm_interface_event_handler">event_handler</a></h1>
<p>

<a id="__rm_interface_event_handler.html:event_handler"></a><a id="__rm_interface_event_handler.html:event_handler_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>event_handler</code> interface is implemented by
   the <code>vtime</code> port object and is invoked by clocks or CPUs
   implementing the <code>event_delta</code> interface.
<p>
   The <b><i>handle_event</i></b> method should be called when the number
   of cycles to the next event has reached zero. The method
   invokes the next event and notifies the CPU or clock about the cycle count
   to the next pending event by invoking the <b><i>set_delta</i></b> method.
</p><p>
   The <b><i>stop</i></b> method should be called if a dispatched
   event requests the simulation to be stopped. The method is typically
   called from the <b><i>stop</i></b> method of the <code>execute</code>
   interface. If the <b><i>stop</i></b> method is not called, then time may be
   advanced by a fraction of a cycle after an event has been dispatched.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(event_handler) {
        bool (*handle_event)(conf_object_t *NOTNULL obj);
        void (*stop)(conf_object_t *NOTNULL obj);
};
#define EVENT_HANDLER_INTERFACE "event_handler"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_event_provider.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_event_provider.html:__rm_interface_event_provider">event_provider</a></h1>
<p>

<a id="__rm_interface_event_provider.html:event_provider"></a><a id="__rm_interface_event_provider.html:event_provider_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">=============================================
<p>
                TECH-PREVIEW
</p><p>
    This interface may change without notice.
</p><p>
  =============================================
</p><p>
  The <code>event_provider</code> interface is used internally in between
  ISIM modules.
</p><p>
  The method <b><i>event_name</i></b> returns name of event with index
  <i>n</i> or <code>NULL</code> if there is no event with that index.
</p><p>
  The method <b><i>event_value</i></b> returns accumulated value for event
  with index <i>n</i>. Output is undefined if there is no event with
  that index.
</p><p>
  Events must de indexed from <code>0</code> to <code>last</code> without gaps.
</p><p>
  To use the <code>event-provider</code> add the following
  EXTRA_MODULE_VPATH := event-provider-interface
  to the modules Makefile.
</p><p>
  </p><pre class="jdocu_small">

SIM_INTERFACE(event_provider) {
        const char *(*event_name)(conf_object_t *obj, unsigned n);
        uint64 (*event_value)(conf_object_t *obj, unsigned n);
};

#define EVENT_PROVIDER_INTERFACE "event_provider"

</pre><p>
</p><p>

  
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Called from performance models.
  
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_exception.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_exception.html:__rm_interface_exception">exception</a></h1>
<p>

<a id="__rm_interface_exception.html:exception"></a><a id="__rm_interface_exception.html:exception_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>exception</code> interface is used to translate
   exception numbers, as received by the Core_Exception hap, to names,
   and vice versa.
<p>
   The <b><i>get_number</i></b> function returns the number associated
   with an exception name, or -1 if the no exception with the given
   name exist. The <b><i>get_name</i></b> returns the name
   associated with an exception number. The <b><i>get_source</i></b>
   function is only used on X86 targets and returns the source for an
   exception, as an exception number can be raised from different
   sources. The <b><i>all_exceptions</i></b> function returns a list of
   all exceptions numbers.
</p><p>
   The exception numbers are architecturally defined, while their
   names are defined by the model.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(exception) {
        int (*get_number)(conf_object_t *NOTNULL obj,
                          const char *NOTNULL name);
        const char *(*get_name)(conf_object_t *NOTNULL obj, int exc);
        int (*get_source)(conf_object_t *NOTNULL obj, int exc);
        attr_value_t (*all_exceptions)(conf_object_t *NOTNULL obj);
};

#define EXCEPTION_INTERFACE "exception"
</pre><p>
</p><p>
   
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_exec_trace.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_exec_trace.html:__rm_interface_exec_trace">exec_trace</a></h1>
<p>

<a id="__rm_interface_exec_trace.html:exec_trace"></a><a id="__rm_interface_exec_trace.html:exec_trace_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>exec_trace</code> interface is implemented by processor models
  that support tracing. A trace listener registers itself with the
  <b><i>register_tracer</i></b> call. The <i>tracer</i> callback will be
  called by the processor model
  when each instruction is just about to be executed, passing the
  <i>tracer_data</i> as passed to the <b><i>register_tracer</i></b> function
  in addition to information about the instruction that is executed.
  Invoke <b><i>unregister_tracer</i></b> with the same two pointers to deregister
  the listener.
<p>
  
</p><pre class="jdocu_small">typedef void (*instruction_trace_callback_t)(lang_void *tracer_data,
                                             conf_object_t *cpu,
                                             linear_address_t la,
                                             logical_address_t va,
                                             physical_address_t pa,
                                             byte_string_t opcode);</pre><p>

</p><p>
  The <i>pa</i> parameter to the callback will always be valid, but some
  CPU architectures may not support <i>la</i> or <i>va</i>. The
  <i>la</i> argument is typically only valid for x86 CPUs. Lastly, the
  opcode of the instruction is passed in <i>opcode</i>. The
  <i>opcode</i> is passed without endian conversion, meaning that byte X in
  <i>opcode</i> corresponds to the byte at <i>pa</i> + X.
</p><p>
  </p><pre class="jdocu_small">SIM_INTERFACE(exec_trace) {
        void (*register_tracer)(conf_object_t *NOTNULL cpu_obj,
                                instruction_trace_callback_t tracer,
                                lang_void *tracer_data);
        void (*unregister_tracer)(conf_object_t *NOTNULL cpu_obj,
                                  instruction_trace_callback_t tracer,
                                  lang_void *tracer_data);
};

#define EXEC_TRACE_INTERFACE "exec_trace"
</pre><p>
</p><p>
  
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Global Context for both methods.
  Cell Context for the callback.
  
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_execute.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_execute.html:__rm_interface_execute">execute</a></h1>
<p>

<a id="__rm_interface_execute.html:execute"></a><a id="__rm_interface_execute.html:execute_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>execute</code> interface is implemented by objects that
   drive a simulation, which is often processor models. The object
   does not have to implement <code>cycle</code> or
   <code>step</code>.
<p>
   An object implementing the <code>execute</code> interface must be
   coupled with one object implementing the <code>cycle</code>
   interface. It can be the same object that implements the
   <code>cycle</code> interface.
</p><p>
   The <b><i>run</i></b> function is called when the simulator starts or
   restarts the execution.
</p><p>
   By default the Simics scheduler will assume that the object being called in
   with the execute interface also implements the corresponding
   <code>processor_info</code> and <code>step</code> interfaces.
   If this assumption is incorrect, the implementation of the <b><i>run</i></b>
   function is responsible for maintaining the simulators view of the current
   objects implementing the <code>processor_info</code> and
   <code>step</code> interfaces. It does that by using the appropriate
   functions in the <code>cell_inspection</code> interface. The current
   objects must always be correctly set when either the <b><i>run</i></b> function
   returns, when any API method is called, or when any other object is called
   through an interface. Several Simics features, such as CLI commands, device
   logging, and hap handling make use of the current objects.
</p><p>
   To handle asynchronous events, and thus allow for reasonable interactive
   performance, the implementor of <code>execute</code> needs to either make
   sure that <b><i>run</i></b> returns after not having run for too long, or
   preferably regularly call the <b><i>VT_check_async_events</i></b> method. In
   the Simics library CPU models, <b><i>VT_check_async_events</i></b> is called
   after servicing events from the <code>cycle</code> or <code>step</code>
   interfaces.
</p><p>
   The simulator core will call <b><i>stop</i></b> when it detects a
   condition that should interrupt the simulation. The callee should
   stop as soon as possible when in a stable state, typically when the
   current executing instruction is finished after getting a request
   to stop. In some cases the callee might receive multiple stop
   requests in a rapid sequence. Conditions leading to a stop request
   include <b><i>SIM_break_simulation</i></b> being called from a device
   or hap-handler, breakpoint triggered, low-memory situations, the
   user interrupting the simulation with Ctrl-C, and the Simics core
   halting the object when it is at the end of the allowed time window
   in temporal decoupled simulation. It is forbidden to do anything in
   the <b><i>stop</i></b> function that can lead to a new stop request,
   this includes posting events, printing <b><i>SIM_log</i></b>-messages,
   etc. Before returning from the <b><i>run</i></b> method, the
   <b><i>VT_stop_event_processing</i></b> function should be called. The
   requirement to call <b><i>VT_stop_event_processing</i></b> is likely
   to be lifted in future versions of Simics.
</p><p>
   The <b><i>switch_in</i></b> function is called whenever the
   execute object is about to gain control of the simulation
   from some other execute object in the cell. Similarly,
   <b><i>switch_out</i></b> is invoked before control is relinquished.
   It should be noted that these functions are called in a
   deterministic manner which is not true for <b><i>run</i></b>.
</p><p>
   The <b><i>switch_in</i></b> and <b><i>switch_out</i></b> functions
   are not called at simulation start (or checkpoint load), in
   general.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(execute) {
        void (*run)(conf_object_t *obj);
        void (*stop)(conf_object_t *obj);

        void (*switch_in)(conf_object_t *obj);
        void (*switch_out)(conf_object_t *obj);
};

#define EXECUTE_INTERFACE "execute"
</pre><p>
</p><p>

   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_execute_control.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_execute_control.html:__rm_interface_execute_control">execute_control</a></h1>
<p>

<a id="__rm_interface_execute_control.html:execute_control"></a><a id="__rm_interface_execute_control.html:execute_control_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>execute_control</code> interface is implemented by CPUs
   and devices that support threading.
<p>
   Warning: This interface is currently considered tech-preview and
   can be changed at any time.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(execute_control) {
        void (*message_pending)(conf_object_t *obj);
        void (*yield_request)(conf_object_t *obj);
};
#define EXECUTE_CONTROL_INTERFACE "execute_control"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Threaded Context
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_freerun.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_freerun.html:__rm_interface_freerun">freerun</a></h1>
<p>

<a id="__rm_interface_freerun.html:freerun"></a><a id="__rm_interface_freerun.html:freerun_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>freerun</code> interface is provided by
   the <b>freerun-extension</b> extension class. The extension
   class augments CPU models with support for freerunning mode. The
   <code>freerun</code> interface is used by CPU models to
   interface with the extension class.
<p>
   The <b><i>enabled</i></b> member returns <code>true</code> if
   freerunning mode is enabled and <code>false</code> otherwise.
   The notifier <code>Sim_Notifier_Freerunning_Mode_Change</code> is
   triggered for the object whenever freerunning mode is enabled or disabled.
</p><p>
   The <b><i>advance_clock</i></b> is used by the CPU model to
   calculate how much its virtual time should be advanced in freerunning mode.
   The <i>ps_limit</i> argument is the maximal number of pico-seconds
   virtual time can be advanced. The next CPU event typically occurs
   at this time. The <i>steps</i> argument should be set to the number
   of elapsed instructions since the last call to <i>advance_clock</i>.
   The <i>idle</i> parameter should be set to <code>true</code> if
   the CPU is idle. The function returns the number of pico-seconds
   the virtual time of the CPU should be advanced. The returned value
   is proportional to the time spent simulating the model, but is also
   subject to configurable freerunning restrictions which ensures that
   the instruction rate is kept in an acceptable range.
</p><p>
   The <b><i>start_clock</i></b> function should be called when
   the CPU model starts instruction simulation. It is used to measure
   the amount of time used to simulate the model.
</p><p>
   The <b><i>stop_clock</i></b> function should be called when
   the CPU model stops instruction simulation.
</p><p>
   The <b><i>current_itime</i></b> function returns a prediction of the amount
   of time needed to simulate an instruction, in pico-seconds. The
   estimate is based on historic data and will always be in an interval
   which does not conflict with configured freerunning restrictions.
   The value can be used to estimate how many instructions
   can be executed until the next time event.
</p><p>
   </p><div class="note">
<b>Note:</b>
The <code>freerun</code> interface is experimental and may
   change without notice.</div><pre class="jdocu_small">SIM_INTERFACE(freerun) {
        bool (*enabled)(conf_object_t *NOTNULL obj);

        int64 (*advance_clock)(conf_object_t *NOTNULL obj,
                               int64 ps_limit, int64 steps, bool idle);
        void (*start_clock)(conf_object_t *NOTNULL obj);
        void (*stop_clock)(conf_object_t *NOTNULL obj);

        uint64 (*current_itime)(conf_object_t *NOTNULL obj);
};
#define FREERUN_INTERFACE "freerun"
</pre><p>
</p><p>

   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_gfx_con.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_gfx_con.html:__rm_interface_gfx_con">gfx_con</a></h1>
<p>

<a id="__rm_interface_gfx_con.html:gfx_con"></a><a id="__rm_interface_gfx_con.html:gfx_con_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>gfx_con</code> is implemented by graphics consoles of class
   <b>graphcon</b> and is used by attached video devices to update the
   screen.
<p>
   The <b><i>set_color</i></b> method sets the specified indexed palette
   color. The return value has no meaning.
</p><p>
   The <b><i>set_size</i></b> method sets the size of the displayed screen.
</p><p>
   The <b><i>put_pixel</i></b>method sets the pixel at (<i>x</i>,
   <i>y</i>) to the specified palette color. The change will only be
   visible after the next call to <b><i>redraw</i></b>.
</p><p>
   The <b><i>put_pixel_rgb</i></b> method sets the pixel at (<i>x</i>,
   <i>y</i>) to the color <i>rgb</i>, which should be in
   <code>GFX_xRGB_8888</code> format. The change will only be visible after the
   next call to <b><i>redraw</i></b>.
</p><p>
   The <b><i>put_pixel_col</i></b> method sets the pixel at (<i>x</i>,
   <i>y</i>) to the color defined by <i>r</i>, <i>g</i> and
   <i>b</i>. The change will only be visible after the next call to
   <b><i>redraw</i></b>.
</p><p>
   The <b><i>put_block</i></b> method draws pixels from a memory block to the
   screen rectangle described by (<i>minx</i>, <i>miny</i>,
   <i>maxx</i>, <i>maxy</i>); the upper bounds are inclusive. The
   <i>block</i> parameter refers to the source memory block, whose rows
   should be <i>src_stride</i> bytes long. Memory on each row outside the
   rectangle is not accessed. The <i>src_fmt</i> parameter specifies the
   pixel format in <i>block</i>. The change will only be visible
   after the next call to <b><i>redraw</i></b>.
</p><p>
   The <b><i>redraw</i></b> method updates the changed parts of the console screen
   window, so should typically be called at the end of every frame update.
</p><p>
   The <b><i>update_keyboard_leds</i></b> method changes the keyboard LEDs.
   The <i>led_change</i> parameter must be one of the <code>KBD_</code>
   constants from <code>simics/model-iface/sim-keys.h</code>.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(gfx_con) {
        int (*set_color)(conf_object_t *obj,
                         uint8 index, uint8 r, uint8 g, uint8 b);
        void (*set_size)(conf_object_t *obj, int width, int height);
        void (*put_pixel)(conf_object_t *obj, int x, int y, uint8 index);
        void (*put_pixel_rgb)(conf_object_t *obj, int x, int y, uint32 rgb);
#ifndef PYWRAP
        void (*put_block_old)(conf_object_t *obj,
                              uint8 *src, int minx, int miny,
                              int maxx, int maxy, int src_fmt,
                              int src_stride, int unused);
#endif
        void (*redraw)(conf_object_t *obj);
        void (*update_keyboard_leds)(conf_object_t *obj, int led_change);
        void (*put_pixel_col)(conf_object_t *obj, int x, int y,
                              int r, int g, int b);
        void (*put_block)(conf_object_t *obj, bytes_t block, int minx, int miny,
                          int maxx, int maxy, gfx_con_pixel_fmt_t src_fmt,
                          int src_stride);
};

#define GFX_CON_INTERFACE "gfx_con"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_hap_listen.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_hap_listen.html:__rm_interface_hap_listen">hap_listen</a></h1>
<p>

<a id="__rm_interface_hap_listen.html:hap_listen"></a><a id="__rm_interface_hap_listen.html:hap_listen_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">With the <code>hap_listen</code> interface, objects can pick up
  haps and process then as they wish, including re-raising the haps.
<p>
  </p><pre class="jdocu_small">SIM_INTERFACE(hap_listen) {
        void (*occurred)(conf_object_t *obj, conf_object_t *origin,
                         hap_type_t hap, int64 value, va_list ap, bool always);
};
#define HAP_LISTEN_INTERFACE "hap_listen"
</pre><p>
</p><p>
  
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem"><table>

  <tbody><tr><td class="jdocu_noborder"><b><i>occurred</i></b></td><td class="jdocu_noborder">Cell Context</td></tr>

  </tbody></table>
<p>
  
</p></dd>
</dl><p></p></section><section class="page" id="__rm_interface_image.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_image.html:__rm_interface_image">image</a></h1>
<p>

<a id="__rm_interface_image.html:image"></a><a id="__rm_interface_image.html:image_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This interface is used for handling big data images.
<p>
   <b><i>read</i></b> and <b><i>write</i></b> access a chunk of data at a time.
   Only accesses within the bounds of the image are allowed.
</p><p>
   <b><i>clear_range</i></b> fills an interval with null bytes,
   <b><i>fill</i></b> with any byte value.
</p><p>
   <b><i>size</i></b> returns the image size.
</p><p>
   <b><i>get</i></b> and <b><i>set</i></b> work like <b><i>read</i></b>
   and <b><i>write</i></b> but pass the data using a bytes_t instead,
   and can be used from Python.
</p><p>
   <b><i>flush_writable</i></b> writes out all unwritten changes to a writable
   backing file if one exists; otherwise, does nothing.
</p><p>
   Other methods are not currently for public use.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(image) {
#if !defined(PYWRAP)
        void (*read)(conf_object_t *img, void *NOTNULL to_buf, uint64 start,
                     size_t length);
        void (*write)(conf_object_t *img, const void *NOTNULL from_buf,
                      uint64 start, size_t length);
        int (*for_all_spages)(conf_object_t *img,
                              int (*NOTNULL f)(image_spage_t *NOTNULL p,
                                               uint64 ofs, void *arg),
                              void *arg);
#endif /* not PYWRAP */
        void (*set_persistent)(conf_object_t *obj);
        void (*save_to_file)(conf_object_t *NOTNULL obj,
                             const char *NOTNULL file,
                             uint64 start, uint64 length, save_flags_t flags);
        void (*save_diff)(conf_object_t *NOTNULL obj,
                          const char *NOTNULL file, save_flags_t flags);
        void (*clear_range)(conf_object_t *NOTNULL obj,
                            uint64 start, uint64 length);
        void (*fill)(conf_object_t *NOTNULL obj,
                     uint64 start, uint64 length, uint8 value);
        uint64 (*size)(conf_object_t *NOTNULL obj);
        void (*set)(conf_object_t *NOTNULL obj, uint64 ofs, bytes_t b);
        bytes_t (*get)(conf_object_t *NOTNULL obj, uint64 ofs, size_t size);
        void (*flush_writable)(conf_object_t *NOTNULL obj);
};

#define IMAGE_INTERFACE "image"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem"><table>

     <tbody><tr><td class="jdocu_noborder"><b><i>read</i></b></td><td class="jdocu_noborder">Cell Context</td></tr>

     <tr><td class="jdocu_noborder"><b><i>write</i></b></td><td class="jdocu_noborder">Cell Context</td></tr>

     <tr><td class="jdocu_noborder"><b><i>for_all_spages</i></b></td><td class="jdocu_noborder">Cell Context</td></tr>

     <tr><td class="jdocu_noborder"><b><i>set_persistent</i></b></td><td class="jdocu_noborder">Cell Context</td></tr>

     <tr><td class="jdocu_noborder"><b><i>save_to_file</i></b></td><td class="jdocu_noborder">Cell Context</td></tr>

     <tr><td class="jdocu_noborder"><b><i>save_diff</i></b></td><td class="jdocu_noborder">Cell Context</td></tr>

     <tr><td class="jdocu_noborder"><b><i>clear_range</i></b></td><td class="jdocu_noborder">Cell Context</td></tr>

     <tr><td class="jdocu_noborder"><b><i>fill</i></b></td><td class="jdocu_noborder">Cell Context</td></tr>

     <tr><td class="jdocu_noborder"><b><i>size</i></b></td><td class="jdocu_noborder">Cell Context</td></tr>

     <tr><td class="jdocu_noborder"><b><i>set</i></b></td><td class="jdocu_noborder">Cell Context</td></tr>

     <tr><td class="jdocu_noborder"><b><i>get</i></b></td><td class="jdocu_noborder">Cell Context</td></tr>

     <tr><td class="jdocu_noborder"><b><i>flush_writable</i></b></td><td class="jdocu_noborder">Cell Context</td></tr>

    </tbody></table>
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_image_snoop.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_image_snoop.html:__rm_interface_image_snoop">image_snoop</a></h1>
<p>

<a id="__rm_interface_image_snoop.html:image_snoop"></a><a id="__rm_interface_image_snoop.html:image_snoop_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The image snoop interface is used to get
   information about when image pages are written to. Note that with the
   addition of inhibit bits in the <code>direct_memory</code> interface, the
   image snoop interface is rarely needed for model functionality.
<p>
   The <b><i>page_modified</i></b> function is always called the first time a page
   is written to. It may also be called additional times even if a page has
   already been written to. A user of the image snoop interface can at any time
   reset this mechanism so that all pages are considered not written to and
   therefore the <b><i>page_modified</i></b> function will be called again on
   future writes. The reset can be accomplished either through the memory page
   update interface or through the pool protect interface.
</p><p>
   The <code>image snoop</code> interface can, for example, be used by frame
   buffer devices to efficiently keep track of areas of the frame buffer to
   redraw, or for a CPU module that builds cached representations of code pages
   to invalidate such caches when memory is modified.
</p><p>
   Listeners using this interface are installed with the
   <i>image_snoop_devices</i> attribute in the
   <b>image</b> class.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(image_snoop) {
        void (*page_modified)(conf_object_t *obj, conf_object_t *img,
                              uint64 offset, uint8 *page_data,
                              image_spage_t *spage);
};
#define IMAGE_SNOOP_INTERFACE "image_snoop"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_instruction_fetch.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_instruction_fetch.html:__rm_interface_instruction_fetch">instruction_fetch</a></h1>
<p>

<a id="__rm_interface_instruction_fetch.html:instruction_fetch"></a><a id="__rm_interface_instruction_fetch.html:instruction_fetch_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>instruction_fetch</code> interface is implemented by
   processors. The interface controls how instruction fetches should
   be modeled.
<p>
   The <b><i>get_mode</i></b> and <b><i>set_mode</i></b> functions get and
   set the instruction fetch mode. There are three available
   modes. All modes are not supported by all processor types. The
   <em>instruction_fetch_none</em> mode is the least accurate but the
   fastest mode. The other modes are more accurate but slower.
</p><p>
   The <b><i>get_line_size</i></b> and <b><i>set_line_size</i></b> functions
   get and set the fetch size on each instruction fetch. This is often
   related to cache line size or similar. The line size must be power
   of 2.
</p><p>
   </p><pre class="jdocu_small">typedef enum {
        /* No instruction fetch sent to memory hierarchy */
        Instruction_Fetch_None = 0,

        /* Memory hierarchy gets fetch for each cache line access */
        Instruction_Fetch_Cache_Access_Trace = 1,

        /* Memory hierarchy gets fetch for each instruction fetch. Only
           x86/x86-64 */
        Instruction_Fetch_Trace = 2
} instruction_fetch_mode_t;

SIM_INTERFACE(instruction_fetch) {
        instruction_fetch_mode_t (*get_mode)(conf_object_t *obj);
        void (*set_mode)(conf_object_t *obj, instruction_fetch_mode_t mode);
        int (*get_line_size)(conf_object_t *obj);
        void (*set_line_size)(conf_object_t *obj, int size);
};
#define INSTRUCTION_FETCH_INTERFACE "instruction_fetch"
</pre><p>
</p><p>

   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem"><table>

   <tbody><tr><td class="jdocu_noborder"><b><i>get_mode</i></b></td><td class="jdocu_noborder">Cell Context</td></tr>

   <tr><td class="jdocu_noborder"><b><i>set_mode</i></b></td><td class="jdocu_noborder">Global Context</td></tr>

   <tr><td class="jdocu_noborder"><b><i>get_line_size</i></b></td><td class="jdocu_noborder">Cell Context</td></tr>

   <tr><td class="jdocu_noborder"><b><i>set_line_size</i></b></td><td class="jdocu_noborder">Global Context</td></tr>

   </tbody></table>
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_instrumentation_order.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_instrumentation_order.html:__rm_interface_instrumentation_order">instrumentation_order</a></h1>
<p>

<a id="__rm_interface_instrumentation_order.html:instrumentation_order"></a><a id="__rm_interface_instrumentation_order.html:instrumentation_order_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This interface is used to control the dispatch order of connected
   instrumentation. It is implemented by instrumentation providers that have
   the ability to change the order in which instrumentation events occur. This
   works by associating every instrumentation event with a connection
   object. It is up to the provider to supply a way to do this. See the
   <code>cpu_instrumentation_subscribe</code> interface for an example.  Most
   users of any instrumentation will only be observing the state of the
   provider, in which case the order is unimportant. However, if users
   of instrumentation may change the behavior of the provider, this interface
   may be useful.
<p>
   The default order for callbacks that should be honored by all providers,
   where possible, regardless if they implement the
   <code>instrumentation_order</code> interface or not is:
</p><p>
   </p><ol>
   <li>all anonymous connections, i.e. NULL connections, in registration order</li>
   <li>connection order, which if not re-ordered will be the connection
   registration order</li>
   <li>callback registration order</li>
   </ol>
<p>
   The <i>get_connections</i> method should return an
   <code>attr_value_t</code> list with connection objects that represent the
   current order. The first element in the list is the first object in the
   dispatch order, etc.
</p><p>
   The <i>move_before</i> method moves the connection given by the
   <i>connection</i> argument before the connection given by the
   <i>anchor</i> argument. If the <i>anchor</i> is NULL the connection
   will be moved last. The given connection objects must be present in the
   current dispatch order for this to succeed.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(instrumentation_order) {
        // Returns an object list in the connection order
        attr_value_t (*get_connections)(conf_object_t *obj);
        
        bool (*move_before)(conf_object_t *self, conf_object_t *connection,
                            conf_object_t *before); 
};
#define INSTRUMENTATION_ORDER_INTERFACE "instrumentation_order"
</pre><p>
</p><p>

   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Global Context for all methods, but must be called from a callback
   receiving a handle of type <code>instruction_handle_t</code>.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_int_register.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_int_register.html:__rm_interface_int_register">int_register</a></h1>
<p>

<a id="__rm_interface_int_register.html:int_register"></a><a id="__rm_interface_int_register.html:int_register_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>int_register</code>
   interface is used for access to registers in a processor.  It
   can be used to access any kind of integer register, not only the
   "normal" registers.  This includes all kinds of control registers,
   hidden registers and anything else that might be useful to access as
   a register.  The only limitation is that the register value should
   be representable as a 64-bit unsigned integer.
<p>
   This interface can be implemented by other classes than processors,
   but it is likely to be found mostly in processors.
 </p><p>
   Registers are identified by a number, and there are two functions
   to translate from register names to register numbers and back.  The
   translation need not be one-to-one, which means that one register
   can have several names.  A register name can, however, only
   translate to a single register number.
</p><p>
   Often, registers are grouped in <i>register banks</i>, where
   registers in the bank are numbered from 0 up. Registers in a bank
   should have consecutive numbers (unless their numbering is very sparse).
   This allows a user to deduce register numbers by calling
   <b><i>get_number</i></b> for the first register only.
   The first register numbers should be used for the general-purpose integer 
   registers, if possible (so that integer register <b>r</b>N has number N).
</p><p>
   Using this interface to read or write registers does not cause any
   side effects, such as triggering interrupts or signalling haps.
</p><p>
   <b>get_number</b> translates a register name to its number. Returns -1 if
   the register does not exist.
</p><p>
   <b>get_name</b> translates a register number to its canonical name.
</p><p>
   <b>read</b> reads a register value.
</p><p>
   <b>write</b> writes a new register value.
</p><p>
   <b>all_registers</b> returns a list of all register numbers that can
   be used for this object.
</p><p>
   <b>register_info</b> returns information about a single register.
   The information return depends on the <i>info</i> parameter.
</p><p>
   </p><dl><dt id="__rm_interface_int_register.html:dt:sim_reginfo_catchable"><a href="#__rm_interface_int_register.html:dt:sim_reginfo_catchable"><b>Sim_RegInfo_Catchable</b></a></dt><dd>Return 1 if
   <code>Core_Control_Register_Write</code> and
   <code>Core_Control_Register_Read</code> are triggered when this
   register is written or read.</dd>Return 0 otherwise.

   </dl><p><span class="jdocu_small">
   <a id="__rm_interface_int_register.html:ireg_info_t"></a></span></p><pre class="jdocu_small">typedef enum {
        Sim_RegInfo_Catchable
} ireg_info_t;</pre><p>

</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(int_register) {
        int (*get_number)(conf_object_t *NOTNULL obj,
                          const char *NOTNULL name);
        const char *(*get_name)(conf_object_t *NOTNULL obj, int reg);
        uint64 (*read)(conf_object_t *NOTNULL obj, int reg);
        void (*write)(conf_object_t *NOTNULL obj, int reg, uint64 val);
        attr_value_t (*all_registers)(conf_object_t *NOTNULL obj);
        int (*register_info)(conf_object_t *NOTNULL obj, int reg,
                             ireg_info_t info);
};

#define INT_REGISTER_INTERFACE "int_register"
</pre><p>
</p><p>
   
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods, except for <b><i>write</i></b> where the
   register is a program counter; Global Context in that case.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_keyboard.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_keyboard.html:__rm_interface_keyboard">keyboard</a></h1>
<p>

<a id="__rm_interface_keyboard.html:keyboard"></a><a id="__rm_interface_keyboard.html:keyboard_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Interface implemented by keyboard controllers. Used by consoles to send
   keyboard events to the controller.
<p>
   The function <b><i>keyboard_event()</i></b> takes the keyboard controller as
   its first argument <i>obj</i>. The <i>key_up</i> argument specifies
   whether the event is a key release (1) or a key press (0). The
   <i>key</i> argument is the Simics internal keycode, as defined in
   the <code>sim_key_t</code> enum.
</p><p>
   If the return value is 1 the keyboard controller accepted the event. If
   return value is 0 the keyboard controller did not accept the event, and the
   console should buffer the event until it gets a <b><i>keyboard_ready()</i></b>
   call from the keyboard controller.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(keyboard) {
        int (*keyboard_event)(conf_object_t *obj, int key_up, uint8 key);
};

#define KEYBOARD_INTERFACE "keyboard"
</pre><p>
</p><p>

   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_keyboard_console.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_keyboard_console.html:__rm_interface_keyboard_console">keyboard_console</a></h1>
<p>

<a id="__rm_interface_keyboard_console.html:keyboard_console"></a><a id="__rm_interface_keyboard_console.html:keyboard_console_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Interface implemented by consoles, to receive notifications from keyboard
   controllers.
<p>
   The function <b><i>keyboard_ready()</i></b>, which takes the console as its
   first argument <i>obj</i>, must be called by the keyboard controller
   when it is ready to receive keyboard events again after having rejected a
   keyboard event. Note that this function may be called even though no
   keyboard event has been rejected, and that the console must not assume that
   keyboard controller will accept an event just because the
   <b><i>keyboard_ready()</i></b> function has been called.
</p><p>
   <b><i>keyboard_ready</i></b> must not be called while the keyboard controller
   is handling a <b><i>keyboard_event()</i></b> call.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(keyboard_console) {
        void (*keyboard_ready)(conf_object_t *obj);
};

#define KEYBOARD_CONSOLE_INTERFACE "keyboard_console"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_linear_image.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_linear_image.html:__rm_interface_linear_image">linear_image</a></h1>
<p>

<a id="__rm_interface_linear_image.html:linear_image"></a><a id="__rm_interface_linear_image.html:linear_image_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><div class="note">
<b>Note:</b>
This interface is an experimental feature. It is excluded from
       the standard support program, and is subject to change or removal
       without notice.
     </div>The <code>linear_image</code> interface permits direct access to the
     data in <b>image</b> objects by requesting a linear allocation
     for the contents. Doing so is not recommended for very large images,
     since there must be space for all data in memory as a contiguous
     block.
<p>
     <b><i>get_base</i></b> returns the linear allocation block if one has
     already been set. Otherwise, a block of the correct size is allocated,
     set and returned. In the latter case, the block is owned by the image
     object and should not be freed by the user. If <i>retsize</i>
     is non-null, it is used to return the size of the image.
</p><p>
     <b><i>set_base</i></b> specifies an existing memory block to be used for
     the image contents. The block must be at least the size of the image,
     and should be aligned to a multiple of 4096 bytes. The caller is
     responsible for the allocation of the block, which must remain
     allocated for the remaining lifetime of the image object.
</p><p>
     <b><i>prepare_range</i></b> must be called, with the matching access type,
     before any direct access to data in a linear block by user code.
     It is then permitted to access bytes in the range
     
       [<i>offs</i>, <i>offs</i> + <i>size</i>)
     . For <i>type</i> = <code>Sim_RW_Write</code>, the 
     permission to modify data in that range only extends until any other
     objects using the image have the opportunity to do so (typically, when
     the modelling function returns control to the simulator).
</p><p>
     <b><i>set_base</i></b> and <b><i>get_base</i></b> cannot be called after
     image data has been accessed (read or written) for the first time.
</p><p>
     </p><pre class="jdocu_small">SIM_INTERFACE(linear_image) {
#if !defined(PYWRAP)
        uint8 *(*get_base)(conf_object_t *obj, size_t *retsize);
        void (*set_base)(conf_object_t *obj, uint8 *NOTNULL base);
#endif /* not PYWRAP */
        void (*prepare_range)(conf_object_t *NOTNULL obj,
                              read_or_write_t type, size_t offs, size_t size);
};
#define LINEAR_IMAGE_INTERFACE "linear_image"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem"><table>

       <tbody><tr>
         <td class="jdocu_noborder"><b><i>set_base</i></b></td>
         <td class="jdocu_noborder">Global Context</td>
       </tr>

       <tr>
         <td class="jdocu_noborder"><b><i>get_base</i></b></td>
         <td class="jdocu_noborder">Global Context</td>
       </tr>

       <tr>
         <td class="jdocu_noborder"><b><i>prepare_range</i></b></td>
         <td class="jdocu_noborder">Cell Context</td>
       </tr>

     </tbody></table>
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_magic_pipe_reader.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_magic_pipe_reader.html:__rm_interface_magic_pipe_reader">magic_pipe_reader</a></h1>
<p>

<a id="__rm_interface_magic_pipe_reader.html:magic_pipe_reader"></a><a id="__rm_interface_magic_pipe_reader.html:magic_pipe_reader_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">An interface for reading received data from a magic pipe application running
  in the target system. This interface is called by a simics extension running
  in the host system communicating with a target application via a magic
  pipe. The communication is identified by a magic number. These numbers are
  acquired or reserved in the magic_pipe_setup_interface.
<p>
  The magic pipe library on the target system allocates a page-locked pipe
  buffer for the target application, which uses the buffer to communicate data
  to and from the host system. That buffer is fragmented when read by the host
  system and therefore copied into a new unfragmented buffer, which is used for
  all read accesses in this interface. All C-code readewr callback functions
  are allowed direct access to this memory area, while Python reader callback
  functions require another copy for ownership reasons.
</p><p>
  This interface does not modify the pipe buffer data in any way, and the
  callers are not allowed to do that neither. It is therefore safe for several
  readers to subscribe to the same data.
</p><p>
    </p><div class="note">
<b>Note:</b>
This interface is an experimental feature. It is excluded from
  the standard support program, and is subject to change or removal
  without notice.</div><pre class="jdocu_small">SIM_INTERFACE(magic_pipe_reader) {
        /* Query whether the byte-order of the simulated target system differs
           from that of the simulator host system. */
        bool (*is_byte_swap_needed)(conf_object_t *obj, uintptr_t buf);

        /* Query the amount of used pipe buffer space. This value is always
           less than the allocated buffer size because it does not count the
           internal pipe buffer header. */
        size_t (*read_buffer_size)(conf_object_t *obj, uintptr_t buf);

#ifndef PYWRAP
        /* Get direct read-only access to the incoming pipe buffer data, at the
           desired offset. The function returns a pointer to, and the remaining
           used size from, the specified offset.

           This function gives a direct pointer into internal memory and
           therefore cannot be used by Python code. */
        bytes_t (*read_data_direct)(conf_object_t *obj, uintptr_t buf,
                                    size_t offs);
#endif

        /* Get a copy the pipe buffer data, at the specified offset with the
           specified length. If the length argument is zero, then the length of
           the remaining space from the offset is assumed.

           This function will allocate a new data buffer to hold the desired
           amount of data and return it to the caller, who is responsible to
           deallocating it once it has served its purpose. */
        bytes_t (*read_data_copy)(conf_object_t *obj, uintptr_t buf,
                                  size_t offs, size_t len);
};

#define MAGIC_PIPE_READER_INTERFACE "magic_pipe_reader"
</pre><p>
</p><p>
  
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
  
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_magic_pipe_setup.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_magic_pipe_setup.html:__rm_interface_magic_pipe_setup">magic_pipe_setup</a></h1>
<p>

<a id="__rm_interface_magic_pipe_setup.html:magic_pipe_setup"></a><a id="__rm_interface_magic_pipe_setup.html:magic_pipe_setup_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The magic pipe setup interface is
  used to establish connections between an application running in the simulated
  target system and a Simics extension executing on the simulator host.
<p>
  Magic numbers are used to identify and isolate connections, called
  pipes. Typically a well-known value is used to perform a handshake and then
  assign a new and unique value, which is used in all successive correspondence
  between the end-points.
</p><p>
  The Simics extension is responsible for assigning these new and unique magic
  numbers, and to subscribe to them. This interface provides the necessary
  facilities to either get a new random number or reserve a range for the
  service to distribute on its own.
</p><p>
  An example of a common communication flow can be divided into two phases,
  first the initial handshake phase where some information about each other is
  exchanged, followed by the duty phase where the target system application is
  communicating back and forth with the host system Simics extension to fulfill
  their purpose.
</p><p>
  The handshake is initiated from the target application, which sends a
  handshake request to the host system extension containing some information
  about itself. The host system extension receives the request and replies with
  a new magic number and some information about itself. The new magic number is
  to be used in all further communication between the parties, to isolate the
  communications pipe from other users of the magic pipe.
</p><p>
  In the duty phase the common communication flow may look like this. The
  target system application starts by allocating a pipe buffer from the magic
  pipe library. Then writes its data to the buffer and sends it to the host
  system extension. The extension handles the data and reuses the same buffer
  to write something back to the application. This means that the buffer size
  is fixed and limits the amount of data that can be returned. Because of this
  it is common for the application to allocate more space than needed for its
  sent data. Once the application returns from its send call, the same buffer
  it allocated earlier is filled with data coming from the extension. This data
  is handled by the application and then the buffer is freed. This duty cycle
  is then repeated as many times as needed.
</p><p>
  Each magic number may have more than one subscribers, therefore reading and
  writing is divided into two phases, where all readers are allowed access
  first. Then comes the writer phase and the subscribers are called in the
  order they registered. This also means that later writer subscribers are
  limited to writing only the remaining amount of data to the buffer.
</p><p>
  There is no on or off setting for a pipe to enable or disable the
  communication. The only option is to unregister from the magic number to
  suspend the communication and then to register again to resume.
</p><p>
  The registered subscribers should unregister when they are no longer
  interested in receiving any data. This will also allow the magic pipe to stop
  listening to haps when there is no one to receive them. The magic pipe will
  automatically resume listening once there are subscribers again.
</p><p>
    </p><div class="note">
<b>Note:</b>
This interface is an experimental feature. It is excluded from the
  standard support program, and is subject to change or removal without
  notice.</div><pre class="jdocu_small">SIM_INTERFACE(magic_pipe_setup) {
        /* Register a subscriber for a new magic number, which is returned by
           this function. The number is guaranteed to be unused and unreserved.

           The reader and writer call-backs will be called in turn for each
           message with the new magic number. Unless they are NULL or None. */
        uint64 (*register_new_pipe)(
                conf_object_t *obj, conf_object_t *cpu, conf_object_t *user,
                pipe_func_t reader, pipe_func_t writer);

        /* Register a subscriber for a range of reserved magic numbers.

           The min_magic argument must be greater than zero and max_magic equal
           to or greater than that. */
        void (*register_pipe_range)(conf_object_t *obj, conf_object_t *user,
                                    uint64 min_magic, uint64 max_magic,
                                    pipe_func_t rd, pipe_func_t wr);

        /* Register a subscriber for a reserved magic number.

           The reader and writer call-backs will be called in turn for each
           message with the reserved magic number, unless NULL or None.

           The magic number zero is reserved for a catch-all handler,
           where any message that is unsubscribed will trigger the
           call-backs. */
        void (*register_reserved_pipe)(
                conf_object_t *obj, conf_object_t *user, uint64 magic,
                pipe_func_t reader, pipe_func_t writer);

        /* Unregister the subscription of a magic number for this user. This
           will unregister both the reader and writer callback functions. If
           the user registered a whole range, then any number in the range will
           do, to unsubscribe to the whole range. */
        void (*unregister_pipe)(conf_object_t *obj, conf_object_t *user,
                                uint64 magic);

        /* Get a list of the subscribers for a magic number. The list can be
           filtered to include only readers or writers or both. If neither is
           specified only reservations are listed. */
        attr_value_t (*get_pipe_subscribers)(conf_object_t *obj, uint64 magic,
                                             bool readers, bool writers);

        /* Get a list of the used or reserved magic numbers. Each entry is a
           list of 5 items: minimum magic number, maximum magic number,
           registered subscriber object, reader callback present and writer
           callback present.

           EXAMPLE:
           [[0, 0, "fault_handler", TRUE, FALSE],
            [1, 1, "handshake", TRUE, TRUE],
            [0x10, 0x20, "my_magics", FALSE, FALSE],
            [0x4711, 0x4711, "cool_user", TRUE, TRUE]]

            The exact same information is available in the map attribute of the
            magic-pipe object. Most of the same information is also printed by
            the status command. */
        attr_value_t (*get_magic_map)(conf_object_t *obj);
};

#define MAGIC_PIPE_SETUP_INTERFACE "magic_pipe_setup"
</pre><p>
</p><p>
  
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
  
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_magic_pipe_writer.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_magic_pipe_writer.html:__rm_interface_magic_pipe_writer">magic_pipe_writer</a></h1>
<p>

<a id="__rm_interface_magic_pipe_writer.html:magic_pipe_writer"></a><a id="__rm_interface_magic_pipe_writer.html:magic_pipe_writer_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">An interface for writing transmit data to a magic pipe application running in
  the target system. This interface is called by a simics extension running in
  the host system which communicates with a target application through a magic
  pipe. The communication is identified by a magic number. These numbers are
  acquired or reserved in the magic_pipe_setup_interface.
<p>
  The write functions operate on an unfragmented host system buffer. All C-code
  writer callback functions are allowed direct access to the unfragmented host
  buffer, while Python callback functions require the data to be copied from a
  Python owned data buffer.
</p><p>
  The target system pipe buffer is not modified until all writer callbacks for
  its magic number have returned. Then the pipe buffer header is updated and
  the whole unfragmented host buffer is copied into the target pipe buffer
  fragments.
</p><p>
    </p><div class="note">
<b>Note:</b>
This interface is an experimental feature. It is excluded from
  the standard support program, and is subject to change or removal
  without notice.</div><pre class="jdocu_small">SIM_INTERFACE(magic_pipe_writer) {
        /* Query whether the simulated target system has a different byte-order
           than the simulator host system. */
        bool (*is_byte_swap_needed)(conf_object_t *obj, uintptr_t buf);

        /* Query how much unused space is available in the pipe buffer.  This
           value is decreased by each call to either write_data_add or
           write_data_copy. */
        size_t (*write_buffer_left)(conf_object_t *obj, uintptr_t buf);

        /* Query the allocated pipe buffer size. This value includes both the
           pipe buffer header and payload data. */
        size_t (*write_buffer_size)(conf_object_t *obj, uintptr_t buf);

#ifndef PYWRAP
        /* Get direct write access to the outgoing pipe buffer data. This call
           returns a pointer to the write position in the pipe buffer and its
           remaining unused size.

           If the caller writes to the pipe buffer, then the write_data_add
           function must be called also to update the amount of used data in
           the pipe buffer and advance the write position.

           The write position is also advanced by calls to the write_data_copy
           function. In case neither write_data_add nor write_data_copy
           function is called, this function will return the exact same pointer
           address and size all the time.

           This function gives a direct pointer into internal memory and
           therefore cannot be used by Python code. */
        buffer_t (*write_data_direct)(conf_object_t *obj, uintptr_t buf);

        /* Increase the amount of used data in the pipe buffer. When a caller
           to the write_data_direct function has written to the pipe buffer,
           the caller must also call this function to declare the amount of
           data written to the fragment. This will cause the write position to
           be moved to the next available space in the pipe buffer.

           If the length argument exceeds the available unused space. It is
           assumed that all the remaining space is used. */
        void (*write_data_add)(conf_object_t *obj, uintptr_t buf, size_t len);
#endif

        /* Append the data from the caller buffer to the outgoing pipe
           buffer. This function will copy as much of the data contents from
           the supplied buffer argument to the end of the pipe buffer as fits.

           The function will return the amount of data from the caller buffer
           that does not fit in the pipe buffer. If the return value is zero,
           then all data was copied. Otherwise the copied data was truncated
           and the remaining uncopied size is returned.

           Be sure to use the write_buffer_left function to determine the
           amount of remaining space, unless truncated data is desired and
           properly handled.

           This call will automatically advance the write position to the next
           unused space. */
        size_t (*write_data_copy)(conf_object_t *obj, uintptr_t buf,
                                  bytes_t data);

        /* Change the magic number in the pipe buffer. This is used to assign a
           new magic number to the target magic pipe application. Typically
           this is done only on the first exchange with a new target
           application, to give it a unique identifier, which is then
           subscribed to by the simics extension, and used throughout all
           further communication.

           The magic number to pick is typically returned by the
           register_new_pipe function in the setup interface. However, the
           simics extension may choose to reserve a range of magic numbers and
           provide its own scheme for assigning these to new target
           applications. */
        void (*write_buffer_magic)(conf_object_t *obj, uintptr_t buf,
                                   uint64 magic);
};

#define MAGIC_PIPE_WRITER_INTERFACE "magic_pipe_writer"
</pre><p>
</p><p>
  
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
  
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_memory_profiler.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_memory_profiler.html:__rm_interface_memory_profiler">memory_profiler</a></h1>
<p>

<a id="__rm_interface_memory_profiler.html:memory_profiler"></a><a id="__rm_interface_memory_profiler.html:memory_profiler_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>memory_profiler</code> interface is implemented by
   processors that support memory profiling. The <b><i>get</i></b>
   function returns the active profiler for the type of access
   specified in the <i>access</i> argument. NULL or None is
   returned if there is no active profiler for that type of access.
<p>
   The <b><i>set</i></b> function installs <i>prof</i> as a profiler
   for the accesses of type <i>access</i>. The <b><i>set</i></b>
   functions returns true if the setting was successful, and false
   otherwise.
</p><p>
   The <b><i>get_granularity_log2</i></b> gets the 2 logarithm of the
   profiling granularity in bytes, for example it returns 10 if the
   granularity for profiling is 1 KiB.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(memory_profiler) {
        conf_object_t *(*get)(conf_object_t *obj, read_or_write_t access);
        bool (*set)(conf_object_t *obj, read_or_write_t access,
                    conf_object_t *prof);
        int (*get_granularity_log2)(conf_object_t *obj);
};

#define MEMORY_PROFILER_INTERFACE "memory_profiler"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_mmc.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_mmc.html:__rm_interface_mmc">mmc</a></h1>
<p>

<a id="__rm_interface_mmc.html:mmc"></a><a id="__rm_interface_mmc.html:mmc_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><pre class="jdocu_small">#define MMC_INTERFACE "mmc"
SIM_INTERFACE(mmc) {
#if !defined(PYWRAP)
        int (*send_command)(conf_object_t *obj, uint8 cmd, uint32 args,
                            buffer_t response);
        int (*read_data)(conf_object_t *obj, buffer_t data);
#endif
        int (*write_data)(conf_object_t *obj, bytes_t data);
};
</pre><p>
</p><p>

   Interface that should be implemented by all MMC/SD/SDHC/SDIO card models.
</p><p>
   send_command: sends a 5-byte command to the card (1-byte command index and
                 4 bytes command arguments).
                 Caller provides the response length. Card fills in actual
                 response data. The response data is 0, 6 or 17 bytes,
                 in big-endian (see the MMC/SD specification for details).
                 Return value: number of response bytes, -1 if the command
                 wasn't accepted (e.g. command is not supported or illegal in
                 current state, or command is not supported or illegal for
                 current card type).
</p><p>
   read_data: reads data. Caller provides the length.
              Return value: the card fills in the provided buffer, and returns
              the number of bytes actually read, which might be less than the
              buffer length in case of error.
</p><p>
   write_data: writes data. Caller provides in both length and data.
               Return value: number of bytes actually written, which might be
               less than the provided data length in case of error.
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_mouse.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_mouse.html:__rm_interface_mouse">mouse</a></h1>
<p>

<a id="__rm_interface_mouse.html:mouse"></a><a id="__rm_interface_mouse.html:mouse_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Interface used to send mouse events to a mouse device. The function
   <b><i>mouse_event()</i></b> takes the destination device as first argument
   in <i>obj</i>. The <i>xmicro</i> and <i>ymicro</i> arguments
   specified the relative mouse movement in micro-meters. If the mouse
   supports a wheel, the wheel movement is supplied in <i>z</i>, as
   number of steps up or down. The last argument <i>buttons</i> is a
   bit-mask with the state of the mouse buttons. The mapping of mouse
   buttons to bits is defined in the header file
   <code>&lt;simics/model-iface/sim-keys.h&gt;</code>.
<p>
   </p><pre class="jdocu_small">SIM_INTERFACE(mouse) {
        void (*mouse_event)(conf_object_t *obj,
                            int xmicro,
                            int ymicro,
                            int z,
                            int buttons);
};

#define MOUSE_INTERFACE "mouse"
</pre><p>
</p><p>

   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_opcode_info.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_opcode_info.html:__rm_interface_opcode_info">opcode_info</a></h1>
<p>

<a id="__rm_interface_opcode_info.html:opcode_info"></a><a id="__rm_interface_opcode_info.html:opcode_info_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>opcode_info</code> interface is implemented by
   processors that need to communicate information about the encoding
   of instructions to the GUI.
<p>
   The <b><i>get_opcode_length</i></b> function returns information about
   instruction encoding in the current operating mode of the
   processor. The <b><i>min_alignment</i></b> field indicates the
   smallest allowed alignment of instructions, typically 4 for regular
   RISC architectures. The <b><i>max_length</i></b> field specifies the
   maximum instruction length in bytes. The <b><i>avg_length</i></b> is
   an approximation of the average instruction size.
</p><p>
   </p><pre class="jdocu_small">typedef struct {
        int min_alignment;
        int max_length;
        int avg_length;
} opcode_length_info_t;

SIM_INTERFACE(opcode_info) {
        opcode_length_info_t (*get_opcode_length_info)(conf_object_t *obj);
};

#define OPCODE_INFO_INTERFACE "opcode_info"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_pre_decoder.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_pre_decoder.html:__rm_interface_pre_decoder">pre_decoder</a></h1>
<p>

<a id="__rm_interface_pre_decoder.html:pre_decoder"></a><a id="__rm_interface_pre_decoder.html:pre_decoder_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This interface extends the <code>cpu_instrumentation_subscribe</code>
   interface and allows a user to observe and change the bytes in the
   instruction stream before the target processor tries to decode them.  This
   can be used to model data encryption of memory or instruction caches with
   different content than the memory.
<p>
   It is currently offered as a separate interface for backwards compatibility,
   and only available for C/C++ development, i.e., no Python mapping exists.
   The interface is only implemented for x86 target processors.
</p><p>
   The <b><i>register_pre_decoder_cb</i></b> method registers a callback,
   <i>cb</i> of type <code>pre_decoder_cb_t</code>, which is called before
   an instruction is decoded an put into Simics internal decode cache. This
   means that this callback is called only the first time an instruction is
   executed (unless it is evicted from the decode cache).
</p><p>
   The <i>cpu</i> is the processor that decodes the instructions, and
   <i>connection</i> is the instrumentation connect object that receives
   the callback. The connection can be NULL, if no connection is available. The
   <i>data</i> is the callback data for the callback.
</p><p>
   See the documentation for the <code>pre_decoder_cb_t</code> for more
   information.
</p><p>
   To remove the callback use either <b><i>remove_callback</i></b> or
   <b><i>remove_connection_callbacks</i></b> methods in the
   <code>cpu_instrumentation_subscribe interface</code>. To identify the
   callback to remove, pass the return value, a <code>cpu_cb_handle_t</code>
   handle, from the register method or the connection object used. The
   callback cannot be disabled.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(pre_decoder) {
        cpu_cb_handle_t *(*register_pre_decoder_cb)(
                conf_object_t *cpu,
                conf_object_t *connection,
                pre_decoder_cb_t cb,
                lang_void *data);
};
#endif

#define PRE_DECODER_INTERFACE "pre_decoder"
</pre><p>
</p><p>

   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Global context.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_processor_cli.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_processor_cli.html:__rm_interface_processor_cli">processor_cli</a></h1>
<p>

<a id="__rm_interface_processor_cli.html:processor_cli"></a><a id="__rm_interface_processor_cli.html:processor_cli_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Some commands and features in the CLI use the
   <code>processor_cli</code> interface. Those commands will have
   limited functionality if the interface is not fully implemented.
<p>
   The first argument to each function is the object to act on. This object
   should implement both the <code>processor_info</code> interface and the
   <code>processor_cli</code> interface.
</p><p>
   The <b><i>get_disassembly</i></b> function is used for the
   <b>disassemble</b> command as well as to disassemble the next
   instruction to be executed, when control is returned to the CLI prompt. For
   most architectures, <b><i>get_disassembly</i></b> can be set to NULL, in which
   case the command will use other interfaces to provide a generic
   disassembly. The <b><i>get_disassembly</i></b> function should return a tuple
   with the length of the instruction in bytes and the disassembly string. The
   <i>addr_prefix</i> parameter selects the address type of the address
   parameter, whether it is a physical address ("p"), a linear address ("l") or
   a virtual address ("v"), just as returned from
   <b><i>get_address_prefix</i></b>. The <i>address</i> parameter is the
   program counter for the instruction to disassemble. If
   <i>print_cpu</i> is non-zero, then the name of the processor should
   be included first in the disassembly line. If <i>mnemonic</i> is not
   NULL, then it should be output instead of the instruction disassemble. The
   mnemonic is used to print exception or interrupt information as returned by
   the <b><i>get_pending_exception_string</i></b> function.
</p><p>
   <b><i>get_pregs</i></b> returns the string to output in the CLI for the
   <b>print-processor-registers</b> command. The <i>all</i>
   parameter is a boolean corresponding to the <i>-all</i> switch to the
   <b>print-processor-registers</b> command.
</p><p>
   The <b><i>diff_regs</i></b> function is used by the <b>stepi</b>
   command when the <i>-r</i> flag is used. The
   <b><i>diff_regs</i></b> function returns a list of register names,
   where each register in that list will be read through the
   <code>int_register</code> interface before and after an
   instruction.
</p><p>
   When returning to the CLI prompt, information about the next
   instruction or step to execute is printed. Normally, that is the
   disassemble of the instruction at the current program counter. The
   <b><i>get_pending_exception_string</i></b> function is called before
   the disassembly to find out if the next step will not be an
   instruction, but rather a taken exception or interrupt. The
   function should inspect the given <i>cpu</i> (an object
   implementing <code>processor_info</code> and
   <code>processor_cli</code>) and return NULL if the next step will
   be the execution of the instruction at the current program
   counter. If the next step will instead be the handling of an
   exception or interrupt, then a string saying that should be
   returned.
</p><p>
   The <b><i>get_address_prefix</i></b> function returns a string with
   the default address prefix for memory related commands. Simics
   defines the generic prefixes "v" for virtual addresses, "l" for
   linear addresses, and "p" for physical addresses. The default if
   <b><i>get_address_prefix</i></b> is NULL is "v" for virtual addresses.
</p><p>
   <b><i>translate_to_physical</i></b> translates an address to a
   physical address. If <b><i>translate_to_physical</i></b> is NULL, then
   the only allowed address prefixes are "v" (virtual) and "p"
   (physical), and the <b><i>logical_to_physical</i></b> function in the
   <code>processor_info</code> interface will be used to translate
   virtual addresses.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(processor_cli) {
	tuple_int_string_t (*get_disassembly)(conf_object_t *obj,
                                              const char *addr_prefix,
                                              generic_address_t address,
                                              bool print_cpu,
                                              const char *mnemonic);
	char *(*get_pregs)(conf_object_t *cpu,
                           bool all);
	attr_value_t (*get_diff_regs)(conf_object_t *obj);
	char *(*get_pending_exception_string)(conf_object_t *obj);
	char *(*get_address_prefix)(conf_object_t *obj);
	physical_block_t (*translate_to_physical)(conf_object_t *obj,
                                                  const char *prefix,
                                                  generic_address_t address);
};

#define PROCESSOR_CLI_INTERFACE "processor_cli"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_processor_endian.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_processor_endian.html:__rm_interface_processor_endian">processor_endian</a></h1>
<p>

<a id="__rm_interface_processor_endian.html:processor_endian"></a><a id="__rm_interface_processor_endian.html:processor_endian_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This interface is used for retrieving endianness and amends to the
   <code>processor_info_v2</code> interface.
<p>
   Many modern processors support mixed endian as well as separate data
   and instruction endianness. This interface reports endianness separately
   for data and instructions dynamically, not just the default as for the
   <code>processor_info_v2</code>. Previously endianness has been static,
   with only one endianness. With newer ARM processors this may cause issues
   for some Big Endian use cases since Little Endian is assumed throughout.
   Primarily due to the fact that they can have separate data and instruction
   endianness. Modifying the existing <code>processor_info_v2</code> easily
   gets complicated due to dependencies, so a new interface
   <code>processor_endian</code> was created.
</p><p>
   The <code>processor_endian_interface_t</code> interface can be
   implemented by processors models and returns the current endianness
   of the system.
</p><p>
   The function <b><i>get_instruction_endian</i></b> returns the active instruction
   endianness of the processor.
</p><p>
   The function <b><i>get_data_endian</i></b> returns endianness of data.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(processor_endian) {
        cpu_endian_t (*get_instruction_endian)(conf_object_t *obj);
        cpu_endian_t (*get_data_endian)(conf_object_t *obj);
};

#define PROCESSOR_ENDIAN_INTERFACE "processor_endian"
</pre><p>
</p><p>

   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem"><table>

   <tbody><tr><td class="jdocu_noborder"><b><i>get_instruction_endian</i></b></td><td class="jdocu_noborder">Cell Context</td></tr>

   <tr><td class="jdocu_noborder"><b><i>get_data_endian</i></b></td><td class="jdocu_noborder">Cell Context</td></tr>

   </tbody></table>
<p>
   
</p></dd>
</dl><p></p></section><section class="page" id="__rm_interface_processor_gui.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_processor_gui.html:__rm_interface_processor_gui">processor_gui</a></h1>
<p>

<a id="__rm_interface_processor_gui.html:processor_gui"></a><a id="__rm_interface_processor_gui.html:processor_gui_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>processor_gui</code> interface is implemented by
   processors that support displays in the Simics native GUI. It is
   only registered to indicate support for the displays, and does not
   contain any actual functionality.
<p>
   </p><pre class="jdocu_small">SIM_INTERFACE(processor_gui) {
        void (*dummy)(conf_object_t *obj);
};

#define PROCESSOR_GUI_INTERFACE "processor_gui"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">There are no methods in this interface.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_processor_info.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_processor_info.html:__rm_interface_processor_info">processor_info</a></h1>
<p>

<a id="__rm_interface_processor_info.html:processor_info"></a><a id="__rm_interface_processor_info.html:processor_info_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">An older version of the processor_info_v2 interface. See processor_info_v2
   for more information.
<p>
   </p><pre class="jdocu_small">SIM_INTERFACE(processor_info) {
        tuple_int_string_t (*disassemble)(conf_object_t *obj,
                                          generic_address_t address,
                                          attr_value_t instruction_data,
                                          int sub_operation);
        void (*set_program_counter)(conf_object_t *obj,
                                    logical_address_t pc);
        logical_address_t (*get_program_counter)(conf_object_t *obj);

        physical_block_t (*logical_to_physical)(conf_object_t *obj,
                                                logical_address_t address,
                                                access_t access_type);
        int (*enable_processor)(conf_object_t *obj);
        int (*disable_processor)(conf_object_t *obj);
        int (*get_enabled)(conf_object_t *obj);

        cpu_endian_t (*get_endian)(conf_object_t *obj);
        conf_object_t *(*get_physical_memory)(conf_object_t *obj);

        int (*get_logical_address_width)(conf_object_t *obj);
        int (*get_physical_address_width)(conf_object_t *obj);

        const char *(*architecture)(conf_object_t *obj);
};

#define PROCESSOR_INFO_INTERFACE "processor_info"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_processor_info_v2.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_processor_info_v2.html:__rm_interface_processor_info_v2">processor_info_v2</a></h1>
<p>

<a id="__rm_interface_processor_info_v2.html:processor_info_v2"></a><a id="__rm_interface_processor_info_v2.html:processor_info_v2_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>processor_info_v2</code> interface is implemented by
   processors models. The interface has processor generic functions
   that are architecture independent.
<p>
   The <b><i>disassemble</i></b> function returns the disassemble string for an
   instruction at <i>address</i> with opcode according to
   <i>instruction_data</i>. The <i>instruction_data</i> is an
   <em>attr_value_t</em> value of <em>data</em> type with the bytes of the
   opcode. The bytes are in the same order as they are stored in memory. For
   VLIW architectures, <i>sub_operation</i> is used to select which
   sub-operation to disassemble. The sub-operations start at zero, and a
   request for the entire unit including all sub-operations is encoded with
   sub-operation -1. A request for a sub-operation that is not present (for
   example when <i>sub-operation</i> is neither 0 nor -1 for non-VLIW
   architectures) results in the integer part of the return tuple being set to
   zero. If successful, the function should return a tuple with the size of the
   instruction in bytes and the disassembly string. The disassembly string
   should be allocated with MM_MALLOC or similar and is to be freed by the
   caller. If more bytes are needed, then the function should indicate that by
   returning a negative number in the tuple where the absolute value of the
   number is the required number of bytes. The string should be NULL if more
   bytes are needed. The implementor of <code>processor_info_v2</code> is
   allowed to request one additional byte at a time until enough bytes are
   passed to determine what the instruction is. Illegal instructions should
   still result in a valid returned tuple, where the integer part will be used
   by the disassemble command to skip that many bytes before disassembling the
   next instruction. The <i>address</i> can be used to display absolute
   destinations of program counter relative branches.
</p><p>
   The <b><i>set_program_counter</i></b> function sets the program
   counter in the processor. The <b><i>get_program_counter</i></b>
   function returns the current program counter.
</p><p>
   The <b><i>logical_to_physical</i></b> function translates a logical
   <i>address</i> to a physical address of the type defined by
   <i>access_type</i>. The function returns a <em>physical_block_t</em>
   struct with <i>valid</i> bit and the <i>address</i>. The
   address is valid when the valid bit is not <code>0</code>. The
   <b><i>logical_to_physical</i></b> function also returns
   <i>block_start</i> and <i>block_end</i>. The start and end
   of a block has the same logical to physical transformation as the translated
   address. The range is inclusive, so block_end should be the
   address of the last byte of the block.
   This information can be used to figure out how often the
   logical_to_physical function needs to be called. An implementation would
   typically return the page start and end here, but it is free to return any
   power of 2 sized block as long as it includes the translated address.
</p><p>
   The current operating mode of the processor is returned with
   <b><i>get_processor_mode</i></b>.
</p><p>
   The processor can be enabled or disabled with the
   <b><i>enable_processor</i></b> or <b><i>disable_processor</i></b>
   functions. The functions should return <code>0</code> if the processor
   changed from enabled to disabled or from disabled to enabled, and
   <code>1</code> if the processor did not change state. The current state
   is returned by the <b><i>get_enabled</i></b> function. Enabled or
   disabled here refers to the state that the user of the model has
   put the processor into. In particular, it is independent of the
   power mode of the processor. A processor that has powered down does
   not count as disabled in this sense, nor does the
   <b><i>enable_processor</i></b> wake up a processor that is in
   a power-saving sleep state.
</p><p>
   The endianness of the processor is returned by the
   <b><i>get_endian</i></b> function.
</p><p>
   The physical memory object is returned by the
   <b><i>get_physical_memory</i></b> function. The object returned by
   <b><i>get_physical_memory</i></b> is used to set breakpoints by the
   global <b>break</b> command, and to read and write physical
   memory through <b>set</b>, <b>get</b>,
   <b>load-binary</b>, <b>load-file</b>, and the default
   implementation of <b>disassemble</b>. The object returned
   implements the <code>memory_space</code> and
   <code>breakpoint</code> interfaces. The
   <code>memory_space</code> interface for the returned object is
   only be used in inquiry mode corresponding to actions by the
   simulator itself rather than by the simulated software. An
   implementation may return NULL from this method, which will lead to
   the command listed above not being supported when such a processor
   is selected.
</p><p>
   The <b><i>get_logical_address_width</i></b> function returns the
   number of logical/virtual address bits and the
   <b><i>get_physical_address_width</i></b> function returns the number
   of physical address bits.
</p><p>
   The processor architecture is returned by calling the
   <b><i>architecture</i></b> function. The architecture should be one of
   <code>arm</code>, <code>mips32</code>,
   <code>mips64</code>, <code>ppc32</code>, <code>ppc64</code>, <code>sparc-v8</code>,
   <code>sparc-v9</code>, <code>x86</code>, <code>x86-64</code>, or something else
   if none of the listed is a good match.
</p><p>
   All functions in the interface are optional. Each function can be
   set to NULL if it is not supported.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(processor_info_v2) {
        tuple_int_string_t (*disassemble)(conf_object_t *obj,
                                          generic_address_t address,
                                          attr_value_t instruction_data,
                                          int sub_operation);
        void (*set_program_counter)(conf_object_t *obj,
                                    logical_address_t pc);
        logical_address_t (*get_program_counter)(conf_object_t *obj);
        physical_block_t (*logical_to_physical)(conf_object_t *obj,
                                                logical_address_t address,
                                                access_t access_type);
        processor_mode_t (*get_processor_mode)(conf_object_t *obj);
        int (*enable_processor)(conf_object_t *obj);
        int (*disable_processor)(conf_object_t *obj);
        int (*get_enabled)(conf_object_t *obj);

        cpu_endian_t (*get_endian)(conf_object_t *obj);
        conf_object_t *(*get_physical_memory)(conf_object_t *obj);

        int (*get_logical_address_width)(conf_object_t *obj);
        int (*get_physical_address_width)(conf_object_t *obj);

        const char *(*architecture)(conf_object_t *obj);
};

#define PROCESSOR_INFO_V2_INTERFACE "processor_info_v2"
</pre><p>
</p><p>

   Note that the original version of this interface
   (<code>processor_info</code>) must also be implemented. The only
   difference between the two interfaces is that the original version lacks the
   <b><i>get_processor_mode</i></b> function.
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem"><table>

   <tbody><tr><td class="jdocu_noborder"><b><i>disassemble</i></b></td><td class="jdocu_noborder">Cell Context</td></tr>

   <tr><td class="jdocu_noborder"><b><i>set_program_counter</i></b></td>
           <td class="jdocu_noborder">Global Context (with some additions; see below)</td></tr>

   <tr><td class="jdocu_noborder"><b><i>get_program_counter</i></b></td><td class="jdocu_noborder">Cell Context</td></tr>

   <tr><td class="jdocu_noborder"><b><i>logical_to_physical</i></b></td><td class="jdocu_noborder">Cell Context</td></tr>

   <tr><td class="jdocu_noborder"><b><i>get_processor_mode</i></b></td><td class="jdocu_noborder">Cell Context</td></tr>

   <tr><td class="jdocu_noborder"><b><i>enable_processor</i></b></td><td class="jdocu_noborder">Cell Context</td></tr>

   <tr><td class="jdocu_noborder"><b><i>disable_processor</i></b></td><td class="jdocu_noborder">Cell Context</td></tr>

   <tr><td class="jdocu_noborder"><b><i>get_enabled</i></b></td><td class="jdocu_noborder">Cell Context</td></tr>

   <tr><td class="jdocu_noborder"><b><i>get_endian</i></b></td><td class="jdocu_noborder">Cell Context</td></tr>

   <tr><td class="jdocu_noborder"><b><i>get_physical_memory</i></b></td><td class="jdocu_noborder">Cell Context</td></tr>

   <tr><td class="jdocu_noborder"><b><i>get_logical_address_width</i></b></td>
       <td class="jdocu_noborder">Cell Context</td></tr>

   <tr><td class="jdocu_noborder"><b><i>get_physical_address_width</i></b></td>
       <td class="jdocu_noborder">Cell Context</td></tr>

   <tr><td class="jdocu_noborder"><b><i>architecture</i></b></td><td class="jdocu_noborder">Cell Context</td></tr>

   </tbody></table>
<p>
   It is explicitly permitted to call <b><i>set_program_counter</i></b> from
   inside an execution breakpoint handler.
   
</p></dd>
</dl><p></p></section><section class="page" id="__rm_interface_ram_access_subscribe.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_ram_access_subscribe.html:__rm_interface_ram_access_subscribe">ram_access_subscribe</a></h1>
<p>

<a id="__rm_interface_ram_access_subscribe.html:ram_access_subscribe"></a><a id="__rm_interface_ram_access_subscribe.html:ram_access_subscribe_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><a id="__rm_interface_ram_access_subscribe.html:ram_access_subscribe_interface_t2"></a>
<p>
   This interface is used to register callbacks to instrument ram/rom accesses.
</p><p>
   The <b><i>register_access_before_cb</i></b> method registers a callback that is
   called before any memory access reached the backing storage in a ram/rom
   image. This makes it possible to modify the transaction before it reaches
   its destination. See the documentation of the <code>ram_access_cb_t</code>
   type for more information. A <code>ram_cb_handle_t</code> pointer is
   returned as a reference to the callback.
</p><p>
   The <b><i>register_access_after_cb</i></b> method registers a callback that is
   called after any memory access has reached the backing storage in a ram/rom
   image. This makes it possible to modify the transaction after the access is
   completed. See the documentation of the <code>ram_access_cb_t</code>
   type for more information. A <code>ram_cb_handle_t</code> pointer is
   returned as a reference to the callback.
</p><p>
   Both of these register callbacks above will receive all types of accesses,
   read, write, or execute, from any initiator hitting any address range. It is
   up to the callback to filter the information if needed, e.g., to only trace
   read accesses. Normally, ram/rom pages can be cached in object using them by
   using the <code>direct_memory_lookup</code> interface. This caching must
   be blocked by this interface to allow the callbacks to be called. This has
   severe impact on simulation speed. However, the following method should be
   used to allow caching for accesses that the callbacks have no interest in.
</p><p>
   The <b><i>register_access_filter_cb</i></b> method can be used to register a
   function callback that allows ram/rom pages to be cached by a user of the
   <code>direct_memory_lookup</code> interface. If caching is allowed the
   access may be invisible to the callbacks installed by
   <b><i>register_access_before_cb</i></b> and <b><i>register_access_after_cb</i></b>
   methods above. Even if an access is allowed to be cached it does not mean
   that it will be, which means that the callbacks can be called anyway.
</p><p>
   See the documentation of the <code>access_filter_cb_t</code> type for more
   information about the callback and how to allow caching. A
   <code>ram_cb_handle_t</code> pointer is returned as a reference to the
   callback.
</p><p>
   The <b><i>remove_callback</i></b> method removes an earlier installed
   callback. The handle is used to identify the callback to be removed. All
   register function above returns such handle.
</p><p>
   The <b><i>enable_callback</i></b> and <b><i>disable_callback</i></b> methods
   temporarily enables and disables a previously installed
   callback. The handle is used to identify the callback. All
   register function above returns such handle.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(ram_access_subscribe) {
        void (*remove_callback)(conf_object_t *NOTNULL obj,
                                ram_cb_handle_t *handle);
        void (*enable_callback)(conf_object_t *NOTNULL obj,
                                ram_cb_handle_t *handle);
        void (*disable_callback)(conf_object_t *NOTNULL obj,
                                 ram_cb_handle_t *handle);
        ram_cb_handle_t *(*register_access_before_cb)(
                conf_object_t *NOTNULL obj,
                conf_object_t *conn_obj,
                ram_access_cb_t cb,
                lang_void *data);
        ram_cb_handle_t *(*register_access_after_cb)(
                conf_object_t *NOTNULL obj,
                conf_object_t *conn_obj,
                ram_access_cb_t cb,
                lang_void *data);
        ram_cb_handle_t *(*register_access_filter_cb)(
                conf_object_t *NOTNULL obj,
                conf_object_t *connection,
                access_filter_cb_t cb,
                lang_void *data);
};

#define RAM_ACCESS_SUBSCRIBE_INTERFACE "ram_access_subscribe"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Global Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_simple_timing_v2.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_simple_timing_v2.html:__rm_interface_simple_timing_v2">simple_timing_v2</a></h1>
<p>

<a id="__rm_interface_simple_timing_v2.html:simple_timing_v2"></a><a id="__rm_interface_simple_timing_v2.html:simple_timing_v2_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">=============================================
<p>
                TECH-PREVIEW
</p><p>
    This interface may change without notice.
</p><p>
  =============================================
</p><p>
  The <code>simple_timing_v2</code> interface is used to send information
  about timing, instructions executed and activity factor from timing models
  to power and temperature models. It should be implemented by the consumer
  of the data.
</p><p>
  The period that is covered by a call is called a heartbeat. The length of
  that period may vary between calls.
</p><p>
  When a core has completed a heartbeat <b><i>new_active_data</i></b> is called
  and when a period of idleness has passed <b><i>new_idle_data</i></b> is called.
</p><p>
  The <i>core</i> argument is the core the performance data comes from.
</p><p>
  The <i>time</i> argument is the virtual time of the core at the end of
  the heartbeat.
</p><p>
  The <i>frequency</i> argument is what the core frequency was set to at
  the time of the call.
</p><p>
  The <i>cycles</i> argument is the number of cycles in the heartbeat.
</p><p>
  The <i>ipc</i> argument is average ipc during this heartbeat.
</p><p>
  The <i>cdyn</i> argument is average activity factor during the heartbeat.
</p><p>
  The <i>version_data</i> argument can be a <code>NULL</code> or a pointer to
  simple json-string that can contain information about the performance model.
</p><p>
  </p><div class="note">
<b>Note:</b>
Temporal decoupling may cause calls regarding different cores to come
  out of order with regards to virtual time.
<p>
  Time during heartbeat may not add up with time passed since last call on a
  particular core, especially when cores goes in and out of idle-mode.</p></div>To use the <code>simple_timing_v2</code> add the following
  EXTRA_MODULE_VPATH := simple-timing-interface
  to the modules Makefile.
<p>
  </p><pre class="jdocu_small">#define SIMPLE_TIMING_V2_MAX_NR_EVENTS  120

SIM_INTERFACE(simple_timing_v2) {
        bool (*new_active_data)
                (conf_object_t *obj,
                 double time,
                 conf_object_t *core,
                 uint64 frequency,

                 cycles_t cycles,
                 double ipc,
                 double cdyn,

                 char const *version_data);

        bool (*new_idle_data)
                (conf_object_t *obj,
                 double time,
                 conf_object_t *core,
                 uint64 frequency,
                 cycles_t cycles);
};

#define SIMPLE_TIMING_V2_INTERFACE "simple_timing_v2"

</pre><p>
</p><p>

  
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Called from performance models.
  
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_simulator_cache.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_simulator_cache.html:__rm_interface_simulator_cache">simulator_cache</a></h1>
<p>

<a id="__rm_interface_simulator_cache.html:simulator_cache"></a><a id="__rm_interface_simulator_cache.html:simulator_cache_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>simulator_cache</code> interface is optionally
  implemented by processors. The interface can be used for
  <code>translate</code> objects to force a flush of the internal
  caches in a processor model, if a memory area that it previously
  allowed for caching is not valid anymore.
<p>
  </p><pre class="jdocu_small">SIM_INTERFACE(simulator_cache) {
        void (*flush)(conf_object_t *obj);
};
#define SIMULATOR_CACHE_INTERFACE "simulator_cache"
</pre><p>
</p><p>
  
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem"><table>

  <tbody><tr><td class="jdocu_noborder"><b><i>flush</i></b></td><td class="jdocu_noborder">Cell Context</td></tr>

  </tbody></table>
<p>
  
</p></dd>
</dl><p></p></section><section class="page" id="__rm_interface_snoop_memory.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_snoop_memory.html:__rm_interface_snoop_memory">snoop_memory</a></h1>
<p>

<a id="__rm_interface_snoop_memory.html:snoop_memory"></a><a id="__rm_interface_snoop_memory.html:snoop_memory_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This interface is described with the <code>timing_model</code>
   interface.
   
</dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_stall.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_stall.html:__rm_interface_stall">stall</a></h1>
<p>

<a id="__rm_interface_stall.html:stall"></a><a id="__rm_interface_stall.html:stall_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>stall</code> interface can be implemented by objects that also
  implement the <code>cycle</code> and <code>step</code> interfaces. The
  <code>stall</code> interface controls the addition of extra cycles between
  steps.
<p>
  The <b><i>get_stall_cycles</i></b> function returns the remaining number of
  stall cycles. The object will advance that number of cycles before starting
  with the next step.
</p><p>
  The <b><i>set_stall_cycles</i></b> function is used to change the number of
  stall cycles before the next step. It is legal to first call this function
  with a large value for <i>cycles</i> and then at a later point reduce the
  cycle count is resume execution earlier than indicated by the first call.
</p><p>
  The <b><i>get_total_stall_cycles</i></b> returns the total accumulated number of
  stall cycles.
</p><p>
  </p><pre class="jdocu_small">SIM_INTERFACE(stall) {
        cycles_t (*get_stall_cycles)(conf_object_t *obj);
        void (*set_stall_cycles)(conf_object_t *obj, cycles_t cycles);
        cycles_t (*get_total_stall_cycles)(conf_object_t *obj);
};
#define STALL_INTERFACE "stall"
</pre><p>
</p><p>
  
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
  
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_step.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_step.html:__rm_interface_step">step</a></h1>
<p>

<a id="__rm_interface_step.html:step"></a><a id="__rm_interface_step.html:step_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>step</code> interface is typically implemented by
  processors, but can be implemented by other objects as well. Its
  purpose is to handle step events using a queue.
<p>
  The current number of steps for the <i>queue</i> is returned
  when calling <b><i>get_step_count</i></b>.
</p><p>
  The <b><i>post_step</i></b> function will schedule an event that will
  occur after <i>steps</i> (which must be nonnegative)
  counted from local current step at
  <i>queue</i>. An event previously posted can be removed by
  calling <b><i>cancel_step</i></b>. The <b><i>cancel_step</i></b> function takes a
  function <i>pred</i> as argument which is called when a matching
  event is found. The event is only removed if <i>pred</i> returns
  <code>1</code>. The <b><i>find_next_step</i></b> takes the same arguments
  as <b><i>cancel_step</i></b> but only returns the number of cycles before
  the event will occur. The <i>evclass</i> is the event class,
  <i>obj</i> is the object posting the event, and
  <i>user_data</i> is pointer to data used as a parameter when
  calling the callback function defined in the <i>evclass</i>.
  If no matching event was found, <b><i>find_next_step</i></b> returns
  1.
</p><p>
  The <b><i>events</i></b> method returns a list of all pending events in
  expiration order. Each element is a four-element list containing the event
  object, the event class name, the expiration time counted in steps as an
  integer and the event description as given by the event class
  <b><i>describe</i></b> method, or <em>nil</em> for events whose event class do
  not define that method.
</p><p>
  The <b><i>advance</i></b> function will increment the number of steps
  for the queue, decrementing the number of steps to the first event
  to the value defined by <i>steps</i>. The number of steps remaining
  to the next event is returned. It is an error to advance beyond the
  next pending event, so the return value is never negative.
</p><p>
  The implementor of the <code>step</code> interface can use any
  checkpoint representation. The <i>name</i> field in the
  event class data structure is unique, and the attribute setter
  function for checkpoint restore can use
  <b><i>SIM_get_event_class</i></b> to get the event class structure
  corresponding to an event class name.
</p><p>
  </p><pre class="jdocu_small">SIM_INTERFACE(step) {
        pc_step_t (*get_step_count)(conf_object_t *NOTNULL queue);
        void (*post_step)(
                conf_object_t *NOTNULL queue,
                event_class_t *NOTNULL evclass,
                conf_object_t *NOTNULL obj,
                pc_step_t steps,
                lang_void *user_data);
        void (*cancel_step)(
                conf_object_t *NOTNULL queue,
                event_class_t *NOTNULL evclass,
                conf_object_t *NOTNULL obj,
                int (*pred)(lang_void *data, lang_void *match_data),
                lang_void *match_data);
        pc_step_t (*find_next_step)(
                conf_object_t *NOTNULL queue,
                event_class_t *NOTNULL evclass,
                conf_object_t *NOTNULL obj,
                int (*pred)(lang_void *data, lang_void *match_data),
                lang_void *match_data);

        attr_value_t (*events)(conf_object_t *NOTNULL obj);

        pc_step_t (*advance)(conf_object_t *queue, pc_step_t steps);
};

#define STEP_INTERFACE "step"
</pre><p>
</p><p>
  
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_step_cycle_ratio.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_step_cycle_ratio.html:__rm_interface_step_cycle_ratio">step_cycle_ratio</a></h1>
<p>

<a id="__rm_interface_step_cycle_ratio.html:step_cycle_ratio"></a><a id="__rm_interface_step_cycle_ratio.html:step_cycle_ratio_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>step_cycle_ratio</code> interface is implemented by
  processors that support a changeable ratio between steps and
  cycles. The <b>set-step-rate</b> command uses this interface to
  set the ratio between steps and cycles.
<p>
  The <b><i>set_ratio</i></b> sets the ratio between <i>steps</i> and
  <i>cycles</i>. Note that the introduction of stall cycles can
  skew the ratio. The <b><i>get_ratio</i></b> simply returns the current
  ratio.
</p><p>
  The <i>cycles</i> and <i>step</i> arguments must be in the range
  [1..128] and <i>cycles</i> must be a power of two. Implementers of this
  interface may choose to ignore other values of <i>cycles</i> and
  <i>step</i> and may log an error.
</p><p>
  </p><pre class="jdocu_small">typedef struct {
        uint32 steps;
        uint32 cycles;
} step_cycle_ratio_t;

SIM_INTERFACE(step_cycle_ratio) {
        step_cycle_ratio_t (*get_ratio)(conf_object_t *obj);
        void (*set_ratio)(conf_object_t *obj, uint32 steps, uint32 cycles);
};

#define STEP_CYCLE_RATIO_INTERFACE "step_cycle_ratio"
</pre><p>
</p><p>
  
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
  
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_step_event_instrumentation.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_step_event_instrumentation.html:__rm_interface_step_event_instrumentation">step_event_instrumentation</a></h1>
<p>

<a id="__rm_interface_step_event_instrumentation.html:step_event_instrumentation"></a><a id="__rm_interface_step_event_instrumentation.html:step_event_instrumentation_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This interface is internal.
   
</dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Global Context.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_step_info.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_step_info.html:__rm_interface_step_info">step_info</a></h1>
<p>

<a id="__rm_interface_step_info.html:step_info"></a><a id="__rm_interface_step_info.html:step_info_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>step_info</code> interface can be implemented by
   processors that optimize the execution by advancing the step count
   using special instructions or processor modes.
<p>
   The <b><i>get_halt_steps</i></b> and <b><i>set_halt_steps</i></b>
   functions are used to get and set the number of steps that have been
   advanced using special features in the architecture. Examples; X86
   processor it is the number of halt instructions executed, PPC
   processors it is the number of steps spent in sleep mode, ARM
   processors it is the number of steps spent in the "wait for
   interrupt" state.
</p><p>
   The <b><i>get_ffwd</i></b> and <b><i>set_ffwd_steps</i></b> functions are
   used to get and set the number of steps that the processor have
   optimized the execution by advancing time that is not
   architectural. This can for instance be execution loops that does
   not affect the processor state.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(step_info) {
        pc_step_t (*get_halt_steps)(conf_object_t *obj);
        void (*set_halt_steps)(conf_object_t *obj, pc_step_t steps);
        pc_step_t (*get_ffwd_steps)(conf_object_t *obj);
        void (*set_ffwd_steps)(conf_object_t *obj, pc_step_t steps);
        pc_step_t (*get_ma_steps)(conf_object_t *obj);
        void (*set_ma_steps)(conf_object_t *obj, pc_step_t steps);
};
#define STEP_INFO_INTERFACE "step_info"
</pre><p>
</p><p>

   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_synchronous_mode.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_synchronous_mode.html:__rm_interface_synchronous_mode">synchronous_mode</a></h1>
<p>

<a id="__rm_interface_synchronous_mode.html:synchronous_mode"></a><a id="__rm_interface_synchronous_mode.html:synchronous_mode_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Experimental, may change without notice.
<p>
   </p><pre class="jdocu_small">SIM_INTERFACE(synchronous_mode) {
        int (*enter)(conf_object_t *NOTNULL obj);
        int (*leave)(conf_object_t *NOTNULL obj);
};
#define SYNCHRONOUS_MODE_INTERFACE "synchronous_mode"
</pre><p>
</p><p>

   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_temporal_state.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_temporal_state.html:__rm_interface_temporal_state">temporal_state</a></h1>
<p>

<a id="__rm_interface_temporal_state.html:temporal_state"></a><a id="__rm_interface_temporal_state.html:temporal_state_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Deprecated interface. Use global notifiers and/or attributes instead.
<p>
   This interface was used to save micro checkpoints for reverse execution.
   It remains in 7, but is only used to get notifications when an
   object's state is about to be restored, or has just been restored.
</p><p>
   All functions in this interface are optional.
   </p><p>
   The <b><i>save</i></b> and <b><i>merge</i></b> functions are never called.
</p><p>
   The function <b><i>prepare_restore</i></b> is called when a saved state
   is about to be loaded, before any attributes have been set.
</p><p>
   The <b><i>finish_restore</i></b> function is called when all
   attributes have been set. The <i>state</i> argument is
   always NULL.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(temporal_state) {
        lang_void *(*save)(conf_object_t *obj);
        void (*merge)(conf_object_t *obj, lang_void *prev, lang_void *killed);
        void (*prepare_restore)(conf_object_t *obj);
        void (*finish_restore)(conf_object_t *obj, lang_void *state);
};

#define TEMPORAL_STATE_INTERFACE "temporal_state"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_timing_model.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_timing_model.html:__rm_interface_timing_model">timing_model</a></h1>
<p>

<a id="__rm_interface_timing_model.html:timing_model"></a><a id="__rm_interface_timing_model.html:timing_model_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>timing_model</code> interface is used to communicate
   stall times for memory accesses. It is typically exported by cache
   models. The <b><i>operate()</i></b> function is then called on every
   memory access that misses in the STC, and the return value from the
   call is the number of cycles to stall.
<p>
   The <code>snoop_memory</code> interface has the exact same layout
   as the <code>timing_model</code> interface, but its
   <b><i>operate()</i></b> function is called after the memory access has
   been performed. The return value from the <b><i>operate()</i></b>
   function of a <code>snoop_memory</code> interface is ignored.
</p><p>
   The <b><i>operate</i></b> function is invoked via the <i>timing_model</i>
   attribute of the <b>memory-space</b> where the STC miss happens.
</p><p>
   See the <em>Model Builder User's Guide</em> for more information on
   how to use these interfaces.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(timing_model) {
        cycles_t (*operate)(conf_object_t *NOTNULL mem_hier,
                            conf_object_t *NOTNULL space,
                            map_list_t *map_list,
                            generic_transaction_t *NOTNULL mem_op);
};

#define TIMING_MODEL_INTERFACE "timing_model"

SIM_INTERFACE(snoop_memory) {
        cycles_t (*operate)(conf_object_t *NOTNULL mem_hier,
                            conf_object_t *NOTNULL space,
                            map_list_t *map_list,
                            generic_transaction_t *NOTNULL mem_op);
};

#define SNOOP_MEMORY_INTERFACE "snoop_memory"
        
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_transaction.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_transaction.html:__rm_interface_transaction">transaction</a></h1>
<p>

<a id="__rm_interface_transaction.html:transaction"></a><a id="__rm_interface_transaction.html:transaction_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><a id="__rm_interface_transaction.html:transaction_t"></a>
<p>
   The <code>transaction</code> interface is implemented by devices that
   can be mapped into address spaces. The <b><i>issue</i></b> method is called
   when a memory transaction <i>t</i> is issued to the object.
</p><p>
   The return value of the <b><i>issue</i></b> function is normally
   <code>Sim_PE_No_Exception</code>, but other pseudo <code>exception_type_t</code>
   values can be used to signal error conditions. The value
   <code>Sim_PE_Deferred</code> must be used when the transaction has been
   deferred using <b><i>SIM_defer_transaction</i></b> for completion at
   some later time.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(transaction) {
        exception_type_t (*issue)(
                conf_object_t *NOTNULL obj,
                transaction_t *NOTNULL t,
                uint64 addr);
};
#define TRANSACTION_INTERFACE  "transaction"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_transaction_subscribe.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_transaction_subscribe.html:__rm_interface_transaction_subscribe">transaction_subscribe</a></h1>
<p>

<a id="__rm_interface_transaction_subscribe.html:transaction_subscribe"></a><a id="__rm_interface_transaction_subscribe.html:transaction_subscribe_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><a id="__rm_interface_transaction_subscribe.html:transaction_subscribe_interface_t2"></a>
<p>
   Note: this interface is internal and may change without notice.
</p><p>
   This interface is used to register callbacks to instrument transactions
   issued through a map target by the SIM_issue_transaction API call. This
   includes all <b>memory_space</b> objects handling transactions.
   The interface is only implemented by the <b>sim.transactions</b>
   object which serves all transactions.
</p><p>
   The <b><i>register_issue_cb</i></b> method registers a callback that is
   called whan a transaction is passed to a map target. This makes it
   possible to modify or replace the transaction before it reaches its
   destination. See the documentation of the
   <code>transaction_issue_cb_t</code> type for more information on now to
   handle the transaction.
</p><p>
   A <code>transaction_cb_handle_t</code> pointer is returned as a reference to
   the callback.
</p><p>
   The registered callbacks above will receive all types of accesses,
   read, write, or execute, from any initiator hitting any address range. It is
   up to the callback to filter the information if needed, e.g., to only trace
   read accesses.
</p><p>
   If more than one cell is used and multithreading is enabled, more that one
   callback can be issued at the same time.
</p><p>
   Normally, for transactions to ram/rom, these accesses can be bypassed by
   caching the destination object by using the
   <code>direct_memory_lookup</code> interface. Then these accesses cannot be
   monitored by the <code>transaction_subscribe</code> interface. However, it
   is possible to block this caching by using the
   <b><i>register_access_filter_cb</i></b> method of the
   <code>ram_access_subscribe</code> interface. This has typically severe
   impact on simulation speed, but allows user to monitor all transactions in
   the system. Note however that a real systems also reduces the transactions to
   memory by using caches, which normally is not modeled by
   Simics,
</p><p>
   The <b><i>remove_callback</i></b> method removes an earlier installed
   callback. The handle is used to identify the callback to be removed. The
   register functions above return such handle.
</p><p>
   The <b><i>enable_callback</i></b> and <b><i>disable_callback</i></b> methods
   temporarily enables and disables a previously installed callback. Note that
   this will not necessary speed up the simulation, since the caching may be
   blocked anyway. The handle is used to identify the callback. The register
   functions above return such handle.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(transaction_subscribe) {
        void (*remove_callback)(conf_object_t *NOTNULL obj,
                                transaction_cb_handle_t *handle);
        void (*enable_callback)(conf_object_t *NOTNULL obj,
                                transaction_cb_handle_t *handle);
        void (*disable_callback)(conf_object_t *NOTNULL obj,
                                 transaction_cb_handle_t *handle);
        transaction_cb_handle_t *(*register_issue_cb)(
                conf_object_t *NOTNULL obj,
                conf_object_t *conn_obj,
                transaction_issue_cb_t cb,
                lang_void *data);
};

#define TRANSACTION_SUBSCRIBE_INTERFACE "transaction_subscribe"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Outside execution context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_tsc_update.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_tsc_update.html:__rm_interface_tsc_update">tsc_update</a></h1>
<p>

<a id="__rm_interface_tsc_update.html:tsc_update"></a><a id="__rm_interface_tsc_update.html:tsc_update_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The methods allow to update/overwrite Time Stamp Counter with values coming
   from PUnit and measured in different units.
<p>
   <b><i>load_tsc_from_xtal</i></b> sets TSC to an absolute value scaled from
   the <i>xtal_value</i>. The latter value is measured in units of always
   running timer clocks.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(tsc_update) {
        void (*load_tsc_from_xtal)(conf_object_t *obj, uint64 xtal_value);
};
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_uint64_state.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_uint64_state.html:__rm_interface_uint64_state">uint64_state</a></h1>
<p>

<a id="__rm_interface_uint64_state.html:uint64_state"></a><a id="__rm_interface_uint64_state.html:uint64_state_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Interface to transfer a state representable in an uint64 from one device to
   another.  Examples of what the state might represent includes:
<p>
   </p><dl><li>a fixed-point value representing the level of an analog signal</li>
     <li>an integer representing a counter</li>
     <li>an integer representing an enum value</li>
   </dl><p>The initiator should call <b><i>set</i></b> when the value changes, and after a
   new target is connected.  The object implementing
   <code>uint64_state</code> should accept multiple calls to <b><i>set</i></b>
   with the same level, and may let this trigger side-effects. Therefore, any
   repeated calls must be deterministic; in particular, <b><i>set</i></b> must not
   be called while restoring a checkpoint.
</p><p>
   A device implementing this interface may choose to only accept a certain set
   of integer values; it is then an error to send any other values to the
   <b><i>set</i></b> method.  A user must therefore be careful to read the
   documentation of both the source and destination object to make sure they
   are compatible.
</p><p>
   No interface call needs to be done after disconnecting a target; the target
   needs to be notified of this through some other channel (typically via a
   connector)
</p><p>
   </p><div class="note">
<b>Note:</b>
The <code>uint64_state</code> interface should be used instead of
   the deprecated <code>multi_level_signal</code> interface when writing new
   models.</div><pre class="jdocu_small">SIM_INTERFACE(uint64_state) {
        void (*set)(conf_object_t *NOTNULL obj, uint64 level);
};
#define UINT64_STATE_INTERFACE "uint64_state"
</pre><p>
</p><p>

   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_vga_text_info.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_vga_text_info.html:__rm_interface_vga_text_info">vga_text_info</a></h1>
<p>

<a id="__rm_interface_vga_text_info.html:vga_text_info"></a><a id="__rm_interface_vga_text_info.html:vga_text_info_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>vga_text_info</code> interface facilitates the graphics console
   to obtain information about displayed text from its attached VGA device,
   when the video mode is a VGA text mode. This interface must be implemented
   by VGA devices that are attached to the graphics console.
<p>
   The <b><i>text_mode</i></b> method indicates whether the current video mode is
   a VGA text mode.
</p><p>
   If the current video mode is not a VGA text mode, all other methods have no
   effect, and will return <code>false</code>. Otherwise they return <code>true</code>
   and behaves as follows:
</p><p>
   The <b><i>font_size</i></b> method sets <i>width</i> and <i>height</i>
   to the current font size.
</p><p>
   The <b><i>screen_size</i></b> method sets <i>columns</i> and
   <i>rows</i> to the current screen size.
</p><p>
   The <b><i>text</i></b> method retrieves the screen text data and line
   lengths. The <i>text</i> parameter must be a buffer with size at least
   <code>columns * rows</code>, as given by <b><i>screen_size</i></b>. Similarly, the
   <i>line_length</i> parameter must be a buffer of length <code>rows</code>.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(vga_text_info) {
        bool (*text_mode)(conf_object_t *NOTNULL obj);
        bool (*font_size)(conf_object_t *NOTNULL obj, int *width, int *height);
        bool (*screen_size)(conf_object_t *NOTNULL obj,
                            int *columns, int *rows);
        bool (*text)(conf_object_t *NOTNULL obj,
                     uint8 *text, uint8 *line_lengths);
};
#define VGA_TEXT_INFO_INTERFACE "vga_text_info"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context
   for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_vga_text_update.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_vga_text_update.html:__rm_interface_vga_text_update">vga_text_update</a></h1>
<p>

<a id="__rm_interface_vga_text_update.html:vga_text_update"></a><a id="__rm_interface_vga_text_update.html:vga_text_update_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>vga_text_update</code> interface facilitates defining an input
   character stream for graphics consoles. The video device associated to a
   graphics console can use this interface to send a stream of characters to
   the console. This stream is used by the graphics console break strings. The
   stream should match the displayed VGA text whenever possible.
<p>
   </p><pre class="jdocu_small">SIM_INTERFACE(vga_text_update) {
        void (*write)(conf_object_t *NOTNULL obj, char value);
};
#define VGA_TEXT_UPDATE_INTERFACE "vga_text_update"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_vga_update.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_vga_update.html:__rm_interface_vga_update">vga_update</a></h1>
<p>

<a id="__rm_interface_vga_update.html:vga_update"></a><a id="__rm_interface_vga_update.html:vga_update_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>vga_update</code> interface facilitates the graphics console to
   request screen redraw from its attached video device, which typically
   happens on every frame update event. This interface must be implemented by
   video devices that are attached to the graphics console. The implementation
   should call functions in the <code>gfx_con</code> interface, e.g. a
   sequence of put_block() calls followed by redraw(), which is implemented by
   the graphics console.
<p>
   The <b><i>refresh</i></b> method requests the video device to redraw dirty
   parts of the screen. The <b><i>refresh_all</i></b> method requests the video
   device to redraw the whole screen.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(vga_update) {
        void (*refresh)(conf_object_t *NOTNULL obj);
        void (*refresh_all)(conf_object_t *NOTNULL obj);
};
#define VGA_UPDATE_INTERFACE "vga_update"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for
   all methods
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_virtual_data_breakpoint.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_virtual_data_breakpoint.html:__rm_interface_virtual_data_breakpoint">virtual_data_breakpoint</a></h1>
<p>

<a id="__rm_interface_virtual_data_breakpoint.html:virtual_data_breakpoint"></a><a id="__rm_interface_virtual_data_breakpoint.html:virtual_data_breakpoint_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Add and remove virtual-address (and, on x86, linear-address) read and
     write breakpoints. On every read access that intersects a read
     breakpoint's interval, the registered callback function is called with the
     object that initiated the read, and the address and size of the read. (The
     interval includes both endpoints; <i>first</i> must be less than
     or equal to <i>last</i>.) Write breakpoints work exactly the same,
     except that the callback is given the actual value being written, not just
     its size.
<p>
     The callback is called before the read or write has taken place, but may
     not intervene. If one or more breakpoint callbacks stop the simulation,
     the current instruction is completed before the stop takes effect. If more
     than one breakpoint is triggered by the same read or write, the
     implementation may call their callbacks in any order.
</p><p>
     On x86, the <code>Virtual_Breakpoint_Flag_Linear</code> flag causes the
     breakpoint to use linear rather than virtual addresses. (Adding a
     breakpoint with unsupported flags is illegal.)
</p><p>
     </p><div class="note">
<b>Note:</b>
This interface is preliminary and may change without prior notice.
     </div><a id="__rm_interface_virtual_data_breakpoint.html:virtual_breakpoint_flags_t"></a>
<pre class="jdocu_small">typedef enum {
        Virtual_Breakpoint_Flag_Linear = 1
} virtual_breakpoint_flags_t;</pre><p>

</p><p>
     </p><pre class="jdocu_small">SIM_INTERFACE(virtual_data_breakpoint) {
        virtual_data_bp_handle_t *NOTNULL (*add_read)(
                conf_object_t *NOTNULL obj,
                generic_address_t first, generic_address_t last,
                void (*NOTNULL callback)(
                        cbdata_call_t data, conf_object_t *NOTNULL initiator,
                        generic_address_t address, unsigned size),
                cbdata_register_t data, uint32 flags);
        virtual_data_bp_handle_t *NOTNULL (*add_write)(
                conf_object_t *NOTNULL obj,
                generic_address_t first, generic_address_t last,
                void (*NOTNULL callback)(
                        cbdata_call_t data, conf_object_t *NOTNULL initiator,
                        generic_address_t address, bytes_t value),
                cbdata_register_t data, uint32 flags);
        void (*remove)(conf_object_t *NOTNULL obj,
                       virtual_data_bp_handle_t *NOTNULL bp_handle);
};
#define VIRTUAL_DATA_BREAKPOINT_INTERFACE "virtual_data_breakpoint"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_virtual_instruction_breakpoint.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_virtual_instruction_breakpoint.html:__rm_interface_virtual_instruction_breakpoint">virtual_instruction_breakpoint</a></h1>
<p>

<a id="__rm_interface_virtual_instruction_breakpoint.html:virtual_instruction_breakpoint"></a><a id="__rm_interface_virtual_instruction_breakpoint.html:virtual_instruction_breakpoint_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Add and remove virtual-address (and, on x86, linear-address) instruction
     breakpoints. Every time the processor executes an instruction that
     intersects the breakpoint's interval, the callback function is called with
     the processor, and the address and size of the instruction. (The interval
     includes both endpoints; <i>first</i> must be less than or equal
     to <i>last</i>.)
<p>
     The callback is called before the instruction is executed. If one or more
     breakpoint callbacks stop the simulation, the stop takes effect before
     the instruction is run. (This means that once the simulation starts
     again, the same breakpoints will trigger immediately again. The callback
     can use <b><i>VT_step_stamp</i></b> to detect re-triggering.) If more than
     one breakpoint is triggered by the same instruction, the implementation
     may call their callbacks in any order.
</p><p>
     If the filter function is non-null and returns false, the callback is not
     called. The filter function is supplied with the instruction opcode (the
     raw bytes of the instruction) and a processor (which may not be the same
     processor that the breakpoint is set on, but is guaranteed to be of the
     same class). The filter may base its decision only on the opcode bytes and
     the string obtained by asking the processor to disassemble the
     instruction; this allows the implementation to cache the result and omit
     future calls to the filter function where the opcode and disassembly
     string would be the same.
</p><p>
     On x86, the <code>Virtual_Breakpoint_Flag_Linear</code> flag causes the
     breakpoint to use linear rather than virtual addresses. Calling with
     unsupported flags is illegal.
</p><p>
     </p><div class="note">
<b>Note:</b>
This interface is preliminary and may change without prior notice.
     </div><a id="__rm_interface_virtual_instruction_breakpoint.html:virtual_breakpoint_flags_t"></a>
<pre class="jdocu_small">typedef enum {
        Virtual_Breakpoint_Flag_Linear = 1
} virtual_breakpoint_flags_t;</pre><p>

</p><p>
     </p><pre class="jdocu_small">SIM_INTERFACE(virtual_instruction_breakpoint) {
        virtual_instr_bp_handle_t *NOTNULL (*add)(
                conf_object_t *NOTNULL obj,
                generic_address_t first, generic_address_t last,
                bool (*filter)(cbdata_call_t filter_data,
                               conf_object_t *NOTNULL cpu, bytes_t opcode),
                cbdata_register_t filter_data,
                void (*NOTNULL callback)(
                        cbdata_call_t callback_data, conf_object_t *NOTNULL cpu,
                        generic_address_t address, unsigned size),
                cbdata_register_t callback_data, uint32 flags);
        void (*remove)(conf_object_t *NOTNULL obj,
                       virtual_instr_bp_handle_t *NOTNULL bp_handle);
};
#define VIRTUAL_INSTRUCTION_BREAKPOINT_INTERFACE \
        "virtual_instruction_breakpoint"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_x86_monitor.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_x86_monitor.html:__rm_interface_x86_monitor">x86_monitor</a></h1>
<p>

<a id="__rm_interface_x86_monitor.html:x86_monitor"></a><a id="__rm_interface_x86_monitor.html:x86_monitor_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This interface is meant to be implemented by an uncore device to support
    implementation of MONITOR/MWAIT instruction pair. A listener (e.g. a cpu)
    uses this interface to setup monitored write-back memory range.
    All listeners subscribed to a particular write-back memory range will be
    notified via <b>x86_monitor_notification_interface</b> when a memory write
    transaction hits the monitored memory range.
<p>
    This interface is internal and may change without notice.
</p><p>
    The <b>arm</b> method is to subscribe for notifications about writes to
    a write-back memory range starting from <b>start_address</b> up to
    <b>start_address</b> + <b>length</b> - 1 , returns true on success.
    The <b>disarm</b> unsubscribes <b>listener</b>, so the latter won't be
    notified about writes to a monitored memory range, returns true on success.
</p><p>
</p><pre class="jdocu_small">SIM_INTERFACE(x86_monitor) {
    bool (*arm)(conf_object_t *obj, conf_object_t *listener,
                physical_address_t start_address, physical_address_t length);
    bool (*disarm)(conf_object_t *obj, conf_object_t *listener);
};

#define X86_MONITOR_INTERFACE "x86_monitor"
</pre><p>
</p><p>
    
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
    
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_x86_monitor_notification.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_x86_monitor_notification.html:__rm_interface_x86_monitor_notification">x86_monitor_notification</a></h1>
<p>

<a id="__rm_interface_x86_monitor_notification.html:x86_monitor_notification"></a><a id="__rm_interface_x86_monitor_notification.html:x86_monitor_notification_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This interface is meant to be implemented by a processor to support
    complex cases of MONITOR/MWAIT instruction pair. A processor will be
    notified about writes to the monitored write-back memory range through the
    <b>notify</b> method. The return value indicates whether to unsubscribe from
    notifications or not. See <b>x86_monitor_interface_t</b> to find out how to
    subscribe for write notifications to a write-back memory range.
<pre class="jdocu_small">SIM_INTERFACE(x86_monitor_notification) {
        bool (*notify)(conf_object_t *obj);
};

#define X86_MONITOR_NOTIFICATION_INTERFACE "x86_monitor_notification"
</pre><p>
</p><p>
    
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context.
    
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_x86_rar_interrupt.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_x86_rar_interrupt.html:__rm_interface_x86_rar_interrupt">x86_rar_interrupt</a></h1>
<p>

<a id="__rm_interface_x86_rar_interrupt.html:x86_rar_interrupt"></a><a id="__rm_interface_x86_rar_interrupt.html:x86_rar_interrupt_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Methods of this interface are used to provide CPU with
   information about RAR interrupt status from APIC
<p>
   The <b>is_rar_requested</b> method returns whether a RAR event is pending.
</p><p>
   The <b>ack_rar</b> method acknowledges RAR interrupt.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(x86_rar_interrupt) {
    bool (*is_rar_requested)(conf_object_t *obj);
    int (*ack_rar)(conf_object_t *obj);
};
#define X86_RAR_INTERRUPT_INTERFACE "x86_rar_interrupt"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_x86_smm_notification.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_x86_smm_notification.html:__rm_interface_x86_smm_notification">x86_smm_notification</a></h1>
<p>

<a id="__rm_interface_x86_smm_notification.html:x86_smm_notification"></a><a id="__rm_interface_x86_smm_notification.html:x86_smm_notification_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Objects registered in processor's <i>smm_listeners</i> attribute will
   be called via the <b><i>notification</i></b> method whenever the CPU's enters
   and leaves SMI handler. SMI handler entry occurs on SMI processing. SMI
   handler exit occurs by RSM instruction execution. Please note that for both
   SMI handler entry and SMI handler exit <b><i>notification</i></b> method will be
   invoked twice: at the beginning of the entry/exit and at the end when CPU
   state was already modified. <i>event</i> argument says if entry/exit is
   performed, <i>phase</i> argument equals to <b>X86_Smm_Phase0</b> for
   the beginning of the event and to <b>X86_Smm_Phase1</b> for the end.
<p>
   <a id="__rm_interface_x86_smm_notification.html:x86_smm_event_type_t"></a>
    
</p><pre class="jdocu_small">typedef enum x86_smm_event_type {
    X86_Smm_Enter,
    X86_Smm_Leave
} x86_smm_event_type_t;</pre><p>

</p><p>
   <a id="__rm_interface_x86_smm_notification.html:x86_smm_phase_type_t"></a>
    
</p><pre class="jdocu_small">typedef enum x86_smm_phase_type {
    X86_Smm_Phase0,
    X86_Smm_Phase1
} x86_smm_phase_type_t;</pre><p>

</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(x86_smm_notification) {
        void (*notification)(conf_object_t *listener, conf_object_t *cpu,
                             x86_smm_event_type_t event,
                             x86_smm_phase_type_t phase);
};
#define X86_SMM_NOTIFICATION_INTERFACE "x86_smm_notification"
</pre><p>
</p><p>

   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_x86_unplug.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_x86_unplug.html:__rm_interface_x86_unplug">x86_unplug</a></h1>
<p>

<a id="__rm_interface_x86_unplug.html:x86_unplug"></a><a id="__rm_interface_x86_unplug.html:x86_unplug_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The methods of the interface are intended to be used
    by a platform to unplug (and optionally re-plug) CPU cores/threads,
    effectively hiding them from the #RESET/INIT signals.
<p>
    This interface is internal and may change without notice.
</p><p>
    The <b>unplug_core</b> method is to disable an operating core with all
    threads on it.
    The <b>replug_core</b> method is to enable a core previously unplugged
    with all threads on it.
    The <b>disable_ht_package</b> method is to disable every secondary thread.
    The <b>enable_ht_package</b> method is to enable every secondary thread.
</p><p>
    Values returned from these methods indicate success (1) or failure (0).
</p><p>
    </p><pre class="jdocu_small">SIM_INTERFACE(x86_unplug) {
        int (*unplug_core)(conf_object_t *obj);
        int (*replug_core)(conf_object_t *obj);
        int (*disable_ht_package)(conf_object_t *obj);
        int (*enable_ht_package)(conf_object_t *obj);
};
#define X86_UNPLUG_INTERFACE "x86_unplug"
</pre><p>
</p><p>
    
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
    
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_x86_unplug_v2.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_x86_unplug_v2.html:__rm_interface_x86_unplug_v2">x86_unplug_v2</a></h1>
<p>

<a id="__rm_interface_x86_unplug_v2.html:x86_unplug_v2"></a><a id="__rm_interface_x86_unplug_v2.html:x86_unplug_v2_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The methods of the interface are intended to be used
    by a platform to unplug (and optionally re-plug) CPU cores/threads,
    effectively hiding them from the #RESET/INIT signals.
<p>
    This interface is internal and may change without notice.
</p><p>
    The <b>unplug_core</b> method is to disable an operating core with all
    threads on it.
    The <b>replug_core</b> method is to enable a core previously unplugged
    with all threads on it.
    The <b>disable_core_ht</b> method is to disable HT in the core (not the package).
    The <b>enable_core_ht</b> method is to enable HT in the core (not the package).
    The <b>core_is_plugged</b> method returns true if core is plugged.
    The <b>core_ht_is_enabled</b> method returns true if HT is enabled in the core (not the package).
    The <b>set_alive_logical_processors</b> method updates number of alive processors reported through CPUID.
    The <b>get_alive_logical_processors</b> method returns number of alive processors reported through CPUID.
</p><p>
    Values returned from enable and disable methods indicate success (1) or failure (0).
</p><p>
    </p><pre class="jdocu_small">SIM_INTERFACE(x86_unplug_v2) {
        int (*unplug_core)(conf_object_t *obj);
        int (*replug_core)(conf_object_t *obj);
        int (*disable_core_ht)(conf_object_t *obj);
        int (*enable_core_ht)(conf_object_t *obj);
        bool (*core_is_plugged)(conf_object_t *obj);
        bool (*core_ht_is_enabled)(conf_object_t *obj);
        void (*set_alive_logical_processors)(conf_object_t *obj, int count);
        int (*get_alive_logical_processors)(conf_object_t *obj);
};
#define X86_UNPLUG_V2_INTERFACE "x86_unplug_v2"
</pre><p>
</p><p>
    
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
    
</dd>
</dl><p></p></section><section class="page" id="simulator-api.html"><h1 class="jdocu"><a id="simulator-api.html:Simulator-API">6 Simulator API</a></h1>
<p>
    
</p><p>
    The Simics Simulator API completes the Device API defined in the Model
    Builder product to give full access to the Simics API from user-written
    extensions, in DML, Python or C/C++. The Simulator API is the same in all
    languages but the syntax of the types and functions declarations will of
    course differ.
</p><p>
    
    
</p></section><section class="page" id="simulator-api-data-types.html"><h1 class="jdocu"><a id="simulator-api-data-types.html:Simulator-API-Data-Types">6.1 Simulator API Data Types</a></h1>
<p>

    </p><h2 class="jdocu"><a id="simulator-api-data-types.html:Generic-Data-Types">6.1.1 Generic Data Types</a></h2>
<p></p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-data-types.html:addr_prof_iter_t">addr_prof_iter_t</a></h3>
<p>
   
   
     <a id="simulator-api-data-types.html:addr_prof_iter_t2"></a>
     
     </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-data-types.html:__jdocu_seealso_addr_prof_iter_t"></a>addr_prof_iter_t</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">typedef struct addr_prof_iter {
        uint64 (*next)(struct addr_prof_iter *i);
        void (*destroy)(struct addr_prof_iter *i);
        generic_address_t addr;
} addr_prof_iter_t;</pre><p>

       </p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
An address profile iterator will iterate over a specified portion of the
         address space in some unspecified order, and return every nonzero counter
         value exactly once. When done, it will return 0.
  <p>
       </p></dd>
</dl><p>
   
</p></section><section class="page" id="simulator-api-functions.html"><h1 class="jdocu"><a id="simulator-api-functions.html:Simulator-API-Functions">6.2 Simulator API Functions</a></h1>
<p>

    

</p><p>
</p><h2 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:Breakpoints">Breakpoints</a></h2>
<p></p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_break_cycle">SIM_break_cycle()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_break_cycle2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_break_cycle"></a><b>SIM_break_cycle</b>  insert breakpoint in time queue</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_break_cycle(conf_object_t *NOTNULL obj, int64 cycles);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Insert a breakpoint event at <i>cycles</i> clock cycles from now,
   causing simulation to stop when reached by <i>obj</i>.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_break_step">SIM_break_step()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_break_step2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_break_step"></a><b>SIM_break_step</b>  set a step breakpoint</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_break_step(conf_object_t *NOTNULL obj, int64 steps);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Sets a step breakpoint on a processor. The <i>steps</i>
   argument is the number of instructions until the break occurs.</dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_InterfaceNotFound</b> Thrown if the <i>obj</i> object
   doesn't implement the <code>step</code> interface.
   <p>
   </p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_breakpoint">SIM_breakpoint()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_breakpoint2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_breakpoint"></a><b>SIM_breakpoint</b>  set breakpoint</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">breakpoint_id_t
SIM_breakpoint(conf_object_t *NOTNULL obj,
               breakpoint_kind_t kind,
               access_t access,
               uint64 address,
               uint64 length,
               breakpoint_flag_t flags);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Add breakpoint on an <i>object</i> implementing
   the <code>breakpoint</code> interface. This is typically
   a memory space object such as physical memory.
<p>
   Please note that breakpoints set by this function may not appear in
   the output from <b>bp.list</b>. It's recommended to use the
   <b>bp.memory.break</b> command to set breakpoints.
</p><p>
   The <i>kind</i> argument sets what type of address to break on:
</p><p>
   
   <a id="simulator-api-functions.html:breakpoint_kind_t"></a>
   </p><pre class="jdocu_small">typedef enum {
        Sim_Break_Physical = 0,
        Sim_Break_Virtual  = 1,
        Sim_Break_Linear   = 2      /* x86 only */
} breakpoint_kind_t;</pre><p>
</p><p>
   
</p><p>
   The <i>access</i> argument is a bit-field setting the type of
   access. Any combination of the three alternatives can be given (added
   together).
</p><p>
   
   <a id="simulator-api-functions.html:access_t"></a>
   </p><pre class="jdocu_small">typedef enum {
        Sim_Access_Read = 1,
        Sim_Access_Write = 2,
        Sim_Access_Execute = 4
} access_t;</pre><p>
</p><p>
   
</p><p>
   The <i>address</i> is the start of the breakpoint range and
   <i>length</i> is its length in bytes. This range will be truncated
   as necessary to fit in the address space. An access intersecting the given
   range will trigger the breakpoint. If <i>length</i> is zero, the
   breakpoint range will be the entire address space.
</p><p>
   The <i>flags</i> argument should be the sum of
   zero or more enumeration constants from 
   <code>breakpoint_flag_t</code>:
</p><p>
   <a id="simulator-api-functions.html:breakpoint_flag_t"></a><a id="simulator-api-functions.html:breakpoint_flag_t2"></a>
   
</p><pre class="jdocu_small">typedef enum breakpoint_flag {
        Sim_Breakpoint_Temporary = 1,
        Sim_Breakpoint_Simulation = 2,
        Sim_Breakpoint_Private = 4
} breakpoint_flag_t;</pre><p>

</p><p>
   If the <code>Sim_Breakpoint_Temporary</code> bit is set, the breakpoint
   is automatically disabled when triggered the first time.
</p><p>
   If the <code>Sim_Breakpoint_Simulation</code> bit is set, the breakpoint
   will not show up in the <b>bp.list</b> command, nor can
   it be removed by the <b>bp.delete</b> command. Also,
   there will be no message printed on the Simics console when this breakpoint
   is triggered. This bit should be set when using breakpoints to simulate the
   target system.
</p><p>
   If the <code>Sim_Breakpoint_Private</code> bit is set, the breakpoint will
   not show up in the <b>bp.list</b> command, nor can it be
   removed by the <b>bp.delete</b> command.
</p><p>
   The default action for a triggered breakpoint is to return to the frontend
   (this can be changed  by using haps). On execution breakpoints Simics will
   return to the frontend before the instructions is executed, while
   instructions triggering read or write breakpoints will complete before
   control is returned to the frontend.
</p><p>
   Several breakpoints can be set on the same address and Simics will break on
   them in turn. If hap handlers are connected to the breakpoints they will
   also be executed in turn. Hap handlers are called before the access is
   performed, allowing the user to read a memory value that may be overwritten
   by the access. See the Simics Reference Manual for a description of hap
   handlers.
</p><p>
   Several attributes can be set for a breakpoint for breaking only when some
   conditions are true. See the <i>breakpoints</i> attribute in the
   <b>sim</b> class.
</p><p>
   This function returns the breakpoint id which is used for further reference
   to the breakpoint:
</p><p>
   <a id="simulator-api-functions.html:breakpoint_id_t"></a>
</p><pre class="jdocu_small">typedef int breakpoint_id_t;</pre><p>

</p><p>
   Breakpoints can be removed using <b><i>SIM_delete_breakpoint</i></b>.</p></dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_General</b> Thrown if the type or access arguments are
   illegal. Also thrown if obj cannot handle breakpoints of the given kind.
   <p>
   </p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Breakpoint id, -1 on exception.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
     </a><b><i>SIM_breakpoint_remove</i></b>, <b><i>SIM_delete_breakpoint</i></b>
   </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_breakpoint_remove">SIM_breakpoint_remove()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_breakpoint_remove2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_breakpoint_remove"></a><b>SIM_breakpoint_remove</b>  delete breakpoint range</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_breakpoint_remove(int id,
                      access_t access,
                      generic_address_t address,
                      generic_address_t length);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Deletes a breakpoint range from an existing breakpoint. Can thus be used to
   create holes in the breakpoint range. <i>id</i> is the breakpoint
   to operate on, as returned by <b><i>SIM_breakpoint</i></b>. A value of zero
   will operate on all breakpoints that were not set using the
   <code>Sim_Breakpoint_Simulation</code> flag.
<p>
   <i>access</i> is a bitfield describing the type of breakpoint to
   remove using the enumeration constants of the <code>access_t</code> enum.
</p><p>
   <i>address</i> is the start address of the range and
   <i>length</i> is the length of the range in bytes.</p></dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_Index</b> Thrown if illegal breakpoint
   <p>
   </p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
     </a><b><i>SIM_breakpoint</i></b>, <b><i>SIM_delete_breakpoint</i></b>
   </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_delete_breakpoint">SIM_delete_breakpoint()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_delete_breakpoint2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_delete_breakpoint"></a><b>SIM_delete_breakpoint</b>  delete breakpoint</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_delete_breakpoint(breakpoint_id_t id);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Deletes breakpoint <i>id</i> as returned by
   <b><i>SIM_breakpoint</i></b>. A value of zero will delete all breakpoints
   that were set without the <code>Sim_Breakpoint_Simulation</code> flag.</dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_Index</b> Thrown if no breakpoint with the id is found.
   <p>
   </p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_disable_breakpoint">SIM_disable_breakpoint()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_disable_breakpoint2"></a><a id="simulator-api-functions.html:SIM_enable_breakpoint"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_disable_breakpoint"></a><b>SIM_disable_breakpoint</b><b>, SIM_enable_breakpoint</b>  disable breakpoint</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_disable_breakpoint(breakpoint_id_t id);
</pre><p></p><pre class="jdocu_small">void
SIM_enable_breakpoint(breakpoint_id_t id);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Enables and disables breakpoint <i>id</i>, as returned by
   <b><i>SIM_breakpoint</i></b>.</dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_Index</b> Thrown if no breakpoint with the id is found.
   </dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>

</p><h2 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:Configuration">Configuration</a></h2>
<p></p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_add_configuration">SIM_add_configuration()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_add_configuration2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_add_configuration"></a><b>SIM_add_configuration</b>  set configuration from Python</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_add_configuration(pre_conf_object_set_t *NOTNULL set,
                      const char *file);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This function creates objects from the parse objects in <i>set</i>
  and adds the initialized objects to the current configuration (creating one
  if necessary).
  When called from Python (which is the intended usage), the configuration
  <i>set</i> is a sequence (list or tuple) of pre_conf_object Python
  objects, or a dictionary of the form
  <nobr><code>{</code><i>name</i><code> : </code><i>pre_conf_object</i><code>}</code></nobr>.
<p>
  The <i>file</i> argument is the name of the file that a configuration
  was read from, and should be set to None/NULL if not used.
</p><p>
  The following examples are written in Python. As they do not map any devices
  in <code>phys_mem</code>, they will not work as stand-alone simulations.
</p><p>
  Example when <i>set</i> is a sequence:
</p><p>
  </p><pre class="jdocu_small">    clock = pre_conf_object('timer', 'clock')
    clock.freq_mhz = 20
    space = pre_conf_object('phys_mem', 'memory-space')
    space.queue = clock

    SIM_add_configuration([clock, space], None)
  </pre><p>
</p><p>
  Example when <i>set</i> is a dictionary:
</p><p>
  </p><pre class="jdocu_small">    objects = {}
    objects['clock'] = pre_conf_object('timer', 'clock')
    objects['clock'].freq_mhz = 20
    objects['space'] = pre_conf_object('phys_mem', 'memory-space')
    objects['space'].queue = objects['clock']

    SIM_add_configuration(objects, None)
  </pre><p></p></dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_General</b> Thrown if Simics fails to initialize all objects.
<p>
  </p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_create_object">
    SIM_create_object</a>, <a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_set_configuration"> SIM_set_configuration</a>, <a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_read_configuration">
    SIM_read_configuration
  </a></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_class_has_attribute">SIM_class_has_attribute()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_class_has_attribute2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_class_has_attribute"></a><b>SIM_class_has_attribute</b>  check if class implements attribute</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">bool
SIM_class_has_attribute(conf_class_t *NOTNULL cls, const char *NOTNULL attr);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns true if the class <i>cls</i> implements an attribute with
   the name <i>attr</i>.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_register_attribute">
     SIM_register_attribute</a>, <a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_get_attribute">
     SIM_get_attribute
   </a></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_create_object">SIM_create_object()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_create_object2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_create_object"></a><b>SIM_create_object</b>  create and initialize object</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">conf_object_t *
SIM_create_object(conf_class_t *NOTNULL cls, const char *name,
                  attr_value_t attrs);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Creates a new instance of the configuration class <i>cls</i>.
   <i>name</i> must consist of a letter followed by letters, digits
   or underscores (<code>_</code>). A unique name will be created if <i>name</i>
   is an empty string or NULL. For backward compatibility, hyphens (<code>-</code>)
   are allowed instead of underscores but their use is deprecated.
<p>
   The new object is initialized with attributes from
   <i>attrs</i>, which must be a list of (<i>attribute-name</i>,
   <i>value</i>) pairs, where each pair is a two-element list. All
   required attributes for the class <i>cls</i> must be present in
   <i>attrs</i>. In Python, <i>attrs</i> can be omitted (if no
   attributes are required), it can be normal lists:
   <code>[['attribute1', value1], ['attribute2', value2]]</code>
   or keyword arguments: <code>attribute1=value1, attribute2=value2</code>.
</p><p>
   Attributes in ports of the <i>cls</i> class can be initialized by
   prefixing the attribute name with the port name,
   e.g. <code>['p.portname.attr', value]</code>.
</p><p>
   The argument value may be modified, but the caller is still responsible for
   freeing it. Neither point applies when the function is called from
   Python.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
The new object, or <code>NULL</code> on
   error (in which case an exception is raised).</dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_General</b> Thrown if the name is not well-formed, if an object
   named <i>name</i> already exists, or if the initialisation failed.
   <p>
   </p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_add_configuration">
     SIM_add_configuration</a>, <a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_set_configuration"> SIM_set_configuration
   </a></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_current_checkpoint_dir">SIM_current_checkpoint_dir()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_current_checkpoint_dir2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_current_checkpoint_dir"></a><b>SIM_current_checkpoint_dir</b>  directory of checkpoint being loaded</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">char *
SIM_current_checkpoint_dir();
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
If called during the loading of a checkpoint, this function returns the
     checkpoint (bundle) directory. Otherwise, the return value is NULL. The
     directory can be absolute or relative, and may be the empty string if the
     checkpoint directory is the current working directory.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context
     </dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_read_configuration">
       SIM_read_configuration</a>, <a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_add_configuration">
       SIM_add_configuration
     </a></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_delete_objects">SIM_delete_objects()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_delete_objects2"></a><a id="simulator-api-functions.html:SIM_delete_object"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_delete_objects"></a><b>SIM_delete_objects</b><b>, SIM_delete_object</b>  delete a list of objects</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">int
SIM_delete_objects(attr_value_t val);
</pre><p></p><pre class="jdocu_small">int
SIM_delete_object(conf_object_t *NOTNULL obj);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Delete the list of objects <i>val</i> (or the single object
   <i>obj</i>) passed as argument, provided that no reference to these
   objects is left in the rest of the configuration. Descendant objects of an
   object being deleted will also be deleted.
<p>
   Some specific objects in Simics, such as <b>sim</b>, are protected
   against deletion and will be ignored by this function. 
</p><p>
   If Simics finds references to the objects in the rest of the configuration,
   a warning will be printed and the operation will be aborted. Note that in
   this case, the deletion process has started and the objects may already have
   began their clean-up routines. The safest action at this point is to fix the
   dangling references and to try to delete the objects once again.
</p><p>
   Events posted by the objects in cycle queues or step queues will be
   automatically removed. Hap callbacks and script branches waiting on deleted
   objects will be interrupted as well.</p></dd>
<dt class="jdocu_descitem">RECURSION</dt><dd>
While removing the listed objects,
   <b><i>SIM_delete_objects</i></b>
   will call various callbacks (<code>Core_Conf_Object_Pre_Delete</code> and
   <code>Core_Conf_Object_Delete</code> haps, as well as
   <b><i>pre_delete_instance</i></b> and <b><i>delete_instance</i></b> for each
   object). Recursive calls to <b><i>SIM_delete_objects</i></b> are allowed
   during the <em>pre-delete</em> phase (Pre_Delete hap and
   <b><i>pre_delete_instance</i></b> callback), and the new objects will be
   added to the current list of objects to delete. Recursive calls after this
   stage will fail.
<p>
   This limited recursion is meant to let objects that "own" other objects
   destroy them automatically if they themselves are to be deleted. This is
   used for example by the standard Simics components.</p></dd>
<dt class="jdocu_descitem">BUGS</dt><dd>
Note that for successful deletion of objects, each class
   should implement the proper deletion methods called by
   <b><i>SIM_delete_objects</i></b>. If the methods are not present,
   <b><i>SIM_delete_objects</i></b>
   will simply remove any reference to the object, but this may leave memory
   and resources unrecoverable.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Returns zero if successful. Throws an exception and
   returns non-zero otherwise.</dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_General</b> Thrown if an error occurred or a reference to the
   objects is left in the rest of the configuration.
   <p>
   </p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
The following line at the Simics prompt:
   <pre class="jdocu_small">   @SIM_delete_objects(list(SIM_object_iterator(None)))
   </pre><p>
   will delete all unprotected objects in the configuration, leaving the Simics
   session empty.</p></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_delete_snapshot">SIM_delete_snapshot()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_delete_snapshot2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_delete_snapshot"></a><b>SIM_delete_snapshot</b>  delete a snapshot</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">snapshot_error_t
SIM_delete_snapshot(const char *name);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Deletes an in-memory snapshot.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_take_snapshot">
     SIM_take_snapshot</a>, <a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_restore_snapshot"> SIM_restore_snapshot</a>, <a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_list_snapshots"> SIM_list_snapshots
   </a></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_get_all_classes">SIM_get_all_classes()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_get_all_classes2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_get_all_classes"></a><b>SIM_get_all_classes</b>  get list of all loaded classes</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">attr_value_t
SIM_get_all_classes();
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Return an unordered list of the names of all configuration classes loaded
   into simulation.
<p>
   The Python function <b><i>cli.global_cmds.list_classes</i></b> can be used to
   get class names, by default including not-loaded classes.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
List of class names.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_get_all_objects">SIM_get_all_objects()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_get_all_objects2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_get_all_objects"></a><b>SIM_get_all_objects</b>  get list of all objects</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">attr_value_t
SIM_get_all_objects();
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The function is going to be deprecated. Please use
   <b><i>SIM_object_iterator</i></b> instead.
<p>
   Return a list of all configuration objects.
   The order is unspecified and may vary between calls to this function.
</p><p>
   This function is deprecated and should not be used.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
List of objects.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<b><i>SIM_object_iterator</i></b></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_get_attribute">SIM_get_attribute()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_get_attribute2"></a><a id="simulator-api-functions.html:SIM_get_attribute_idx"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_get_attribute"></a><b>SIM_get_attribute</b><b>, SIM_get_attribute_idx</b>  get attribute</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">attr_value_t
SIM_get_attribute(conf_object_t *NOTNULL obj, const char *NOTNULL name);
</pre><p></p><pre class="jdocu_small">attr_value_t
SIM_get_attribute_idx(conf_object_t *NOTNULL obj, const char *NOTNULL name,
                      attr_value_t *NOTNULL index);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Extracts the attribute specified by <i>name</i> parameter from
   <i>obj</i>. If an error occurs, an invalid value is returned. The
   _idx version of the function can be used to get a single entry in a list or
   data attribute. The attribute must support indexing for this to work.
<p>
   The caller is as usual responsible for freeing the returned value by
   calling <b><i>SIM_attr_free</i></b>.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Attribute value. An attribute of Invalid type
   is returned if the attribute could not be read.</dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<ul>
   <li><b>SimExc_AttrNotFound</b> If the object did not have the specified
   attribute.</li>

   <li><b>SimExc_AttrNotReadable</b> If the attribute cannot be read.</li>

   <li><b>SimExc_Type</b> If the index has the wrong type.</li>

   <li><b>SimExc_General</b> If <b><i>SIM_attribute_error</i></b> or
   <b><i>SIM_c_attribute_error</i></b> was called inside the getter function.</li>
   </ul>
   </dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_attr_free">SIM_attr_free</a>, <a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_set_attribute">
   SIM_set_attribute</a>, <a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_attribute_error"> SIM_attribute_error</a></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_get_attribute_attributes">SIM_get_attribute_attributes()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_get_attribute_attributes2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_get_attribute_attributes"></a><b>SIM_get_attribute_attributes</b>  get attribute flags</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">attr_attr_t
SIM_get_attribute_attributes(conf_class_t *NOTNULL cls,
                             const char *NOTNULL attr);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns the attribute flags of the <i>attr</i> attribute of the
   class <i>cls</i>.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_register_attribute">
     SIM_register_attribute
   </a></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_get_class_attribute">SIM_get_class_attribute()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_get_class_attribute2"></a><a id="simulator-api-functions.html:SIM_get_class_attribute_idx"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_get_class_attribute"></a><b>SIM_get_class_attribute</b><b>, SIM_get_class_attribute_idx</b>  get class attribute</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">attr_value_t
SIM_get_class_attribute(conf_class_t *NOTNULL cls, const char *NOTNULL name);
</pre><p></p><pre class="jdocu_small">attr_value_t
SIM_get_class_attribute_idx(conf_class_t *NOTNULL cls,
                            const char *NOTNULL name,
                            attr_value_t *NOTNULL index);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Extracts the class attribute specified by <i>name</i> from the class
   <i>cls</i>. If an error occurs, an invalid value is returned. The
   _idx version of the function can be used to get a single entry in a list or
   data attribute. The attribute must support indexing for this to work.
<p>
   The caller is as usual responsible for freeing the returned value by
   calling <b><i>SIM_attr_free</i></b>.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Attribute value. A value of Invalid type is
   returned if the attribute could not be read.</dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<ul>
       <li><b>SimExc_AttrNotFound</b> If the class did not have the specified
       attribute.</li>

       <li><b>SimExc_AttrNotReadable</b> If the attribute cannot not be
       read.</li>

       <li><b>SimExc_Type</b> If the index has the wrong type.</li>

       <li><b>SimExc_General</b> Other errors.</li>
     </ul>
   </dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context, unless the attribute
   documentation says otherwise.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_attr_free">
     SIM_attr_free</a>, <a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_set_class_attribute"> SIM_set_class_attribute
   </a></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_get_object">SIM_get_object()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_get_object2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_get_object"></a><b>SIM_get_object</b>  get object</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">conf_object_t *
SIM_get_object(const char *NOTNULL name);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns the object with name <i>name</i>.
<p>
   The function does an object look-up in the order; <em>object ID</em>,
   <em>object name</em>, and <em>hierarchical location</em> for all objects in
   the simulation. The function returns the first match from the look-up or
   NULL if there was no object match.
</p><p>
   The <em>object ID</em> is a unique name that never changes and is returned
   by the <b><i>SIM_object_id</i></b> function. The <em>object name</em> is the
   name of the object, used for instance when printing log messages and is
   returned by the <b><i>SIM_object_name</i></b> function. The <em>hierarchical
   location</em> is the absolute location of the object in the component
   hierarchy. The <em>object name</em> and the <em>hierarchical location</em>
   is the same.
</p><p>
   Please note that in Python Simics objects are available directly
   as attributes of the <code>conf</code> module. For example, one can access
   the <b>sim</b> object like this: </p><pre class="jdocu_small">conf.sim</pre><p>.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Object, or NULL if not found.
   </dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_General</b> Thrown if the object can not be found.
   <p>
   </p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_object_name">SIM_object_name</a>, <a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_object_id">
   SIM_object_id</a>, <a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_object_parent"> SIM_object_parent</a>, <a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_object_descendant"> SIM_object_descendant</a></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_get_python_interface_type">SIM_get_python_interface_type()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_get_python_interface_type2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_get_python_interface_type"></a><b>SIM_get_python_interface_type</b>  get Python interface type</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">PyObject *
SIM_get_python_interface_type(const char *NOTNULL name);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns the Python data type for the <i>name</i> interface, or NULL
   if not available from Python.
<p>
   If necessary, will try to load modules registering the Python translation
   for this interface.</p></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_get_snapshot_info">SIM_get_snapshot_info()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_get_snapshot_info2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_get_snapshot_info"></a><b>SIM_get_snapshot_info</b>  get information about a snapshot</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">attr_value_t
SIM_get_snapshot_info(const char *NOTNULL name);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns a dictionary of information about a snapshot.
   The currently defined keys in the dictionary are:
   <dl><dt id="simulator-api-functions.html:dt:name"><a href="#simulator-api-functions.html:dt:name"><b>name</b></a></dt><dd>The name of the snapshot</dd><dt id="simulator-api-functions.html:dt:pages"><a href="#simulator-api-functions.html:dt:pages"><b>pages</b></a></dt><dd>The number of non-zero image pages in the snapshot</dd><dt id="simulator-api-functions.html:dt:previous"><a href="#simulator-api-functions.html:dt:previous"><b>previous</b></a></dt><dd>The name of the latest snapshot taken or restored
        before this snapshot was taken. <code>nil</code> if there was no
        such snapshot, or if that snapshot has been deleted.</dd></dl><p></p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_list_snapshots">
     SIM_list_snapshots</a>, <a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_take_snapshot"> SIM_take_snapshot</a>, <a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_restore_snapshot"> SIM_restore_snapshot</a>, <a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_delete_snapshot">
     SIM_delete_snapshot
   </a></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_is_restoring_snapshot">SIM_is_restoring_snapshot()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_is_restoring_snapshot2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_is_restoring_snapshot"></a><b>SIM_is_restoring_snapshot</b>  check if a snapshot is currently being restored</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">bool
SIM_is_restoring_snapshot();
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns <code>true</code> if an in-memory snapshot is currently being
   restored.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_list_snapshots">SIM_list_snapshots()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_list_snapshots2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_list_snapshots"></a><b>SIM_list_snapshots</b>  list snapshots</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">attr_value_t
SIM_list_snapshots();
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns a list of the names of the currently taken snapshots.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_take_snapshot">
     SIM_take_snapshot</a>, <a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_restore_snapshot"> SIM_restore_snapshot</a>, <a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_delete_snapshot"> SIM_delete_snapshot</a>, <a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_get_snapshot_info">
     SIM_get_snapshot_info
   </a></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_object_class">SIM_object_class()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_object_class2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_object_class"></a><b>SIM_object_class</b>  get object class</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE conf_class_t *
SIM_object_class(const conf_object_t *NOTNULL obj);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns the class of an object.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<b><i>SIM_get_class</i></b></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_object_descendant">SIM_object_descendant()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_object_descendant2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_object_descendant"></a><b>SIM_object_descendant</b>  return a descendant of the specified object</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">conf_object_t *
SIM_object_descendant(conf_object_t *obj, const char *NOTNULL relname);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This function returns the descendant object of <i>obj</i>
   which has the relative name <i>relname</i>, or NULL if
   no such object exists.
<p>
   It is legal for the relative name to contain multiple components,
   like "device.p.RESET".
</p><p>
   If <i>obj</i> is NULL, then the object lookup is performed
   relative the object hierarchy root.
</p><p>
   If <i>obj</i> is instantiated at the same time as the descendant,
   then the function is guaranteed to succeed if called after the
   <b><i>alloc_object</i></b> phase of object initialization; i.e., it is safe for
   <i>obj</i> to invoke the function from its <b><i>init_object</i></b>
   method.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Object, or NULL if the object has no
   hierarchical descendant with the specified relative name.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
        </a><b><i>SIM_object_parent</i></b>
        <b><i>SIM_register_port</i></b>
   </dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_object_is_processor">SIM_object_is_processor()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_object_is_processor2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_object_is_processor"></a><b>SIM_object_is_processor</b>  test if object is a processor</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">bool
SIM_object_is_processor(conf_object_t *NOTNULL obj);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns non-zero if <i>obj</i> is a processor.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
All contexts (including Threaded Context)
   </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_object_iterator">SIM_object_iterator()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_object_iterator2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_object_iterator"></a><b>SIM_object_iterator</b>  start object iteration</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">object_iter_t
SIM_object_iterator(conf_object_t *obj);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The <b><i>SIM_object_iterator</i></b> function returns an
   iterator for the descendants of the object <i>obj</i>.
   If <i>obj</i> is NULL, then the returned iterator
   will iterate over all objects in the configuration.
<p>
   The iterator returns objects sorted by name,
   with parents before children.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Object iterator</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
Sample C code to find all objects implementing
   <code>signal</code> interface:<br>
   <pre class="jdocu_small">    #include &lt;simics/util/vect.h&gt;
    #include &lt;simics/devs/signal.h&gt;

    ...

    VECT(conf_object_t *) v = VNULL;
    object_iter_t it = SIM_object_iterator(NULL);
    conf_object_t *obj;
    while ((obj = SIM_object_iterator_next(&amp;it)) != NULL) {
        if (SIM_C_GET_INTERFACE(obj, signal) != NULL)
            VADD(v, obj);
    }
    ...  // any code using 'v' vector here
    VFREE(v);
   </pre><p>
</p><p>

   Sample Python code to find all objects implementing
   <code>signal</code> interface:<br>
   </p><pre class="jdocu_small">    v = []
    for obj in SIM_object_iterator(None):
        if hasattr(obj.iface, simics.SIGNAL_INTERFACE):
            v.append(obj)</pre><p>
</p><p>
   The <code>simics.SIGNAL_INTERFACE</code> constant from the above
   example holds </p><pre class="jdocu_small">"signal"</pre><p> string. Such constants are
   available for some interfaces. One can safely use string literals instead.
   </p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<b><i>SIM_object_iterator_next,
        SIM_shallow_object_iterator,
        SIM_object_iterator_for_class,
        SIM_object_iterator_for_interface</i></b></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_object_iterator_for_class">SIM_object_iterator_for_class()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_object_iterator_for_class2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_object_iterator_for_class"></a><b>SIM_object_iterator_for_class</b>  start class instance iteration</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">object_iter_t
SIM_object_iterator_for_class(conf_class_t *cls);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The <b><i>SIM_object_iterator_for_class</i></b> function returns an iterator
   for the instances of the class <i>cls</i>. See
   <b><i>SIM_object_iterator</i></b> for examples on how to use the iterator.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Object iterator</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<b><i>SIM_object_iterator_next,
        SIM_object_iterator,
        SIM_object_iterator_for_interface</i></b></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_object_iterator_for_interface">SIM_object_iterator_for_interface()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_object_iterator_for_interface2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_object_iterator_for_interface"></a><b>SIM_object_iterator_for_interface</b>  start class instance iteration</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">object_iter_t
SIM_object_iterator_for_interface(attr_value_t ifaces);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The <b><i>SIM_object_iterator_for_interface</i></b> function returns an
   iterator for the objects that implement all interfaces in <i>ifaces</i>
   (i.e. all objects if <i>ifaces</i> is empty), which must be a list of
   strings of length at most 16. See <b><i>SIM_object_iterator</i></b> for
   examples on how to use the iterator.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Object iterator</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<b><i>SIM_object_iterator_next,
        SIM_object_iterator,
        SIM_object_iterator_for_class</i></b></dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_General</b> Thrown if the <i>ifaces</i> argument does not
   conform to the above requirements.
<p>
   </p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_object_iterator_next">SIM_object_iterator_next()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_object_iterator_next2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_object_iterator_next"></a><b>SIM_object_iterator_next</b>  get next object</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">conf_object_t *
SIM_object_iterator_next(object_iter_t *iter);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The <b><i>SIM_object_iterator_next</i></b> function returns the next
   object from an iterator obtained from <b><i>SIM_object_iterator</i></b>
   or <b><i>SIM_shallow_object_iterator</i></b>. If there are no more
   objects in the sequence, then NULL is returned.
<p>
   It is illegal to call <b><i>SIM_object_iterator_next</i></b> using
   an iterator which has reached the end of its sequence.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Next object or NULL</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<b><i>SIM_object_iterator_next,
        SIM_object_iterator</i></b></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_object_parent">SIM_object_parent()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_object_parent2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_object_parent"></a><b>SIM_object_parent</b>  get object parent</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">conf_object_t *
SIM_object_parent(conf_object_t *NOTNULL obj);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns the hierarchical parent of the specified object.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Object, or NULL if the object has no
   hierarchical parent.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
   </a><b><i>SIM_object_descendant, SIM_port_object_parent</i></b></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_port_object_parent">SIM_port_object_parent()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_port_object_parent2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_port_object_parent"></a><b>SIM_port_object_parent</b>  get object parent</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">conf_object_t *
SIM_port_object_parent(conf_object_t *NOTNULL obj);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns the parent of the specified port object.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Object, or NULL if the object is not
   a port object.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<b><i>SIM_object_parent, SIM_object_descendant</i></b></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_printf_error">SIM_printf_error()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_printf_error2"></a><a id="simulator-api-functions.html:SIM_printf_error_vararg"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_printf_error"></a><b>SIM_printf_error</b><b>, SIM_printf_error_vararg</b>  print error message</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_printf_error(const char *format, ...);
</pre><p></p><pre class="jdocu_small">void
SIM_printf_error_vararg(const char *format, va_list ap);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This can be used to print an error message during the simulation. It is
   analogous to log error messages, but for non-device code. I.e. it should be
   used for errors that prevents the simulation from continuing.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_printf_warning">SIM_printf_warning</a></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_printf_warning">SIM_printf_warning()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_printf_warning2"></a><a id="simulator-api-functions.html:SIM_printf_warning_vararg"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_printf_warning"></a><b>SIM_printf_warning</b><b>, SIM_printf_warning_vararg</b>  print warning message</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_printf_warning(const char *format, ...);
</pre><p></p><pre class="jdocu_small">void
SIM_printf_warning_vararg(const char *format, va_list ap);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This can be used to print a warning message during the simulation. It is
   analogous to log warning messages, but for non-device code. I.e. it should be
   used for problems that do not prevent the simulation from continuing.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_printf_error">SIM_printf_error</a></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_read_configuration">SIM_read_configuration()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_read_configuration2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_read_configuration"></a><b>SIM_read_configuration</b>  read configuration</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_read_configuration(const char *NOTNULL file);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Read configuration from <i>filename</i> and create a machine
   accordingly.</dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_General</b> Thrown if the file could not be opened, the machine
   was already initialized, or if an error in the configuration file was
   detected.
   <p>
   </p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_register_context_handler">SIM_register_context_handler()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_register_context_handler2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_register_context_handler"></a><b>SIM_register_context_handler</b>  register mandatory interface and attribute for context handler
   objects</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">int
SIM_register_context_handler(conf_class_t *NOTNULL cls,
                             const context_handler_interface_t *NOTNULL iface);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Register the <i>cls</i> class as a class for context handler
   objects. This includes registering the <code>context_handler</code>
   interface (<i>iface</i>), in addition to which
   <b><i>SIM_register_context_handler</i></b> registers a
   <i>current_context</i> attribute which will hold the current context.
<p>
   The <code>context_handler</code> interface will be wrapped by standard
   functions so that standard context change behavior is taken care off
   automatically. This includes, among other things, making sure that the
   context is valid, and triggering the correct haps on context changes. Thus
   the context_handler implementation need only care about the effect of the
   change on the <code>context</code>_handler object itself (virtual
   breakpoints present in the context, cache flushing, etc.).
</p><p>
   The return value is 0 if everything works, and non-zero if something
   fails. <b><i>SIM_register_context_handler</i></b> will return the error value
   provided by <b><i>SIM_register_interface</i></b>.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Returns non-zero on failure, 0 otherwise.
   </dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_General</b> Thrown if the <code>context_handler</code> interface
   has already been registered for this class.
<p>
   </p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<b><i>SIM_register_interface</i></b></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_restore_snapshot">SIM_restore_snapshot()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_restore_snapshot2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_restore_snapshot"></a><b>SIM_restore_snapshot</b>  restore a snapshot of the configuration state</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">snapshot_error_t
SIM_restore_snapshot(const char *name);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Restores the state of the configuration to a previously taken snapshot.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_take_snapshot">
     SIM_take_snapshot</a>, <a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_delete_snapshot"> SIM_delete_snapshot</a>, <a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_list_snapshots"> SIM_list_snapshots
   </a></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_set_attribute">SIM_set_attribute()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_set_attribute2"></a><a id="simulator-api-functions.html:SIM_set_attribute_idx"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_set_attribute"></a><b>SIM_set_attribute</b><b>, SIM_set_attribute_idx</b>  set attribute</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">set_error_t
SIM_set_attribute(conf_object_t *NOTNULL obj,
                  const char *NOTNULL name,
                  attr_value_t *NOTNULL value);
</pre><p></p><pre class="jdocu_small">set_error_t
SIM_set_attribute_idx(conf_object_t *NOTNULL obj,
                      const char *NOTNULL name,
                      attr_value_t *NOTNULL index,
                      attr_value_t *NOTNULL value);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Set the <i>name</i> attribute in <i>obj</i> to <i>value</i>.
<p>
   The <code>_idx</code> version of the function can be used to get a
   single entry in a list or data attribute. For this to work, the
   attribute must support indexing.
</p><p>
   After the call the <i>value</i> is still owned by the caller.
</p><p>
   If the attribute setter function calls <b><i>SIM_attribute_error</i></b> or
   <b><i>SIM_c_attribute_error</i></b> and returns Sim_Set_Ok, it is treated like
   Sim_Set_IllegalValue.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
The return value is from the
   <code>set_error_t</code> enum, with <code>Sim_Set_Ok</code> indicating
   success.<a id="simulator-api-functions.html:set_error_t"></a></dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<ul>
   <li><b>SimExc_AttrNotFound</b> If the object did not have the specified
   attribute</li>

   <li><b>SimExc_AttrNotWritable</b> if the attribute cannot not be
   written</li>

   <li><b>SimExc_Type</b> if the index has the wrong type, the value to be set
   does not match the type specified by the attribute or the setter function
   returned Sim_Set_Illegal_Type</li>

   <li><b>SimExc_IllegalValue</b> if the setter function returned
   Sim_Set_Illegal_Value</li>

   <li><b>SimExc_Index</b> if the setter function returned
   Sim_Set_Illegal_Index</li>

   <li><b>SimExc_InterfaceNotFound</b> if the setter function returned
   Sim_Set_Interface_Not_Found</li>

   <li><b>SimExc_General</b> if the setter function returned something else than
   Sim_Set_Ok, Sim_Set_Illegal_Type, Sim_Set_Illegal_Value,
   Sim_Set_Illegal_Index or Sim_Set_Interface_Not_Found.</li>
   </ul>
   </dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context in general; individual attributes may be less
     constrained.
   </dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_get_attribute">
     SIM_get_attribute</a>, <a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_attribute_error">
     SIM_attribute_error</a>, <a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_set_error_t">
     set_error_t
   </a></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_set_class_attribute">SIM_set_class_attribute()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_set_class_attribute2"></a><a id="simulator-api-functions.html:SIM_set_class_attribute_idx"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_set_class_attribute"></a><b>SIM_set_class_attribute</b><b>, SIM_set_class_attribute_idx</b>  set class attribute</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">set_error_t
SIM_set_class_attribute(conf_class_t *NOTNULL cls,
                        const char *NOTNULL name,
                        attr_value_t *NOTNULL value);
</pre><p></p><pre class="jdocu_small">set_error_t
SIM_set_class_attribute_idx(conf_class_t *NOTNULL cls,
                            const char *NOTNULL name,
                            attr_value_t *NOTNULL index,
                            attr_value_t *NOTNULL value);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Set the <i>name</i> attribute in <i>cls</i> to <i>value</i>.
<p>
   The <code>_idx</code> version of the function can be used to set a
   single entry in a list or data attribute. For this to work, the
   attribute must support indexing.
</p><p>
   After the call the <i>value</i> is still owned by the caller.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
The return value is from the
   <code>set_error_t</code> enum, with <code>Sim_Set_Ok</code> indicating
   success.<a id="simulator-api-functions.html:set_error_t2"></a></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_get_attribute">
     SIM_get_attribute</a>, <a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_set_error_t"> set_error_t
   </a></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_set_configuration">SIM_set_configuration()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_set_configuration2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_set_configuration"></a><b>SIM_set_configuration</b>  set configuration from data</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_set_configuration(attr_value_t conf);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<div class="note">
<b>Note:</b>
It is recommended that the <b><i>SIM_add_configuration</i></b> function is
  used instead of <b><i>SIM_set_configuration</i></b>.</div>This function is an alternative to reading the configuration
  from a file. A configuration is an <code>attr_value_t</code>
  which should have the following structure.
<p>
  <span class="jdocu_smaller"></span></p><pre class="jdocu_small">  (("name", "class",  ("attr_name", attr_val) ... ), ... )
  </pre><p>
</p><p>
  That is a list of object specifiers containing name, class,
  and a list of attribute specifiers. An attribute specifier is
  a list of length 2 containing the attribute name and its
  value. <b><i>SIM_set_configuration</i></b> allows an easy way
  of parameterizing the configuration, especially if called from
  Python.
</p><p>
  The argument value may be modified, but the caller is still responsible for
  freeing it. Neither point applies when the function is called from
  Python.</p></dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
The following is a Python example:
<p>
  <span class="jdocu_small">
  </span></p><pre class="jdocu_small">  from configuration import OBJ
  from simics import SIM_set_configuration

  SIM_set_configuration([
   ["cpu0", "x86",
    ["queue", OBJ("cpu0")],
    ["freq_mhz", 20],
    ["physical_memory", OBJ("phys_mem0")]],

   ["phys_mem0", "memory-space",
    ["map",  [[0xa0000,    OBJ("vga0"),    1, 0, 0x20000],
              [0x00000,    OBJ("mem0"),    0, 0x00000, 0xA0000],
              [0xc0000,    OBJ("mem0"),    0, 0xc0000, 0x8000],
              [0xc8000,    OBJ("setmem0"), 0, 0, 0x28000],
              [0xf0000,    OBJ("mem0"),    0, 0xf0000, 0x10000],
              [0x100000,   OBJ("mem0"),    0, 0x100000, 0x3ff00000],
              [0xfee00000, OBJ("apic0"),   0, 0, 0x4000]]]],
      ... ])
  </pre><p>
  
  </p></dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_Attribute</b> Thrown if malformed configuration list.<br>
<p>
  <b>SimExc_General</b> Thrown if Simics fails to initialize all objects.
</p><p>
  </p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_add_configuration">
    SIM_add_configuration</a>, <a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_create_object"> SIM_create_object
  </a></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_shallow_object_iterator">SIM_shallow_object_iterator()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_shallow_object_iterator2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_shallow_object_iterator"></a><b>SIM_shallow_object_iterator</b>  start object iteration</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">object_iter_t
SIM_shallow_object_iterator(conf_object_t *obj);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The <b><i>SIM_shallow_object_iterator</i></b> function returns an
   iterator for the direct children of the object <i>obj</i>.
   If <i>obj</i> is NULL, then the returned iterator
   will iterate over objects on the root level.
<p>
   The iterator returns objects sorted by name.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Object iterator</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<b><i>SIM_object_iterator_next,
        SIM_object_iterator</i></b></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_take_snapshot">SIM_take_snapshot()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_take_snapshot2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_take_snapshot"></a><b>SIM_take_snapshot</b>  take snapshot of the current configuration</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">snapshot_error_t
SIM_take_snapshot(const char *name);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Takes an in-memory snapshot of the state of all objects.
   Objects whose <code>class_kind_t</code> is equal to
   <code>Sim_Class_Kind_Pseudo</code> are not saved.
   This also holds for attributes (in all objects) of type 
   <code>Sim_Attr_Pseudo</code>.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_restore_snapshot">
     SIM_restore_snapshot</a>, <a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_delete_snapshot"> SIM_delete_snapshot</a>, <a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_list_snapshots"> SIM_list_snapshots
   </a></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_write_configuration_to_file">SIM_write_configuration_to_file()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_write_configuration_to_file2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_write_configuration_to_file"></a><b>SIM_write_configuration_to_file</b>  write configuration</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_write_configuration_to_file(const char *NOTNULL file, save_flags_t flags);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Saves all objects to <i>filename</i>. Objects whose
   <code>class_kind_t</code> is equal to <code>Sim_Class_Kind_Session</code>
   or <code>Sim_Class_Kind_Pseudo</code> are not saved. This also holds for
   attributes (in all objects) of type Sim_Attr_Pseudo.
<p>
   The <i>flags</i> argument should be 0.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_write_persistent_state">SIM_write_persistent_state()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_write_persistent_state2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_write_persistent_state"></a><b>SIM_write_persistent_state</b>  save persistent state</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_write_persistent_state(const char *file, conf_object_t *root,
                                    save_flags_t flags);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Saves the persistent state to a <i>file</i>. Persistent
   data typically includes disk images, NVRAM and flash memory contents
   and clock settings, i.e data that survives reboots. The Persistent
   state is saved as a standard simics configuration.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
</dl><p>

</p><h2 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:Embedding-Simics">Embedding Simics</a></h2>
<p></p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_get_init_arg_string">SIM_get_init_arg_string()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_get_init_arg_string2"></a><a id="simulator-api-functions.html:SIM_get_init_arg_boolean"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_get_init_arg_string"></a><b>SIM_get_init_arg_string</b><b>, SIM_get_init_arg_boolean</b>  get an argument that the Simics core was initialized with</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">const char *
SIM_get_init_arg_string(const char *name, const char *default_value);
</pre><p></p><pre class="jdocu_small">bool
SIM_get_init_arg_boolean(const char *name, bool default_value);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns the value of init argument <i>name</i> previously supplied
   to Simics using <b><i>SIM_init_simulator2</i></b>. Arguments are either strings
   (<code>char *</code>) or booleans (<code>bool</code>).
<p>
   This function is only needed when directly embedding
   <code>libsimics-common</code> in another application, which is deprecated.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
The argument value or
   <i>default_value</i> if the argument was not supplied to
   <b><i>SIM_init_simulator2</i></b> or if the argument value was NULL.
   </dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_General</b> Thrown if the argument is of the wrong type.
   </dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<b><i>SIM_init_simulator2</i></b></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_init_command_line">SIM_init_command_line()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_init_command_line2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_init_command_line"></a><b>SIM_init_command_line</b>  initialize the Simics command line</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_init_command_line();
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<b><i>SIM_init_command_line</i></b> initializes the Simics command line used
   when running from a Linux shell or the Windows Command Prompt.
<p>
   This function must be called after the Simics Python module has been loaded
   and should only be called when embedding Simics in another application.</p></dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_General</b> Thrown if the function already has been called once.
<p>
   </p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
     </a><b><i>SIM_main_loop</i></b>
   </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_init_environment">SIM_init_environment()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_init_environment2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_init_environment"></a><b>SIM_init_environment</b>  perform early initialization of the simulator</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_init_environment(char **NOTNULL argv,
                     bool handle_signals, bool allow_core_dumps);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The <b><i>SIM_init_environment</i></b> function should be called as early as
   possible when Simics is embedded in another application, before any other
   Simics API function. It will initialize Simics dynamic memory handling
   <code>VTMEM</code>, set up signal handling and perform some other early
   initialization.
<p>
   The <i>argv</i> argument is a NULL terminated list of strings. It must
   not be NULL. It must contain at least one element, which will be used as
   the program name. Often you can use the <i>argv</i> that <b><i>main</i></b> receives as the value of this argument.
</p><p>
   If <i>handle_signals</i> is true, Simics will install its handler for
   Control-C, e.g. the SIGINT signal on Linux and ConsoleCtrlHandler on
   Windows. Set this value to false if the embedding application handles
   signals itself.
</p><p>
   If <i>allow_core_dumps</i> is true, Simics will not install handlers for
   fatal signals but instead let the application crash possibly generating a
   core dump on Linux systems. If the argument is false, no core
   dump is generated and Simics will try to catch fatal signals and return
   control to the command line again.
</p><p>
   This function is only needed when directly embedding
   <code>libsimics-common</code> in another application, which is deprecated.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_init_simulator2">SIM_init_simulator2()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_init_simulator22"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_init_simulator2"></a><b>SIM_init_simulator2</b>  perform initialization of the simulator</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_init_simulator2(init_arg_t *NOTNULL init_args);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<b><i>SIM_init_simulator2</i></b> initializes the simulator core and should
   only be called when embedding Simics in another application. It has to be
   called after <b><i>SIM_init_environment</i></b> but before using most other
   parts of the Simics API. The <i>init_args</i> argument is an array with
   <code>init_arg_t</code> structs, where the last entry has NULL in the
   <code>name</code> field.
<p>
   Each entry in the <i>init_args</i> array contains an argument name
   and an associated value that is either a string or a boolean. Simics has a
   number of pre-defined arguments that are used to configure the simulator.
</p><p>
   It is possible to provide additional arguments in the call to
   <b><i>SIM_init_simulator2</i></b>. Such arguments are ignored by Simics and
   assumed to be used-defined. Their values can be obtained using the
   <b><i>SIM_get_init_arg_string</i></b> and <b><i>SIM_get_init_arg_boolean</i></b>
   functions in the Simics API.
</p><p>
   List of pre-defined parameters and their types:
   <table>

   <tbody><tr><td class="jdocu_noborder">batch-mode</td>         <td class="jdocu_noborder">bool</td>
     <td class="jdocu_noborder">See -batch-mode command line flag.</td></tr>

   <tr><td class="jdocu_noborder">deprecation-level</td>  <td class="jdocu_noborder">char *</td>
     <td class="jdocu_noborder">One of <code>0</code>, <code>1</code> and <code>2</code>.
         See the sim.deprecation_level attribute.</td></tr>

   <tr><td class="jdocu_noborder">gui-mode</td>           <td class="jdocu_noborder">char *</td>
     <td class="jdocu_noborder">One of <code>gui</code>, <code>mixed</code> and <code>no-gui</code></td></tr>

   <tr><td class="jdocu_noborder">fail-on-warnings</td>   <td class="jdocu_noborder">bool</td>
     <td class="jdocu_noborder">See -werror command line flag.</td></tr>

   <tr><td class="jdocu_noborder">log-enable</td>         <td class="jdocu_noborder">bool</td>
     <td class="jdocu_noborder">Deprecated.</td></tr>

   <tr><td class="jdocu_noborder">log-file</td>           <td class="jdocu_noborder">char *</td>
     <td class="jdocu_noborder">See -log-file command line flag.</td></tr>

   <tr><td class="jdocu_noborder">no-settings</td>        <td class="jdocu_noborder">bool</td>
     <td class="jdocu_noborder">See -no-settings command line flag.</td></tr>

   <tr><td class="jdocu_noborder">no-windows</td>         <td class="jdocu_noborder">bool</td>
     <td class="jdocu_noborder">See -no-win command line flag.</td></tr>

   <tr><td class="jdocu_noborder">python-verbose</td>     <td class="jdocu_noborder">bool</td>
     <td class="jdocu_noborder">Legacy flag; does nothing.</td></tr>

   <tr><td class="jdocu_noborder">project</td>            <td class="jdocu_noborder">char *</td>
     <td class="jdocu_noborder">See -project command line flag.</td></tr>

   <tr><td class="jdocu_noborder">quiet</td>              <td class="jdocu_noborder">bool</td>
     <td class="jdocu_noborder">See -quiet command line flag.</td></tr>

   <tr><td class="jdocu_noborder">script-trace</td>       <td class="jdocu_noborder">bool</td>
     <td class="jdocu_noborder">Show when a Simics script is entered/exited, along with any parameters
     passed to it and result variables returned from it.</td></tr>

   <tr><td class="jdocu_noborder">verbose</td>            <td class="jdocu_noborder">bool</td>
     <td class="jdocu_noborder">See -verbose command line flag.</td></tr>

   <tr><td class="jdocu_noborder">Internal or deprecated:</td><td class="jdocu_noborder"></td><td class="jdocu_noborder"></td></tr>

   <tr><td class="jdocu_noborder">alt-settings-dir</td>   <td class="jdocu_noborder">char *</td><td class="jdocu_noborder"></td></tr>

   <tr><td class="jdocu_noborder">application-mode</td>   <td class="jdocu_noborder">char *</td><td class="jdocu_noborder"></td></tr>

   <tr><td class="jdocu_noborder">check-ifaces</td>       <td class="jdocu_noborder">bool</td><td class="jdocu_noborder"></td></tr>

   <tr><td class="jdocu_noborder">disable-dstc</td>       <td class="jdocu_noborder">bool</td><td class="jdocu_noborder"></td></tr>

   <tr><td class="jdocu_noborder">disable-istc</td>       <td class="jdocu_noborder">bool</td><td class="jdocu_noborder"></td></tr>

   <tr><td class="jdocu_noborder">package-list</td>       <td class="jdocu_noborder">char *</td><td class="jdocu_noborder"></td></tr>

   <tr><td class="jdocu_noborder">py-import-all</td>      <td class="jdocu_noborder">bool</td><td class="jdocu_noborder"></td></tr>

   <tr><td class="jdocu_noborder">use-module-cache</td>   <td class="jdocu_noborder">bool</td><td class="jdocu_noborder"></td></tr>

   </tbody></table>
</p><p>
   This function is only needed when directly embedding
   <code>libsimics-common</code> in another application, which is deprecated.</p></dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
None</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
     </a><b><i>SIM_init_environment</i></b>,
     <b><i>SIM_get_init_arg_string</i></b>, <b><i>SIM_get_init_arg_boolean</i></b>.
   </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_main_loop">SIM_main_loop()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_main_loop2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_main_loop"></a><b>SIM_main_loop</b>  run the Simics main loop</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_main_loop();
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<b><i>SIM_main_loop</i></b> enters the main loop of Simics and never returns.
   It should only be called when embedding Simics in another application that
   wishes to transfer full control of the simulation to Simics.
<p>
   The main loop waits for work requests to be posted by notifiers,
   <b><i>SIM_thread_safe_callback</i></b> and <b><i>SIM_realtime_event</i></b>. If
   the command line has been initialized it will be active as well.
</p><p>
   If the embedding application do not wish to transfer the control to Simics
   while the simulation is not advancing should use the
   <b><i>SIM_process_work</i></b> or <b><i>SIM_process_pending_work</i></b> to make
   sure that Simics can process any pending idle work.</p></dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_General</b> Thrown if the function is called recursively.
<p>
   </p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
     </a><b><i>SIM_init_command_line</i></b>,
     <b><i>SIM_realtime_event</i></b>, <b><i>SIM_thread_safe_callback</i></b>,
     <b><i>SIM_process_work</i></b>
   </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_process_work">SIM_process_work()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_process_work2"></a><a id="simulator-api-functions.html:SIM_process_pending_work"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_process_work"></a><b>SIM_process_work</b><b>, SIM_process_pending_work</b>  run the Simics main loop</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">int
SIM_process_work(int (*done)(lang_void *done_data), lang_void *done_data);
</pre><p></p><pre class="jdocu_small">int
SIM_process_pending_work();
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<b><i>SIM_process_work</i></b> and <b><i>SIM_process_pending_work</i></b>
   processes work posted by <b><i>SIM_register_work</i></b>,
   <b><i>SIM_thread_safe_callback</i></b> and <b><i>SIM_realtime_event</i></b> and
   related functions to be run in <em>Global Context</em>. They do not process
   work posted with <i>run_in_thread</i> set. Such work is processed
   in worker threads.
<p>
   These process work functions are typically called when embedding Simics in
   another application to allow periodic and asynchronous Simics work to run
   while the simulation is not advancing. They can also be used as part of
   running the simulation to wait for events coming from external sources.
   </p><p>
   <b><i>SIM_process_pending_work</i></b> runs all work that has been queued up
   since the last call and returns immediately after.
</p><p>
   <b><i>SIM_process_work</i></b> is similar but waits for new work to arrive.
   Each time all work that has been queued up has been processed the supplied
   <i>done</i> callback, which must be non-NULL, is called with
   <i>done_data</i> as its only argument. A return value of 1 tells
   <b><i>SIM_process_work</i></b> to stop processing work and return control to
   the caller again while 0 tells it to continue.
</p><p>
   The <b><i>SIM_process_work</i></b> functions return -1 if the user has pressed
   the interrupt key before or while they were running, provided that the
   simulator core was initialized to catch signals. Otherwise the return value
   is 0. The function checks for user interrupt at the same time as it checks
   the <i>done</i> predicate and only if such a predicate is provided.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
     </a><b><i>SIM_main_loop</i></b>,
     <b><i>SIM_realtime_event</i></b>, <b><i>SIM_thread_safe_callback</i></b>
   </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_set_frontend_context">SIM_set_frontend_context()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_set_frontend_context2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_set_frontend_context"></a><b>SIM_set_frontend_context</b>  register a stack context buffer for Simics to longjmp back to</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_set_frontend_context(void *context);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
When Simics encounters a fatal error that it cannot handle, it uses
   <code>longjmp()</code> to give control back to the main loop. The longjmp
   destination depends on the stack context buffer registered by the embedding
   application using <b><i>SIM_set_frontend_context</i></b>.
   The main loop run by <b><i>SIM_main_loop</i></b> already sets up the stack
   context. You only need to set up the stack context manually if you write
   your own main loop.
<p>
   A stack context buffer is created by calling <code>sigsetjmp()</code> on Linux
   and <code>setjmp()</code> on Windows.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
     </a><b><i>SIM_main_loop</i></b>,
     <b><i>SIM_process_work</i></b>
   </dd>
</dl><p>

</p><h2 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:Haps">Haps</a></h2>
<p></p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_get_all_hap_types">SIM_get_all_hap_types()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_get_all_hap_types2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_get_all_hap_types"></a><b>SIM_get_all_hap_types</b>  get list of all hap types</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">attr_value_t
SIM_get_all_hap_types();
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Get a list of the names of all registered hap types.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Attribute list of strings.
   </dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<b><i>SIM_hap_get_number</i></b>,
   <b><i>SIM_hap_add_type</i></b></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_hap_add_callback">SIM_hap_add_callback()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_hap_add_callback2"></a><a id="simulator-api-functions.html:SIM_hap_add_callback_index"></a><a id="simulator-api-functions.html:SIM_hap_add_callback_range"></a><a id="simulator-api-functions.html:SIM_hap_add_callback_obj"></a><a id="simulator-api-functions.html:SIM_hap_add_callback_obj_index"></a><a id="simulator-api-functions.html:SIM_hap_add_callback_obj_range"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_hap_add_callback"></a><b>SIM_hap_add_callback</b><b>, SIM_hap_add_callback_index</b><b>, SIM_hap_add_callback_range</b><b>, SIM_hap_add_callback_obj</b><b>, SIM_hap_add_callback_obj_index</b><b>, SIM_hap_add_callback_obj_range</b>  install callback on a hap</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">hap_handle_t
SIM_hap_add_callback(const char *NOTNULL hap,
                     NOTNULL obj_hap_func_t func,
                     lang_void *user_data);
</pre><p></p><pre class="jdocu_small">hap_handle_t
SIM_hap_add_callback_index(const char *NOTNULL hap,
                           NOTNULL obj_hap_func_t func,
                           lang_void *user_data,
                           int64 index);
</pre><p></p><pre class="jdocu_small">hap_handle_t
SIM_hap_add_callback_range(const char *NOTNULL hap,
                           NOTNULL obj_hap_func_t func,
                           lang_void *user_data,
                           int64 start,
                           int64 end);
</pre><p></p><pre class="jdocu_small">hap_handle_t
SIM_hap_add_callback_obj(const char *NOTNULL hap,
                         conf_object_t *NOTNULL obj,
                         int flags,
                         NOTNULL obj_hap_func_t func,
                         lang_void *user_data);
</pre><p></p><pre class="jdocu_small">hap_handle_t
SIM_hap_add_callback_obj_index(const char *NOTNULL hap,
                               conf_object_t *NOTNULL obj,
                               int flags,
                               NOTNULL obj_hap_func_t func,
                               lang_void *user_data,
                               int64 index);
</pre><p></p><pre class="jdocu_small">hap_handle_t
SIM_hap_add_callback_obj_range(const char *NOTNULL hap,
                               conf_object_t *NOTNULL obj,
                               int flags,
                               NOTNULL obj_hap_func_t func,
                               lang_void *user_data,
                               int64 start,
                               int64 end);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Registers a function, pointed to by <i>func</i>, to be called
   when <i>hap</i> occurs for object <i>obj</i>.
   If a hap add function that
   does not have the <i>obj</i> argument is used, then the callback
   function will be called regardless of what object that triggers
   the hap. The <i>user_data</i> argument is the callback-specific
   data, and it will be passed as first argument to the installed callback
   function.
<p>
   Some hap add functions also take a <i>flags</i> argument. This flag
   is currently Simics internal and should be set to 0.
</p><p>
   The hap callback functions should not return any data. In C, the functions
   are declared to have a <code>void</code> return type and in Python, any
   return value is ignored. Since callback functions with different arguments
   may be installed using the same API function, the compiler may warn about a
   type mismatch. The solution is to cast the callback function pointer to the
   <code>obj_hap_func_t</code> type.
</p><p>
   The callback will be called in Cell Context, unless the
   documentation for the hap states otherwise.
</p><p>
   In hap functions, the execution can be interrupted by calling
   <b><i>SIM_break_simulation</i></b>. If a frontend or Python exception is
   raised, an error message will be printed including a stack trace if the
   callback is written in Python.
</p><p>
   The <code>_index_</code> and <code>_range_</code> versions will install callbacks
   that only trigger for a specified index, or range of indices. The index
   is specific for each hap type, see the hap documentation. The index and
   range must be non-negative and the end of the range must not be lower than
   the start.
</p><p>
   <a id="simulator-api-functions.html:hap_handle_t"></a>
</p><pre class="jdocu_small">typedef int hap_handle_t;</pre><p>
</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
The return value is a hap callback handle (identifier) of the type
   <code>hap_handle_t</code>, or -1 on error. This handle can be used to remove
   the installed callback with <b><i>SIM_hap_delete_callback_id</i></b>.
   </dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_Lookup</b> Thrown if the hap does not exist.<br>
<p>
   <b>SimExc_Attribute</b> Thrown if the index is negative or if the range is
   negative in value or size.
</p><p>
   </p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context for hap callbacks tied to
   an object, and Global Context for hap callbacks not tied to an
   object. An exception is made for callbacks on Core_Breakpoint_Memop, which
   can be installed with SIM_hap_add_callback_index even in Cell Context.</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_hap_delete_callback">SIM_hap_delete_callback()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_hap_delete_callback2"></a><a id="simulator-api-functions.html:SIM_hap_delete_callback_obj"></a><a id="simulator-api-functions.html:SIM_hap_delete_callback_id"></a><a id="simulator-api-functions.html:SIM_hap_delete_callback_obj_id"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_hap_delete_callback"></a><b>SIM_hap_delete_callback</b><b>, SIM_hap_delete_callback_obj</b><b>, SIM_hap_delete_callback_id</b><b>, SIM_hap_delete_callback_obj_id</b>  delete installed hap callback</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_hap_delete_callback(const char *NOTNULL hap,
                        NOTNULL obj_hap_func_t func, lang_void *user_data);
</pre><p></p><pre class="jdocu_small">void
SIM_hap_delete_callback_obj(const char *NOTNULL hap,
                            conf_object_t *NOTNULL obj,
                            NOTNULL obj_hap_func_t func, lang_void *user_data);
</pre><p></p><pre class="jdocu_small">void
SIM_hap_delete_callback_id(const char *NOTNULL hap, hap_handle_t handle);
</pre><p></p><pre class="jdocu_small">void
SIM_hap_delete_callback_obj_id(const char *NOTNULL hap,
                               conf_object_t *NOTNULL obj, hap_handle_t handle);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Removes a callback for a hap type specified by the <code>hap</code> argument.
<p>
   The <b><i>SIM_hap_delete_callback_obj...</i></b> functions will remove a
   callback that is installed on the specified object <i>obj</i>.
</p><p>
   <b><i>SIM_hap_delete_callback</i></b> removes a callback not associated with
   any object, with the callback function <code>func</code> and the same
   <code>user_data</code>.
   The <b><i>SIM_hap_delete_callback_..._id</i></b> functions take a hap handle
   argument instead, as returned by the <b><i>SIM_hap_add_callback...</i></b>
   functions.
</p><p>
   These functions will trigger the <code>Core_Hap_Callback_Removed</code> hap
   for each removed callback.</p></dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_Lookup</b> Thrown if the specified hap does not exist.
   </dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context for callbacks tied to an
   object. Global Context for callbacks not tied to an object.</dd>
</dl><p>

</p><h2 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:Logging">Logging</a></h2>
<p></p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_get_quiet">SIM_get_quiet()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_get_quiet2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_get_quiet"></a><b>SIM_get_quiet</b>  return setting of the quiet flag</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">bool
SIM_get_quiet();
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This function returns the current value of Simics's quiet flag.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_get_verbose">SIM_get_verbose()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_get_verbose2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_get_verbose"></a><b>SIM_get_verbose</b>  get the verbose flag</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">bool
SIM_get_verbose();
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This function returns the value of Simics's verbosity flag
   (corresponding to the <code>-verbose</code> command line argument).</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_set_quiet">SIM_set_quiet()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_set_quiet2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_set_quiet"></a><b>SIM_set_quiet</b>  enable/disable quiet mode</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_set_quiet(bool quiet);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Calling this function with an argument of <code>true</code> will enable the
   quiet mode, whereas an argument of <code>false</code> will disable it. Any other
   arguments will cause a frontend exception. Please note that enabling the
   quiet mode will disable verbose mode.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_set_verbose">SIM_set_verbose()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_set_verbose2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_set_verbose"></a><b>SIM_set_verbose</b>  enable/disable verbose mode</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_set_verbose(bool verbose);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This function sets Simics's internal verbosity flag (corresponding to the
   <code>-verbose</code> command line argument). The <code>verbose</code> argument can
   be either <code>true</code> or <code>false</code>. Note that setting this flag will
   disable quiet mode.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>

</p><h2 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:Memory">Memory</a></h2>
<p></p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_load_binary">SIM_load_binary()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_load_binary2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_load_binary"></a><b>SIM_load_binary</b>  read an executable file into memory</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">physical_address_t
SIM_load_binary(conf_object_t *NOTNULL obj, const char *NOTNULL file,
                physical_address_t offset, bool use_pa, bool verbose);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Read a binary file (ELF, Motorola S-Record, PE32, PE32+,
   or TI COFF format) into memory and return the code entry point.
<p>
   The file will be loaded at the address formed by adding
   the virtual load address from the file, with the offset
   <i>offset</i>. If the flag <i>use_pa</i> is set, the ELF
   physical load address is used instead. The <i>verbose</i> flag
   will cause Simics to print info about the binary to the console.
</p><p>
   The memory space to load into is given in the <i>obj</i>
   parameter.  If the given space is a CPU object, its current virtual
   address space will be used, and addresses will be translated before
   writing to the physical memory space attached to the CPU.
</p><p>
   If the file is not found in the current directory, the search path (see
   <b>add-directory</b>) is used to find the file.</p></dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<code>SimExc_IOError</code> Thrown if there was a problem reading the
     file.<br>
     <code>SimExc_General</code> Thrown if binary cannot be read into
     memory.
   </dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
The code entry address.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_load_file">SIM_load_file()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_load_file2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_load_file"></a><b>SIM_load_file</b>  read a file into memory</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_load_file(conf_object_t *NOTNULL obj, const char *NOTNULL file,
              physical_address_t base_address, bool verbose);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Loads the contents of <i>file</i> into memory starting at address
   <i>base_address</i>. The <i>obj</i> argument can either be
   a processor, a memory-space, or an image object. In case of a processor,
   the address is interpreted as a virtual address.
<p>
   The <i>file</i> can be either a raw binary file or a file in the craff
   format.
</p><p>
   The <i>verbose</i> flag will cause Simics to print some information
   about the load.</p></dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_IOError</b> Thrown if there was a problem reading the file.<br>
     <b>SimExc_General</b> Thrown if file cannot be read into memory.
   </dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_read_byte">SIM_read_byte()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_read_byte2"></a><a id="simulator-api-functions.html:SIM_write_byte"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_read_byte"></a><b>SIM_read_byte</b><b>, SIM_write_byte</b>  read/write byte from a memory space</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">uint8
SIM_read_byte(conf_object_t *NOTNULL obj, generic_address_t paddr);
</pre><p></p><pre class="jdocu_small">void
SIM_write_byte(conf_object_t *NOTNULL obj,
               generic_address_t paddr, uint8 value);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Read or write a byte from a given address in the memory space <i>obj</i>.</dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_Memory</b> Thrown if the memory space threw an exception<br>
   <p>
   <b>SimExc_General</b> Thrown if the object does not implement the memory
   space interface.
</p><p>
   </p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
The byte read.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_read_phys_memory">SIM_read_phys_memory()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_read_phys_memory2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_read_phys_memory"></a><b>SIM_read_phys_memory</b>  read data from a physical address</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">uint64
SIM_read_phys_memory(conf_object_t *NOTNULL cpu,
                     physical_address_t paddr,
                     int length);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Reads <i>length</i> bytes from address <i>paddr</i> in the physical
   memory space associated with the processor <i>cpu</i>.
<p>
   Up to 8 bytes can be read in one call. The memory access will be of
   inquiry type, i.e. no timing-model or snoop device will be called.
</p><p>
   For non-inquiry accesses, use the <code>memory_space</code>
   interface directly.</p></dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_Memory</b> Thrown if no memory defined at <i>paddr</i>.<br>
<p>
     <b>SimExc_Attribute</b> Thrown if <i>length</i> is out of range.
</p><p>
     <b>SimExc_General</b> Thrown if the processors physical memory does not
     implement the necessary interface methods.
</p><p>
   </p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
The read data, zero-extended.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_read_phys_memory_tags">SIM_read_phys_memory_tags()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_read_phys_memory_tags2"></a><a id="simulator-api-functions.html:SIM_write_phys_memory_tags"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_read_phys_memory_tags"></a><b>SIM_read_phys_memory_tags</b><b>, SIM_write_phys_memory_tags</b>  access auxiliary bits in physical memory</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">uint64
SIM_read_phys_memory_tags(conf_object_t *NOTNULL mem_space,
                          physical_address_t paddr, unsigned ntags);
</pre><p></p><pre class="jdocu_small">void
SIM_write_phys_memory_tags(conf_object_t *NOTNULL mem_space,
                           physical_address_t paddr,
                           uint64 tag_bits, unsigned ntags);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Reads or writes <i>ntags</i> auxiliary bits starting at <i>paddr</i>
   in the physical memory space <i>mem_space</i>.
   Up to 64 bits can be accessed at once. The bits are specified and returned
   right-aligned, least significant bit corresponding to the lowest address.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_write_phys_memory">SIM_write_phys_memory()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_write_phys_memory2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_write_phys_memory"></a><b>SIM_write_phys_memory</b>  write data to a physical address</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_write_phys_memory(conf_object_t *NOTNULL cpu,
                      physical_address_t paddr,
                      uint64 value, int length);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Writes <i>length</i> bytes to address <i>paddr</i> in the physical
   memory space associated with the processor <i>cpu</i>.
<p>
   Up to 8 bytes can be written in one call. The memory access will be of
   inquiry type, i.e. no timing-model or snoop device will be called.</p></dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_Memory</b> Thrown if no memory defined at <i>paddr</i>.<br>
<p>
     <b>SimExc_Attribute</b> Thrown if <i>length</i> is out of range.
</p><p>
     <b>SimExc_General</b> Thrown if the processors physical memory does not
     implement the necessary interface methods.
</p><p>
   </p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>

</p><h2 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:Modules">Modules</a></h2>
<p></p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_add_module_dir">SIM_add_module_dir()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_add_module_dir2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_add_module_dir"></a><b>SIM_add_module_dir</b>  add loadable module search path</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_add_module_dir(const char *path);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Add given path to the list of paths where Simics searches for loadable
   modules. The function <b><i>SIM_module_list_refresh</i></b> has to be called
   after calling this function, for the change to take effect.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_get_all_failed_modules">SIM_get_all_failed_modules()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_get_all_failed_modules2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_get_all_failed_modules"></a><b>SIM_get_all_failed_modules</b>  return a list of all modules that failed to load</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">attr_value_t
SIM_get_all_failed_modules();
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
A failed module is a module that is not loadable by the current version
   of Simics. The list returned contains information about why the module
   failed. Each list entry is another list with module specific information.
   The layout of this sub-list is described below. The list may change
   in future Simics versions.
   <ul>
   <li><i>name</i> - Module name (string).</li>
   <li><i>path</i> - File system path to the module (string).</li>
   <li><i>duplicate</i> - Flag indicating a duplicate module
   (boolean).</li>
   <li><i>linker</i> - Flag indicating a linker error (boolean).</li>
   <li><i>version</i> - Simics ABI version that the module was built for
   (integer).</li>
   <li><i>build_id</i> - Simics build number when the module was built
   (integer).</li>
   <li><i>build_date</i> - When the module was built, in seconds from epoch
   (integer).</li>
   <li><i>user version</i> - User version of the module (string).</li>
   <li><i>error</i> - Error message, typically from the linker
   (string or nil).</li>
   </ul></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<b><i>SIM_get_all_modules</i></b></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_get_all_modules">SIM_get_all_modules()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_get_all_modules2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_get_all_modules"></a><b>SIM_get_all_modules</b>  return a list of all modules</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">attr_value_t
SIM_get_all_modules();
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The list returned contains information about all modules that can be loaded
   into Simics. Each list entry is another list with module specific
   information. The layout of this sub-list is described below. The list may
   grow in future Simics version, but the currently defined fields will not
   change.
   <ul>
   <li><i>name</i> - Module name (string).</li>
   <li><i>path</i> - File system path to the module (string).</li>
   <li><i>loaded</i> - Flag indicating that the module is already loaded
   (boolean).</li>
   <li><i>version</i> - Oldest Simics ABI version that the module was built for
   (integer).</li>
   <li><i>user version</i> - User version of the module (string).</li>
   <li><i>build-id</i> - Simics build-id that indicates in which Simics 
   build this module was created (integer).</li>
   <li><i>build-date</i> - Build date of the module, in seconds 
   (integer).</li>
   <li><i>classes</i> - Classes this module claims to implement.</li>
   <li><i>thread-safe</i> - If the module is thread-safe.</li>
   <li><i>components</i> - Components this module claims to implement.</li>
   <li><i>user path</i> - Module was loaded from path provided by user.</li>
   </ul></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
     </a><b><i>SIM_get_all_failed_modules</i></b>
   </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_load_module">SIM_load_module()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_load_module2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_load_module"></a><b>SIM_load_module</b>  load a module</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_load_module(const char *NOTNULL module);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Load a Simics module. Normally, modules are loaded automatically
     as needed for the configuration classes they implement, and there is
     rarely any need to call this function explicitly.
<p>
     The <i>module</i> argument is the name of the module (not
     file name) to be loaded.</p></dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_License</b> Thrown if the module requires a non-existing
       license feature.<br>
<p>
       <b>SimExc_General</b> Thrown if the module failed to load for other
       reasons.
</p><p>
     </p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_module_list_refresh">SIM_module_list_refresh()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_module_list_refresh2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_module_list_refresh"></a><b>SIM_module_list_refresh</b>  refresh list of loadable modules</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_module_list_refresh();
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Simics maintains a list of all modules that can be loaded successfully. If a
   module is changed or added, the list has to be refreshed before Simics can
   load this module.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
</dl><p>

</p><h2 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:Object-Locks">Object Locks</a></h2>
<p></p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_ASSERT_CELL_CONTEXT">SIM_ASSERT_CELL_CONTEXT()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_ASSERT_CELL_CONTEXT2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_ASSERT_CELL_CONTEXT"></a><b>SIM_ASSERT_CELL_CONTEXT</b>  assert Cell Context</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">SIM_ASSERT_CELL_CONTEXT(obj);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The <b><i>SIM_ASSERT_CELL_CONTEXT</i></b> function verifies that cell
  thread domain associated with <i>obj</i> is held by the calling thread
  and raises a hard failure if this is not the case.
<p>
  In other worlds, the macro ensures that the execution context is either
  Cell Context or Global Context.</p></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_ASSERT_OBJECT_LOCK">SIM_ASSERT_OBJECT_LOCK()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_ASSERT_OBJECT_LOCK2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_ASSERT_OBJECT_LOCK"></a><b>SIM_ASSERT_OBJECT_LOCK</b>  assert thread domain is held</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">SIM_ASSERT_OBJECT_LOCK(obj);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The <b><i>SIM_ASSERT_OBJECT_LOCK</i></b> function checks that the
  thread domain associated with <i>obj</i> is held. A hard failure
  is raised if the thread domain is not held.</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_acquire_cell">SIM_acquire_cell()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_acquire_cell2"></a><a id="simulator-api-functions.html:SIM_release_cell"></a><a id="simulator-api-functions.html:SIM_ACQUIRE_CELL"></a><a id="simulator-api-functions.html:SIM_RELEASE_CELL"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_acquire_cell"></a><b>SIM_acquire_cell</b><b>, SIM_release_cell</b><b>, SIM_ACQUIRE_CELL</b><b>, SIM_RELEASE_CELL</b>  enter Cell Context</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">domain_lock_t *
SIM_acquire_cell(conf_object_t *NOTNULL obj,
                 const char *NOTNULL function_name,
                 const char *NOTNULL source_location);
</pre><p></p><pre class="jdocu_small">void
SIM_release_cell(conf_object_t *NOTNULL obj, domain_lock_t *lock);
</pre><p></p><pre class="jdocu_small">SIM_ACQUIRE_CELL(obj, lockp);
</pre><p></p><pre class="jdocu_small">SIM_RELEASE_CELL(obj, lockp);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Enters Cell Context for the cell associated with the
   object <i>obj</i>.
<p>
   As part of entering Cell Context, the cell thread domain
   for the cell associated with <i>obj</i> is acquired.
</p><p>
   Entering Cell Context multiple times is allowed, but
   acquired thread domains must be released in strict reverse order.
</p><p>
   This function will block until the cell is available if another
   thread is currently holding the cell thread domain.
   While blocking, any previously held domains can be acquired by
   the thread already in Cell Context. Thus, the caller must
   be prepared to handle e.g. incoming interface calls.
</p><p>
   In Cell Context, API functions marked with Cell Context
   or Global Context can be called safely, and interfaces
   on objects belonging to the same cell can be called directly. More
   generally, the full Standard Device Model applies in Cell Context.
   Refer to the chapter about threading in the API Reference Manual for more
   details.
</p><p>
   The macro version of this API call sets the
   <i>function_name</i> and <i>source_location</i> arguments
   automatically with the information where the API call was made. This data
   is used when lock statistics collection is enabled
   through the <b>enable-object-lock-stats</b> command.</p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_acquire_object">
   SIM_acquire_object</a>, <a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_acquire_target">
   SIM_acquire_target
   </a></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
<b><i>SIM_acquire_cell</i></b> returns a domain lock handle which should
     be passed as an argument to <b><i>SIM_release_cell</i></b> when the
     lock is released. <b><i>SIM_ACQUIRE_CELL</i></b> does not return
     anything but instead stores the domain lock handle in the pointer
     passed as the second argument.
   </dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Any</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_acquire_object">SIM_acquire_object()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_acquire_object2"></a><a id="simulator-api-functions.html:SIM_release_object"></a><a id="simulator-api-functions.html:SIM_ACQUIRE_OBJECT"></a><a id="simulator-api-functions.html:SIM_RELEASE_OBJECT"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_acquire_object"></a><b>SIM_acquire_object</b><b>, SIM_release_object</b><b>, SIM_ACQUIRE_OBJECT</b><b>, SIM_RELEASE_OBJECT</b>  acquire thread domain</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">domain_lock_t *
SIM_acquire_object(conf_object_t *NOTNULL obj,
                   const char *NOTNULL function_name,
                   const char *NOTNULL source_location);
</pre><p></p><pre class="jdocu_small">void
SIM_release_object(conf_object_t *NOTNULL obj, domain_lock_t *lock);
</pre><p></p><pre class="jdocu_small">SIM_ACQUIRE_OBJECT(obj, lockp);
</pre><p></p><pre class="jdocu_small">SIM_RELEASE_OBJECT(obj, lockp);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Acquires the thread domain associated with the object <i>obj</i>.
<p>
   A particular thread domain can only be held by a single thread at a time,
   and this function blocks until the domain is available. Once the domain
   is held, the thread can safely access state protected
   by the domain.
</p><p>
   While blocking, any previously held domains can be acquired by
   threads with higher priority, such as a thread running in
   Cell Context.
</p><p>
   More than one thread domain can be held simultaneously, and the same
   thread domain may be acquired multiple times.
   However, domains must be released in strict reverse order.
</p><p>
   This function is typically used by models using the Threaded Device Model
   to acquire the model's own thread domain from its interface methods.
   In this case, <i>obj</i> is set to the model itself.
</p><p>
   The macro version of this API call sets the
   <i>function_name</i> and <i>source_location</i> arguments
   automatically with the information where the API call was made. This data
   is used when lock statistics collection is enabled
   through the <b>enable-object-lock-stats</b> command.
</p><p>
   More details about thread domains and the threading model are
   available in the chapter about threading in the API Reference Manual.</p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_acquire_target">
   SIM_acquire_target</a>, <a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_acquire_cell">
   SIM_acquire_cell
   </a></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
<b><i>SIM_acquire_object</i></b> returns a domain lock handle which should
     be passed as an argument to <b><i>SIM_release_object</i></b> when the
     lock is released. <b><i>SIM_ACQUIRE_OBJECT</i></b> does not return
     anything but instead stores the domain lock handle in the pointer
     passed as the second argument.
   </dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Any</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_acquire_object_for_execution">SIM_acquire_object_for_execution()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_acquire_object_for_execution2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_acquire_object_for_execution"></a><b>SIM_acquire_object_for_execution</b>  acquire object lock for execution</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">domain_lock_t *
SIM_acquire_object_for_execution(conf_object_t *NOTNULL obj);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Acquire the thread domain lock associated with object <i>arg</i>.
<p>
   Note: This API function is considered tech-preview and may
   change without notice.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Domain lock handle which should be passed as
   an argument to <b><i>SIM_release_object</i></b> when the lock is released.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Any</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_acquire_target">SIM_acquire_target()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_acquire_target2"></a><a id="simulator-api-functions.html:SIM_release_target"></a><a id="simulator-api-functions.html:SIM_ACQUIRE_TARGET"></a><a id="simulator-api-functions.html:SIM_RELEASE_TARGET"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_acquire_target"></a><b>SIM_acquire_target</b><b>, SIM_release_target</b><b>, SIM_ACQUIRE_TARGET</b><b>, SIM_RELEASE_TARGET</b>  conditionally enter Cell Context</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">domain_lock_t *
SIM_acquire_target(conf_object_t *NOTNULL obj,
                   const char *NOTNULL function_name,
                   const char *NOTNULL source_location);
</pre><p></p><pre class="jdocu_small">void
SIM_release_target(conf_object_t *NOTNULL obj, domain_lock_t *lock);
</pre><p></p><pre class="jdocu_small">SIM_ACQUIRE_TARGET(obj, lockp);
</pre><p></p><pre class="jdocu_small">SIM_RELEASE_TARGET(obj, lockp);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Enters Cell Context if the specified object
   <i>obj</i> uses the Standard Device Model.
   The function does nothing if <i>obj</i> is a thread-aware object,
   i.e., if the object belongs to a thread-domain other than the cell.
<p>
   The intended use for this function is ensuring that Cell Context
   is entered before a code running in Threaded Context invokes an
   interface on some external object. If the external object is thread aware,
   and does not require Cell Context, this function avoids entering
   Cell Context as an optimization.
</p><p>
   The macro version of this API call sets the
   <i>function_name</i> and <i>source_location</i> arguments
   automatically with the information where the API call was made. This data
   is used when lock statistics collection is enabled
   through the <b>enable-object-lock-stats</b> command.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
<b><i>SIM_acquire_target</i></b> returns a domain lock handle which should
     be passed as an argument to <b><i>SIM_release_target</i></b> when the
     lock is released. <b><i>SIM_ACQUIRE_TARGET</i></b> does not return
     anything but instead stores the domain lock handle in the pointer
     passed as the second argument.
   </dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_acquire_object">
     SIM_acquire_object</a>, <a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_acquire_cell">
     SIM_acquire_cell
   </a></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Any</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_drop_thread_domains">SIM_drop_thread_domains()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_drop_thread_domains2"></a><a id="simulator-api-functions.html:SIM_reacquire_thread_domains"></a><a id="simulator-api-functions.html:SIM_DROP_THREAD_DOMAINS"></a><a id="simulator-api-functions.html:SIM_REACQUIRE_THREAD_DOMAINS"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_drop_thread_domains"></a><b>SIM_drop_thread_domains</b><b>, SIM_reacquire_thread_domains</b><b>, SIM_DROP_THREAD_DOMAINS</b><b>, SIM_REACQUIRE_THREAD_DOMAINS</b>  temporarily release all held thread domains</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">domain_lock_t *
SIM_drop_thread_domains();
</pre><p></p><pre class="jdocu_small">void
SIM_reacquire_thread_domains(domain_lock_t *dl);
</pre><p></p><pre class="jdocu_small">SIM_DROP_THREAD_DOMAINS(obj, lockp);
</pre><p></p><pre class="jdocu_small">SIM_REACQUIRE_THREAD_DOMAINS(obj, lockp);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Temporarily releases all held thread domains and enters
   Threaded Context.
<p>
   This function is intended to use before blocking is initiated on an
   external synchronization mechanism, like a condition variable.
   Releasing thread domains before blocking is often necessary
   to avoid deadlock situations where other threads get stuck
   trying to acquire thread domains held by the blocking thread.
</p><p>
   Each call to <b><i>SIM_drop_thread_domains</i></b> must be
   followed with a call to <b><i>SIM_reacquire_thread_domains</i></b>
   to reacquire the released thread domains. This must
   be done from the same thread.
</p><p>
   If the purpose of the call is just to provide other threads
   an opportunity to acquire held domains, then the more efficient
   <b><i>SIM_yield_thread_domains</i></b> should be used instead.
</p><p>
   The macro versions of the API calls are currently wrappers of
   the corresponding SIM-function. In the future, they might collect
   extra information about where in the code the domain locks are
   reacquired.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
<b><i>SIM_drop_thread_domains</i></b> returns a domain lock handle
     which should be passed as an argument to
     <b><i>SIM_reacquire_thread_domains_object</i></b>.
     The <b><i>SIM_DROP_THREAD_DOMAINS</i></b> does not return
     anything but instead stores the domain lock handle in the pointer
     passed as the second argument.
   </dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_yield_thread_domains">
   SIM_yield_thread_domains
   </a></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Any</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_yield_thread_domains">SIM_yield_thread_domains()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_yield_thread_domains2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_yield_thread_domains"></a><b>SIM_yield_thread_domains</b>  yield held thread domains</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_yield_thread_domains();
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Yields held thread domains if there are other threads waiting to
   acquire them.
<p>
   The function blocks until all threads waiting for one of the
   held domains have had the opportunity to acquire the domain in question,
   and then resumes execution with the domains held again.
</p><p>
   One example usage of this function is when a CPU model is notified
   through the <code>execute_control</code> interface that another
   thread wants to acquire the CPU's thread domain. Then the CPU
   function should call this function as quickly as possible,
   preferably before starting the simulation of the next instruction.</p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_drop_thread_domains">
   SIM_drop_thread_domains</a>, <a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_acquire_object">
   SIM_acquire_object
   </a></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Any</dd>
</dl><p>

</p><h2 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:Output">Output</a></h2>
<p></p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_add_output_handler">SIM_add_output_handler()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_add_output_handler2"></a><a id="simulator-api-functions.html:SIM_remove_output_handler"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_add_output_handler"></a><b>SIM_add_output_handler</b><b>, SIM_remove_output_handler</b>  add or remove output handler</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_add_output_handler(void (*NOTNULL f)(lang_void *user_data,
                                         const char *text,
                                         size_t length),
                       lang_void *user_data);
</pre><p></p><pre class="jdocu_small">void
SIM_remove_output_handler(void (*NOTNULL f)(lang_void *user_data,
                                            const char *text,
                                            size_t length),
                          lang_void *user_data);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<b><i>SIM_add_output_handler</i></b> registers
   <b><i>f</i></b>(<i>user_data</i>, <i>text</i>, <i>length</i>) 
   to be called whenever there is text output from Simics.
<p>
   <i>text</i> contains <i>length</i> bytes of output data.
   <i>user_data</i> is passed unchanged to the output handler.
</p><p>
   <b><i>SIM_remove_output_handler</i></b> removes <i>f</i> as an output
   recipient. If <i>user_data</i> is <code>NULL</code>, all output
   handlers with the same function will be removed; otherwise, only those with
   equal <i>user_data</i> will be removed.
</p><p>
   Output handlers must be thread-safe in order to handle output from different
   threads properly. There will only be one activation of each handler at a
   given instant so strict re-entrancy is not required, but proper locking
   around resources shared with other code should be in place.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<b><i>SIM_write</i></b></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_write">SIM_write()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_write2"></a><a id="simulator-api-functions.html:SIM_flush"></a><a id="simulator-api-functions.html:SIM_putchar"></a><a id="simulator-api-functions.html:SIM_puts"></a><a id="simulator-api-functions.html:SIM_printf_vararg"></a><a id="simulator-api-functions.html:SIM_printf"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_write"></a><b>SIM_write</b><b>, SIM_flush</b><b>, SIM_putchar</b><b>, SIM_puts</b><b>, SIM_printf_vararg</b><b>, SIM_printf</b>  text output routines</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">int
SIM_write(const void *NOTNULL src, int length);
</pre><p></p><pre class="jdocu_small">int
SIM_flush();
</pre><p></p><pre class="jdocu_small">int
SIM_putchar(int c);
</pre><p></p><pre class="jdocu_small">int
SIM_puts(const char *NOTNULL s);
</pre><p></p><pre class="jdocu_small">int
SIM_printf_vararg(const char *NOTNULL format, va_list ap);
</pre><p></p><pre class="jdocu_small">int
SIM_printf(const char *NOTNULL format, ...);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
These are the Simics versions of the <b><i>write</i></b>,
   <b><i>putchar</i></b>, <b><i>puts</i></b>, <b><i>printf</i></b>,
   <b><i>vprintf</i></b>, and <b><i>fflush</i></b> C library functions.
   The arguments and return values
   are the same as for the library functions, except for
   <b><i>SIM_write</i></b> which does not take any file argument.
<p>
   The output will be sent to <i>stdout</i>, but more output recipients
   can be added using the <b><i>SIM_add_output_handler</i></b> function.
   Output is line buffered. <b><i>SIM_flush</i></b> will force output of an
   unterminated line.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<b><i>SIM_add_output_handler</i></b></dd>
</dl><p>

</p><h2 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:Path">Path</a></h2>
<p></p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_add_directory">SIM_add_directory()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_add_directory2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_add_directory"></a><b>SIM_add_directory</b>  add directory to search path</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_add_directory(const char *NOTNULL directory, bool prepend);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Adds a directory to Simics's search path. This is a list of directories
   which Simics uses when searching for files such as disk dumps, kernel
   images, etc.
   <p>
   The <i>directory</i> argument is first converted using
   <b><i>SIM_native_path</i></b>, to yield a path on host native form.
   If the path does not exist, a frontend exception is raised.
</p><p>
   If <i>prepend</i> is true, the directory is inserted first in the
   list of directories.
</p><p>
   This list of directories is saved as the attribute
   <i>simics_path</i> when doing <b>write-configuration</b>.
   Each directory is first converted to absolute form if relative.</p></dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_General</b> Thrown if the directory does not exist.
   <p>
   </p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
     </a><b><i>SIM_lookup_file</i></b>, <b><i>SIM_clear_directories</i></b>
   </dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_clear_directories">SIM_clear_directories()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_clear_directories2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_clear_directories"></a><b>SIM_clear_directories</b>  clear the search path</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_clear_directories();
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Deletes all directories from the search path.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
     </a><b><i>SIM_add_directory</i></b>, <b><i>SIM_lookup_file</i></b>
   </dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_get_directories">SIM_get_directories()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_get_directories2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_get_directories"></a><b>SIM_get_directories</b>  get the current search path</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">attr_value_t
SIM_get_directories();
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns the current value of the directory search path.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_lookup_file">SIM_lookup_file()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_lookup_file2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_lookup_file"></a><b>SIM_lookup_file</b>  find a file using simics search path</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">char *
SIM_lookup_file(const char *file);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Searches for a file in the Simics search path.
<p>
   The returned path will always be in host native format, so it will not need
   to be converted. See <b><i>SIM_native_path</i></b> for more details on what
   "host native format" means.
</p><p>
   <code>NULL</code> is returned if <i>file</i> cannot be found.
</p><p>
   The search algorithm is as follows.
</p><p>
   </p><ul>
     <li> If <i>file</i> is <code>NULL</code> or an empty string,
          the function returns <code>NULL</code>. </li>

     <li> If <i>file</i> exists and is an absolute path, it is
          converted to host native form and returned.</li>

     <li> If <i>file</i> starts with <code>%simics%</code>, the rest of the
          path is looked up first in the current Simics project, and then in
          all configured Simics packages. If a match is found, the native form
          of the file found will be returned.</li>

     <li> If <i>file</i> exists in or relative to the current
          directory, it is returned without using the Simics search path. This
          is more or less equivalent of always having "." first in the
          search path.</li>

     <li> For each directory in Simics search path: The directory and the file
          is concatenated and converted to host native format. Each such file
          is looked up first in the current Simics project, and then in all
          Simics packages. If a match is found, the native form of the file
          found will be returned.</li>
   </ul>
<p>
   If the file was found, a pointer to the full path to the file is returned.
   The ownership of the string is passed to the caller.</p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
     </a><b><i>SIM_add_directory</i></b>, <b><i>SIM_clear_directories</i></b>
   </dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_native_path">SIM_native_path()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_native_path2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_native_path"></a><b>SIM_native_path</b>  convert path to its native form</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">char *
SIM_native_path(const char *NOTNULL path);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Translates a path to its host native form. This functions is a no-op on all
   platforms except Windows.
<p>
   The value returned by this function is allocated and owned by the caller.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>

</p><h2 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:Processor">Processor</a></h2>
<p></p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_clear_augmentation_bit">SIM_clear_augmentation_bit()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_clear_augmentation_bit2"></a><a id="simulator-api-functions.html:SIM_get_augmentation_bit"></a><a id="simulator-api-functions.html:SIM_set_augmentation_bit"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_clear_augmentation_bit"></a><b>SIM_clear_augmentation_bit</b><b>, SIM_get_augmentation_bit</b><b>, SIM_set_augmentation_bit</b>  convenience functions to work with augmented memory bits</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE void
SIM_clear_augmentation_bit(uint8 *tag_page_data, unsigned pofs);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE int
SIM_get_augmentation_bit(uint8 *tag_page_data, unsigned pofs);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE void
SIM_set_augmentation_bit(uint8 *tag_page_data, unsigned pofs);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The <b><i>SIM_clear_augmentation_bit</i></b>,
     <b><i>SIM_get_augmentation_bit</i></b>,
     and <b><i>SIM_set_augmentation_bit</i></b> functions are used to modify
     and read augmented memory bits. The <code>direct_memory_tags</code>
     interface supports augmented memory through the <code>data</code>
     field in the <code>direct_memory_tags_t</code> struct.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_disassemble_address">SIM_disassemble_address()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_disassemble_address2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_disassemble_address"></a><b>SIM_disassemble_address</b>  disassemble address</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">tuple_int_string_t
SIM_disassemble_address(conf_object_t *NOTNULL cpu, generic_address_t address, 
                        int logical, int sub_operation);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This function disassembles the instruction at the given
   address. Address is either a physical address (logical == 0) or a
   logical address (logical == 1). For VLIW architectures,
   <i>sub_operation</i> is used to select which sub-operation
   to disassemble. A request for a not present sub-operation (for
   example <i>sub-operation</i> != 0 for non-VLIW
   architectures) results in the int part of the return tuple being
   set to zero.
<p>
   A <code>tuple_int_string_t</code> is returned which contains the
   disassembly string as well as the length of the instruction in
   bytes.  <a id="simulator-api-functions.html:tuple_int_string_t">tuple_int_string_t</a> is defined like this: 
   
</p><pre class="jdocu_small">typedef struct {
        int integer;
        char *string;
} tuple_int_string_t;</pre><p>
 For the Sparc and PowerPC
   targets the length is always 4 bytes.
</p><p>
   This function can be more convenient to use than the
   <b><i>disassemble</i></b> function in the
   <code>processor_info</code> interface.</p></dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_General</b> Thrown if arguments are invalid.<br>
<p>
   <b>SimExc_Memory</b> Thrown if the address is undefined or not mapped in the
   MMU (for logical addresses).
   </p><p>
   </p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_get_all_processors">SIM_get_all_processors()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_get_all_processors2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_get_all_processors"></a><b>SIM_get_all_processors</b>  get list of all processors</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">attr_value_t
SIM_get_all_processors();
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Return a list of all processor objects.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
List of processors.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_get_processor">SIM_get_processor()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_get_processor2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_get_processor"></a><b>SIM_get_processor</b>  get processor pointer from number</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">conf_object_t *
SIM_get_processor(int proc_no);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Converts processor id number to processor pointer. This function cannot be
   used until a configuration had been loaded successfully.</dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_Index</b> Thrown if no processor with number <i>proc_no</i>
   exists.
   <p>
   </p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
The processor pointer, NULL on failure.
   </dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<b><i>SIM_number_processors</i></b></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_get_processor_number">SIM_get_processor_number()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_get_processor_number2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_get_processor_number"></a><b>SIM_get_processor_number</b>  get the number of a processor</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">int
SIM_get_processor_number(const conf_object_t *NOTNULL cpu);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns the global processor number for a processor in Simics.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
The processor number</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_number_processors">SIM_number_processors()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_number_processors2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_number_processors"></a><b>SIM_number_processors</b>  number of processors</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">int
SIM_number_processors();
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns the current total number of processors in the system.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Number of processors.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<b><i>SIM_get_processor</i></b></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_processor_privilege_level">SIM_processor_privilege_level()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_processor_privilege_level2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_processor_privilege_level"></a><b>SIM_processor_privilege_level</b>  return the current privilege level for a processor</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">int
SIM_processor_privilege_level(conf_object_t *NOTNULL cpu);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Return the current privilege level for a processor.  The definition
  of privilege levels depends on the processor type.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
For SPARC, and PowerPC, and ARM processors: 0 for User mode, and
  1 for Supervisor mode.<br>
  For x86 and IA-64 processors: 0-3, where 0 is the most privileged.<br>
  For MIPS processors: 0
  </dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_General</b> Thrown if <i>cpu</i> does not implement the privilege
   level interface function.
<p>
   </p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_reset_processor">SIM_reset_processor()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_reset_processor2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_reset_processor"></a><b>SIM_reset_processor</b>  reset the processor</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_reset_processor(conf_object_t *NOTNULL cpu, int hard_reset);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Performs a reset on the processor, causing a System Reset exception to be
   taken when execution continues. <i>cpu</i> is the processor that should be
   reset.
   <i>hard_reset</i> indicates if a soft (0) or hard (1) (power-on type) reset
   should be performed. If a hard reset is requested, a number of register are
   initiated with default values.</dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_General</b> Thrown if <i>cpu</i> does not implement reset.<br>
<p>
   </p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>

</p><h2 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:Profiling">Profiling</a></h2>
<p></p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_iter_next">SIM_iter_next()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_iter_next2"></a><a id="simulator-api-functions.html:SIM_iter_addr"></a><a id="simulator-api-functions.html:SIM_iter_free"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_iter_next"></a><b>SIM_iter_next</b><b>, SIM_iter_addr</b><b>, SIM_iter_free</b>  Iterate over address profile counters</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">FORCE_INLINE uint64
SIM_iter_next(addr_prof_iter_t *iter);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE generic_address_t
SIM_iter_addr(addr_prof_iter_t *iter);
</pre><p></p><pre class="jdocu_small">FORCE_INLINE void
SIM_iter_free(addr_prof_iter_t *iter);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<b>EXPERIMENTAL.</b> While this functionality is expected to be retained in
   future releases, the interface is likely to change.
<p>
   
</p><p>
   

   An address profile iterator visits some of the counters of an address
   profiler in some order. It is obtained from the <b><i>iter</i></b> function of
   the <code>address_profiler</code> interface.
</p><p>
   <b><i>SIM_iter_next</i></b> advances the address profile iterator
   <i>iter</i> to the next nonzero counter and returns the count. It
   will return 0 when there are no more counters to visit. Note that the order
   in which the counters are visited is unspecified.
</p><p>
   <b><i>SIM_iter_addr</i></b> returns the address of the counter returned by the
   most recent call to <b><i>iter_next</i></b>.
</p><p>
   When you are done with the iterator, deallocate it with
   <b><i>SIM_iter_free</i></b>.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>

</p><h2 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:Simulation-Control">Simulation Control</a></h2>
<p></p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_break_message">SIM_break_message()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_break_message2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_break_message"></a><b>SIM_break_message</b>  stop the simulation</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_break_message(const char *msg);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Display the reason why Simics will stop simulation.
<p>
   This is similar to <b><i>SIM_break_simulation</i></b>, with the
   difference that it doesn't actually break the simulation. It can be
   used by code that wants to display a break message and stop the
   simulation by some other means.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<b><i>SIM_break_simulation</i></b></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_break_simulation">SIM_break_simulation()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_break_simulation2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_break_simulation"></a><b>SIM_break_simulation</b>  stop the simulation</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_break_simulation(const char *msg);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Ask Simics to stop the simulation as soon as possible, displaying the
   supplied message.
<p>
   Simics will normally stop before the next instruction is executed.
   If this function is called when an instruction has started
   executing, and the instruction can be aborted, it will rewind to
   before the instruction.  This might leave the simulation in a state
   where some repeatable part of the instruction is already executed.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<b><i>SIM_break_message</i></b></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_continue">SIM_continue()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_continue2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_continue"></a><b>SIM_continue</b>  run the simulation</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">pc_step_t
SIM_continue(int64 steps);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Run the simulation. In typical usage with <i>steps</i> being 0, the
   simulation will run forward until it is stopped, either by a breakpoint,
   internal event, or through the user interface.
<p>
   With a non-zero <i>steps</i>, Simics will make sure that at least
   one processor runs <i>steps</i> steps and then stop the
   simulation. As with <i>steps</i> being 0, the function can also
   return early if other break criteria are met.
</p><p>
   In order to properly control when simulation stops in time, it is advisable
   to use step or cycle breakpoints on one or more objects.
</p><p>
   The function returns non-zero if the simulation was started, and 0 otherwise.</p></dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_General</b> Thrown if the simulation could not be started. Check
   the exception message for more information.
<p>
   </p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_current_clock">SIM_current_clock()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_current_clock2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_current_clock"></a><b>SIM_current_clock</b>  return current clock</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">conf_object_t *
SIM_current_clock();
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns the clock (an object implementing the <code>cycle</code>
   interface) that is driving the simulation in the current cell and current
   thread. In Global Context, <code>NULL</code> is returned.
<p>
   Please note that typically model code would use <b><i>SIM_object_clock</i></b>
   to obtain the clock used for posting events. Another alternative for models
   is to get the initiator of a memory transaction from the memory transaction
   itself with the functions like <b><i>SIM_transaction_initiator</i></b> and
   <b><i>SIM_get_mem_op_initiator</i></b> and use that for event posting.
</p><p>
   The currently running clock returned by this function can be used, for
   example, to post events right after the current instruction finishes. But,
   as it is pointed out above, there are other alternatives for getting a clock
   for posting events. The use of this function is generally discouraged.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
   </a><b><i>SIM_object_clock</i></b>, <b><i>SIM_transaction_initiator</i></b>,
   <b><i>SIM_get_mem_op_initiator</i></b>
   </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_simics_is_running">SIM_simics_is_running()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_simics_is_running2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_simics_is_running"></a><b>SIM_simics_is_running</b>  check if simulation is running</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">bool
SIM_simics_is_running();
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns true if the simulation is running, e.g. if it has been started using
   <b><i>SIM_continue</i></b>, or false otherwise. It also returns true when the
   simulation is reversing.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>

</p><h2 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:Simulation-Independent-Services">Simulation Independent Services</a></h2>
<p></p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_cancel_realtime_event">SIM_cancel_realtime_event()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_cancel_realtime_event2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_cancel_realtime_event"></a><b>SIM_cancel_realtime_event</b>  cancel callback in host time</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">int
SIM_cancel_realtime_event(int64 id);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Cancel a callback registered by <b><i>SIM_realtime_event</i></b>, whose
   return value is specified as <i>id</i>.
<p>
   Returns 0 if the callback existed and was cancelled, or -1 if no callback
   with that identifier existed. (No exception is raised.)</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<b><i>SIM_realtime_event</i></b></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_notify_on_socket">SIM_notify_on_socket()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_notify_on_socket2"></a><a id="simulator-api-functions.html:SIM_notify_on_object"></a><a id="simulator-api-functions.html:SIM_notify_on_descriptor"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_notify_on_socket"></a><b>SIM_notify_on_socket</b><b>, SIM_notify_on_object</b><b>, SIM_notify_on_descriptor</b>  register notification on host I/O events</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_notify_on_socket(socket_t sock, notify_mode_t mode, int run_in_thread,
                     void (*callback)(lang_void *data), lang_void *data);
</pre><p></p><pre class="jdocu_small">void
SIM_notify_on_object(HANDLE obj, int run_in_thread,
                     void (*callback)(lang_void *data), lang_void *data);
</pre><p></p><pre class="jdocu_small">void
SIM_notify_on_descriptor(int fd, notify_mode_t mode, int run_in_thread,
                         void (*callback)(lang_void *data),
                         lang_void *data);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
These functions allow the function <i>callback</i> to be called
   with argument <i>data</i> whenever a specific I/O event occurs on
   the host machine. If <i>callback</i> is a null function pointer,
   a previously installed notification is removed.
<p>
   If <i>run_in_thread</i> is 1, the callback function may be run
   in a thread where it cannot access or call anything in Simics except for
   these functions and <b><i>SIM_thread_safe_callback</i></b>. If
   <i>run_in_thread</i> is zero, the callback function is always run in
   Global Context. This may incur a small penalty in latency (time
   between the occurrence of the host event and execution of
   <i>callback</i>).
</p><p>
   Values other than 0 and 1 for <i>run_in_thread</i> are reserved.
</p><p>
   Notification on a specific event will be blocked during the execution of
   its callback function.
</p><p>
   <b><i>SIM_notify_on_socket</i></b> will call a registered callback depending
   on <i>mode</i>:
</p><p>
   <table>

    <tbody><tr>
     <td class="jdocu_noborder"><i>mode</i></td>
     <td class="jdocu_noborder">condition</td>
    </tr>

    <tr>
     <td class="jdocu_noborder"><code>Sim_NM_Read</code></td>
     <td class="jdocu_noborder">Socket is readable, closed, or incoming connection accepted</td>
    </tr>

    <tr>
     <td class="jdocu_noborder"><code>Sim_NM_Write</code></td>
     <td class="jdocu_noborder">Socket is writeable, or outgoing connection has completed</td>
    </tr>

   </tbody></table>
   <a id="simulator-api-functions.html:notify_mode_t"></a>
</p><p>
   Socket notifiers of the mode <code>Sim_NM_Write</code> are not guaranteed
   to be called again unless a previous attempt to send data to the socket
   failed for flow control reasons (that is, it would have blocked).
</p><p>
   This means that notifiers of that mode should only be enabled for waiting on
   the completion of a nonblocking outgoing connection or for a previously
   "full" socket to accept data again.
</p><p>
   <b>Linux only</b>: <b><i>SIM_notify_on_descriptor</i></b> will call a
   registered callback depending on <i>mode</i> for a given file
   descriptor in a way similar to <b><i>SIM_notify_on_socket</i></b>.
</p><p>
   <b>Windows only</b>: <b><i>SIM_notify_on_object</i></b> will call a registered
   callback when <i>object</i> (which must be a waitable object) is in
   signalled state. The signalling object is modified in the same way as
   the Windows wait functions (<b><i>WaitForMultipleObjects</i></b> etc).
</p><p>
   </p><div class="note">
<b>Note:</b>
A notification should be removed before its socket or descriptor is
   closed.</div><div class="note">
<b>Note:</b>
On Windows, sockets registered for notification become nonblocking and
   must remain so for as long as they are registered. This is a limitation of
   the underlying Win32 API.</div></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context (call);
   Threaded Context (callback with nonzero <i>run_in_thread</i>);
   Global Context (callback otherwise)</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<b><i>SIM_thread_safe_callback</i></b></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_realtime_event">SIM_realtime_event()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_realtime_event2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_realtime_event"></a><b>SIM_realtime_event</b>  schedule callback in host time</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">int64
SIM_realtime_event(unsigned delay, void (*NOTNULL callback)(lang_void *data),
                   lang_void *data, int run_in_thread, const char *desc);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Register <i>callback</i> to be run in <i>delay</i> ms, with
   argument <i>data</i>. The delay is in real time (on the host
   machine), and the actual delay may be somewhat larger because of host
   scheduling.
<p>
   If <i>run_in_thread</i> is 1, the callback may be run in a
   thread where it cannot access or call anything in Simics except for
   <b><i>SIM_thread_safe_callback</i></b>. If <i>run_in_thread</i> is
   zero, the callback function is always run in Global Context,
   with the simulation temporarily suspended and the entire Simics API 
   available. This may cause the call to occur slightly later than requested,
   depending on what Simics is doing at the time.
</p><p>
   Values other than 0 and 1 for <i>run_in_thread</i> are reserved.
</p><p>
   The <i>desc</i> parameter is only present for debugging and has no
   other effect; it should be a static string describing the callback but may
   also be left NULL if desired.
</p><p>
   The callback is only called once.
</p><p>
   The return value is a non-zero identifier that can be used to cancel the
   callback using <b><i>SIM_cancel_realtime_event</i></b>.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context. The callback is called in
   Threaded Context if <i>run_in_thread</i> is nonzero,
   in Global Context otherwise.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
     </a><b><i>SIM_cancel_realtime_event</i></b>, <b><i>SIM_thread_safe_callback</i></b>
   </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_register_work">SIM_register_work()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_register_work2"></a><a id="simulator-api-functions.html:SIM_thread_safe_callback"></a><a id="simulator-api-functions.html:SIM_run_alone"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_register_work"></a><b>SIM_register_work</b><b>, SIM_thread_safe_callback</b><b>, SIM_run_alone</b>  register function to be called in Global Context</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_register_work(void (*NOTNULL f)(lang_void *data), lang_void *data);
</pre><p></p><pre class="jdocu_small">void
SIM_thread_safe_callback(void (*NOTNULL f)(lang_void *data), lang_void *data);
</pre><p></p><pre class="jdocu_small">void
SIM_run_alone(void (*NOTNULL f)(lang_void *data), lang_void *data);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<b><i>SIM_register_work</i></b> and <b><i>SIM_thread_safe_callback</i></b>
   register work to be done in Global Context as soon as
   possible, (but not during the call to <b><i>SIM_register_work</i></b> or
   <b><i>SIM_thread_safe_callback</i></b> itself).
<p>
   <b><i>SIM_run_alone</i></b> also registers work to be done in Global Context
   and if called from Cell Context the callback is executed before the next
   instruction is dispatched in the cell. If this isn't used the cell may
   execute several instructions before the callback is executed.
   If <b><i>SIM_run_alone</i></b> is used while an instruction is being emulated
   then the callback will be invoked when the current instruction has completed
   and before the next instruction is dispatched.
</p><p>
   No other execution threads are running when the callback is invoked,
   but their exact position in simulated time may vary between runs. If
   the callback accesses objects in cells other than the one that
   <b><i>SIM_run_alone</i></b> was called from, then care must be taken to
   preserve determinism.
</p><p>
   When the callback is run, it is executed in Global Context,
   which means that it is safe to call any API functions from
   it. Another thread in the module may at this time also call API
   functions, if it synchronizes correctly with the callback
   function. For example, the callback function might just signal to the
   foreign thread to do its Simics API calls, wait for the thread to
   signal that it has finished, and then return.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Threaded context (call);
   Global Context (callback)
   </dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<b><i>SIM_run_unrestricted</i></b></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_run_async_work">SIM_run_async_work()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_run_async_work2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_run_async_work"></a><b>SIM_run_async_work</b>  launch asynchronous work in a separate thread</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_run_async_work(lang_void *(*NOTNULL async_call)(lang_void *arg),
                   void (*async_ready)(lang_void *async_ret, lang_void *arg),
                   lang_void *arg);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<b><i>SIM_run_async_work</i></b> creates a new thread, running in parallel with
   the Simics main thread, where the <i>async_call</i> function will be
   called. Since the function runs in Threaded Context, most Simics API
   functions are not available. Once the <i>async_call</i> function has
   run, its return value is passed to <i>async_ready</i>, if supplied,
   that will be called in Global Context, i.e. in the Simics main thread.
<p>
   The user supplied <i>arg</i> parameter is passed unmodified to both
   callback functions.
</p><p>
   <b><i>SIM_run_async_work</i></b> is typically used when calling functions that
   would block the main thread for a long time while obtaining their result.
</p><p>
   If the result of <b><i>SIM_run_async_work</i></b> is used in the simulation, it
   should be sent through a recorder to make sure that the session can be
   replayed. See the recorder module and the <code>recorder_v2</code>
   interface for more information.</p></dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
<pre class="jdocu_small">import socket

def async_call(arg):
    # runs in separate thread without blocking Simics
    return socket.gethostbyname(arg)

def async_ready(ret, arg):
    # runs in Simics main thread with access to the full Simics API
    print("Host %s has IP address %s" % (arg, ret))

simics.SIM_run_async_work(async_call, async_ready, "www.intel.com")
</pre><p></p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context (call);
     Threaded Context (<i>async_call</i> callback);
     Global Context (<i>async_ready</i> callback)
   </dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
     </a><b><i>SIM_notify_on_descriptor</i></b>, <b><i>SIM_notify_on_object</i></b>,
     <b><i>SIM_notify_on_socket</i></b>, <b><i>SIM_thread_safe_callback</i></b>,
     <b><i>SIM_run_alone</i></b>, <b><i>SIM_run_unrestricted</i></b>
   </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_run_in_thread">SIM_run_in_thread()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_run_in_thread2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_run_in_thread"></a><b>SIM_run_in_thread</b>  run function in a separate thread</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_run_in_thread(void (*NOTNULL f)(lang_void *arg), lang_void *arg);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<b><i>SIM_run_in_thread</i></b> schedules the callback <i>f</i> to run
   on a separate thread. The callback will run in Threaded Context
   and must observe the associated restrictions.
<p>
   Simics maintains a pool of worker threads used by this function, and hence
   the callback can typically be started quickly.
</p><p>
   The callback is allowed to block or otherwise run for a long time.
</p><p>
   The user supplied <i>arg</i> parameter is passed unmodified to the
   callback.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Any thread context (call);
     Threaded Context (callback);
   </dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
     </a><b><i>SIM_run_async_work</i></b>, <b><i>SIM_run_alone</i></b>
   </dd>
</dl><p>

</p><h2 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:Simulator-Translation-Caches">Simulator Translation Caches</a></h2>
<p></p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_STC_flush_cache">SIM_STC_flush_cache()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_STC_flush_cache2"></a><a id="simulator-api-functions.html:SIM_flush_I_STC_logical"></a><a id="simulator-api-functions.html:SIM_flush_D_STC_logical"></a><a id="simulator-api-functions.html:SIM_flush_I_STC_physical"></a><a id="simulator-api-functions.html:SIM_flush_D_STC_physical"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_STC_flush_cache"></a><b>SIM_STC_flush_cache</b><b>, SIM_flush_I_STC_logical</b><b>, SIM_flush_D_STC_logical</b><b>, SIM_flush_I_STC_physical</b><b>, SIM_flush_D_STC_physical</b>  flush or remove entries in the STCs of a cpu</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_STC_flush_cache(conf_object_t *NOTNULL cpu);
</pre><p></p><pre class="jdocu_small">void
SIM_flush_I_STC_logical(conf_object_t *NOTNULL cpu,
			logical_address_t vaddr,
                        logical_address_t length);
</pre><p></p><pre class="jdocu_small">void
SIM_flush_D_STC_logical(conf_object_t *NOTNULL cpu,
			logical_address_t vaddr,
                        logical_address_t length);
</pre><p></p><pre class="jdocu_small">void
SIM_flush_I_STC_physical(conf_object_t *NOTNULL cpu,
                         physical_address_t paddr,
                         physical_address_t length);
</pre><p></p><pre class="jdocu_small">void
SIM_flush_D_STC_physical(conf_object_t *NOTNULL cpu,
                         physical_address_t paddr,
                         physical_address_t length,
                         read_or_write_t read_or_write);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
These functions remove entries from the Simics internal caches (STCs) or
   completely flushes the STCs contents. Memory mappings which have been
   cached in the STCs will be faster for Simics to execute. Simics
   extensions such as a cache model will need to flush entries in the STC
   when a cache line is replaced, in order to be called when a cache line
   is used again.
   <p>
   <b><i>SIM_STC_flush_cache</i></b> flushes the entire contents of the STCs
   (both instruction and data) from the specified cpu.
</p><p>
   The <b><i>SIM_flush_<em>xxx</em></i></b> functions removes specified memory
   ranges in the instruction or data STC. The address range is either the
   logical or the physical address. The <code>read_or_write</code> parameter
   specifies whether the read or the write D-STC should be flushed. If the
   function doesn't have such a parameter, both read and write D-STCs are
   flushed. The flushed address range is at least [ <i>vaddr</i>
   ... (<i>vaddr</i> + <i>length</i>  1) ], but may be larger.
   <b><i>SIM_flush_D_STC_logical</i></b> currently always flushes an entire
   page.
</p><p>
   The <b><i>SIM_flush_<em>xxx</em></i></b> functions can only be used on CPUs
   that implement the internal <code>stc</code> interface; hence, they can
   not be used on user-defined CPU models.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_flush_all_caches">SIM_flush_all_caches()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_flush_all_caches2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_flush_all_caches"></a><b>SIM_flush_all_caches</b>  clear Simics's internal caches</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_flush_all_caches();
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Clears Simics's internal caches such as STC contents and intermediate code.
   This function is mainly for internal use (for debugging purposes)
   and may be removed in the future.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_flush_cell_caches">SIM_flush_cell_caches()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_flush_cell_caches2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_flush_cell_caches"></a><b>SIM_flush_cell_caches</b>  clear internal caches for a given cell</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_flush_cell_caches(conf_object_t *NOTNULL obj);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Clears internal caches in Simics for a given cell, such as STC contents and
   intermediate code.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>

</p><h2 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:Stalling">Stalling</a></h2>
<p></p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_stall_count">SIM_stall_count()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_stall_count2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_stall_count"></a><b>SIM_stall_count</b>  get number of cycles a processor has been stalled</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">cycles_t
SIM_stall_count(conf_object_t *NOTNULL obj);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<b><i>SIM_stall_count</i></b> returns the total number of cycles the
   processor associated to <i>obj</i> has been stalled.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Returns the total number of cycles the processor associated with
   <i>obj</i> has been stalled.
   </dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_stall_cycle">SIM_stall_cycle()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_stall_cycle2"></a><a id="simulator-api-functions.html:SIM_stall"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_stall_cycle"></a><b>SIM_stall_cycle</b><b>, SIM_stall</b>  stall execution a specified number of cycles</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_stall_cycle(conf_object_t *NOTNULL obj, cycles_t cycles);
</pre><p></p><pre class="jdocu_small">void
SIM_stall(conf_object_t *NOTNULL obj, double seconds);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<b><i>SIM_stall_cycle</i></b> and <b><i>SIM_stall</i></b> set the stall duration
   of the processor <i>obj</i>. The stall duration is given in clock
   cycles or seconds and is how long <i>obj</i> will stall before
   resuming its normal activity. If <i>obj</i> was already stalling,
   the time remaining is changed. A zero stall duration is a request to cease
   stalling immediately.
<p>
   The specified duration is interpreted as relative the local time of
   <i>obj</i>.
</p><p>
   <i>obj</i> must implement the <code>stall</code> and
   <code>cycle</code> interfaces.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_General</b> Thrown if <i>cycles</i> or <i>seconds</i> is negative.
<p>
   </p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
     </a><b><i>SIM_stalled_until</i></b>, <b><i>SIM_stall_count</i></b>
   </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_stalled_until">SIM_stalled_until()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_stalled_until2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_stalled_until"></a><b>SIM_stalled_until</b>  query how many cycles that remains of stall</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">cycles_t
SIM_stalled_until(conf_object_t *NOTNULL obj);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<b><i>SIM_stalled_until</i></b> returns how many more cycles the
   processor will stall before the associated processor starts to
   execute instructions again.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>

</p><h2 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:Time-and-Events">Time and Events</a></h2>
<p></p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_get_global_message">SIM_get_global_message()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_get_global_message2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_get_global_message"></a><b>SIM_get_global_message</b>  obtain current global message</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">const char *
SIM_get_global_message(void *ref);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Return the global message currently being triggered, if <i>ref</i>
   does not match the reference of the source trigger, otherwise return
   <code>NULL</code>.
<p>
   This function must only be called from a callback of the global notifier
   <code>Sim_Global_Notify_Message</code>.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context
   </dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
   </a><b><i>SIM_trigger_global_message</i></b>
   </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_trigger_global_message">SIM_trigger_global_message()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_trigger_global_message2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_trigger_global_message"></a><b>SIM_trigger_global_message</b>  queue up a global message</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_trigger_global_message(const char *msg, void *ref);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This queues up a global message, which will be dispatched shortly in
   global context, to all listeners of the Sim_Global_Notify_Message
   global notifier. The <i>ref</i> parameter is the reference of the
   source, or <code>NULL</code> to dispatch to all listeners.
<p>
   The notifier callbacks should use <b><i>SIM_get_global_message</i></b> to
   retrieve the message. Only callbacks that provide a <code>NULL</code> reference
   or a reference different from <i>ref</i> will obtain the message.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
All contexts including Threaded Context
   </dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
   </a><b><i>SIM_get_global_message</i></b>
   </dd>
</dl><p>

</p><h2 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:User-Interface">User Interface</a></h2>
<p></p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_call_python_function">SIM_call_python_function()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_call_python_function2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_call_python_function"></a><b>SIM_call_python_function</b>  call a Python named function</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">attr_value_t
SIM_call_python_function(const char *NOTNULL func, attr_value_t *NOTNULL args);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Calls the Python function named <i>func</i> with arguments in
     <i>args</i>, which must be a list.
<p>
     The namespace searched for <i>func</i> is the same as the Simics
     commands <b>@</b> and <b>python</b> use; i.e., the Python module
     <code>__main__</code>. You may want to use a module-relative name for
     <i>func</i> such as <code>__builtin__.repr</code> when calling functions 
     not defined at the Simics command-line. This avoids calling any local
     redefinition of that function.</p></dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_Type</b> Thrown if <i>args</i> is not list or cannot be
       converted to Python or if <b><i>func</i></b> is not callable or if the
       return value cannot be converted to an <code>attr_value_t</code>.<br>
<p>
       <b>SimExc_Lookup</b> Thrown if <b><i>func</i></b> does not exist.<br>
       <b>SimExc_General</b> Thrown if there was an error executing
       Python code.<br>
       <b>SimExc_Break</b> Thrown on user interrupt.
     </p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Return value of the Python function
     </dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context
     </dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
       </a><b><i>SIM_make_attr_list</i></b>, <b><i>SIM_run_python</i></b>
     </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_get_api_function">SIM_get_api_function()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_get_api_function2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_get_api_function"></a><b>SIM_get_api_function</b>  return an API function by name</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">api_function_t
SIM_get_api_function(const char *function);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Looks up a C function in the Simics API based on its name and returns a
   pointer to it. Typically used to access a function added to the Simics API
   in an update release (minor version) while remaining binary compatible with
   older versions of Simics.
<p>
   The pre-processor macro <code><a id="simulator-api-functions.html:GET_API_FUNCTION">GET_API_FUNCTION</a></code> provides
   wrapping of <b><i>SIM_get_api_function</i></b> for simpler type casting.
</p><p>
   <b><i>SIM_get_api_function</i></b> is neither available nor needed in Python.
   Code examples showing how to access a new function in a backward compatible
   in Python are provided below.</p></dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
A new function <b><i>SIM_foo</i></b> is introduced in the
   Simics release with <em>build id</em> 5234. Since older versions of Simics
   do not have this function, a module writer that wants to use it while
   remaining compatible with old Simics versions, can write the following:<br>
   <pre class="jdocu_small">    GET_API_FUNCTION(tmp_SIM_foo, SIM_foo);
    if (tmp_SIM_foo != NULL)
        tmp_SIM_foo(1);
    else
        // code for older versions
   </pre><p>
</p><p>
   Once compatibility with versions before build id 5234 can be dropped, the
   code in the example is simply replaced with a direct call to
   <b><i>SIM_foo</i></b>.
</p><p>
   In Python, one can check whether the function is present like this:<br>
   </p><pre class="jdocu_small">    if hasattr(simics, 'SIM_foo'):
        simics.SIM_foo(1)
    else:
        # code for older versions
   </pre><p>
</p><p>
   Another alternative for Python code is to check the build id value:<br>
   </p><pre class="jdocu_small">    if conf.sim.build_id &gt;= 5234:
        simics.SIM_foo(1)
    else:
        # code for older versions
   </pre><p>
   </p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Returns a pointer to the API function if it exists
   or zero. The return type <code>api_function_t</code> is defined as:
   
<pre class="jdocu_small">typedef void (*api_function_t)(void);</pre><p>
</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_get_batch_mode">SIM_get_batch_mode()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_get_batch_mode2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_get_batch_mode"></a><b>SIM_get_batch_mode</b>  return setting of the batch-mode</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">bool
SIM_get_batch_mode();
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This function returns the current value of Simics's batch-mode flag.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_get_debugger">SIM_get_debugger()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_get_debugger2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_get_debugger"></a><b>SIM_get_debugger</b>  return the debugger object</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">conf_object_t *
SIM_get_debugger();
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns the Simics Debugger. The returned object is the object which
   implements the Simics Debugger API. The debugger object is created if it
   does not already exist. Returns NULL and signals an exception if the
   debugger could not be created.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Returns the debugger object</dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_General</b> Thrown if the debugger could not be created.
   </dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_load_target">SIM_load_target()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_load_target2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_load_target"></a><b>SIM_load_target</b>  load Simics target from file</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">attr_value_t
SIM_load_target(const char *NOTNULL target,
                const char *ns, attr_value_t presets,
                attr_value_t cmdline_args);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Load the target <i>target</i> into Simics. This can either be a
   file name or a target name, as returned by the <b>list-targets</b>
   command.
<p>
   This function is functionally equivalent to invoking the script by passing
   it as a command line argument or to running the script with the
   <b>load-target</b> or <b>run-script</b> command, with the
   <code>local</code> flag set.
</p><p>
   The <i>ns</i> and <i>presets</i> arguments have the same
   semantics as <i>namespace</i> and <i>presets</i> arguments to the
   <b>run-script</b> command.
</p><p>
   The <i>cmdline_args</i> argument should be a list of 2-element lists
   of target parameters <code>[name, value]</code>.</p></dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_Break</b> Thrown if the script was interrupted by the user.<br>
<p>
   <b>SimExc_General</b> Thrown if the script was interrupted by an error.<br>
</p><p>
   <b>SimExc_IOError</b> Thrown if the script file could not be opened.<br>
</p><p>
   </p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_quit">SIM_quit()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_quit2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_quit"></a><b>SIM_quit</b>  quit Simics</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_quit(int exit_code);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Quit Simics in an orderly fashion. The Simics process will return the value
   <i>exit_code &amp; 0xFF</i>, since the exit(3) call from the C standard
   library is used (see its man page). See the Core_Clean_At_Exit and
   Core_At_Exit haps for ways to run user code when Simics exits. Callbacks for
   the Core_Clean_At_Exit hap will only run if <b><i>SIM_quit</i></b> is called
   from Global Context, while Core_At_Exit is always called</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context. Global Context if possible.</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_run_command">SIM_run_command()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_run_command2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_run_command"></a><b>SIM_run_command</b>  evaluate a CLI command</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">attr_value_t
SIM_run_command(const char *NOTNULL line);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Runs a CLI command and returns the value, if any, as an attr_value_t.</dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_General</b> Thrown if there was an error executing the CLI
   command.<br>
<p>
   <b>SimExc_Type</b> Thrown if the return value could not be converted
   to an <code>attr_value_t</code>.
</p><p>
   </p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_run_command_file">SIM_run_command_file()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_run_command_file2"></a><a id="simulator-api-functions.html:SIM_run_command_file_params"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_run_command_file"></a><b>SIM_run_command_file</b><b>, SIM_run_command_file_params</b>  read CLI commands from file</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_run_command_file(const char *NOTNULL file, bool local);
</pre><p></p><pre class="jdocu_small">void
SIM_run_command_file_params(const char *NOTNULL file, bool local,
                            attr_value_t params);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Read and execute the script file <i>file</i>; i.e., execute each line
   in the file as if it was typed at the Simics prompt.
   <p>
   This function is functionally equivalent to invoking the script by
   passing it as a command line argument or to running the script with
   the <b>run-command-file</b> command.
</p><p>
   If <i>local</i> is true, the script will run with its own
   copy of all global CLI variables. When the script has finished executing,
   the previous variable set is restored.
</p><p>
   The <i>params</i> argument can be used to pass parameters to the
   script. It must be a list of name-value pairs of strings, for example, from
   Python it could be <code>[["num_cores", "4"], ["memory_megs", "1024"]]</code>.</p></dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_Break</b> Thrown if the script was interrupted by the user.<br>
<p>
   <b>SimExc_General</b> Thrown if the script was interrupted by an error.<br>
</p><p>
   <b>SimExc_IOError</b> Thrown if the script file could not be opened.<br>
</p><p>
   </p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_run_python">SIM_run_python()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_run_python2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_run_python"></a><b>SIM_run_python</b>  run a Python expression</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">attr_value_t
SIM_run_python(const char *NOTNULL line);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<b><i>SIM_run_python</i></b> runs a Python expression or statement. The
     return value, if any, is converted to a Simics attribute value. If
     <i>line</i> is a statement, a NIL attribute is returned.</dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_General</b> Thrown if there was an error executing
       Python code.<br>
<p>
       <b>SimExc_Type</b> Thrown if the return value could not be converted
       to an <code>attr_value_t</code>.<br>
</p><p>
       <b>SimExc_Break</b> Thrown on user interrupt.
     </p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-data-types.html:__jdocu_seealso_4">
       </a><b><i>SIM_call_python_function</i></b>
     </dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context
     </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_shutdown">SIM_shutdown()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_shutdown2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_shutdown"></a><b>SIM_shutdown</b>  shutdown Simics</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_shutdown();
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Perform the same clean up as <b><i>SIM_quit</i></b>, but do not exit the
   process. After having called this function, no Simics API function can be
   called.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context. Global Context
   if possible.</dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="simulator-api-functions.html:SIM_source_python">SIM_source_python()</a></h3>
<p>

<a id="simulator-api-functions.html:SIM_source_python2"></a><a id="simulator-api-functions.html:SIM_source_python_in_module"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simulator-api-functions.html:__jdocu_seealso_SIM_source_python"></a><b>SIM_source_python</b><b>, SIM_source_python_in_module</b>  execute Python source file</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIM_source_python(const char *NOTNULL file);
</pre><p></p><pre class="jdocu_small">void
SIM_source_python_in_module(const char *NOTNULL file,
                            const char *NOTNULL module);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<b><i>SIM_source_python</i></b> executes Python from <i>file</i> in the
     global Python scope. <b><i>SIM_source_python_in_module</i></b> is similar
     but executes the file contents in a named Python module.</dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>SimExc_General</b> Thrown if there was an error executing
       Python code.<br>
<p>
       <b>SimExc_IOError</b> Thrown if there was an error opening the file.<br>
</p><p>
       <b>SimExc_Break</b> Thrown on user interrupt.
</p><p>
     </p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context
     </dd>
</dl><p>


</p></section><section class="page" id="simulator-to-simulator-interfaces.html"><h1 class="jdocu"><a id="simulator-to-simulator-interfaces.html:Simulator-to-Simulator-Interfaces">7 Simulator-to-Simulator Interfaces</a></h1>
<p>

    




























































</p></section><section class="page" id="__rm_interface_address_profiler.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_address_profiler.html:__rm_interface_address_profiler">address_profiler</a></h1>
<p>

<a id="__rm_interface_address_profiler.html:address_profiler"></a><a id="__rm_interface_address_profiler.html:address_profiler_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Interface for getting statistics out of profilers. The target is some kind
   of profiler whose data can be meaningfully viewed as counts per address.
<p>
   The function <b><i>num_views</i></b> returns the number k of
   different ways you can view the data of this object. The view selection
   parameter <i>view</i> to all other functions in the interface
   accepts values between 0 and k  1.
</p><p>
   <b><i>description</i></b> returns a short string that explains what the data
   means. <b><i>physical_addresses</i></b> returns true if the profiler works with
   physical addresses, or false if it uses virtual addresses.
   <b><i>address_bits</i></b> returns the number of bits in an address.
</p><p>
   <b><i>granularity_log2</i></b> returns the base 2 logarithm of the size, in
   bytes, of the address intervals that the counters are associated to. For
   example, if the data is instruction execution count and each instruction is
   4 bytes long, one would expect the granularity to be at least 4 bytes since
   that is the smallest interval containing a whole instruction (but it might
   be more, if the profiler is less fine-grained for some reason). And for a
   4-byte granularity, <b><i>granularity_log2</i></b> would return 2.
</p><p>
   <b><i>sum</i></b> returns the sum of all counters between <i>start</i>
   and <i>stop</i>, inclusive. <b><i>max</i></b> returns the maximum value
   of any counter in the range.
</p><p>
   <b><i>iter</i></b> returns an address profile iterator that will visit all
   nonzero counters in the range precisely once, in some order. In C, you can
   use the functions <b><i>SIM_iter_next</i></b>, <b><i>SIM_iter_addr</i></b> and
   <b><i>SIM_iter_free</i></b> to operate the iterator. In Python, it works just
   like any other iterator, and returns (count, address) pairs. Note that you
   may not continue to use the iterator after the underlying address profiler
   has been modified.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(address_profiler) {
        addr_prof_iter_t *(*iter)(conf_object_t *prof_obj, unsigned view,
                                  generic_address_t start,
                                  generic_address_t stop);
        uint64 (*sum)(conf_object_t *prof_obj, unsigned view,
                      generic_address_t start, generic_address_t end);
        uint64 (*max)(conf_object_t *prof_obj, unsigned view,
                      generic_address_t start, generic_address_t end);
        unsigned (*granularity_log2)(conf_object_t *prof_obj, unsigned view);
        int (*address_bits)(conf_object_t *prof_obj, unsigned view);
        int (*physical_addresses)(conf_object_t *prof_obj, unsigned view);
        const char *(*description)(conf_object_t *prof_obj, unsigned view);
        unsigned (*num_views)(conf_object_t *prof_obj);
};

#define ADDRESS_PROFILER_INTERFACE "address_profiler"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_branch_arc.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_branch_arc.html:__rm_interface_branch_arc">branch_arc</a></h1>
<p>

<a id="__rm_interface_branch_arc.html:branch_arc"></a><a id="__rm_interface_branch_arc.html:branch_arc_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><a id="__rm_interface_branch_arc.html:branch_arc_iter_t"></a>
   <a id="__rm_interface_branch_arc.html:branch_arc_t"></a>
   <a id="__rm_interface_branch_arc.html:branch_arc_type_t"></a>
   <a id="__rm_interface_branch_arc.html:branch_recorder_direction_t"></a>
<p>
   Interface for getting branch arcs out profilers. The target is some kind of
   profiler whose data can be meaningfully viewed as branch arcs (usually a
   branch profiler).
</p><p>
   <b><i>iter</i></b> returns a branch arc iterator that will visit all branch
   arcs in the range precisely once, in order of selected address (to or from,
   selected with <i>dir</i>), other address and type. In Python, it
   works just like any other iterator, and returns (from, to, counter, type)
   tuples. Note that you may not continue to use the iterator after the
   underlying profiler has been modified.
</p><p>
  <code>branch_arc_type_t</code> defines the branch types returned by a branch
  arc iterator.
</p><p>
  </p><dl><dt id="__rm_interface_branch_arc.html:dt:branch_arc_branch"><a href="#__rm_interface_branch_arc.html:dt:branch_arc_branch"><b><code>Branch_Arc_Branch</code></b></a></dt><dd>Normal branch operation</dd><dt id="__rm_interface_branch_arc.html:dt:branch_arc_exception"><a href="#__rm_interface_branch_arc.html:dt:branch_arc_exception"><b><code>Branch_Arc_Exception</code></b></a></dt><dd>Branch because an exception 
  was encountered</dd><dt id="__rm_interface_branch_arc.html:dt:branch_arc_exception_return"><a href="#__rm_interface_branch_arc.html:dt:branch_arc_exception_return"><b><code>Branch_Arc_Exception_Return</code></b></a></dt><dd>Branch to finish an 
  exception handler</dd></dl><p></p><pre class="jdocu_small">typedef enum {
        Branch_Arc_Branch,
        Branch_Arc_Exception,
        Branch_Arc_Exception_Return,
        Branch_Arc_Max
} branch_arc_type_t;</pre><p>

   
</p><pre class="jdocu_small">typedef enum {
        BR_Direction_From,
        BR_Direction_To
} branch_recorder_direction_t;</pre><p>

   </p><pre class="jdocu_small">SIM_INTERFACE(branch_arc) {
        branch_arc_iter_t *(*iter)(conf_object_t *prof_obj,
                                   generic_address_t start,
                                   generic_address_t stop,
                                   branch_recorder_direction_t dir);
};

#define BRANCH_ARC_INTERFACE "branch_arc"
</pre><p>
</p><p>

   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_break_strings_v2.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_break_strings_v2.html:__rm_interface_break_strings_v2">break_strings_v2</a></h1>
<p>

<a id="__rm_interface_break_strings_v2.html:break_strings_v2"></a><a id="__rm_interface_break_strings_v2.html:break_strings_v2_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>break_strings_v2</code> interface facilitates management of
   string breakpoints. It is implemented by the text console and the graphics
   console (but will only function when in text mode).
<p>
   The text console tries to match each break string on the stream of
   characters coming from the attached serial device, and if a match occurs,
   the given callback function will be called. If no callback is given, the
   simulation will be stopped. The graphics console behaves in the same way,
   but in this case the character stream is defined by what is sent to the
   console via the <code>vga_text_update</code> interface. Break strings
   only lives during a single Simics session, they are not checkpointed.
</p><p>
   The <b><i>add</i></b> method registers a breakpoint string <i>str</i>, and
   returns a breakpoint ID, unique during the Simics session, which is also
   passed to <i>cb</i> when the breakpoint matches. If <i>cb</i> is not
   <code>NULL</code>, then this function will be called on breakpoint match,
   otherwise a match stops the simulation.
</p><p>
   The <b><i>add_single</i></b> method is similar to <b><i>add</i></b>, but the
   breakpoint is removed automatically after the first match.
</p><p>
   The <b><i>add_regexp</i></b> method is similar to <b><i>add</i></b>, but the given
   string is interpreted as a regular expression. The support regular
   expression syntax is that of the Hyperscan library
   <a class="jdocu" href="https://hyperscan.io" rel="noopener noreferrer" target="_top">https://hyperscan.io</a>.
</p><p>
   The <b><i>remove</i></b> method deactivates a previously activated breakpoint.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(break_strings_v2) {
        int64 (*add)(conf_object_t *NOTNULL obj, const char *str,
                     break_string_cb_t cb, lang_void *arg);
        int64 (*add_single)(conf_object_t *NOTNULL obj, const char *str,
                            break_string_cb_t cb, lang_void *arg);
        int64 (*add_regexp)(conf_object_t *NOTNULL obj, const char *str,
                            break_string_cb_t cb, lang_void *arg);
        void (*remove)(conf_object_t *NOTNULL obj, int64 bp_id);
};
#define BREAK_STRINGS_V2_INTERFACE "break_strings_v2"
</pre><p>
 
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Global Context
   for all methods
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_breakpoint_manager.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_breakpoint_manager.html:__rm_interface_breakpoint_manager">breakpoint_manager</a></h1>
<p>

<a id="__rm_interface_breakpoint_manager.html:breakpoint_manager"></a><a id="__rm_interface_breakpoint_manager.html:breakpoint_manager_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">An internal interface used by the breakpoint manager. Can be changed
   at any time.
   
</dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Internal.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_breakpoint_type.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_breakpoint_type.html:__rm_interface_breakpoint_type">breakpoint_type</a></h1>
<p>

<a id="__rm_interface_breakpoint_type.html:breakpoint_type"></a><a id="__rm_interface_breakpoint_type.html:breakpoint_type_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>breakpoint_type</code> interface is implemented by the
   breakpoint manager and facilitates registering breakpoint types.
<p>
   This interface is currently a tech preview and can be changed at any time.
</p><p>
   The <b><i>register_type</i></b> method registers a breakpoint type and creates
   CLI commands for this type. The <i>name</i> parameter should be the
   unique name for the type, which is also used in the names of any commands
   registered on interfaces or class. The <i>provider</i> parameter should
   be the provider object, which must implement the
   <code>breakpoint_type_provider</code> interface.
</p><p>
   The registered commands are <b>break</b>, <b>run-until</b>,
   <b>wait-for</b>, <b>trace</b> and <b>untrace</b>, which are
   registered on the provider class. If <i>cls</i> or <i>iface</i> are
   non-NULL, commands are also registered on that class or interface. These
   commands are <b>bp-break-{name}</b>, <b>bp-run-until-{name}</b>,
   <b>bp-wait-for-{name}</b>, <b>bp-trace-{name}</b> and
   <b>bp-untrace-{name}</b>, where {name} is the <i>name</i> parameter.
</p><p>
   The <i>cls</i> and <i>iface</i> parameters cannot both be non-NULL.
</p><p>
   The <i>args</i> parameter is a list that defines the CLI command
   arguments. It should be a list of lists where each inner list contains the
   name of the cli.Arg_type subclass, such as <code>str_t</code>, <code>flag_t</code>
   etc, and then all parameters to its constructor (including values for
   parameters that have default values).
</p><p>
   The <i>docs</i> parameter should be an 8-element list with short and
   long command documentation texts for the four commands <b>break</b>,
   <b>run-until</b>, <b>wait-for</b> and <b>trace</b>.
</p><p>
   The <i>object_required</i> parameter indicates if the commands
   registered on the provider class (as opposed to the commands on the class or
   interface) should require an object (or if the command can use a default
   object). Note that there will only be an object parameter if <i>cls</i>
   or <i>iface</i> are non-NULL.
</p><p>
   The <i>temporary_default</i> parameter indicates if the breakpoints of
   this type should be temporary by default. This also results in the generated
   break command not having a -once flag.
</p><p>
   Setting <i>recursive</i> to true will append a '-recursive' flag to both
   global and object commands, and for the global command, the 'object'
   argument will have no specified class or iface.
</p><p>
   The <b><i>trigger</i></b> method must be called by the provider every time a
   breakpoint triggers, both breakpoints added with <b><i>register_bp</i></b>
   method and those added with <b><i>add_bp</i></b> method of the
   <code>breakpoint_type_provider</code> interface.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(breakpoint_type) {
        /* Returns false if type is already registered. */
        bool (*register_type)(conf_object_t *NOTNULL mgr,
                              const char *NOTNULL name,
                              conf_object_t *NOTNULL provider,
                              /* CLI command arguments as a list */
                              attr_value_t args,
                              /* Class and/or iface for command */
                              const char *cls,
                              const char *iface,
                              /* 8-element list with short and long
                                 command help texts */
                              attr_value_t docs,
                              /* Is an object required
                                 (or can it default to something) */
                              bool object_required,
                              /* Should breakpoints be temporary by default? */
                              bool temporary_default,
                              /* Set to true to allow all objects in 'object' argument */
                              bool recursive);
        /* Notify manager that breakpoint has triggered, given ID returned by
           add_bp. Returns true if simulation was stopped or otherwise the
           breakpoint action happened. Optionally provide trigger object and
           message, used if the simulation is stopped. */
        bool (*trigger)(conf_object_t *NOTNULL mgr,
                        conf_object_t *NOTNULL provider, uint64 bp_id,
                        conf_object_t *trigger, const char *msg);
        /* Return provider ID from breakpoint manager ID. */
        uint64 (*get_break_id)(conf_object_t *NOTNULL mgr, uint64 bm_id);
        uint64 (*get_manager_id)(conf_object_t *NOTNULL mgr,
                                 conf_object_t *NOTNULL provider, uint64 bp_id);
};
#define BREAKPOINT_TYPE_INTERFACE "breakpoint_type"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Global Context
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_breakpoint_type_provider.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_breakpoint_type_provider.html:__rm_interface_breakpoint_type_provider">breakpoint_type_provider</a></h1>
<p>

<a id="__rm_interface_breakpoint_type_provider.html:breakpoint_type_provider"></a><a id="__rm_interface_breakpoint_type_provider.html:breakpoint_type_provider_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>breakpoint_type_provider</code> interface should be implemented
   by objects that wish to act as breakpoint type providers towards the
   breakpoint manager. An object that is passed to the breakpoint manager via
   the <b><i>register_type</i></b> method in the <code>breakpoint_type</code>
   interface must implement <code>breakpoint_type_provider</code>.
<p>
   This interface is currently a tech preview and can be changed at any time.
</p><p>
   The <b><i>register_bp</i></b> and <b><i>add_bp</i></b> methods receives the
   command arguments, corresponding to what the breakpoint manager received in
   the <b><i>register_type</i></b>. The <b><i>register_bp</i></b> method should set
   up a breakpoint, register it with the breakpoint manager via the
   <code>breakpoint_registration</code> interface, and return the breakpoint
   manager ID for that breakpoint. The <b><i>add_bp</i></b> method should set up
   an internal breakpoint, which is not registered with the breakpoint manager,
   and return a provider-specific ID for this breakpoint. The breakpoint
   manager will use this ID to remove the breakpoint via the
   <b><i>remove_bp</i></b> method, and this ID should also be used when calling
   the <b><i>trigger</i></b> method in the <code>breakpoint_type</code>
   interface.
</p><p>
   The <b><i>register_bp</i></b> and <b><i>add_bp</i></b> methods should return 0 to
   indicate an error in setting up the breakpoint.
</p><p>
   The <b><i>break_msg</i></b> method should return the message that should be
   printed by the <b>bp.break</b> command after the breakpoint is set
   up. It receives the breakpoint manager ID for the breakpoint.
</p><p>
   The <b><i>trace_msg</i></b> method should return the message that should be
   printed when an (internal) trace breakpoint has hit. It receives the
   provider specific ID for the breakpoint.
</p><p>
   The <b><i>wait_msg</i></b> method should return the message that is attached to
   the script branch while waiting for a breakpoint to hit (displayed by
   e.g. <b>list-script-branches</b>). It receives the provider specific ID
   for the breakpoint.
</p><p>
   The optional method <b><i>break_data</i></b> can be implemented to make the
   <b>wait-for</b> and <b>run-until</b> commands return something. It
   receives the provider specific ID for the breakpoint.
</p><p>
   The method <b><i>values</i></b> must be implemented if the provider has
   specified that CLI command expanders should be used, when registering the
   breakpoint type. Otherwise the method is not called by the breakpoint
   manager. It should return the possible values for the command argument
   <i>arg</i>, which will be one of the argument names used when
   registering the type. The parameter <i>prev_args</i> will be the list of
   preceding argument values.
</p><p>
   The <b><i>deleted</i></b> method is typically optional. If implemented, it is
   called by the <b><i>deleted</i></b> function of
   the <code>breakpoint_registration</code> interface. Normally,
   breakpoint manager
   registered breakpoints are deleted using the function that was given
   to the <b><i>register_breakpoint</i></b> method of the
   <code>breakpoint_registration</code> interface, which is used by the
   <b>bp.delete</b>, but if the breakpoint can be removed by other means,
   then this method can be implemented.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(breakpoint_type_provider) {
        /* Register breakpoint in manager.
           Return breakpoint manager ID, or 0 on error. */
        uint64 (*register_bp)(conf_object_t *NOTNULL obj, uint64 bp_id);
        /* Add breakpoint and return provider specific ID, or 0 on error. */
        uint64 (*add_bp)(conf_object_t *NOTNULL obj,
                         int flags, attr_value_t data);
        /* Remove breakpoint, given ID returned by add_bp. */
        void (*remove_bp)(conf_object_t *NOTNULL obj, uint64 bp_id);
        /* Return trace message, given ID returned by add_bp. */
        char *(*trace_msg)(conf_object_t *NOTNULL obj, uint64 bp_id);
        /* Message returned by break command, given ID returned by add_bp. */
        char *(*break_msg)(conf_object_t *NOTNULL obj, uint64 bp_id);
        /* Script branch wait message, given ID returned by add_bp. */
        char *(*wait_msg)(conf_object_t *NOTNULL obj, uint64 bp_id);
        /* Optional return value from wait-for and run-until commands,
           given ID returned by add_bp. */
        attr_value_t (*break_data)(conf_object_t *NOTNULL obj, uint64 bp_id);
        /* Return possible values for command argument.
           Optional unless expanders used. */
        attr_value_t (*values)(conf_object_t *NOTNULL obj,
                               const char *arg, attr_value_t prev_args);
        /* Optional trace output function. The default is to log on the
           provider with level 1 and group 0. */
        void (*trace)(conf_object_t *NOTNULL obj, const char *msg);
};
#define BREAKPOINT_TYPE_PROVIDER_INTERFACE "breakpoint_type_provider"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Global Context
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_checkpoint.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_checkpoint.html:__rm_interface_checkpoint">checkpoint</a></h1>
<p>

<a id="__rm_interface_checkpoint.html:checkpoint"></a><a id="__rm_interface_checkpoint.html:checkpoint_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <b><i>save</i></b> function in this interface is called when a checkpoint
   is saved, right before the attributes of an object is read. If defined,
   it should prepare the object for checkpointing, saving any state to
   <i>path</i> that is not directly included in the attributes.
   Default behavior is image to be compressed craff and config to be compressed
   too. Errors are signalled through exceptions.
<p>
   The <b><i>save_v2</i></b> function is same as <b><i>save</i></b> but take an extra
   parameter with the type of save_flags_t to control format of files in the
   checkpoint other than defaults.
</p><p>
   The <i>path</i> argument may be the empty string, which indicates
   that the checkpoint bundle directory is the same as the current working
   directory while the checkpoint is being saved.
</p><p>
   The <b><i>finish</i></b> function is called after the checkpoint has been
   saved, for all objects that <b><i>save</i></b> was called for. If
   <i>success</i> is nonzero, the checkpoint was saved successfully;
   otherwise there was a failure. This permits the object to clean up temporary
   data structures and files in either case. In particular, any files written
   to <i>path</i> in the <b><i>save</i></b> method must be removed in
   <b><i>finish</i></b> if <i>success</i> is zero.
</p><p>
   The function <b><i>has_persistent_data</i></b>, if implemented, should return
   0 if the object only has volatile attributes, 1 otherwise. This overrides
   <code>Sim_Attr_Persistent</code> on individual attributes.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(checkpoint) {
        void (*save)(conf_object_t *obj, const char *NOTNULL path);
        void (*finish)(conf_object_t *obj, int success);
        int (*has_persistent_data)(conf_object_t *obj);
        void (*save_v2)(conf_object_t *obj, const char *NOTNULL path,
                        save_flags_t flags);
};

#define CHECKPOINT_INTERFACE "checkpoint"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Global Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_con_input.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_con_input.html:__rm_interface_con_input">con_input</a></h1>
<p>

<a id="__rm_interface_con_input.html:con_input"></a><a id="__rm_interface_con_input.html:con_input_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>con_input</code> interface facilitates sending simulated input
   to the target system. It is implemented by the text console.
<p>
   Simulated input is passed through the associated <b>recorder</b>
   object and then sent to the serial device connected to the console. The
   console will not perform VT100 input handling or BS/DEL conversion.
</p><p>
   The <b><i>input_str</i></b> method allows input of a NUL-terminated string. The
   <b><i>input_data</i></b> allows sending a buffer, which can include NUL
   characters.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(con_input) {
        void (*input_str)(conf_object_t *NOTNULL obj, const char *str);
        void (*input_data)(conf_object_t *NOTNULL obj, bytes_t data);
};
#define CON_INPUT_INTERFACE "con_input"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Global Context
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_con_input_code.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_con_input_code.html:__rm_interface_con_input_code">con_input_code</a></h1>
<p>

<a id="__rm_interface_con_input_code.html:con_input_code"></a><a id="__rm_interface_con_input_code.html:con_input_code_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>con_input_code</code> interface facilitates sending simulated
   key events to the simulation. It is implemented by the graphics console.
<p>
   Simulated key events are passed through the associated
   <b>recorder</b> object and then sent to the keyboard connected to the
   console.
</p><p>
   The <b><i>input</i></b> method sends the key <i>code</i>, either a key
   press or a release, depending on the <i>down</i> parameter.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(con_input_code) {
        void (*input)(conf_object_t *NOTNULL obj, sim_key_t code, bool down);
};
#define CON_INPUT_CODE_INTERFACE "con_input_code"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Global Context
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_context_handler.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_context_handler.html:__rm_interface_context_handler">context_handler</a></h1>
<p>

<a id="__rm_interface_context_handler.html:context_handler"></a><a id="__rm_interface_context_handler.html:context_handler_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><div class="note">
<b>Note:</b>
This interface is not supported, and may change in the future.</div>Get and set current context. The <b><i>set_current_context</i></b> function
   returns zero if the passed object is not of the context class, otherwise
   one is returned.
<p>
   </p><pre class="jdocu_small">SIM_INTERFACE(context_handler) {
        conf_object_t *(*get_current_context)(conf_object_t *obj);
        int (*set_current_context)(conf_object_t *obj, conf_object_t *ctx);
};

#define CONTEXT_HANDLER_INTERFACE "context_handler"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_debug_notification.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_debug_notification.html:__rm_interface_debug_notification">debug_notification</a></h1>
<p>

<a id="__rm_interface_debug_notification.html:debug_notification"></a><a id="__rm_interface_debug_notification.html:debug_notification_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><a id="__rm_interface_debug_notification.html:debug_notification_interface_t2"></a>
<p>
   This interface is used to get notifications from events in the
   debugger. Examples of events are when certain functions, addresses or code
   lines are hit.
</p><p>
   In order to be able to get notifications for symbols, the symbol file
   containing the debug information must have been added using the
   <code>debug_setup</code> interface or in some other way.
</p><p>
   All notifications take callback functions that are called when the debugger
   event occurs. The notifications will not stop the simulation, to do so
   <b><i>SIM_break_simulation</i></b> can be called in the callback.
</p><p>
   
</p><p>
   For all functions that return an <code>attr_value_t</code>, that return value
   will consists of a list with two elements. The first element is an error code
   of <code>debugger_error_t</code> type (see <code>debug_query</code>
   interface documentation for definition). The second element depends on the
   first. If the first element is <code>Debugger_No_Error</code>, meaning that
   the function went well, then the second element will contain the expected
   return value that is specified per function below. If the first element is
   another error code, then the second element will be a string describing the
   error that occurred.
</p><p>
   
</p><p>
   <a id="__rm_interface_debug_notification.html:notify_context_creationdebug_notification-interface-method"></a>
   <b><i>notify_context_creation</i></b> provides a callback when a new context
   that matches the context query <i>query</i> is created or renamed. The
   callback will also be triggered when a context is renamed, so if the context
   query matches both the name before and after the context was renamed then
   there will be two creation callbacks for the same context. When the callback
   is triggered because of a rename the <i>updated</i> argument of the
   callback will be true, otherwise if it is triggered because a new context
   was created the <i>updated</i> argument will be false.
</p><p>
   <b><i>notify_context_destruction</i></b> provides a callback when a context
   that matches the context query <i>query</i> is destroyed.
</p><p>
   The callbacks for <b><i>notify_context_creation</i></b> and
   <b><i>notify_context_destruction</i></b> will contain an ID to the context that
   was created, updated or destroyed, <i>ctx_id</i>, the tcf_agent object
   <i>obj</i> and some custom <i>data</i>.
</p><p>
   </p><div class="note">
<b>Note:</b>
The <b><i>notify_context_creation</i></b> and
   <b><i>notify_context_destruction</i></b> callbacks will only trigger for
   contexts that have state, this is most commonly the leaf nodes in an OS
   Awareness node tree.</div><b><i>notify_location</i></b> will give a callback when a memory access of type
   <i>access</i> is done at the address specified by <i>location</i>,
   for contexts matching <i>query</i>. The <i>size</i> argument is used
   to specify the width of the symbol provided by <i>location</i>. For
   execution notifications a <i>size</i> of 1 is usually used. The maximum
   value of <i>size</i> is 0x7fffffff. Notifying on location will only work
   for global symbols. For symbols that are not global, no errors will be given,
   and no callback will be triggered.
<p>
   <b><i>notify_address</i></b> will provide a callback when an <i>address</i>
   is hit with a certain <i>access</i> type for contexts matching
   <i>query</i>. The <i>size</i> argument specifies the width of the
   breakpoint for the notification, with a maximum value of 0x7fffffff.
   The notification can be set to notify on <i>physical</i> breakpoints
   instead of virtual, but for that to work a processor or memory space context
   must be covered by the <i>query</i>. For process related contexts
   <i>physical</i> should be false.
</p><p>
   <b><i>notify_line</i></b> will provide a callback when a specific
   <i>line</i> and <i>column</i> in a specific source <i>file</i>
   for a context matching <i>query</i> is executed. The <i>column</i>
   argument can be set to 0 to not care about column.
</p><p>
   The notification functions <b><i>notify_location</i></b>,
   <b><i>notify_address</i></b> and <b><i>notify_line</i></b> will all provide
   callbacks on the same format. They will pass the context ID,
   <i>ctx_id</i>, for which the access occurred. A processor,
   <i>cpu</i>, which did the access is provided. The
   <i>instruction_address</i> is the address of the instruction that
   performed the access. For execution callbacks the callback will occur before
   the instruction has run, but for read or write accesses the callback will
   occur after the instruction has run. The <i>data_address</i> will
   provide which data address was accesses, for execution accesses this is the
   same as <i>instruction_address</i> but for read or write accesses this
   is where the actual access was. And <i>size</i> specifies the actual
   size of the access that was made to trigger the notification, for execution
   this size is 1.
</p><p>
   <b><i>notify_activated</i></b> and <b><i>notify_deactivated</i></b> are used to
   notify when a context, that matches the <i>query</i>, gets activated or
   deactivated. The callback for this will include which context,
   <i>ctx_id</i>, was (de)activated and on what processor, <i>cpu</i>.
</p><p>
   For all notifications functions in this interface, on success, the returned
   value of a notification function will be a cancel ID which can be used to
   cancel the notification.
</p><p>
   If several callbacks occur on the same cycle, then the order for which the
   callbacks are called is not determined. This means that a
   <b><i>notify_activated</i></b> callback for one processor can occur before a
   <b><i>notify_deactivated</i></b> callback on the same processor.
</p><p>
   <b><i>notify_callbacks_done</i></b> will be called once all other callbacks
   that happen because of the same event are done. For example when a move to
   and a move from is done in the same step then this callback can be used to
   keep grouped notifications together that occurred at the same time. This
   will always be called after one or more callbacks have been called.
</p><p>
   <b><i>cancel</i></b> is used to cancel a notification by providing it with a
   cancel ID, <i>cid</i>, that was returned from the notification function.
   When this goes well the returned value will be nil.
</p><p>
   Errors specific to this function: </p><ul>

   <li><em>Debugger_Unknown_Id</em> - The cancel ID, <i>cid</i>, is
   unknown.</li>

   </ul>
<p>
   All callbacks except <b><i>notify_location</i></b>, <b><i>notify_address</i></b>,
   and <b><i>notify_line</i></b>, with execution access, will occur after the
   instruction triggering the callbacks has executed. For the callbacks
   specified here, when using execution access, the callback will occur before
   the instruction at that location, address or line has executed.
</p><p>
   </p><div class="note">
<b>Note:</b>
In order to get contexts for processes, OS Awareness with a properly
   configured tracker has to exist. A context will then be created for each OS
   Awareness node. Without any OS Awareness tracker enabled for the system,
   contexts will only be available for processors and some memory spaces. The
   <b><i>notify_activated</i></b> and <b><i>notify_deactivated</i></b> functions will
   only give callbacks when a tracker is used, because processor contexts are
   always active. More information about configuring and using OS Awareness and
   trackers can be found in the <em>Analyzer User's Guide</em></div><div class="note">
<b>Note:</b>
For functions that take <i>query</i> as argument, having this set
   to nil will work the same way as for <code>"*"</code>. A bad context query will
   result in a <code>Debugger_Incorrect_Context_Query</code> error.</div><pre class="jdocu_small">SIM_INTERFACE(debug_notification) {
        attr_value_t (*notify_context_creation)(
                conf_object_t *NOTNULL obj, const char *query,
                void (*cb)(cbdata_call_t data, conf_object_t *obj,
                           const char *ctx_id, bool updated),
                cbdata_register_t data);
        attr_value_t (*notify_context_destruction)(
                conf_object_t *NOTNULL obj, const char *query,
                void (*cb)(cbdata_call_t data, conf_object_t *obj,
                           const char *ctx_id), cbdata_register_t data);
        attr_value_t (*notify_location)(
                conf_object_t *NOTNULL obj, const char *query,
                const char *NOTNULL location, unsigned size, access_t access,
                void (*cb)(cbdata_call_t data, conf_object_t *obj,
                           const char *ctx_id, conf_object_t *cpu,
                           uint64 instruction_address, uint64 data_address,
                           unsigned size), cbdata_register_t data);
        attr_value_t (*notify_address)(
                conf_object_t *NOTNULL obj, const char *query, uint64 address,
                unsigned size, access_t access, bool physical,
                void (*cb)(cbdata_call_t data, conf_object_t *obj,
                           const char *ctx_id, conf_object_t *cpu,
                           uint64 instruction_address, uint64 data_address,
                           unsigned size), cbdata_register_t data);
        attr_value_t (*notify_line)(
                conf_object_t *NOTNULL obj, const char *query,
                const char *NOTNULL file, unsigned line, unsigned column,
                void (*cb)(cbdata_call_t data, conf_object_t *obj,
                           const char *ctx_id, conf_object_t *cpu,
                           uint64 instruction_address, uint64 data_address,
                           unsigned size), cbdata_register_t data);
        attr_value_t (*notify_activated)(
                conf_object_t *NOTNULL obj, const char *query,
                void (*cb)(cbdata_call_t data, conf_object_t *obj,
                           const char *ctx_id, conf_object_t *cpu),
                cbdata_register_t data);
        attr_value_t (*notify_deactivated)(
                conf_object_t *NOTNULL obj, const char *query,
                void (*cb)(cbdata_call_t data, conf_object_t *obj,
                           const char *ctx_id, conf_object_t *cpu),
                cbdata_register_t data);
        attr_value_t (*notify_callbacks_done)(
                conf_object_t *NOTNULL obj,
                void (*cb)(cbdata_call_t data, conf_object_t *obj),
                cbdata_register_t data);
        attr_value_t (*cancel)(conf_object_t *NOTNULL obj,
                               debug_cancel_id_t cid);
};
#define DEBUG_NOTIFICATION_INTERFACE "debug_notification"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Global Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_debug_query.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_debug_query.html:__rm_interface_debug_query">debug_query</a></h1>
<p>

<a id="__rm_interface_debug_query.html:debug_query"></a><a id="__rm_interface_debug_query.html:debug_query_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><a id="__rm_interface_debug_query.html:debug_query_interface_t2"></a>
<p>
   This interface provides functions for querying the debugger for contexts and
   their information. Functions here will be used to find specific contexts or
   to create context-queries, that can be used with other functions in debugger
   interfaces.
</p><p>
   Most functions in this interface take a Context ID, <i>ctx_id</i>, as
   argument. This ID is passed as an argument to most callback functions in the
   <code>debug_notification</code> interface and returned by some functions
   in this interface.
</p><p>
   All functions return an <code>attr_value_t</code> consisting of a list with
   two elements. The first element is an error code of
   <code>debugger_error_t</code> type. The second element depends on the
   first. If the first element is <code>Debugger_No_Error</code>, meaning that
   the function went well, then the second element will contain the expected
   return value that is specified per function below. If the first element is
   another error code, then the second element will be a string describing the
   error that occurred.
</p><p>
   <a id="__rm_interface_debug_query.html:matching_contextdebug_query-interface-method"></a>
   <b><i>matching_contexts</i></b> returns a list of context IDs matching the
   specified context-query, <i>query</i>. The returned list can be empty if
   there are no matching contexts.
</p><p>
   <a id="__rm_interface_debug_query.html:get_context_groupdebug_query-interface-method"></a>
   <b><i>get_context_group</i></b> returns a context ID for the context marked
   as the group leader for the specified context, <i>ctx_id</i>. As example
   in a Linux tracker the process node will be the group leader for all threads
   belonging to that process. A context that lacks a specific group leader will
   return itself.
</p><p>
   <a id="__rm_interface_debug_query.html:get_context_parentdebug_query-interface-method"></a>
   <b><i>get_context_parent</i></b> returns an ID to the parent context for the
   specified context.
</p><p>
   Errors specific to this function: </p><ul>

   <li><em>Debugger_Not_Supported_For_Context</em> - The context does not have
   a parent.</li>

   </ul>
<p>
   <a id="__rm_interface_debug_query.html:get_context_childrendebug_query-interface-method"></a>
   <b><i>get_context_children</i></b> returns a list of context IDs for the
   children of the specified context. This list can be empty if the context has
   no children.
</p><p>
   <a id="__rm_interface_debug_query.html:query_for_context_groupdebug_query-interface-method"></a>
   <a id="__rm_interface_debug_query.html:query_for_context_iddebug_query-interface-method"></a>
   <a id="__rm_interface_debug_query.html:query_for_context_treedebug_query-interface-method"></a>
   <b><i>query_for_context_group</i></b>, <b><i>query_for_context_id</i></b> and
   <b><i>query_for_context_tree</i></b> will return context-queries which can be
   used for matching all contexts in a group, the context that matches an ID or
   contexts in the tree that starts with the specified context. The latter
   context-query will match the context itself plus all its child contexts, the
   children of those contexts and so on. The result of these functions should
   be used with functions that take a context-query as argument.
</p><p>
   <a id="__rm_interface_debug_query.html:context_namedebug_query-interface-method"></a> <b><i>context_name</i></b>
   returns the name of the specified context.
</p><p>
   Errors specific to this function: </p><ul>

   <li><em>Debugger_Not_Supported_For_Context</em> - If the he context lacks a
   name.</li>

   </ul>
<p>
   <a id="__rm_interface_debug_query.html:context_id_for_objectdebug_query-interface-method"></a>
   <b><i>context_id_for_object</i></b> returns a context ID for the specified
   Simics object, <i>ctx_obj</i>, if that has an associated context. In
   general, processors and some memory spaces usually have contexts associated
   with them.
</p><p>
   Errors specific to this function: </p><ul>

   <li><em>Debugger_No_Context_For_Object</em> - The object does not have any
   associated context.</li>

   </ul>
<p>
   <a id="__rm_interface_debug_query.html:context_has_statedebug_query-interface-method"></a>
   <b><i>context_has_state</i></b> returns a boolean that tells whether the
   specified context has state or not. That a context has state will mean that
   callbacks in the <code>debug_notification</code> will trigger for this
   context. The contexts that have state are usually leaf nodes in the OS
   Awareness node tree.
</p><p>
   <a id="__rm_interface_debug_query.html:object_for_contextdebug_query-interface-method"></a>
   <b><i>object_for_context</i></b> is used to get a Simics object that matches
   the context for <i>ctx_id</i>, if such an object exists.
</p><p>
   Errors specific to this function: </p><ul>

   <li><em>Debugger_Missing_Object</em> - The context does not match a Simics
   object.</li>

   </ul>
<p>
   <a id="__rm_interface_debug_query.html:get_active_processordebug_query-interface-method"></a>
   <b><i>get_active_processor</i></b> is used check if a context is active and in
   that case return the Simics processor object that the node is active on.
</p><p>
   Errors specific to this function: </p><ul>

   <li><em>Debugger_Context_Is_Not_Active</em> - Context is not active.</li>

   </ul>
<p>
   </p><div class="note">
<b>Note:</b>
For functions that take <i>query</i> as argument, having this set
   to nil will work the same way as for <code>"*"</code>. A bad context query will
   result in a <code>Debugger_Incorrect_Context_Query</code> error.</div><pre class="jdocu_small">SIM_INTERFACE(debug_query) {
        attr_value_t (*matching_contexts)(conf_object_t *NOTNULL obj,
                                          const char *query);
        attr_value_t (*get_context_group)(conf_object_t *NOTNULL obj,
                                          const char *NOTNULL ctx_id);
        attr_value_t (*get_context_parent)(conf_object_t *NOTNULL obj,
                                           const char *NOTNULL ctx_id);
        attr_value_t (*get_context_children)(conf_object_t *NOTNULL obj,
                                             const char *NOTNULL ctx_id);
        attr_value_t (*query_for_context_group)(conf_object_t *NOTNULL obj,
                                                const char *ctx_id);
        attr_value_t (*query_for_context_id)(conf_object_t *NOTNULL obj,
                                             const char *NOTNULL ctx_id);
        attr_value_t (*query_for_context_tree)(conf_object_t *NOTNULL obj,
                                               const char *NOTNULL ctx_id);
        attr_value_t (*context_name)(conf_object_t *NOTNULL obj,
                                     const char *NOTNULL ctx_id);
        attr_value_t (*context_id_for_object)(conf_object_t *NOTNULL obj,
                                              conf_object_t *NOTNULL ctx_obj);
        attr_value_t (*object_for_context)(conf_object_t *NOTNULL obj,
                                           const char *NOTNULL ctx_id);
        attr_value_t (*context_has_state)(conf_object_t *NOTNULL obj,
                                          const char *NOTNULL ctx_id);
        attr_value_t (*get_active_processor)(conf_object_t *NOTNULL obj,
                                             const char *NOTNULL ctx_id);
};
#define DEBUG_QUERY_INTERFACE "debug_query"
</pre><p>
</p><p>

   
</p><pre class="jdocu_small">typedef enum {
        Debugger_No_Error = 0,
        Debugger_Not_Allowed_In_Execution_Context,
        Debugger_Unknown_Context,
        Debugger_Not_Supported_For_Context,
        Debugger_Context_Does_Not_Have_State,
        Debugger_Context_Is_Not_Active,
        Debugger_Lookup_Failure,
        Debugger_Failed_To_Get_Stack_Frame,
        Debugger_Failed_To_Get_PC,
        Debugger_Failed_To_Read,
        Debugger_Failed_To_Write,
        Debugger_Frame_Outside_Of_Known_Stack,
        Debugger_Failed_To_Evaluate_Expression,
        Debugger_Incorrect_Type,
        Debugger_Incorrect_Size,
        Debugger_Incorrect_Context_Query,
        Debugger_Unknown_Id,
        Debugger_Source_Not_Found,
        Debugger_File_Not_Found,
        Debugger_Unrecognized_File_Format,
        Debugger_Unsupported_For_File_Format,
        Debugger_Failed_To_Open_File,
        Debugger_Not_Relocatable,
        Debugger_Segment_Info_Missing,
        Debugger_Section_Info_Missing,
        Debugger_Segment_Not_Found,
        Debugger_Section_Not_Found,
        Debugger_Already_Running,
        Debugger_Failed_To_Continue,
        Debugger_No_Context_For_Object,
        Debugger_Invalid_Path,
        Debugger_Missing_Object,
        Debugger_Unexpected_Error,
        Debugger_Step_Interrupted,
} debugger_error_t;
</pre><p>
</p><p>

   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Global Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_debug_setup.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_debug_setup.html:__rm_interface_debug_setup">debug_setup</a></h1>
<p>

<a id="__rm_interface_debug_setup.html:debug_setup"></a><a id="__rm_interface_debug_setup.html:debug_setup_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><a id="__rm_interface_debug_setup.html:debug_setup_interface_t2"></a>
<p>
   Functions in the <code>debug_setup</code> interfaces are used to provide
   the debugger with symbol files and paths. There are also functions for
   listing what symbol files and paths have been added.
</p><p>
   
</p><p>
   For all functions that return an <code>attr_value_t</code>, that return value
   will consists of a list with two elements. The first element is an error code
   of <code>debugger_error_t</code> type (see <code>debug_query</code>
   interface documentation for definition). The second element depends on the
   first. If the first element is <code>Debugger_No_Error</code>, meaning that
   the function went well, then the second element will contain the expected
   return value that is specified per function below. If the first element is
   another error code, then the second element will be a string describing the
   error that occurred.
</p><p>
   
</p><p>
   Upon success, all functions for adding symbols will return an <code>id</code>
   that can be used with <b><i>remove_symbol_file</i></b>.
</p><p>
   <a id="__rm_interface_debug_setup.html:add_symbol_filedebug_setup-interface-method"></a>
   <b><i>add_symbol_file</i></b> adds a symbol file, <i>symbol_file</i>, used
   for debugging contexts that match the context-query <i>query</i>. The
   <i>address</i> argument specifies the address that the file should be
   mapped to. If <i>absolute_address</i> is set then the given
   <i>address</i> will be the absolute address of the first relocatable
   segment and other segments will be added with their given offsets to that
   segment.
</p><p>
   Errors specific to this function:
</p><p>
   </p><ul>

   <li><em>Debugger_Failed_To_Open_File</em> - File cannot be opened.</li>

   <li><em>Debugger_Unrecognized_File_Format</em> - The file format is not
   recognized.</li>

   <li><em>Debugger_Segment_Info_Missing</em> - If an ELF file is being added,
   but no valid segments can be found.</li>

   </ul>
<p>
   <a id="__rm_interface_debug_setup.html:add_symbol_segmentdebug_setup-interface-method"></a>
   <b><i>add_symbol_segment</i></b> adds symbols from the specified
   <i>segment</i> of an ELF symbol file. Other arguments are the same as
   for <b><i>add_symbol_file</i></b>. The address of the segment is specified with
   the <i>address</i> argument. If <i>absolute_address</i> is set this
   <i>address</i> will be an absolute address otherwise it will be an
   offset to the address found in the symbol file for that segment.
</p><p>
   Errors specific to this function: </p><ul>

   <li><em>Debugger_Segment_Not_Found</em> - Segment not found when adding a
   segment.</li>

   <li><em>Debugger_Segment_Info_Missing</em> - Segment information is missing
   or incomplete.</li>

   <li><em>Debugger_Not_Relocatable</em> - The segment is not relocatable.</li>

   <li><em>Debugger_Unsupported_For_File_Format</em> - File format is not
   ELF.</li>

   </ul>
<p>
   <a id="__rm_interface_debug_setup.html:add_symbol_sectiondebug_setup-interface-method"></a>
   <b><i>add_symbol_section</i></b> adds symbols from the specified
   <i>section</i> of an ELF symbol file. Other arguments are the same as
   for <b><i>add_symbol_file</i></b>. The address of the section is specified with
   the <i>address</i> argument. If <i>absolute_address</i> is set this
   <i>address</i> will be an absolute address otherwise it will be an
   offset to the address found in the symbol file for that section.
</p><p>
   Errors specific to this function: </p><ul>

   <li><em>Debugger_Section_Not_Found</em> - Section not found when adding a
   section.</li>

   <li><em>Debugger_Section_Info_Missing</em> - Section information is missing
   or incomplete.</li>

   <li><em>Debugger_Not_Relocatable</em> - The section is not relocatable.</li>

   <li><em>Debugger_Unsupported_For_File_Format</em> - File format is not
   ELF.</li>

   </ul>
<p>
   </p><div class="note">
<b>Note:</b>
Adding the same symbol file, section or segment more than once might
   result in unexpected behavior and is not supported.</div><a id="__rm_interface_debug_setup.html:remove_symbol_filedebug_setup-interface-method"></a>
   <b><i>remove_symbol_file</i></b> removes the debugger's knowledge of symbols
   that was added with any of the functions for adding symbols. The
   <i>id</i> argument is the id returned from the add function.
<p>
   Errors specific to this function: </p><ul>

   <li><em>Debugger_Unknown_Id</em> - The <i>id</i> is unknown.</li>

   </ul>
<p>
   <a id="__rm_interface_debug_setup.html:clear_symbol_filesdebug_setup-interface-method"></a>
   <b><i>clear_symbol_files</i></b> removes the debugger's knowledge about all
   symbol files added by <i>add_symbol_file</i>.
</p><p>
   <a id="__rm_interface_debug_setup.html:symbol_filesdebug_setup-interface-method"></a> <b><i>symbol_files</i></b>
   lists all added symbol files. A dictionary, with <code>id</code> as key will be
   returned. An id is always bound to one query and one symbol file, but it can
   contain several memory maps. The listed <i>id</i> is the argument passed
   to <b><i>remove_symbol_file</i></b>. The dictionary values have the following
   format:
</p><p>
   </p><ul>

   <li><i>query</i> <code>(string)</code> - The context query the symbol is
   valid for.</li>

   <li><i>relocation</i> <code>(uint64)</code> - The relocation address
   provided when the symbol file was added.</li>

   <li><i>symbol-file</i> <code>(string)</code> - The file containing the
   symbol information.</li>

   <li><i>memory-maps</i> <code>([&lt;dict&gt;, ...])</code> - A list of
   memory maps that are added togheter as the same <code>id</code>, see format
   below:</li>

   </ul>
<p>
   The dictionary describing a memory map has the following format:
   </p><ul>

   <li><i>address</i> <code>(uint64)</code> - The address of the section in
   memory.</li>

   <li><i>size</i> <code>(uint64)</code> - The section size in memory.</li>

   <li><i>flags</i> <code>(uint64)</code> - Format specific flags describing
   the section.</li>

   <li><i>section</i> <code>(string)</code> - The name of the section.</li>

   <li><i>file-offset</i> <code>(uint64)</code> - Offset in symbol file for
   the section.</li>

   <li><i>file-size</i> <code>(uint64)</code> - Size of the section in the
   symbol file.</li>

   </ul>
<p>
   <a id="__rm_interface_debug_setup.html:symbol_files_for_ctxdebug_setup-interface-method"></a>
   <b><i>symbol_files_for_ctx</i></b> is the same as <b><i>symbol_files</i></b>
   except that it only returns symbol files that are valid for the given
   context id, <i>ctx_id</i>.
</p><p>
   <a id="__rm_interface_debug_setup.html:list_all_mappingsdebug_setup-interface-method"></a>
   <b><i>list_all_mappings</i></b> lists all symbol mappings for a certain context
   <i>ctx_id</i>. This will be all mappings from symbol files added by
   users plus any symbol mappings added elsewhere, from trackers for example.
   The returned value is a dictionary on the following format:
</p><p>
   </p><ul>

   <li><i>filename</i> <code>(string)</code> - The file backing the memory
   map.</li>

   <li><i>query</i> <code>(string)</code> - The query the map is valid
   for.</li>

   <li><i>address</i> <code>(uint64)</code> - The map's address in context
   memory.</li>

   <li><i>size</i> <code>(uint64)</code> - The size of the map in
   memory.</li>

   <li><i>flags</i> <code>(uint64)</code> - Read, write, and execute flags,
   bit 0 is set if readable, bit 1 if writeable and bit 2 if executable. If this
   value is 0 this is the same as if all flags are set.</li>

   <li><i>section-name</i> <code>(string)</code> - The section name, or
   NIL.</li>

   <li><i>file-offset</i> <code>(int64)</code> - Offset into the backing
   file.</li>

   <li><i>file-size</i> <code>(uint64)</code> - Size of the map in the
   backing file.</li>

   <li><i>relocation</i> <code>(uint64)</code> - The offset from the address
   in the symbol file to where the mappings is actually loaded in memory. This
   is not always present in the dictionary.</li>

   </ul>
<p>
   Some other internal entries could possibly also be present in the
   dictionary.
</p><p>

   <a id="__rm_interface_debug_setup.html:add_path_map_entrydebug_setup-interface-method"></a>
   <b><i>add_path_map_entry</i></b> adds a path math entry that maps a source
   file from the <i>source</i> in the symbol file to the actual
   destination, <i>dest</i>, where it is located on disk. The
   <i>query</i> argument specifies for which context-queries the mapping
   should apply. The returned id can be used with
   <b><i>remove_path_map_entry</i></b> to remove the added path map. The source
   path may not be empty or be just "." or "./".
</p><p>
   Errors specific to this function: </p><ul>

   <li><em>Debugger_Invalid_Path</em> - The source path is not valid.</li>

   </ul>
<p>
   <a id="__rm_interface_debug_setup.html:remove_path_map_entrydebug_setup-interface-method"></a>
   <b><i>remove_path_map_entry</i></b> removes an entry that was added with
   <b><i>add_path_map_entry</i></b>. The <i>id</i> is the value returned from
   the add function.
</p><p>
   Errors specific to this function: </p><ul>

   <li><em>Debugger_Unknown_Id</em> - The provided <i>id</i> is
   unknown.</li>

   </ul>
<p>
   <a id="__rm_interface_debug_setup.html:clear_path_map_entriesdebug_setup-interface-method"></a>
   <b><i>clear_path_map_entries</i></b> removes all knowledge about all path map
   entries added with <b><i>add_path_map_entry</i></b>.
</p><p>
   <a id="__rm_interface_debug_setup.html:path_map_entriesdebug_setup-interface-method"></a>
   <b><i>path_map_entries</i></b> lists all path map entries that have been added
   with <b><i>add_path_map_entry</i></b>, that matches the given context id. If
   the context id is nil, then all path maps will be listed. The format of the
   entries in the returned list are dictionaries, with an <code>id</code> of type
   debug_setup_id_t as key:
</p><p>
   </p><ul>

   <li><i>query</i> <code>(string)</code> - The context query the path map
   is valid for.</li>

   <li><i>source</i> <code>(string)</code> - The source to translate
   from.</li>

   <li><i>destination</i> <code>(string)</code> - The destination to
   translate to.</li>

   </ul>
<p>
   <a id="__rm_interface_debug_setup.html:path_map_entries_for_ctxdebug_setup-interface-method"></a>
   <b><i>path_map_entries_for_ctx</i></b> is the same as
   <b><i>path_map_entries</i></b> except that it only lists path maps that are
   valid for the given context id, <i>ctx_id</i>.
</p><p>

   <a id="__rm_interface_debug_setup.html:apply_path_mapdebug_setup-interface-method"></a>
   <b><i>apply_path_map</i></b> applies any added path map to a file path,
   <i>filename</i>, for a given context with ID <i>ctx_id</i>. The path
   with the path map applied will be returned. The path map will only apply if
   the destination file exists and if the path given in <i>filename</i>
   does not, otherwise the provided file will be returned. The returned path
   will always contain forward slashes as path separator, regardless of what
   the host system uses, or if any path map was applied or not.
</p><p>
   </p><div class="note">
<b>Note:</b>
For functions that take <i>query</i> as argument, having this set
   to nil will work the same way as for <code>"*"</code>. A bad context query will
   result in a <code>Debugger_Incorrect_Context_Query</code> error.</div><pre class="jdocu_small">typedef int64 debug_setup_id_t;

SIM_INTERFACE(debug_setup) {
        attr_value_t (*add_symbol_file)(conf_object_t *NOTNULL obj,
                                        const char *query,
                                        const char *NOTNULL symbol_file,
                                        uint64 address, bool absolute_address);
        attr_value_t (*add_symbol_segment)(conf_object_t *NOTNULL obj,
                                           const char *query,
                                           const char *NOTNULL symbol_file,
                                           unsigned segment, uint64 address,
                                           bool absolute_address);
        attr_value_t (*add_symbol_section)(conf_object_t *NOTNULL obj,
                                           const char *query,
                                           const char *NOTNULL symbol_file,
                                           const char *NOTNULL section,
                                           uint64 address,
                                           bool absolute_address);
        attr_value_t (*remove_symbol_file)(conf_object_t *NOTNULL obj,
                                           debug_setup_id_t id);
        void (*clear_symbol_files)(conf_object_t *NOTNULL obj);
        attr_value_t (*symbol_files)(conf_object_t *NOTNULL obj);
        attr_value_t (*symbol_files_for_ctx)(conf_object_t *NOTNULL obj,
                                             const char *NOTNULL ctx_id);
        attr_value_t (*list_all_mappings)(conf_object_t *NOTNULL obj,
                                          const char *NOTNULL ctx_id);
        attr_value_t (*add_path_map_entry)(conf_object_t *NOTNULL obj,
                                           const char *query,
                                           const char *NOTNULL source,
                                           const char *NOTNULL dest);
        attr_value_t (*remove_path_map_entry)(conf_object_t *NOTNULL obj,
                                              debug_setup_id_t id);
        void (*clear_path_map_entries)(conf_object_t *NOTNULL obj);
        attr_value_t (*path_map_entries)(conf_object_t *NOTNULL obj);
        attr_value_t (*path_map_entries_for_ctx)(conf_object_t *NOTNULL obj,
                                                 const char *NOTNULL ctx_id);
        attr_value_t (*apply_path_map)(conf_object_t *NOTNULL obj,
                                       const char *NOTNULL ctx_id,
                                       const char *NOTNULL filename);
};
#define DEBUG_SETUP_INTERFACE "debug_setup"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Global Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_debug_step.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_debug_step.html:__rm_interface_debug_step">debug_step</a></h1>
<p>

<a id="__rm_interface_debug_step.html:debug_step"></a><a id="__rm_interface_debug_step.html:debug_step_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><a id="__rm_interface_debug_step.html:debug_step_interface_t2"></a>
<p>
   This interface is used to perform stepping with the debugger, on a specified
   debug context.
</p><p>
   
</p><p>
   For all functions that return an <code>attr_value_t</code>, that return value
   will consists of a list with two elements. The first element is an error code
   of <code>debugger_error_t</code> type (see <code>debug_query</code>
   interface documentation for definition). The second element depends on the
   first. If the first element is <code>Debugger_No_Error</code>, meaning that
   the function went well, then the second element will contain the expected
   return value that is specified per function below. If the first element is
   another error code, then the second element will be a string describing the
   error that occurred.
</p><p>
   
</p><p>
   <a id="__rm_interface_debug_step.html:instruction_intodebug_step-interface-method"></a>
   <a id="__rm_interface_debug_step.html:instruction_overdebug_step-interface-method"></a>
   <b><i>instruction_into</i></b> and <b><i>instruction_over</i></b> runs one step
   forward for the specified context. <b><i>instruction_into</i></b> will enter
   subroutine calls while <b><i>instruction_over</i></b> will step over subroutine
   calls.
</p><p>
   <a id="__rm_interface_debug_step.html:intodebug_step-interface-method"></a>
   <a id="__rm_interface_debug_step.html:overdebug_step-interface-method"></a>
   <b><i>into</i></b> and <b><i>over</i></b> will run one
   source line forward for the specified context. <b><i>into</i></b> will enter
   function calls while <b><i>over</i></b> will skip over functions.
</p><p>
   <a id="__rm_interface_debug_step.html:outdebug_step-interface-method"></a>
   <b><i>out</i></b> will run until the currently active function returns.
</p><p>
   All function take a context ID, <i>ctx_id</i>, as argument. This context
   ID is passed as an argument to callbacks for functions in the
   <code>debug_notification</code> interface. The context, that is passed to
   functions in this interface, has to have state (see
   <b><i>context_has_state</i></b> in the <code>debug_query</code> interface)
   otherwise a <code>Debugger_Context_Does_Not_Have_State</code> error will be
   returned.
</p><p>
   Calling functions in this interface can only be done when simulation is
   stopped, otherwise a <code>Debugger_Already_Running</code> error will be
   returned.
</p><p>
   For all functions in this interface, if another stop reason occurs before a
   function finishes the simulation will stop at that point instead.
</p><p>
   Stepping for a context that is not active will run until that context
   becomes active and then take the step.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(debug_step) {
        attr_value_t (*instruction_into)(conf_object_t *NOTNULL obj,
                                         const char *NOTNULL ctx_id);
        attr_value_t (*into)(conf_object_t *NOTNULL obj,
                             const char *NOTNULL ctx_id);
        attr_value_t (*instruction_over)(conf_object_t *NOTNULL obj,
                                         const char *NOTNULL ctx_id);
        attr_value_t (*over)(conf_object_t *NOTNULL obj,
                             const char *NOTNULL ctx_id);
        attr_value_t (*out)(conf_object_t *NOTNULL obj,
                            const char *NOTNULL ctx_id);
        attr_value_t (*reverse_instruction_into)(conf_object_t *NOTNULL obj,
                                                 const char *NOTNULL ctx_id);
        attr_value_t (*reverse_into)(conf_object_t *NOTNULL obj,
                                     const char *NOTNULL ctx_id);
        attr_value_t (*reverse_instruction_over)(conf_object_t *NOTNULL obj,
                                                 const char *NOTNULL ctx_id);
        attr_value_t (*reverse_over)(conf_object_t *NOTNULL obj,
                                     const char *NOTNULL ctx_id);
        attr_value_t (*reverse_out)(conf_object_t *NOTNULL obj,
                                    const char *NOTNULL ctx_id);
};
#define DEBUG_STEP_INTERFACE "debug_step"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Global Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_debug_symbol.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_debug_symbol.html:__rm_interface_debug_symbol">debug_symbol</a></h1>
<p>

<a id="__rm_interface_debug_symbol.html:debug_symbol"></a><a id="__rm_interface_debug_symbol.html:debug_symbol_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><a id="__rm_interface_debug_symbol.html:debug_symbol_interface_t2"></a>
<p>
   This interface contains functions for retrieving various symbol information
   for a debug context, <i>ctx_id</i>. There are also a few functions for
   updating symbol information.
</p><p>
   Prior to using functions in this interface, symbol file(s) containing symbol
   information should have been added using the <code>debug_setup</code>
   interface, for a context-query that matches the context ID provided to the
   function here. Symbol files can also be added in other ways such as from a
   tracker or from Eclipse.
</p><p>
   Some functions, that do read values or stack, can also be used directly with
   symbol files opened with the <code>debug_symbol_file</code> interface.
</p><p>
   All functions in this interface take a context ID <i>ctx_id</i> as
   argument. This is the ID passed as an argument to
   <code>debug_notification</code> callbacks or returned from some
   <code>debug_query</code> interface functions.
</p><p>
   
</p><p>
   For all functions that return an <code>attr_value_t</code>, that return value
   will consists of a list with two elements. The first element is an error code
   of <code>debugger_error_t</code> type (see <code>debug_query</code>
   interface documentation for definition). The second element depends on the
   first. If the first element is <code>Debugger_No_Error</code>, meaning that
   the function went well, then the second element will contain the expected
   return value that is specified per function below. If the first element is
   another error code, then the second element will be a string describing the
   error that occurred.
</p><p>
   
</p><p>
   All addresses used in this interface are virtual addresses.
</p><p>
   For functions that take <i>frame</i> as argument, providing
   <i>frame</i> = -1 means no frame. This can be used when finding symbols
   for functions or global variables. When using other <i>frame</i> than -1
   the context has to be active, otherwise no frame will exists and a
   <code>Debugger_Context_Is_Not_Active</code> error will be returned. If the
   specified frame cannot be found, then error code
   <code>Debugger_Frame_Outside_Of_Known_Stack</code> will be returned.
</p><p>
   Functions that handle stack can only be used with an active context,
   otherwise error code <code>Debugger_Context_Is_Not_Active</code> or
   <code>Debugger_Context_Does_Not_Have_State</code> will be returned depending
   on if the context has state or not.
</p><p>
   <a id="__rm_interface_debug_symbol.html:address_sourcedebug_symbol-interface-method"></a>
   <b><i>address_source</i></b> will provide callbacks, <i>cb</i>, with source
   information for the range specified by <i>address</i> and
   <i>size</i>. The range must not wrap around the 64-bit limit. Source
   information will be provided as code areas, which is the source information
   for a range of continuous addresses matching the same file and line. User
   data can be passed to the callback using the <i>data</i> argument and
   will be passed as the first argument in the callback. Each code area
   matching the range will get a callback with information about the code area
   in the <i>code_area</i> argument, which is a dictionary with the
   following elements:
</p><p>
   </p><ul>

   <li><i>filename</i> <code>(string)</code> - File name of the source file
   where the specified <i>address</i> is found.</li>

   <li><i>start-line</i>, <i>end-line</i> <code>(int64)</code> -
   Starting and ending lines in the source file for the <i>address</i>.
   <i>end-line</i> is inclusive so if the <i>address</i> just matches
   one source line <i>start-line</i> and <i>end-line</i> will be the
   same.</li>

   <li><i>start-column</i>, <i>end-column</i> <code>(int64)</code> -
   Starting and ending columns on the line for <i>address</i>. If column
   information is not available in debug information the value will be 0.
   <i>end-column</i> is inclusive so the column is included for
   <i>address</i>.</li>

   <li><i>start-address</i>, <i>end-address</i> <code>(uint64)</code> -
   Starting and ending addresses that correspond to the returned line and
   column information. <i>end-address</i> is inclusive so this matches the
   last byte of the last instruction of this code area. If the code area is
   empty then, then <i>end-address</i> will not be present. This can happen
   when asking for a line prior to the first executable line.</li>

   </ul>
<p>
   Errors specific to this function: </p><ul>

   <li><em>Debugger_Source_Not_Found</em> - There are no matching code
   areas.</li>

   <li><em>Debugger_Incorrect_Size</em> - Incorrect <i>size</i>
   provided. The size cannot be zero and it cannot make the end address exceed
   64 bits.</li>

   <li><em>Debugger_Lookup_Failure</em> Address lookup failure. Can occur if
   the address is not in the debug information or the lookup failed for some
   other reason. The error message explains more what went wrong.</li>

   </ul>
<p>
   <a id="__rm_interface_debug_symbol.html:source_addressdebug_symbol-interface-method"></a>
   <b><i>source_address</i></b> will provide callbacks, with source information
   for the line specified by <i>filename</i>, <i>line</i> and
   <i>column</i>. The <i>column</i> argument will only be useful for
   binaries with column information in the debug information.
</p><p>
   One call to this function will provide as many callbacks as there are code
   areas matching that source information. The <i>code_area</i> provided to
   the callback is a dictionary with the same format as for the callback from
   <b><i>address_source</i></b>.
</p><p>
   Errors specific to this function: </p><ul>

   <li><em>Debugger_File_Not_Found</em> - There is no matching source file,
   <i>filename</i>, in the debug information.</li>

   <li><em>Debugger_Source_Not_Found</em> - The <i>line</i> or
   <i>column</i> is not found in the debug information.</li>

   <li><em>Debug_Lookup_Failure</em> - Some problem with the lookup other than
   that file, line or column was not found. Error described in error
   message.</li>

   </ul>
<p>
   For binaries <em>without</em> column information, a line is executable if
   the <i>start-line</i> in the callback matches the asked <i>line</i>.
</p><p>
   For binaries <em>with</em> column information one can say that the line is
   executable if any code area can be found with <i>start-line</i> matching
   the asked line. When asking for a <i>line</i> and <i>column</i> and
   the <i>start-line</i> matches a previous line, but the
   <i>end-line</i> matches the asked line, then one should ask for the
   <i>column</i> just after <i>end-column</i> to see if the
   <i>start-line</i> of that code area matches the asked line and if it
   does then the asked line is considered executable.
</p><p>
   <a id="__rm_interface_debug_symbol.html:stack_depthdebug_symbol-interface-method"></a>
   <b><i>stack_depth</i></b> returns the current stack depth.
</p><p>
   Errors specific to this function: </p><ul>

   <li><em>Debugger_Failed_To_Get_Stack_Frame</em> - Failed to get stack
   frames.</li>

   </ul>
<p>
   <a id="__rm_interface_debug_symbol.html:stack_framesdebug_symbol-interface-method"></a>
   <b><i>stack_frames</i></b> returns a list of dictionaries with information
   about each frame. The executing frame is at position zero in the list. The
   elements of the stack frame dictionary are:
</p><p>
   </p><ul>

   <li><i>address</i> <code>(uint64)</code> - For the executing frame this
   is the address of the program counter, for all other frames this is the
   address that the function will return to.</li>

   <li><i>source-file</i> <code>(string)</code> - The source file for the
   frame. Can be nil if no matching file is found.</li>

   <li><i>source-line</i> <code>(uint64)</code> - The source line in the
   file for the frame. Will be nil if <i>source-file</i> is nil.</li>

   <li><i>function-name</i> <code>(string)</code> - The function that is
   executing in the frame. Can be nil if no function is found.</li>

   </ul>
<p>
   Errors specific to this function: </p><ul>

   <li><code>Debugger_Failed_To_Get_Stack_Frame</code> - If there are problems
   getting stack depth or getting frame info.</li>

   <li><code>Debugger_Failed_To_Read</code> - If a register cannot be read for
   some frame.</li>

   <li><code>Debugger_Failed_To_Get_PC</code> - If the program counter
   definition cannot be found for the context.</li>

   </ul>
<p>
   <a id="__rm_interface_debug_symbol.html:local_variablesdebug_symbol-interface-method"></a>
   <b><i>local_variables</i></b> returns a list of names for local variables in
   the specified <i>frame</i>.
</p><p>
   <a id="__rm_interface_debug_symbol.html:local_argumentsdebug_symbol-interface-method"></a>
   <b><i>local_arguments</i></b> returns a list of names of arguments to the
   function in the specified <i>frame</i>.
</p><p>
   Both <b><i>local_variables</i></b> and <b><i>local_arguments</i></b> can return an
   empty list if no local variables or arguments are found. If something goes
   wrong while looking up variables or arguments they will return a
   <code>Debugger_Lookup_Failure</code> with more information in the error
   string.
</p><p>
   <a id="__rm_interface_debug_symbol.html:expression_valuedebug_symbol-interface-method"></a>
   <b><i>expression_value</i></b> returns the value of an expression,
   <i>expr</i>, in the specified <i>frame</i>. See note about
   <i>address_scope</i> further down. The returned value will be of integer
   type if the expression is of integer type, including if it is an
   address. Floating-point types will be returned as such. If the expression is
   a structure, union, class or an array a list containing the elements of that
   type will be returned.
</p><p>
   Errors specific to this function: </p><ul>

   <li><em>Debugger_Failed_To_Evaluate_Expression</em> - The expression could
   not be evaluated, more information in the error message.</li>

   </ul>
<p>
   <a id="__rm_interface_debug_symbol.html:expression_typedebug_symbol-interface-method"></a>
   <b><i>expression_type</i></b> returns the type of an expression,
   <i>expr</i>, in the specified <i>frame</i>. See note about
   <i>address_scope</i> further down. For most types the return value will
   be a string containing the type, for example <code>'int'</code>,
   <code>'double'</code>, <code>'char'</code> or <code>'my_own_type_t</code>.
</p><p>
   For pointers the return value will be a list with <i>'*'</i> as the
   first argument followed by the type of the pointer, for example <code>['*',
   'void']</code> or <code>['*', ['*', 'char']]</code>.
</p><p>
   For qualifiers ('const', 'volatile' or 'restrict') these will be added as an
   element to the list, such as <code>['const', 'char']</code> or <code>['volatile',
   ['*', 'int']]</code>.
</p><p>
   Functions are returned with a <i>'()'</i> string as the first element of
   a list, followed by the return type, followed by a list of arguments to the
   function. Example: <code>['*', ['()', 'int', ['int', ['*', ['*',
   'char']]]]]</code> for a function of type <code>int (*)(int, char **)</code>.
</p><p>
   A <code>struct</code> or <code>union</code> will return a string
   <code>'struct'</code>, followed by the struct name, if available, then
   followed by a list of lists containing the struct member type and name
   <code>['struct', 'my_struct', [['int', 'i'], ['float', 'f']]]</code> as
   example. If the struct has been assigned a type with <b><i>typedef</i></b> then
   the output will be <code>'typedef'</code> followed by the name of the
   assigned type, then the list of members. An example: <code>['typedef',
   'mytype_t', [['int', 'age'], [['*', 'char'], 'name']]]</code>. For unions the
   string <code>'struct'</code> will be replace with the string
   <code>'union'</code>.
</p><p>
   A <code>bit field</code> will return a list containing a string
   <code>'bitfield'</code> followed by the basic type of the bit field,
   followed by the size of the bit field. An example: <code>['bitfield', 'int',
   5]</code> for a variable declared as <code>int var:5</code>.
</p><p>
   For array types <b><i>expression_type</i></b> will return a list, <code>['[]',
   array size, array type]</code>, where the array type is of the same format as
   other types for this function. An example: <code>['[]', 10, 'char']</code> for a
   variable declared as <code>char x[10]</code>;
</p><p>
   Enumerations will be displayed as a list: <code>['enum', enum name,
   members]</code>. The <i>enum name</i> is the declared name for the
   enumeration, if no such name exists this list field will be left out. The
   <i>members</i> field will contain a list of [name, value] lists for all
   the members of the enumeration. An example: <code>['enum, 'my_enum',
   [['My_Val_0', 0], [My_Val_1, 1]]]</code>.
</p><p>
   </p><div class="note">
<b>Note:</b>
There are some limitations for symbols from PE files that can depend
   on the version of <code>dbghelp.dll</code>.
   <ul>
   <li>Type defined types might get shown as the
   base type instead of the <code>'typedef'</code> type.</li>

   <li>Variables with a <code>const</code> qualifier might be shown without
   that qualifier.</li>

   <li>Members of anonymous structures within a base structure are shown as
   being part of the base structure.</li>
   </ul></div>Errors specific to this function: <ul>

   <li><em>Debugger_Failed_To_Evaluate_Expression</em> - Could not evaluate the
   expression, more information in the error message.</li>

   </ul>
<p>
   <a id="__rm_interface_debug_symbol.html:type_infodebug_symbol-interface-method"></a> <b><i>type_info</i></b>
   returns information about what base type a type that has been added with
   <b><i>typedef</i></b> has. See note about <i>address_scope</i> further
   down. The returned value will be a list on the same format as for
   <b><i>expression_value</i></b>.
</p><p>
   Errors specific to this function: </p><ul>

   <li><em>Debugger_Incorrect_Type</em> - If the <i>type</i> asked for is
   not a valid type.</li>

   <li><em>Debugger_Lookup_Failure</em> - Finding the symbol failed or the type
   of symbol cannot be retrieved. More information in the error string.</li>

   </ul>
<p>
   <a id="__rm_interface_debug_symbol.html:type_to_stringdebug_symbol-interface-method"></a>
   <b><i>type_to_string</i></b> converts the return value from
   <b><i>expression_type</i></b> or <b><i>type_info</i></b> to a readable string and
   returns that.
</p><p>
   Errors specific to this function: </p><ul>

   <li><em>Debugger_Incorrect_Type</em> - The format of <i>type</i> is
   incorrect.</li>

   </ul>
<p>
   <a id="__rm_interface_debug_symbol.html:symbol_addressdebug_symbol-interface-method"></a>
   <b><i>symbol_address</i></b> takes a <i>frame</i> and a <i>symbol</i>
   as arguments and returns a list of addresses that matches that symbol name.
   If a single symbol address is wanted near a provided instruction pointer
   then the <b><i>expression_value</i></b> function can be used with the
   expression set as <code>&amp;&lt;symbol&gt;</code>.
</p><p>
   Errors specific to this function: </p><ul>

   <li><em>Debugger_Lookup_Failure</em> - The address for the symbol cannot be
   found. This can be because the symbol was not found or if evaluation
   failed. More information will be found in the error message.</li>

   </ul>
<p>
   <a id="__rm_interface_debug_symbol.html:address_stringdebug_symbol-interface-method"></a>
   <b><i>address_string</i></b> returns the string at the specified
   <i>address</i>. The <i>maxlen</i> is used to specify the maximum
   length of a string to read from memory. If the string at <i>address</i>
   exceeds the given length the truncated string will be returned, and a
   terminating null character will be added if needed. A <i>maxlen</i>
   value of zero means no maximum string length.
</p><p>
   Errors specific to this function: </p><ul>

   <li><em>Debugger_Failed_To_Read</em> - Failed to read memory at
   <i>address</i>.</li>

   </ul>
<p>
   <a id="__rm_interface_debug_symbol.html:lvalue_writedebug_symbol-interface-method"></a>
   <b><i>lvalue_write</i></b> writes a <i>value</i> to a <i>symbol</i> in
   the specified <i>frame</i>. The <i>value</i> can be of
   <code>integer</code> types or <code>floating-point</code> type if the type
   of the lvalue is of <code>floating-point</code> type. The returned value
   when the write goes well is nil.
</p><p>
   Errors specific to this function: </p><ul>

   <li><em>Debugger_Incorrect_Type</em> - The type of <i>value</i> is
   incorrect.</li>

   <li><em>Debugger_Failed_To_Evaluate_Expression</em> - The provided
   <i>symbol</i> could not be found or evaluated as an expression.</li>

   <li><em>Debugger_Failed_To_Write</em> - Failed to write to
   <i>symbol</i>.</li>

   </ul>
<p>
   <a id="__rm_interface_debug_symbol.html:address_writedebug_symbol-interface-method"></a>
   <b><i>address_write</i></b> writes an <code>attr_value_t</code> of
   <code>data</code> type, <i>value</i>, to the specified
   <i>address</i>. Returned value is nil when the write goes well.
</p><p>
   Errors specific to this function: </p><ul>

   <li><em>Debugger_Incorrect_Type</em> - The type of <i>value</i> is
   incorrect.</li>

   <li><em>Debugger_Failed_To_Write</em> - The memory at <i>address</i>
   cannot be written to.</li>

   </ul>
<p>
   <a id="__rm_interface_debug_symbol.html:address_readdebug_symbol-interface-method"></a>
   <b><i>address_read</i></b> reads <i>size</i> number of bytes from the
   specified <i>address</i>. The read data is returned as an
   <code>attr_value_t</code> of <code>data</code> type.
</p><p>
   Errors specific to this function: </p><ul>

   <li><em>Debugger_Failed_To_Read</em> - The <i>address</i> cannot be
   read.</li>

   </ul>
<p>
   <a id="__rm_interface_debug_symbol.html:struct_membersdebug_symbol-interface-method"></a>
   <b><i>struct_members</i></b> returns a list of all members of a struct,
   <i>struct_name</i>. See note about <i>address_scope</i> further
   down. Each element of the returned list will be on the format <code>[name,
   offset, size]</code>. The <i>size</i> and <i>offset</i> elements are
   usually integers representing the offset into the struct and the size of the
   variable. If the struct member is a bit field then <i>size</i> will be a
   list on the format <code>[base size, bits]</code>, where <i>base size</i> is
   the number of bytes for the declared base type and <i>bits</i> is the
   number of bits the declared for the bit field. For bit fields
   <i>offset</i> will be a list on the format <code>[byte offset, bit
   offset]</code>, where <i>byte offset</i> is the offset of in bytes into
   the structure and <i>bit offset</i> is the offset in bits from the byte
   offset to where the bit field starts. If some member, size or offset cannot
   be retrieved then that element will be set as nil. This can for example
   occur if a struct member is an anonymous struct or union.
</p><p>
   Errors specific to this function: </p><ul>

   <li><em>Debugger_Incorrect_Type</em> - The provided symbol,
   <i>struct_name</i>, is not a structure.</li>

   <li><em>Debugger_Lookup_Failure</em> - Failed to find the symbol or its
   type.</li>

   </ul>
<p>
   <a id="__rm_interface_debug_symbol.html:struct_fielddebug_symbol-interface-method"></a>
   <b><i>struct_field</i></b> returns a list of [offset, size] for a
   <i>field</i> of a given structure, <i>struct_name</i>. The
   <i>offset</i> and <i>size</i> are usually integers, but if the
   <i>field</i> is a bit field then the returned <i>size</i> and
   <i>offset</i> will be on the same format as for
   <b><i>struct_members</i></b>. See note about <i>address_scope</i> below.
</p><p>
   This function can return the same error codes, for the same reasons, as
   the <b><i>struct_members</i></b> function.
</p><p>
   The <i>address_scope</i> argument that is provided for several functions
   can be used to specify where to find the symbol if there are several matches
   for the provided symbol name or expression. This argument is used to provide
   an address that tells the function in which scope to search for the symbol.
   This is only taken in account when no frame (-1) is given as frame. This
   address can be an address that belongs to a loaded symbol file to prioritize
   finding symbols from that symbol file.
</p><p>
   <a id="__rm_interface_debug_symbol.html:list_functionsdebug_symbol-interface-method"></a>
   <a id="__rm_interface_debug_symbol.html:list_global_variablesdebug_symbol-interface-method"></a>
   <b><i>list_functions</i></b> and <b><i>list_global_variables</i></b> lists all
   function or global variable symbols that are known for the given
   context. The symbols shown are the ones that have been added with the
   <b><i>add_symbol_file</i></b> function of the <code>debug_setup</code>
   interface. The returned format is a list of dictionaries with the dictionary
   elements on the format:
</p><p>
   </p><ul>

   <li><i>symbol</i> <code>(string)</code> - The name of the symbol.</li>

   <li><i>address</i> <code>(uint64)</code> - The address in memory of the
   symbol.</li>

   <li><i>size</i> <code>(uint64)</code> - The size of the symbol in
   memory.</li>

   </ul>
<p>
   <a id="__rm_interface_debug_symbol.html:list_source_filesdebug_symbol-interface-method"></a>
   <b><i>list_source_files</i></b> lists all source files provided by the debug
   information of the symbol files for the given context.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(debug_symbol) {
        attr_value_t (*address_source)(conf_object_t *NOTNULL obj,
                                       const char *NOTNULL ctx_id,
                                       uint64 address, uint64 size,
                                       void (*cb)(cbdata_call_t data,
                                                  attr_value_t code_area),
                                       cbdata_register_t data);
        attr_value_t (*source_address)(conf_object_t *NOTNULL obj,
                                       const char *NOTNULL ctx_id,
                                       const char *NOTNULL filename,
                                       uint32 line, uint32 column,
                                       void (*cb)(cbdata_call_t data,
                                                  attr_value_t code_area),
                                       cbdata_register_t data);
        attr_value_t (*address_symbol)(conf_object_t *NOTNULL obj,
                                       const char *NOTNULL ctx_id,
                                       uint64 address);
        attr_value_t (*stack_depth)(conf_object_t *NOTNULL obj,
                                    const char *NOTNULL ctx_id);
        attr_value_t (*stack_frames)(conf_object_t *NOTNULL obj,
                                     const char *NOTNULL ctx_id, int min,
                                     int max);
        attr_value_t (*local_variables)(conf_object_t *NOTNULL obj,
                                        const char *NOTNULL ctx_id, int frame);
        attr_value_t (*local_arguments)(conf_object_t *NOTNULL obj,
                                        const char *NOTNULL ctx_id, int frame);
        attr_value_t (*expression_value)(conf_object_t *NOTNULL obj,
                                         const char *NOTNULL ctx_id,
                                         int32 frame, uint64 address_scope,
                                         const char *NOTNULL expr);
        attr_value_t (*expression_type)(conf_object_t *NOTNULL obj,
                                        const char *NOTNULL ctx_id,
                                        int32 frame, uint64 address_scope,
                                        const char *NOTNULL expr);
        attr_value_t (*type_info)(conf_object_t *NOTNULL obj,
                                  const char *NOTNULL ctx_id,
                                  uint64 address_scope,
                                  const char *NOTNULL type);
        attr_value_t (*type_to_string)(conf_object_t *NOTNULL obj,
                                       attr_value_t type);
        attr_value_t (*symbol_address)(conf_object_t *NOTNULL obj,
                                       const char *NOTNULL ctx_id, int32 frame,
                                       const char *NOTNULL symbol);
        attr_value_t (*address_string)(conf_object_t *NOTNULL obj,
                                       const char *NOTNULL ctx_id,
                                       uint64 address, int maxlen);
        attr_value_t (*lvalue_write)(conf_object_t *NOTNULL obj,
                                     const char *NOTNULL ctx_id, int32 frame,
                                     const char *NOTNULL symbol,
                                     attr_value_t value);
        attr_value_t (*address_write)(conf_object_t *NOTNULL obj,
                                      const char *NOTNULL ctx_id,
                                      uint64 address, attr_value_t value);
        attr_value_t (*address_read)(conf_object_t *NOTNULL obj,
                                     const char *NOTNULL ctx_id, uint64 address,
                                     unsigned size);
        attr_value_t (*struct_members)(conf_object_t *NOTNULL obj,
                                       const char *NOTNULL ctx_id,
                                       uint64 address_scope,
                                       const char *NOTNULL struct_name);
        attr_value_t (*struct_field)(conf_object_t *NOTNULL obj,
                                     const char *NOTNULL ctx_id,
                                     uint64 address_scope,
                                     const char *NOTNULL struct_name,
                                     const char *NOTNULL field);
        attr_value_t (*list_functions)(conf_object_t *NOTNULL obj,
                                       const char *NOTNULL ctx_id);
        attr_value_t (*list_global_variables)(conf_object_t *NOTNULL obj,
                                              const char *NOTNULL ctx_id);
        attr_value_t (*list_source_files)(conf_object_t *NOTNULL obj,
                                          const char *NOTNULL ctx_id);
};
#define DEBUG_SYMBOL_INTERFACE "debug_symbol"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Global Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_debug_symbol_file.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_debug_symbol_file.html:__rm_interface_debug_symbol_file">debug_symbol_file</a></h1>
<p>

<a id="__rm_interface_debug_symbol_file.html:debug_symbol_file"></a><a id="__rm_interface_debug_symbol_file.html:debug_symbol_file_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><a id="__rm_interface_debug_symbol_file.html:debug_symbol_file_interface_t2"></a>
<p>
   This interface has functions for operating directly on symbol files, instead
   of using contexts related to processes or processors. Files opened with this
   interface can be used together with functions in the
   <code>debug_symbol</code> interface that do not require any stack or
   location information. There are also functions for getting information about
   the symbol file, such as listing sections or segments.
</p><p>
   
</p><p>
   For all functions that return an <code>attr_value_t</code>, that return value
   will consists of a list with two elements. The first element is an error code
   of <code>debugger_error_t</code> type (see <code>debug_query</code>
   interface documentation for definition). The second element depends on the
   first. If the first element is <code>Debugger_No_Error</code>, meaning that
   the function went well, then the second element will contain the expected
   return value that is specified per function below. If the first element is
   another error code, then the second element will be a string describing the
   error that occurred.
</p><p>
   
</p><p>
   All function but <b><i>open_symbol_file</i></b> has to act on a context id,
   <i>ctx_id</i>, that has been returned by <b><i>open_symbol_file</i></b>,
   otherwise a <code>Debugger_Not_Supported_For_Context</code> error will be
   returned.
</p><p>
   <a id="__rm_interface_debug_symbol_file.html:open_symbol_filedebug_symbol_file-interface-method"></a>
   <b><i>open_symbol_file</i></b> opens a symbol file, specified by the
   <i>filename</i> argument, as a context so that this can be used with
   many of the symbol lookup functions in the <code>debug_symbol</code>
   interface. The <i>address</i> is the offset for which to load the symbol
   file if <i>absolute_address</i> is false. If <i>absolute_address</i>
   is true, <i>address</i> will instead be the absolute address to load the
   symbol file on. The returned value will be a context id that can be used as
   argument where a <i>ctx_id</i> is required. Functions that take a stack
   frame can only be accessed with no stack (value -1) when used with a symbol
   file context. Files that read or write memory cannot be used.
</p><p>
   Errors specific to this function: </p><ul>

   <li><em>Debugger_Unrecognized_File_Format</em> - The file format of the file
   is not ELF or PE.</li>

   <li><em>Debugger_Unsupported_For_File_Format</em> - If the symbol file is of
   PE format then the <i>address</i> cannot be 0 as the internal handling
   does not support that.</li>

   </ul>
<p>
   <a id="__rm_interface_debug_symbol_file.html:open_symbol_sectiondebug_symbol_file-interface-method"></a>
   <b><i>open_symbol_section</i></b> opens a symbol file in the same way as
   <b><i>open_symbol_file</i></b>, but only adds symbols from the specified
   <i>section</i>. Other arguments and return value are as for
   <b><i>open_symbol_file</i></b>. The symbol section is closed using
   <b><i>close_symbol_file</i></b>. This method can only handle ELF binaries. In
   addition to errors reported by <b><i>open_symbol_file</i></b> this function can
   report <em>Debugger_Section_Not_Found</em> if the <i>section</i> cannot
   be found.
</p><p>
   <a id="__rm_interface_debug_symbol_file.html:close_symbol_filedebug_symbol_file-interface-method"></a>
   <b><i>close_symbol_file</i></b> closes a symbol file that was opened with
   <b><i>open_symbol_file</i></b>. The <i>ctx_id</i> should be the context id
   returned from that function. The returned value will just be nil when this
   goes well.
</p><p>
   <a id="__rm_interface_debug_symbol_file.html:symbol_file_infodebug_symbol_file-interface-method"></a>
   <b><i>symbol_file_info</i></b> returns a list containing a string describing
   the file format and a dictionary with information about the file. The
   <i>ctx_id</i> argument should be the context id returned from the
   <b><i>open_symbol_file</i></b>. The returned information depends on which file
   format the file has. For ELF files the string is "ELF" and the returned
   entries are:
</p><p>
   </p><ul>

   <li><i>big-endian</i> <code>(uint64)</code> - Set to 1 if the binary is
   built for big endian, otherwise 0.</li>

   <li><i>elf-machine-id</i> <code>(uint64)</code> - The ELF machine
   identifier number (<code>e_machine</code>) in the ELF header. This is usually
   prefixed with <code>EM_</code> in headers. For example <code>EM_386 = 3</code> and
   <code>EM_X86_64 = 62.</code> </li>

   </ul>
<p>
   For PE files the string is "PE" and the returned entries are:
</p><p>
   </p><ul>

   <li><i>image-size</i> <code>(uint64)</code> - The size of the PE image in
   memory.</li>

   <li><i>image-base</i> <code>(uint64)</code> - The recommended address for
   the image to be loaded at.</li>

   </ul>
<p>
   Both PE and ELF files will include the following entries:
</p><p>
   </p><ul>

   <li><i>entry-address</i> <code>(uint64)</code> - The program counter for
   where the execution in the file should begin.</li>

   <li><i>file-size</i> <code>(uint64)</code> - The file size in bytes.</li>

   <li><i>machine</i> <code>(string)</code> - The type of machine the binary
   is built for, for example "X86-64", "X86" or "ARM".</li>

   <li><i>address-width</i> <code>(uint64)</code> - The address width the
   file was built for, should be 32 or 64, but 0 specifies unknown.</li>

   </ul>
<p>

   <a id="__rm_interface_debug_symbol_file.html:sections_infodebug_symbol_file-interface-method"></a>
   <b><i>sections_info</i></b> provides information about the sections in the
   symbol file. The <i>ctx_id</i> must be an id for a file opened with
   <b><i>open_symbol_file</i></b> or <b><i>open_symbol_section</i></b> in this
   interface. The returned result is a list with two elements, the first a
   string specifying the format of the file, "ELF" or "PE", and the second a
   list of dictionaries where each dictionary contains information about the
   section. If an id from <b><i>open_symbol_section</i></b> is used then only the
   opened section will be included in the list. The following keys exist in the
   dictionary:
</p><p>
   </p><ul>

   <li><i>name</i> <code>(string)</code> - The name of the section. This key
   could potentially be left out if the sections does not have a name.</li>

   <li><i>address</i> <code>(uint64)</code> - The address in memory.</li>

   <li><i>offset</i> <code>(uint64)</code> - The offset in the file.</li>

   <li><i>size</i> <code>(uint64)</code> - The section size in the file
   image.</li>

   <li><i>executable</i> <code>(boolean)</code> - A boolean telling if the
   section is executable or not.</li>

   <li><i>index</i> <code>(uint64)</code> - Only available for ELF
   files. The section index.</li>

   <li><i>flags</i> <code>(uint64)</code> - Only available for ELF
   files. The value of <code>sh_flags</code> in the ELF section header.</li>

   <li><i>characteristics</i> <code>(uint64)</code> - Only available for PE
   files. The value of <code>Characteristics</code> in the PE section
   <code>IMAGE_SECTION_HEADER</code> structure.</li> </ul>
<p>
   <a id="__rm_interface_debug_symbol_file.html:segments_infodebug_symbol_file-interface-method"></a>
   <b><i>segments_info</i></b> provides information about the segments in the
   symbol file, this is only supported for ELF. The <i>ctx_id</i> must be
   an id for a file opened with <b><i>open_symbol_file</i></b> in this
   interface. The returned result is a list where each entry represent a
   segment. Each entry is in turn a dictionary with the following keys:
</p><p>
   </p><ul>

   <li><i>address</i> <code>(uint64)</code> - Virtual address in
   memory.</li>

   <li><i>size</i> <code>(uint64)</code> - The segment size in
   memory, specified in bytes.</li>

   <li><i>offset</i> <code>(uint64)</code> - Offset into the segment
   location on file.</li>

   <li><i>flags</i> <code>(uint64)</code> - Flags, depending on segment
   type, corresponds to <code>p_flags</code> in the ELF program header table.</li>

   <li><i>type</i> <code>(uint64)</code> - The type of the segment,
   corresponds to <code>p_type</code> in the ELF program header table.</li>

   <li><i>physical-address</i> <code>(uint64)</code> - Physical address in
   memory, if applicable.</li>

   <li><i>file-size</i> <code>(uint64)</code> - The size of the segment in
   file.</li>

   <li><i>sections</i> <code>([string,...])</code> - A list of sections
   included in the segment, presented by the section name.</li>

   </ul>
<p>
   </p><pre class="jdocu_small">SIM_INTERFACE(debug_symbol_file) {
        attr_value_t (*open_symbol_file)(conf_object_t *NOTNULL obj,
                                         const char *NOTNULL filename,
                                         uint64 address, bool absolute_address);
        attr_value_t (*close_symbol_file)(conf_object_t *NOTNULL obj,
                                         const char *NOTNULL ctx_id);
        attr_value_t (*symbol_file_info)(conf_object_t *NOTNULL obj,
                                         const char *NOTNULL ctx_id);
        attr_value_t (*sections_info)(conf_object_t *NOTNULL obj,
                                      const char *NOTNULL ctx_id);
        attr_value_t (*segments_info)(conf_object_t *NOTNULL obj,
                                      const char *NOTNULL ctx_id);
        attr_value_t (*open_symbol_section)(conf_object_t *NOTNULL obj,
                                            const char *NOTNULL filename,
                                            const char *NOTNULL section,
                                            uint64 address,
                                            bool absolute_address);
};
#define DEBUG_SYMBOL_FILE_INTERFACE "debug_symbol_file"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Global Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_disassemble.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_disassemble.html:__rm_interface_disassemble">disassemble</a></h1>
<p>

<a id="__rm_interface_disassemble.html:disassemble"></a><a id="__rm_interface_disassemble.html:disassemble_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The disassemble interface can be used to disassemble code from a
   buffer in memory. It is typically used to disassemble code for the
   host architecture independent of the target architecture
   implemented in a particular version of Simics.
<p>
   </p><pre class="jdocu_small">SIM_INTERFACE(disassemble) {
        /* Set up new block to disassemble */
        void (*init)(conf_object_t *obj, uint8 *buff,
                     int buff_len, uint64 address);
        /* Disassemble the next instruction */
        disasm_instr_t (*next)(conf_object_t *obj);
};

#define DISASSEMBLE_INTERFACE "disassemble"
</pre><p>
</p><p>

   <b><i>init()</i></b> is used to initialize a new disassemble
   session. You should provide a buffer in <code>buff</code>, the buffer
   length in bytes in <code>buff_len</code> and the base address for this
   chunk in <code>address</code>. The <code>address</code> parameter is used
   to calculate program counter relative offsets (for branches and
   other program counter relative constructs).
</p><p>
   <a id="__rm_interface_disassemble.html:disasm_instr_t"></a>
    
</p><pre class="jdocu_small">typedef struct {
        int start;          /* Where the instructions starts in the buffer */
        int length;         /* Length of instruction, or -1 if incomplete */
        char *string;       /* Disassembly string (allocated) */
} disasm_instr_t;</pre><p>

</p><p>
   <b><i>next()</i></b> returns a structure with the next disassembled
   instruction. Repeated use of <b><i>next()</i></b> will disassemble
   additional instructions.
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_follower_agent.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_follower_agent.html:__rm_interface_follower_agent">follower_agent</a></h1>
<p>

<a id="__rm_interface_follower_agent.html:follower_agent"></a><a id="__rm_interface_follower_agent.html:follower_agent_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This interface is intended to be implemented by a follower agent to accept
   data from the follower.
<p>
   The <b><i>accept</i></b> method delivers a deterministic message from the
   follower to the agent.
</p><p>
   The <b><i>accept_async</i></b> method delivers an asynchronous
   (non-deterministic) message from the follower to the agent.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(follower_agent) {
        void (*accept)(conf_object_t *obj, bytes_t msg);
        void (*accept_async)(conf_object_t *obj, bytes_t msg);
};
#define FOLLOWER_AGENT_INTERFACE "follower_agent"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_gfx_break.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_gfx_break.html:__rm_interface_gfx_break">gfx_break</a></h1>
<p>

<a id="__rm_interface_gfx_break.html:gfx_break"></a><a id="__rm_interface_gfx_break.html:gfx_break_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>gfx_break</code> interface facilitates management of graphical
   breakpoints. It is implemented by the graphics console.
<p>
   A graphical breakpoint is defined by an image patch and a location on the
   screen, stored in a file using a bespoke format. Such a file can be created
   using the <b><i>store</i></b> method.
</p><p>
   A breakpoint can then be activated using the <b><i>add</i></b> method.
   The console will check if the breakpoint matches the screen data
   every <i>interval</i> seconds in virtual time, using the clock that
   is associated to the console. Graphical breakpoints
   are therefore deterministic.
</p><p>
   Note that the coordinates of the image patch is stored in the graphical
   breakpoint, and the breakpoint will only match on those coordinates.
</p><p>
   The <b><i>store</i></b> method stores the specified rectangle on the screen in
   the given file. It returns <code>false</code> if the rectangle is invalid or on
   I/O error.
</p><p>
   The <b><i>add</i></b> method activates a previously stored graphical
   breakpoint, and returns a breakpoint ID, which is also passed to
   <i>cb</i> when the breakpoint matches. The parameter <i>name</i> is
   the breakpoint name that will appear in log messages. If <i>name</i> is
   <code>NULL</code> then the file name is used. If <i>oneshot</i> is true, the
   breakpoint will be removed automatically after the first match. The
   <i>interval</i> parameter specifies how often the breakpoint is tested,
   in seconds of simulated time. If <i>cb</i> is not <code>NULL</code>, then
   this function will be called on breakpoint match, otherwise a match stops
   the simulation. If the breakpoint file cannot be loaded, the method returns
   <code>-1</code>.
</p><p>
   The <b><i>remove</i></b> method deactivates a previously activated breakpoint.
</p><p>
   The <b><i>match</i></b> method determines if a stored graphical breakpoint
   matches the current screen. It returns -1 if the breakpoint could not be
   loaded, 1 on match or 0 otherwise.
</p><p>
   The <b><i>info</i></b> method returns the header of a stored graphical
   breakpoint, including the image patch coordinates. If the given file cannot
   be read or has invalid data, then a header containing all 0's is returned.
</p><p>
   The <b><i>export_png</i></b> method converts the image data in a graphical
   breakpoint file to PNG format.
</p><p>
   The <b><i>add_bytes</i></b> method behaves as <b><i>add</i></b> but reads the
   breakpoint data from memory instead of a file.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(gfx_break) {
        bool (*store)(conf_object_t *NOTNULL obj,
                      const char *file,
                      int minx, int miny, int maxx, int maxy);
        int64 (*add)(conf_object_t *NOTNULL obj,
                     const char *file, const char *name,
                     bool oneshot, double interval,
                     gfx_break_cb_t cb, lang_void *arg);
        bool (*remove)(conf_object_t *NOTNULL obj, int64 break_id);
        int (*match)(conf_object_t *NOTNULL obj, const char *file);
        gbp_header_t (*info)(conf_object_t *NOTNULL obj, const char *file);
        bool (*export_png)(conf_object_t *NOTNULL obj, const char *file,
                           const char *png_file);
        int64 (*add_bytes)(conf_object_t *NOTNULL obj,
                           bytes_t data, const char *name,
                           bool oneshot, double interval,
                           gfx_break_cb_t cb, lang_void *arg);
};
#define GFX_BREAK_INTERFACE "gfx_break"
</pre><p>
 
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Global Context
   for all methods
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_host_serial.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_host_serial.html:__rm_interface_host_serial">host_serial</a></h1>
<p>

<a id="__rm_interface_host_serial.html:host_serial"></a><a id="__rm_interface_host_serial.html:host_serial_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>host_serial</code> interface is used to control the text
   console host serial connection.
<p>
   The <b><i>setup</i></b> method will set up a host serial connection on a pty
   (Linux) or COM port (Windows). On Linux, <i>name</i> can be
   <code>NULL</code> in which case a new pty is opened.
</p><p>
   The <b><i>name</i></b> method returns the name of any opened pty or COM port,
   or <code>NULL</code>.
</p><p>
   The <b><i>shutdown</i></b> closes any opened pty or COM port.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(host_serial) {
        bool (*setup)(conf_object_t *NOTNULL obj, const char *name);
        const char *(*name)(conf_object_t *NOTNULL obj);
        void (*shutdown)(conf_object_t *NOTNULL obj);
};
#define HOST_SERIAL_INTERFACE "host_serial"
</pre><p>
 
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Global Context
   for all methods
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_instrumentation_connection.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_instrumentation_connection.html:__rm_interface_instrumentation_connection">instrumentation_connection</a></h1>
<p>

<a id="__rm_interface_instrumentation_connection.html:instrumentation_connection"></a><a id="__rm_interface_instrumentation_connection.html:instrumentation_connection_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This interface is intended to be implemented by instrumentation connections
   using the instrumentation framework. This interface is used to request that
   instrumentation should be temporarily disabled and then re-enabled. That is,
   the connection should not collect any data when it is being disabled. How
   this is achieved is up to the tool, it could tell the provider to stop
   sending information, or simply throw away anything it sends.
   This interface can be used with high frequency while simulation is running,
   so it should be implemented with performance in mind.
   <pre class="jdocu_small">SIM_INTERFACE(instrumentation_connection) {
        void (*enable)(conf_object_t *obj);
        void (*disable)(conf_object_t *obj);
};

#define INSTRUMENTATION_CONNECTION_INTERFACE "instrumentation_connection"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_instrumentation_filter_master.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_instrumentation_filter_master.html:__rm_interface_instrumentation_filter_master">instrumentation_filter_master</a></h1>
<p>

<a id="__rm_interface_instrumentation_filter_master.html:instrumentation_filter_master"></a><a id="__rm_interface_instrumentation_filter_master.html:instrumentation_filter_master_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This interface is intended to be implemented by instrumentation filters.
   Instrumentation filters should enable the associated slaves, which
   themselves are associated with instrumentation connections.
<p>
   The <b><i>set_source_id</i></b> method supplies the filter with an unique
   source number for the filter. This function should only be called once,
   the filter needs to store this number so it can be used when 
   calling the <code>instrumentation_filter_slave</code> interface
   methods.
</p><p>
   The <b><i>add_slave</i></b> method informs the filter that it should enable or
   disable this slave too. The <i>slave</i> object should implement the
   <code>instrumentation_filter_slave</code> interface which should be
   used. The <i>provider_obj</i> parameter is the provider object that
   is located behind the slave and its connection.  Depending on how the filter
   works, it may or may not make use of this parameter. For example, the
   process-filter might detect that the filtered process is now running on a
   particular processor, then it can enable this particular connection only,
   given that it can match the <i>provider_obj</i> with the processor
   currently running the tracked process.
</p><p>
   The <b><i>remove_slave</i></b> method removes a slave from the filter, so
   it should not call it anymore.
</p><p>
   The <b><i>short_filter_config</i></b> method should return a short textual
   description on how the filter is currently set up. This information
   is used in various print commands.
   </p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(instrumentation_filter_master) {
        void (*set_source_id)(conf_object_t *obj, unsigned source_id);
        bool (*add_slave)(conf_object_t *obj, conf_object_t *slave,
                          conf_object_t *provider_obj);
        void (*remove_slave)(conf_object_t *obj, conf_object_t *slave,
                             conf_object_t *provider_obj);
        char *(*short_filter_config)(conf_object_t *obj);
};
#define INSTRUMENTATION_FILTER_MASTER_INTERFACE "instrumentation_filter_master"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Global Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_instrumentation_filter_slave.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_instrumentation_filter_slave.html:__rm_interface_instrumentation_filter_slave">instrumentation_filter_slave</a></h1>
<p>

<a id="__rm_interface_instrumentation_filter_slave.html:instrumentation_filter_slave"></a><a id="__rm_interface_instrumentation_filter_slave.html:instrumentation_filter_slave_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This interface is implemented by the
   <b>instrumentation_filter_aggregator</b> class objects,
   here referred to as "aggregator". The interface should be
   called by instrumentation filters to enable or disable a connection.
   The aggregator object is located between the filters and the connection,
   keeping the connections unaware of multiple filters that might
   be disabling them.
<p>
   The <b><i>disable</i></b> method tells the aggregator that the unique
   <i>source_id</i> currently wants to disable the connection.
   As long as there is one <i>source_id</i> that is disabled,
   the connection is disabled. Only when all sources are enabled
   the connection is enabled.
</p><p>
   Similarly, the <b><i>enable</i></b> enables the connection. That
   is, the filter is now in a state when it thinks the connection
   should be enabled.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(instrumentation_filter_slave) {
        void (*disable)(conf_object_t *obj, unsigned source_id);
        void (*enable)(conf_object_t *obj, unsigned source_id);
};
#define INSTRUMENTATION_FILTER_SLAVE_INTERFACE "instrumentation_filter_slave"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_instrumentation_filter_status.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_instrumentation_filter_status.html:__rm_interface_instrumentation_filter_status">instrumentation_filter_status</a></h1>
<p>

<a id="__rm_interface_instrumentation_filter_status.html:instrumentation_filter_status"></a><a id="__rm_interface_instrumentation_filter_status.html:instrumentation_filter_status_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This interface is implemented by the
   <b>instrumentation_filter_aggregator</b> class objects. This
   interface should only be used by Simics instrumentation framework itself.
   The <b><i>get_disabled_sources</i></b> method returns an
   <code>attr_value_t</code> list of integers representing the source_ids that
   currently causing the connection to be disabled.
<p>
   </p><pre class="jdocu_small">SIM_INTERFACE(instrumentation_filter_status) {
        attr_value_t (*get_disabled_sources)(conf_object_t *obj);
};
#define INSTRUMENTATION_FILTER_STATUS_INTERFACE "instrumentation_filter_status"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Global Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_instrumentation_tool.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_instrumentation_tool.html:__rm_interface_instrumentation_tool">instrumentation_tool</a></h1>
<p>

<a id="__rm_interface_instrumentation_tool.html:instrumentation_tool"></a><a id="__rm_interface_instrumentation_tool.html:instrumentation_tool_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This interface is intended to be implemented by instrumentation tools using
   the instrumentation framework. The instrumentation framework handles setting
   up, controlling and removing the connection between providers and tools, but
   the actual communication is handled by instrumentation specific interfaces.
<p>
   When a connection with a provider is being established, the
   <b><i>connect</i></b> method is called. The <i>provider</i> argument
   specifies the provider which should be connected. The <i>args</i>
   are tool specific arguments that can be used allowing the connection
   to be configured a certain way. The tool should create a new
   dedicated connection object, which register itself with the provider
   using the dedicated interface. The connection object created
   is returned by the <b><i>connect</i></b> function.   
   If, for any reason, the tool cannot successfully connect
   to the provider, NULL should be returned to indicate failure.
</p><p>
   If a connection should be removed, the <b><i>disconnect</i></b> method
   is called. The <i>conn_obj</i> argument is the connection object
   returned earlier in <b><i>connect</i></b>.
   It is up to the tool to delete the created object which should
   unregister itself from the provider.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(instrumentation_tool) {
        conf_object_t *(*connect)(
                conf_object_t *NOTNULL obj,
                conf_object_t *NOTNULL provider,
                attr_value_t args);
        void  (*disconnect)(
                conf_object_t *NOTNULL obj,
                conf_object_t *NOTNULL conn_obj);
};
#define INSTRUMENTATION_TOOL_INTERFACE "instrumentation_tool"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Global Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_leader_message.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_leader_message.html:__rm_interface_leader_message">leader_message</a></h1>
<p>

<a id="__rm_interface_leader_message.html:leader_message"></a><a id="__rm_interface_leader_message.html:leader_message_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This interface is implemented by the leader, and is used from a follower
   agent to send data to the follower.
<p>
   The <b><i>send</i></b> method sends a deterministic message to the follower to
   be delivered at <i>time</i>. If several messages will be delivered at
   same time, an increasing <i>skey</i> determines the sort order.
</p><p>
   The <b><i>send_async</i></b> method sends a non-deterministic (asynchronous)
   message to the follower to be delivered as soon as possible.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(leader_message) {
        void (*send)(conf_object_t *obj,
                     follower_time_t time, uint64 skey, bytes_t msg);
        void (*send_async)(conf_object_t *obj, bytes_t msg);
};
#define LEADER_MESSAGE_INTERFACE "leader_message"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_osa_component.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_osa_component.html:__rm_interface_osa_component">osa_component</a></h1>
<p>

<a id="__rm_interface_osa_component.html:osa_component"></a><a id="__rm_interface_osa_component.html:osa_component_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><a id="__rm_interface_osa_component.html:osa_component_interface_t2"></a>
<p>
   <a id="__rm_interface_osa_component.html:get_adminosa_component-interface-method"></a>
   <b><i>get_admin</i></b> returns the <b>osa_admin</b> object associated
   with the component.
</p><p>
   <a id="__rm_interface_osa_component.html:get_root_nodeosa_component-interface-method"></a>
   <b><i>get_root_node</i></b> returns a maybe_node_id_t with the <i>valid</i>
   field set to true and <i>id</i> set to the current root node if a root
   node exists. If no root node exists the <i>valid</i> field will be set
   to false.
</p><p>
   It is only valid to call <b><i>get_admin</i></b> or <b><i>get_root_node</i></b> on
   instantiated components.
</p><p>
   <a id="__rm_interface_osa_component.html:notify_trackerosa_component-interface-method"></a>
   <b><i>notify_tracker</i></b> registers a callback function <i>cb</i> that
   will be called when a tracker is added to the component using the
   <b>insert-tracker</b> command. Returns a cancel id that can be used to
   cancel the callback using <b><i>cancel_notify</i></b>. It is a one time
   notification and will automatically be canceled once it has been called. The
   <i>data</i> argument will be passed on to the callback.
</p><p>
   <a id="__rm_interface_osa_component.html:cancel_notifyosa_component-interface-method"></a>
   <b><i>cancel_notify</i></b> cancels a callback made by
   <b><i>notify_tracker</i></b>.
</p><p>
   <a id="__rm_interface_osa_component.html:has_trackerosa_component-interface-method"></a>
   <b><i>has_tracker</i></b> returns true if the component has a tracker inserted,
   otherwise false.
</p><p>
   <a id="__rm_interface_osa_component.html:get_processorsosa_component-interface-method"></a>
   <b><i>get_processors</i></b> returns a list of processors to use for the
   software domain.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(osa_component) {
        conf_object_t *(*get_admin)(conf_object_t *NOTNULL obj);
        maybe_node_id_t (*get_root_node)(conf_object_t *NOTNULL obj);
        cancel_id_t (*notify_tracker)(conf_object_t *NOTNULL obj,
                                      void (*cb)(cbdata_call_t data),
                                      cbdata_register_t data);
        void (*cancel_notify)(conf_object_t *NOTNULL obj,
                              cancel_id_t cancel_id);
        bool (*has_tracker)(conf_object_t *NOTNULL obj);
        attr_value_t (*get_processors)(conf_object_t *NOTNULL obj);
};

#define OSA_COMPONENT_INTERFACE "osa_component"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_osa_control.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_osa_control.html:__rm_interface_osa_control">osa_control</a></h1>
<p>

<a id="__rm_interface_osa_control.html:osa_control"></a><a id="__rm_interface_osa_control.html:osa_control_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><a id="__rm_interface_osa_control.html:osa_control_interface_t2"></a>
<p>
   <a id="__rm_interface_osa_control.html:requestosa_control-interface-method"></a> <b><i>request</i></b> is used
   to register clients that are interested in using the tracker framework and
   activates the tracker framework if it is not already activated. The
   <i>initiator</i> argument is a string which should describe the client
   that requests to activate the OS Awareness framework. The return value is an
   ID that should be passed to the <b><i>release</i></b> function to signal that
   the client no longer needs the OS Awareness framework.
</p><p>
   Upon a failure while initializing the OS Awareness framework,
   OSA_Request_Error_ID will be returned.
</p><p>
   <a id="__rm_interface_osa_control.html:releaseosa_control-interface-method"></a> <b><i>release</i></b> removes a
   client that has previously requested to use the tracker framework. The
   <i>id</i> argument is the returned value from <b><i>request</i></b>. The
   tracker framework will be disabled when there are no more registered users.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(osa_control) {
        request_id_t (*request)(conf_object_t *NOTNULL obj,
                                const char *initiator);
        void (*release)(conf_object_t *NOTNULL obj, request_id_t id);
};

#define OSA_CONTROL_INTERFACE "osa_control"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Global Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_osa_control_v2.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_osa_control_v2.html:__rm_interface_osa_control_v2">osa_control_v2</a></h1>
<p>

<a id="__rm_interface_osa_control_v2.html:osa_control_v2"></a><a id="__rm_interface_osa_control_v2.html:osa_control_v2_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><a id="__rm_interface_osa_control_v2.html:osa_control_v2_interface_t2"></a>
<p>
   <a id="__rm_interface_osa_control_v2.html:requestosa_control_v2-interface-method"></a> <b><i>request</i></b> is
   used to register clients that are interested in using the tracker framework
   and activates the tracker framework if it is not already activated. The
   <i>initiator</i> argument is a string which should describe the client
   that requests to activate the OS Awareness framework. The return format is
   [bi|s]. If the first element is True, then the second element will contain
   the request_id, which can be passed to the <b><i>release</i></b>
   function to signal that the client no longer needs the OS Awareness
   framework. If the first element is False, the second element will be an
   error message.
</p><p>
   <a id="__rm_interface_osa_control_v2.html:releaseosa_control_v2-interface-method"></a> <b><i>release</i></b>
   removes a client that has previously requested to use the tracker
   framework. The <i>id</i> argument is the returned value from
   <b><i>request</i></b>. The tracker framework will be disabled when there are no
   more registered users.
</p><p>
   <a id="__rm_interface_osa_control_v2.html:clear_stateosa_control_v2-interface-method"></a>
   <b><i>clear_state</i></b> can be called to clear the state in the tracker
   framework that could exist after loading a checkpoint. This can only be
   called while the tracker is disabled. The return value will be on the format
   [bi|s]. If the first element is True then clearing state succeeded and the
   second element can be ignored. If the first element is False then clearing
   state failed and the second element will contain a string with a message of
   what went wrong.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(osa_control_v2) {
        attr_value_t (*request)(conf_object_t *NOTNULL obj,
                                const char *initiator);
        void (*release)(conf_object_t *NOTNULL obj, request_id_t id);
        attr_value_t (*clear_state)(conf_object_t *NOTNULL obj);
};

#define OSA_CONTROL_V2_INTERFACE "osa_control_v2"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Global Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_osa_machine_notification.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_osa_machine_notification.html:__rm_interface_osa_machine_notification">osa_machine_notification</a></h1>
<p>

<a id="__rm_interface_osa_machine_notification.html:osa_machine_notification"></a><a id="__rm_interface_osa_machine_notification.html:osa_machine_notification_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><a id="__rm_interface_osa_machine_notification.html:osa_machine_notification_interface_t2"></a>
<p>
   <a id="__rm_interface_osa_machine_notification.html:notify_mode_changeosa_machine_notification-interface-method"></a>
   <b><i>notify_mode_change</i></b> registers a callback function that will be
   called when processor <i>cpu</i> changes processor mode. The
   callback function will be called with the processor that changed mode
   <i>cpu</i>, the mode previous to the change <i>old_mode</i> and
   the mode after the change <i>new_mode</i>.
</p><p>
   <a id="__rm_interface_osa_machine_notification.html:notify_exceptionosa_machine_notification-interface-method"></a>
   <b><i>notify_exception</i></b> registers a callback function that will be
   called when processor <i>cpu</i> takes an exception with exception
   number <i>exc_num</i>. The callback function <i>cb</i> will be
   called with the processor <i>cpu</i> causing the exception and
   exception number <i>exc_num</i> of that exception.
</p><p>
   <a id="__rm_interface_osa_machine_notification.html:notify_control_regosa_machine_notification-interface-method"></a>
   <b><i>notify_control_reg</i></b> registers a callback function that will be
   called when a control register, with register number <i>reg_num</i>, in
   processor <i>cpu</i> is updated. The callback function <i>cb</i>
   will be called with the processor <i>cpu</i>, register number
   <i>reg_num</i> and the written register <i>value</i> (see
   Core_Control_Register_Write documentation for more details) as
   arguments. The register number for a certain register can be retrieved with
   the <b><i>get_register_number</i></b> function.
</p><p>
   <a id="__rm_interface_osa_machine_notification.html:notify_control_reg_readosa_machine_notification-interface-method"></a>
   <b><i>notify_control_reg_read</i></b> registers a callback function that will
   be called when a control register, with register number <i>reg_num</i>,
   in processor <i>cpu</i> is read. The callback function <i>cb</i>
   will be called with the processor <i>cpu</i> and register number
   <i>reg_num</i> as arguments. The register number for a certain register
   can be retrieved with the <b><i>get_register_number</i></b> function.
</p><p>
   <a id="__rm_interface_osa_machine_notification.html:notify_exec_breakpointosa_machine_notification-interface-method"></a>
   <b><i>notify_exec_breakpoint</i></b>,
   <a id="__rm_interface_osa_machine_notification.html:notify_read_breakpointosa_machine_notification-interface-method"></a>
   <b><i>notify_read_breakpoint</i></b> and
   <a id="__rm_interface_osa_machine_notification.html:notify_write_breakpointosa_machine_notification-interface-method"></a>
   <b><i>notify_write_breakpoint</i></b> plant breakpoints of length
   <i>len</i> for processor <i>cpu</i> on <i>address</i>.
   The breakpoint is of type execution, read, write respectively. The
   <i>virt</i> argument specifies if <i>address</i> is a virtual
   or physical address. The callback function <i>cb</i> is called when
   the breakpoint is hit.
   The arguments of the callback functions are the processor that the
   breakpoint hit on <i>cpu</i> and the <i>address</i>
   (virtual or physical depending on what the breakpoint was registered as)
   that was hit.
   Callbacks functions for <b><i>notify_read_breakpoint</i></b> and
   <b><i>notify_write_breakpoint</i></b> also gets the access size <i>len</i>
   of the read or write.
   The callback function for <b><i>notify_write_breakpoint</i></b> additionally
   has the previous value <i>old_val</i> at the address written and the new
   value <i>new_val</i> that is being written passed as arguments. Reading
   the actual memory from the callback will result in reading the new value that
   has been written as the callback is called after the write is done.
   On x86 virtual breakpoints use linear addresses (as opposed to logical
   addresses).
</p><p>
   For all functions, the <i>tracker</i> argument should be the tracker
   calling this interface. This makes it possible for a hypervisor tracker to
   handle guests differently.
</p><p>
   All methods that register a notification callback take <i>data</i> as an
   argument which will be passed on to callback function. These methods return
   a cancel ID to be used with the <b><i>cancel</i></b> method to cancel the
   callback. A returned value of 0 means that an error occurred and no callback
   was registered, in which case the caller is responsible for freeing the
   callback <i>data</i>.
</p><p>
   <a id="__rm_interface_osa_machine_notification.html:cancelosa_machine_notification-interface-method"></a>
   <b><i>cancel</i></b> cancels the callback function with ID <i>cancel_id</i>
   and will free the callback <i>data</i> associated with the
   notification. This ID will have been returned from the function that
   registered the callback.
</p><p>
   </p><pre class="jdocu_small">typedef enum {
        OSA_Read_One_Byte = 1,
        OSA_Read_Two_Byte = 2,
        OSA_Read_Four_Byte = 4,
        OSA_Read_Eight_Byte = 8,
} osa_read_len_t;

SIM_INTERFACE(osa_machine_notification) {
        cancel_id_t (*notify_mode_change)(
                conf_object_t *NOTNULL obj, conf_object_t *NOTNULL tracker,
                conf_object_t *NOTNULL cpu,
                void (*cb)(cbdata_call_t data, conf_object_t *cpu,
                           processor_mode_t old_mode,
                           processor_mode_t new_mode),
                cbdata_register_t data);
        cancel_id_t (*notify_exception)(
                conf_object_t *NOTNULL obj, conf_object_t *NOTNULL tracker,
                conf_object_t *NOTNULL cpu, int exc_num,
                void (*cb)(cbdata_call_t data, conf_object_t *cpu, int exc_num),
                cbdata_register_t data);
        cancel_id_t (*notify_control_reg)(
                conf_object_t *NOTNULL obj, conf_object_t *NOTNULL tracker,
                conf_object_t *NOTNULL cpu, int reg_num,
                void (*cb)(cbdata_call_t data, conf_object_t *cpu, int reg_num,
                           uint64 value),
                cbdata_register_t data);
        cancel_id_t (*notify_exec_breakpoint)(
                conf_object_t *NOTNULL obj, conf_object_t *NOTNULL tracker,
                conf_object_t *NOTNULL cpu, uint64 address, uint64 len,
                bool virt,
                void (*cb)(cbdata_call_t data, conf_object_t *cpu,
                           uint64 address),
                cbdata_register_t data);
        cancel_id_t (*notify_read_breakpoint)(
                conf_object_t *NOTNULL obj, conf_object_t *NOTNULL tracker,
                conf_object_t *NOTNULL cpu, uint64 address, unsigned len,
                bool virt,
                void (*cb)(cbdata_call_t data, conf_object_t *NOTNULL cpu,
                           uint64 address, unsigned len),
                cbdata_register_t data);
        cancel_id_t (*notify_write_breakpoint)(
                conf_object_t *NOTNULL obj, conf_object_t *NOTNULL tracker,
                conf_object_t *NOTNULL cpu, uint64 address, unsigned len,
                bool virt,
                void (*cb)(cbdata_call_t data, conf_object_t *NOTNULL cpu,
                           uint64 address, unsigned len, uint64 old_val,
                           uint64 new_val),
                cbdata_register_t data);
        void (*cancel)(conf_object_t *NOTNULL obj,
                       conf_object_t *NOTNULL tracker, cancel_id_t cancel_id);
        cancel_id_t (*notify_control_reg_read)(
                conf_object_t *NOTNULL obj, conf_object_t *NOTNULL tracker,
                conf_object_t *NOTNULL cpu, int reg_num,
                void (*cb)(cbdata_call_t data, conf_object_t *cpu, int reg_num),
                cbdata_register_t data);
};

#define OSA_MACHINE_NOTIFICATION_INTERFACE "osa_machine_notification"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_osa_machine_query.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_osa_machine_query.html:__rm_interface_osa_machine_query">osa_machine_query</a></h1>
<p>

<a id="__rm_interface_osa_machine_query.html:osa_machine_query"></a><a id="__rm_interface_osa_machine_query.html:osa_machine_query_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><a id="__rm_interface_osa_machine_query.html:osa_machine_query_interface_t2"></a>
<p>
   <a id="__rm_interface_osa_machine_query.html:read_registerosa_machine_query-interface-method"></a>
   <b><i>read_register</i></b> reads the register with number <i>reg</i>
   (number can be retrieved with <b><i>get_register_number</i></b>) from processor
   <i>cpu</i> and returns the value of that register.
</p><p>
   <a id="__rm_interface_osa_machine_query.html:get_register_numberosa_machine_query-interface-method"></a>
   <b><i>get_register_number</i></b> returns the register number of the register
   with name <i>reg</i> from processor <i>cpu</i> or -1 upon error.
</p><p>
   <a id="__rm_interface_osa_machine_query.html:read_phys_memoryosa_machine_query-interface-method"></a>
   <b><i>read_phys_memory</i></b> reads <i>len</i> bytes of memory from
   physical address <i>addr</i> of processor <i>cpu</i>. The returned
   value is an uint64 with the value if the read succeeded, otherwise nil. The
   <i>len</i> argument should use one of the lengths declared in the
   <code>osa_read_len_t</code> enum.
</p><p>
   <a id="__rm_interface_osa_machine_query.html:read_phys_bytesosa_machine_query-interface-method"></a>
   <b><i>read_phys_bytes</i></b> reads <i>len</i> bytes of memory from
   physical address <i>addr</i>. The length to read can be up to 1024
   bytes. The returned value is of data type containing the bytes read upon
   success or nil otherwise.
</p><p>
   <a id="__rm_interface_osa_machine_query.html:virtual_to_physicalosa_machine_query-interface-method"></a>
   <b><i>virtual_to_physical</i></b> translates the virtual address
   <i>vaddr</i> of processor <i>cpu</i> to a physical address as
   translation would be for a data read. The returned value is the physical
   address as an uint64 upon success, otherwise nil. For x86 this uses linear
   to physical translation (as opposed to the logical to physical variant).
</p><p>
   <a id="__rm_interface_osa_machine_query.html:cpu_modeosa_machine_query-interface-method"></a>
   <b><i>cpu_mode</i></b> returns the current processor mode of <i>cpu</i>.
</p><p>
   <a id="__rm_interface_osa_machine_query.html:get_all_processorsosa_machine_query-interface-method"></a>
   <b><i>get_all_processors</i></b> returns all available processors. For example,
   when detecting parameters, a tracker should use its known processors if the
   system is enabled, otherwise it can get them via get_all_processors. For
   hypervisor configurations, the tracker framework must be enabled in order to
   detect parameters for a guest.
</p><p>
   <a id="__rm_interface_osa_machine_query.html:get_exception_numberosa_machine_query-interface-method"></a>
   <b><i>get_exception_number</i></b> returns the exception number of the
   exception with name <i>name</i> from processor <i>cpu</i>.
   Returns -1 if no exception with the given name exists.
</p><p>
   For all functions, the <i>tracker</i> argument should be the tracker
   calling this interface. This makes it possible for a hypervisor tracker to
   handle guests differently.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(osa_machine_query) {
        uint64 (*read_register)(
                conf_object_t *NOTNULL obj, conf_object_t *NOTNULL tracker,
                conf_object_t *NOTNULL cpu, int reg);
        int (*get_register_number)(
                conf_object_t *NOTNULL obj, conf_object_t *NOTNULL tracker,
                conf_object_t *NOTNULL cpu, const char *reg);
        attr_value_t (*read_phys_memory)(
                conf_object_t *NOTNULL obj, conf_object_t *NOTNULL tracker,
                conf_object_t *NOTNULL cpu, physical_address_t addr,
                osa_read_len_t len);
        attr_value_t (*read_phys_bytes)(
                conf_object_t *NOTNULL obj, conf_object_t *NOTNULL tracker,
                conf_object_t *NOTNULL cpu, physical_address_t paddr,
                unsigned len);
        attr_value_t (*virtual_to_physical)(
                conf_object_t *NOTNULL obj, conf_object_t *NOTNULL tracker,
                conf_object_t *NOTNULL cpu, uint64 vaddr);
        processor_mode_t (*cpu_mode)(conf_object_t *NOTNULL obj,
                                     conf_object_t *NOTNULL tracker,
                                     conf_object_t *NOTNULL cpu);
        attr_value_t (*get_all_processors)(conf_object_t *NOTNULL obj,
                                           conf_object_t *NOTNULL tracker);
        int (*get_exception_number)(
                conf_object_t *NOTNULL obj, conf_object_t *NOTNULL tracker,
                conf_object_t *NOTNULL cpu, const char *name);
};

#define OSA_MACHINE_QUERY_INTERFACE "osa_machine_query"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_osa_mapper_admin.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_osa_mapper_admin.html:__rm_interface_osa_mapper_admin">osa_mapper_admin</a></h1>
<p>

<a id="__rm_interface_osa_mapper_admin.html:osa_mapper_admin"></a><a id="__rm_interface_osa_mapper_admin.html:osa_mapper_admin_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><a id="__rm_interface_osa_mapper_admin.html:osa_mapper_admin_interface_t2"></a>
<p>
   <a id="__rm_interface_osa_mapper_admin.html:tracker_updatedosa_mapper_admin-interface-method"></a>
   <b><i>tracker_updated</i></b> is called from the node tree when entities are
   added, modified or removed. To receive such an update, the mapper must
   subscribe to tracker updates by calling <b><i>subscribe_tracker</i></b> in
   the <code>osa_tracker_state_notification</code> interface. The
   <i>initiator</i> argument is the processor object that initiated the
   transaction. This can be nil if the transaction was not initiated by a
   processor (for example, enable or disable tracker). The format of
   <i>changeset</i> is a dictionary with tracker objects that were updated
   as keys and other dictionaries as values.
</p><p>
   The dictionary that is set as the value for each tracker contains the
   following keywords: <i>"added"</i>, <i>"modified"</i>,
   <i>"removed"</i> and <i>"events"</i>.
</p><p>
   The value for <i>"added"</i> is a dictionary which contains the added
   entity IDs as keys and the attributes of those entities as values.
</p><p>
   An example of <i>"added"</i> where two entities were added:
   </p><pre class="jdocu_small">"added": {0x1000: {"name": "task1", "pid": 1},
          0x2000: {"name": "task2", "pid": 2}}</pre><p>
</p><p>
   The value for <i>"modified"</i> is a dictionary which contains the
   modified entity IDs as keys and a dictionary with the attribute name
   as key and a list of old and new values for that attribute as its value.
   Only the attributes that have changed will be included. If an attribute
   is removed that will be set so that it changed to nil. If an attribute was
   added that will be set so that it changed from nil.
</p><p>
   An example of <i>"modified"</i>, entity 0x1000 had <i>"name"</i>
   changed and entity 0x2000 had <i>"tgid"</i> added and <i>"pid"</i>
   removed:
   </p><pre class="jdocu_small">"modified": {0x1000: {"name": ["task1", "new_name"]},
             0x2000: {"tgid": [None, 4], "pid": [2, None]}}</pre><p>
</p><p>
   The value for <i>"removed"</i> is a list which contains the entity IDs
   for the entities that have been removed.
</p><p>
   The value for <i>"events"</i> is a dictionary indexed by the entity
   id. Each value is a list of lists, each inner list is an event. The first
   element of the inner list is the event name and the second element is user
   defined data associated with the event.
</p><p>
   An example of <i>"events"</i> where entity 0x1000 has two associated
   events and entity 0x2000 has one associated event:
   </p><pre class="jdocu_small">"events": {0x1000: [["event1", {}], ["event2", {}]],
           0x2000: [["syscall", {'sys_num': 0x10, 'sys_name': "open"}]]}</pre><p>
</p><p>
   An example of how the complete <i>changeset</i> might look like:
   </p><pre class="jdocu_small">{&lt;the tracker 'tracker1_obj'&gt;: {"added": {0x1000: {"name": "task"}},
                                "modified": {0x2000: {"dummy": [1, 2]}},
                                "removed": [0x3000, 0x3100]},}</pre><p>
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(osa_mapper_admin) {
        void (*tracker_updated)(conf_object_t *NOTNULL obj,
                                conf_object_t *initiator,
                                attr_value_t changeset);
};
#define OSA_MAPPER_ADMIN_INTERFACE "osa_mapper_admin"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_osa_mapper_control.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_osa_mapper_control.html:__rm_interface_osa_mapper_control">osa_mapper_control</a></h1>
<p>

<a id="__rm_interface_osa_mapper_control.html:osa_mapper_control"></a><a id="__rm_interface_osa_mapper_control.html:osa_mapper_control_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><a id="__rm_interface_osa_mapper_control.html:osa_mapper_control_interface_t2"></a>
<p>
   <a id="__rm_interface_osa_mapper_control.html:disableosa_mapper_control-interface-method"></a> The
   <b><i>disable</i></b> function is called when the mapper should be
   disabled. The mapper should then clean-up the node tree and stop listening
   to changes from trackers.
</p><p>
   <a id="__rm_interface_osa_mapper_control.html:enableosa_mapper_control-interface-method"></a> The
   <b><i>enable</i></b> function is called when the mapper should be enabled. The
   mapper should then create the node tree and start listening to changes from
   trackers.
</p><p>
   <a id="__rm_interface_osa_mapper_control.html:clear_stateosa_mapper_control-interface-method"></a> The
   <b><i>clear_state</i></b> is called to clear the mapper's state. The mapper
   should clear all its internal data when this is called, so that
   <b><i>enable</i></b> can be called again. This call can only occur while
   the mapper is disabled.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(osa_mapper_control) {
        void (*disable)(conf_object_t *NOTNULL obj);
        bool (*enable)(conf_object_t *NOTNULL obj);
        void (*clear_state)(conf_object_t *NOTNULL obj);
};
#define OSA_MAPPER_CONTROL_INTERFACE "osa_mapper_control"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_osa_mapper_query.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_osa_mapper_query.html:__rm_interface_osa_mapper_query">osa_mapper_query</a></h1>
<p>

<a id="__rm_interface_osa_mapper_query.html:osa_mapper_query"></a><a id="__rm_interface_osa_mapper_query.html:osa_mapper_query_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><a id="__rm_interface_osa_mapper_query.html:osa_mapper_query_interface_t2"></a>
<p>
   <a id="__rm_interface_osa_mapper_query.html:get_process_listosa_mapper_query-interface-method"></a> The optional
   <b><i>get_process_list</i></b> function provides data for the 'list'
   command. It should return a two-element list, where the first element is a
   list of column headers, and the second element is a list of (row, subtable)
   two-element lists. All rows should have the same number of elements as the
   header list (this is the number of columns in the resulting table).
</p><p>
   The elements of the header list and row lists---that is, the individual
   elements in the table---should be of type string or integer. Integers will
   be formatted by the system, so in order to force a specific base, such as
   decimal or hexadecimal, convert them to strings.
</p><p>
   The subtables paired with each row should either be None (meaning no
   subtable) or a nested list such as that returned by get_process_list(), in
   which case that list will be printed, slightly indented, below the row. This
   makes it possible for the list command to handle stacked trackers. An
   example of how a complete return value from <b><i>get_process_list</i></b>
   function can look like:
</p><p>
   </p><pre class="jdocu_small">[["Process", "Pid"], [[["ls", 1], None], [["cat", 2], None]]]</pre><p>
</p><p>
   If the function is not implemented, the function pointer should be set to
   NIL.
</p><p>
   <a id="__rm_interface_osa_mapper_query.html:get_mapperosa_mapper_query-interface-method"></a> The optional
   <b><i>get_mapper</i></b> function returns the mapper that is responsible for
   the given node. A mapper that has guest mappers should forward the request
   to the guests as well if the node belongs to one of the guests. If the
   function is not implemented by the mapper, it is assumed that the node is
   owned by the mapper.
</p><p>
   If this function is not implemented, the function pointer should be set to
   NIL. Stacked trackers, which support guest trackers must implement this
   function.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(osa_mapper_query) {
        attr_value_t (*get_process_list)(conf_object_t *NOTNULL obj);
        conf_object_t *(*get_mapper)(conf_object_t *NOTNULL obj,
                                     node_id_t node_id);
};
#define OSA_MAPPER_QUERY_INTERFACE "osa_mapper_query"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Global Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_osa_micro_checkpoint.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_osa_micro_checkpoint.html:__rm_interface_osa_micro_checkpoint">osa_micro_checkpoint</a></h1>
<p>

<a id="__rm_interface_osa_micro_checkpoint.html:osa_micro_checkpoint"></a><a id="__rm_interface_osa_micro_checkpoint.html:osa_micro_checkpoint_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><a id="__rm_interface_osa_micro_checkpoint.html:osa_micro_checkpoint_interface_t2"></a>
<p>
   This interface is used to get information when micro checkpointing (for
   reverse execution) starts and stops. The functions will only be called
   when the tracker framework is enabled.
</p><p>
   <a id="__rm_interface_osa_micro_checkpoint.html:startedosa_micro_checkpoint-interface-method"></a>
   <b><i>started</i></b> is called when a saved state is about to be loaded,
   before any attributes have been set.
</p><p>
   <a id="__rm_interface_osa_micro_checkpoint.html:finishedosa_micro_checkpoint-interface-method"></a>
   <b><i>finished</i></b> is called once all attributes have been set for all
   objects. At this point callbacks calls to the machine interfaces can be
   done.
</p><p>
   It is allowed to implement only one of these functions if notification are
   only wanted before or after setting attributes of a micro checkpoint.
</p><p>
   This interface is optional and can be implemented by either a tracker or a
   mapper.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(osa_micro_checkpoint) {
        void (*started)(conf_object_t *NOTNULL obj);
        void (*finished)(conf_object_t *NOTNULL obj);
};

#define OSA_MICRO_CHECKPOINT_INTERFACE "osa_micro_checkpoint"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Global Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_osa_node_path.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_osa_node_path.html:__rm_interface_osa_node_path">osa_node_path</a></h1>
<p>

<a id="__rm_interface_osa_node_path.html:osa_node_path"></a><a id="__rm_interface_osa_node_path.html:osa_node_path_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><a id="__rm_interface_osa_node_path.html:osa_node_path_interface_t2"></a>
<p>
   <a id="__rm_interface_osa_node_path.html:matching_nodesosa_node_path-interface-method"></a>
   <b><i>matching_nodes</i></b> function returns a list of all nodes rooted at
   <i>root_id</i> that matches the given <i>node_path_pattern</i>. The
   node_path_pattern should be either an integer representing a node id or a
   string, see <em>Analyzer User's Guide</em> for more details.
</p><p>
   Upon success, the return value is a list where the first entry is true and
   the second entry is a list containing all the matching node ids.
</p><p>
   Upon failure, the return value is a list where the first entry is false and
   the second entry is a string describing the error.
</p><p>
   <a id="__rm_interface_osa_node_path.html:node_pathosa_node_path-interface-method"></a> <b><i>node_path</i></b>
   function translates a node id into a fully qualified node path string. See
   <em>Analyzer User's Guide</em> for more details.
</p><p>
   Upon success, the return value is a list where the first entry is true and
   the second entry is the node path string.
</p><p>
   Upon failure, the return value is a list where the first entry is false and
   the second entry is a string describing the error.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(osa_node_path) {
        attr_value_t (*matching_nodes)(conf_object_t *NOTNULL obj,
                                       node_id_t root_id,
                                       attr_value_t node_path_pattern);
        attr_value_t (*node_path)(conf_object_t *NOTNULL obj,
                                  node_id_t node_id);
};

#define OSA_NODE_PATH_INTERFACE "osa_node_path"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Global Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_osa_node_tree_admin.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_osa_node_tree_admin.html:__rm_interface_osa_node_tree_admin">osa_node_tree_admin</a></h1>
<p>

<a id="__rm_interface_osa_node_tree_admin.html:osa_node_tree_admin"></a><a id="__rm_interface_osa_node_tree_admin.html:osa_node_tree_admin_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><a id="__rm_interface_osa_node_tree_admin.html:osa_node_tree_admin_interface_t2"></a>
<p>
   <a id="__rm_interface_osa_node_tree_admin.html:beginosa_node_tree_admin-interface-method"></a> <b><i>begin</i></b> is
   called from the mapper to start a transaction when adding, updating or
   removing nodes in the node tree. The <i>initiator</i> argument specifies
   the initiator processor, this can be nil if the transaction is not initiated
   by a processor. The <i>initiator</i> will be passed as <i>cpu</i>
   argument to callback functions in the
   <code>osa_node_tree_notification</code> interface. The function returns an
   ID to be used when calling <b><i>end</i></b>.
</p><p>
   <a id="__rm_interface_osa_node_tree_admin.html:endosa_node_tree_admin-interface-method"></a> <b><i>end</i></b> is called
   from the mapper to end a transaction. This should be called at the end of a
   transaction when all modifications to the node tree are complete. The
   <i>transaction_id</i> argument should be the value returned from the
   <b><i>begin</i></b> method that started the transaction.  Stacked calls to
   <b><i>begin</i></b> and <b><i>end</i></b> are possible, then the transaction will
   be ended when the first <b><i>begin</i></b> is ended. The <b><i>begin</i></b>
   methods must be ended in the opposite order that they were called. For
   stacked calls to <b><i>begin</i></b> only the initiator of the first call to
   begin will be used.
</p><p>
   <a id="__rm_interface_osa_node_tree_admin.html:createosa_node_tree_admin-interface-method"></a>
   <b><i>create</i></b> creates a new node tree and associates <i>mapper</i>
   with it. The properties of the root node for the new tree are set through
   <i>props</i> which is a dictionary. The returned value is the node ID
   of the created root node.
</p><p>
   <a id="__rm_interface_osa_node_tree_admin.html:addosa_node_tree_admin-interface-method"></a>
   <b><i>add</i></b> adds a new node rooted at <i>parent_id</i>. The new
   node gets the properties specified by <i>props</i> which is a
   dictionary. The returned value is the node ID of the newly added node.
</p><p>
   <a id="__rm_interface_osa_node_tree_admin.html:updateosa_node_tree_admin-interface-method"></a>
   <b><i>update</i></b> updates the properties of a node in the node tree.
   <i>node_id</i> specifies the node to be updated and <i>props</i>
   is a dictionary of the properties that should be updated.
</p><p>
   <a id="__rm_interface_osa_node_tree_admin.html:set_propertyosa_node_tree_admin-interface-method"></a>
   <b><i>set_property</i></b> updates one property of a node in the node tree.
   This is similar to <b><i>update</i></b> but there is no need to build up a
   dictionary. <i>node_id</i> specifies the node to be updated,
   <i>key</i> the key of the property to be updated and <i>value</i>
   the value to update the property with.
</p><p>
   <a id="__rm_interface_osa_node_tree_admin.html:resetosa_node_tree_admin-interface-method"></a>
   <b><i>reset</i></b> resets a node, <i>node_id</i>, to the properties
   specified by <i>props</i>. All the children for the node will be removed
   and all properties except the ones in <i>props</i> will be removed. If
   the reset node was previously active it will be deactivated.
</p><p>
   All methods have the limitation that data and dictionary types are not
   supported as the value of a property. The keys of the <i>props</i>
   dictionary must all be of string type.
</p><p>
   <a id="__rm_interface_osa_node_tree_admin.html:removeosa_node_tree_admin-interface-method"></a>
   <b><i>remove</i></b> removes the node with the ID specified by
   <i>node_id</i> from the node tree.
</p><p>
   <a id="__rm_interface_osa_node_tree_admin.html:eventosa_node_tree_admin-interface-method"></a>
   <b><i>event</i></b> registers a new event, associated with the given
   <i>node_id</i>. The <i>event_name</i> argument is the name of the
   event, this name can also be used by a user to only listen to a specific
   event type per node tree. The <i>event_data</i> argument is the data
   associated with the event and it is up to the responsible tracker to
   document its exact form. An event differes from other properties in the way
   that they are not persistent.
</p><p>
   <a id="__rm_interface_osa_node_tree_admin.html:activateosa_node_tree_admin-interface-method"></a>
   <b><i>activate</i></b> sets <i>node_id</i> as the active node for
   processor <i>cpu</i> in the node tree where <i>node_id</i> exists.
   All the ancestors of <i>node_id</i> will also be set as active. Any
   previously active node for <i>cpu</i> will be deactivated.
   </p><p>
   <a id="__rm_interface_osa_node_tree_admin.html:deactivateosa_node_tree_admin-interface-method"></a>
   <b><i>deactivate</i></b> deactivates processor <i>cpu</i> in the node tree
   where <i>node_id</i> exists. The <i>node_id</i> argument should be
   set to the node that was previously active on <i>cpu</i> in the node
   tree.
</p><p>
   <a id="__rm_interface_osa_node_tree_admin.html:register_formatterosa_node_tree_admin-interface-method"></a>
   <b><i>register_formatter</i></b> registers a callback function which will be
   called when the property specified by the <i>key</i> argument should be
   formatted in a specific way. This is typically called from
   <b><i>"get_formatted_properties"</i></b> in the
   <code>osa_node_tree_query</code> interface. This is useful for
   systems where an integer property should be formatted in hexadecimal to make
   a closer match to the target OS mapper of that property. For example, a node
   with the following properties:
</p><p>
   </p><pre class="jdocu_small">{"name": "foo", "tid": 4711}</pre><p>
</p><p>
   could then be formatted as:
</p><p>
   </p><pre class="jdocu_small">{"name": "foo", "tid": "0x1267"}</pre><p>
</p><p>
   The function itself must return a string, given as an attr_value_t. The
   mapper must have been registered by calling the <b><i>create</i></b> function
   in the <code>osa_node_tree_admin</code> interface before registering a
   formatter.
</p><p>
   The <b><i>register_formatter</i></b> function returns a cancel id that can be
   passed to the <b><i>unregister_formatter</i></b> function to unregister the
   formatting function. Registering a new formatter on the same
   <i>node_id</i> and <i>key</i> as a previous formatter will override
   the previous formatter with the new one. This is useful when dealing with
   stacked trackers and a sub-tracker needs to register a formatter for a node
   that already have a registered formatter.
</p><p>
   <a id="__rm_interface_osa_node_tree_admin.html:unregister_formatterosa_node_tree_admin-interface-method"></a>
   <b><i>unregister_formatter</i></b> unregisters a previously registered
   formatter function using the <b><i>register_formatter</i></b> function.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(osa_node_tree_admin) {
        transaction_id_t (*begin)(conf_object_t *NOTNULL obj,
                                  conf_object_t *initiator);
        void (*end)(conf_object_t *NOTNULL obj,
                    transaction_id_t transaction_id);
        node_id_t (*create)(conf_object_t *NOTNULL obj,
                            conf_object_t *NOTNULL mapper, attr_value_t props);
        node_id_t (*add)(conf_object_t *NOTNULL obj,
                         node_id_t parent_id, attr_value_t props);
        void (*update)(conf_object_t *NOTNULL obj, node_id_t node_id,
                       attr_value_t props);
        void (*remove)(conf_object_t *NOTNULL obj, node_id_t node_id);
        void (*event)(conf_object_t *NOTNULL obj, node_id_t node_id,
                      const char *event_name, attr_value_t event_data);
        void (*activate)(conf_object_t *NOTNULL obj, node_id_t node_id,
                         conf_object_t *NOTNULL cpu);
        void (*deactivate)(conf_object_t *NOTNULL obj, node_id_t node_id,
                           conf_object_t *NOTNULL cpu);
        cancel_id_t (*register_formatter)(
                conf_object_t *NOTNULL obj, node_id_t node_id,
                const char *NOTNULL key,
                bool recursive, attr_value_t (*formatter)(attr_value_t val));
        void (*unregister_formatter)(
                conf_object_t *NOTNULL obj, cancel_id_t node_id);
        void (*reset)(conf_object_t *NOTNULL obj,
                      node_id_t node_id, attr_value_t props);
        void (*set_property)(conf_object_t *NOTNULL obj, node_id_t node_id,
                             const char *key, attr_value_t value);
};

#define OSA_NODE_TREE_ADMIN_INTERFACE "osa_node_tree_admin"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_osa_node_tree_notification.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_osa_node_tree_notification.html:__rm_interface_osa_node_tree_notification">osa_node_tree_notification</a></h1>
<p>

<a id="__rm_interface_osa_node_tree_notification.html:osa_node_tree_notification"></a><a id="__rm_interface_osa_node_tree_notification.html:osa_node_tree_notification_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><a id="__rm_interface_osa_node_tree_notification.html:osa_node_tree_notification_interface_t2"></a>
<p>
   <a id="__rm_interface_osa_node_tree_notification.html:notify_createosa_node_tree_notification-interface-method"></a>
   <b><i>notify_create</i></b> and
   <a id="__rm_interface_osa_node_tree_notification.html:notify_destroyosa_node_tree_notification-interface-method"></a>
   <b><i>notify_destroy</i></b> register callbacks to be
   called when the node is created and destroyed, respectively. The
   <i>node_id</i> argument specifies for which node the callback should be
   installed. By specifying both the <i>node_id</i> and the
   <i>recursive</i> arguments it is possible to get notifications for all
   nodes in a subtree. It is safe to read the node with <b><i>get_node</i></b> in
   the <code>osa_node_tree_query</code> interface from within the callback
   function.
</p><p>
   Calling <b><i>notify_create</i></b> without <i>recursive</i> being set is
   only useful when used together with reverse execution, as only then can the
   node ID of a node that is to be created later be known. 
</p><p>
   <a id="__rm_interface_osa_node_tree_notification.html:notify_property_changeosa_node_tree_notification-interface-method"></a>
   <b><i>notify_property_change</i></b> registers a callback that is
   triggered when the given property <i>key</i> changes on the node (or any
   property, if <i>key</i> is nil). The callback function will receive the
   name of the property that was changed in the <i>key</i> argument and the
   old and new values of that property in the <i>old_val</i> and
   <i>new_val</i> arguments.
</p><p>
   <a id="__rm_interface_osa_node_tree_notification.html:notify_eventosa_node_tree_notification-interface-method"></a>
   <b><i>notify_event</i></b> register a callback <i>cb</i> to be called when
   an event occurs for the given <i>node_id</i>. If the
   <i>event_name</i> argument is nil the callback will be associated with
   all events, by providing a specific event name instead the callback will
   only trigger for that particular event type. The <i>event_data</i>
   argument passed to the callback contains tracker specific data associated
   with the event. See specific tracker documentation for details.
</p><p>
   If <i>recursive</i>, the callback will be triggered for the given node's
   descendants as well as the node itself.
</p><p>
   Most callbacks have <i>cpu</i> and <i>obj</i> arguments. The
   <i>cpu</i> argument specifies the processor that caused the event, but
   may be nil if the event was not caused by a processor. The <i>obj</i>
   will contain the object that implements the interface. The
   <i>node_id</i> argument passed to the callback specifies the node ID for
   the node that has been created, destroyed, modified or has triggered an
   event.
</p><p>
   <a id="__rm_interface_osa_node_tree_notification.html:notify_cpu_move_fromosa_node_tree_notification-interface-method"></a>
   <b><i>notify_cpu_move_from</i></b> and
   <a id="__rm_interface_osa_node_tree_notification.html:notify_cpu_move_toosa_node_tree_notification-interface-method"></a>
   <b><i>notify_cpu_move_to</i></b> register callbacks that are triggered when
   a processor moves from one node path to anotherbut only if either
   path lies in the subtree rooted at the given node <i>node_id</i>.
</p><p>
   Since a single update to the node tree can result in several different
   callbacks being triggered, reading nodes with <b><i>get_node</i></b> from a
   callback function may yield a result containing updates whose callbacks have
   not yet been run. For example, if two nodes change their <i>name</i>
   attributes simultaneously, the final state of both nodes may be visible to
   both property change callbacks. With
   <a id="__rm_interface_osa_node_tree_notification.html:notify_callbacks_doneosa_node_tree_notification-interface-method"></a>
   <b><i>notify_callbacks_done</i></b>, you can register a callback that will run
   when all other callbacks pertaining to a particular change in the node tree
   are finished.
</p><p>
   <b><i>notify_enable</i></b> register a callback <i>cb</i> to be called when
   the tracker framework is enabled.
</p><p>
   <b><i>notify_disable</i></b> register a callback <i>cb</i> to be called when
   the tracker framework is disabled.
</p><p>
   The functions that install callbacks return an integer ID. This ID can be
   passed to <b><i>cancel_notify</i></b>
   <a id="__rm_interface_osa_node_tree_notification.html:cancel_notifyosa_node_tree_notification-interface-method"></a> in
   order to uninstall the callback. In case of error in a notification function
   the returned cancel ID from that function will be 0.
</p><p>
   New callbacks registered inside a registered callback will not be called
   until the next transaction they trigger for. Canceled callbacks are canceled
   immediately.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(osa_node_tree_notification)
{
        cancel_id_t (*notify_create)(conf_object_t *NOTNULL obj,
                                     node_id_t node_id, bool recursive,
                                     void (*cb)(cbdata_call_t data,
                                                conf_object_t *obj,
                                                conf_object_t *cpu,
                                                node_id_t node_id),
                                     cbdata_register_t data);
        cancel_id_t (*notify_destroy)(conf_object_t *NOTNULL obj,
                                      node_id_t node_id, bool recursive,
                                      void (*cb)(cbdata_call_t data,
                                                 conf_object_t *obj,
                                                 conf_object_t *cpu,
                                                 node_id_t node_id),
                                      cbdata_register_t data);
        cancel_id_t (*notify_property_change)(
                conf_object_t *NOTNULL obj, node_id_t node_id,
                const char *key, bool recursive,
                void (*cb)(cbdata_call_t data, conf_object_t *obj,
                           conf_object_t *cpu, node_id_t node_id,
                           const char *key, attr_value_t old_val,
                           attr_value_t new_val),
                cbdata_register_t data);
        cancel_id_t (*notify_cpu_move_from)(
                conf_object_t *NOTNULL obj, node_id_t node_id,
                void (*cb)(cbdata_call_t data, conf_object_t *obj,
                           conf_object_t *cpu, attr_value_t node_path),
                cbdata_register_t data);
        cancel_id_t (*notify_cpu_move_to)(
                conf_object_t *NOTNULL obj, node_id_t node_id,
                void (*cb)(cbdata_call_t data, conf_object_t *obj,
                           conf_object_t *cpu, attr_value_t node_path),
                cbdata_register_t data);
        cancel_id_t (*notify_event)(
                conf_object_t *NOTNULL obj, node_id_t node_id,
                const char *event_name, bool recursive,
                void (*cb)(cbdata_call_t data, conf_object_t *obj,
                           conf_object_t *cpu, node_id_t node_id,
                           const char *event_name, attr_value_t event_data),
                cbdata_register_t data);
        cancel_id_t (*notify_enable)(
                conf_object_t *NOTNULL obj,
                void (*cb)(cbdata_call_t data, conf_object_t *obj),
                cbdata_register_t data);
        cancel_id_t (*notify_disable)(
                conf_object_t *NOTNULL obj,
                void (*cb)(cbdata_call_t data, conf_object_t *obj),
                cbdata_register_t data);
        void (*cancel_notify)(conf_object_t *NOTNULL obj,
                              cancel_id_t cancel_id);
        cancel_id_t (*notify_callbacks_done)(
                conf_object_t *NOTNULL obj, uint64 node_id,
                void (*cb)(cbdata_call_t data, conf_object_t *obj),
                cbdata_register_t data);
};

#define OSA_NODE_TREE_NOTIFICATION_INTERFACE "osa_node_tree_notification"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_osa_node_tree_query.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_osa_node_tree_query.html:__rm_interface_osa_node_tree_query">osa_node_tree_query</a></h1>
<p>

<a id="__rm_interface_osa_node_tree_query.html:osa_node_tree_query"></a><a id="__rm_interface_osa_node_tree_query.html:osa_node_tree_query_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><a id="__rm_interface_osa_node_tree_query.html:osa_node_tree_query_interface_t2"></a>
<p>
   <a id="__rm_interface_osa_node_tree_query.html:get_root_nodesosa_node_tree_query-interface-method"></a>
   <b><i>get_root_nodes</i></b> returns a list of node IDs for the root nodes.
</p><p>
   <a id="__rm_interface_osa_node_tree_query.html:get_nodeosa_node_tree_query-interface-method"></a>
   <b><i>get_node</i></b> returns a dictionary for a given node, containing all
   the node's properties; or nil if no such node exists.
</p><p>
   <a id="__rm_interface_osa_node_tree_query.html:get_current_nodesosa_node_tree_query-interface-method"></a>
   <b><i>get_current_nodes</i></b> returns the current node path of the given
   processor. That is, a list of node IDs of all nodes that are currently
   running on the processor, the first node being the root node, and every
   subsequent node a child of the node before it. If the tracker is not
   tracking the given processor, the return value is nil.
</p><p>

   <a id="__rm_interface_osa_node_tree_query.html:get_current_processorsosa_node_tree_query-interface-method"></a>
   <b><i>get_current_processors</i></b> returns a list of processors that are
   currently active on the given node, or one of it's descendants. The list
   will be empty if there is no active processor. Nil will be returned if the
   given node does not exist.
</p><p>
   <a id="__rm_interface_osa_node_tree_query.html:get_all_processorsosa_node_tree_query-interface-method"></a>
   <b><i>get_all_processors</i></b> returns a list of all processors that are
   available for the OS Awareness framework.
</p><p>
   <a id="__rm_interface_osa_node_tree_query.html:get_parentosa_node_tree_query-interface-method"></a>
   <b><i>get_parent</i></b> returns the node ID of the specified node's parent;
   or nil if the node has no parent.
</p><p>
   <a id="__rm_interface_osa_node_tree_query.html:get_childrenosa_node_tree_query-interface-method"></a>
   <b><i>get_children</i></b> returns a list of node IDs for the children of
   the specified node, this will be an empty list if the node does not have
   any children. The method will return nil if the node does not exist.
</p><p>
   The <b><i>get_formatted_properties</i></b> function returns a dictionary
   containing all properties for a node, formatted as strings or integers. It
   will return nil upon a failure. For example, a tracker could format the
   value of property <code>pid</code> to show the value in hexadecimal form.
</p><p>
   </p><pre class="jdocu_small">{'name': "Our OS", 'pid': "0x1234"}</pre><p>
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(osa_node_tree_query) {
        attr_value_t (*get_root_nodes)(conf_object_t *NOTNULL obj);
        attr_value_t (*get_node)(conf_object_t *NOTNULL obj, node_id_t node_id);
        attr_value_t (*get_current_nodes)(conf_object_t *NOTNULL obj,
                                          node_id_t base_id,
                                          conf_object_t *cpu);
        attr_value_t (*get_current_processors)(conf_object_t *NOTNULL obj,
                                               node_id_t node_id);
        attr_value_t (*get_all_processors)(conf_object_t *NOTNULL obj);
        conf_object_t *(*get_mapper)(conf_object_t *NOTNULL obj,
                                     node_id_t node_id);
        attr_value_t (*get_parent)(conf_object_t *NOTNULL obj,
                                   node_id_t node_id);
        attr_value_t (*get_children)(conf_object_t *NOTNULL obj,
                                     node_id_t node_id);
        attr_value_t (*get_formatted_properties)(conf_object_t *NOTNULL obj,
                                                 uint64 node_id);
};

#define OSA_NODE_TREE_QUERY_INTERFACE "osa_node_tree_query"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_osa_parameters.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_osa_parameters.html:__rm_interface_osa_parameters">osa_parameters</a></h1>
<p>

<a id="__rm_interface_osa_parameters.html:osa_parameters"></a><a id="__rm_interface_osa_parameters.html:osa_parameters_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><a id="__rm_interface_osa_parameters.html:osa_parameters_interface_t2"></a>
<p>
   Interface implemented by tracker components that support getting and setting
   their parameters.
</p><p>
   If either method fails it returns a (false, error-string) pair. If
   get_parameters succeed it returns (true, parameters). If set_parameters
   succeed it returns (true, nil).
</p><p>
   The parameters you pass to set_parameters and thare are returned by
   get_parameters should be a pair (tracker-kind, parameters-value), where
   tracker-kind is a string identifying the kind of tracker and parameters-value
   is the parameters for that kind of tracker. The parameters for an
   unconfigured tracker are (tracker-kind, nil).
</p><p>
   The <i>include_children</i> argument of <b><i>get_parameters</i></b> is
   only used for stacked tracker and specifies if parameters for guest trackers
   should be included or filtered out.
</p><p>
   The is_kind_supported method returns true if the tracker-kind in a parameter
   set is of the right kind for the tracker. This is no guarantee that setting
   these parameters will succeed. If the method returns false the parameters
   will not work.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(osa_parameters) {
        attr_value_t (*get_parameters)(conf_object_t *NOTNULL obj,
                                       bool include_children);
        attr_value_t (*set_parameters)(conf_object_t *NOTNULL obj,
                                       attr_value_t parameters);
        bool (*is_kind_supported)(conf_object_t *NOTNULL obj,
                                  const char *kind);
};

#define OSA_PARAMETERS_INTERFACE "osa_parameters"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Global Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_osa_tracker_component.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_osa_tracker_component.html:__rm_interface_osa_tracker_component">osa_tracker_component</a></h1>
<p>

<a id="__rm_interface_osa_tracker_component.html:osa_tracker_component"></a><a id="__rm_interface_osa_tracker_component.html:osa_tracker_component_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><a id="__rm_interface_osa_tracker_component.html:osa_tracker_component_interface_t2"></a>
<p>
   <a id="__rm_interface_osa_tracker_component.html:get_trackerosa_tracker_component-interface-method"></a>
   <b><i>get_tracker</i></b> returns the tracker object associated with the
   component or nil if no such tracker exists.
</p><p>
   <a id="__rm_interface_osa_tracker_component.html:get_trackerosa_tracker_component-interface-method2"></a>
   <b><i>get_mapper</i></b> returns the mapper object associated with the
   component or nil if no such mapper exists.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(osa_tracker_component) {
        conf_object_t *(*get_tracker)(conf_object_t *NOTNULL obj);
        conf_object_t *(*get_mapper)(conf_object_t *NOTNULL obj);
};

#define OSA_TRACKER_COMPONENT_INTERFACE "osa_tracker_component"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_osa_tracker_control.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_osa_tracker_control.html:__rm_interface_osa_tracker_control">osa_tracker_control</a></h1>
<p>

<a id="__rm_interface_osa_tracker_control.html:osa_tracker_control"></a><a id="__rm_interface_osa_tracker_control.html:osa_tracker_control_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><a id="__rm_interface_osa_tracker_control.html:osa_tracker_control_interface_t2"></a>
<p>
   <a id="__rm_interface_osa_tracker_control.html:enableosa_tracker_control-interface-method"></a>
   <b><i>enable</i></b> and
   <a id="__rm_interface_osa_tracker_control.html:disableosa_tracker_control-interface-method"></a>
   <b><i>disable</i></b> are called from the OS Awareness framework,
   for all trackers that have been set in the <i>top_trackers</i>
   attribute for the <b>node_tree</b> object, when OS Awareness is
   enabled or disabled, respectively.
</p><p>
   <a id="__rm_interface_osa_tracker_control.html:clear_stateosa_tracker_control-interface-method"></a>
   <b><i>clear_state</i></b> is called to clear the trackers state. The tracker
   should clear all its internal data and its data in the node tree when this
   is called.  This call can only occur while the tracker is disabled.
</p><p>
   <a id="__rm_interface_osa_tracker_control.html:add_processorosa_tracker_control-interface-method"></a>
   <b><i>add_processor</i></b> and
   <a id="__rm_interface_osa_tracker_control.html:remove_processorosa_tracker_control-interface-method"></a>
   <b><i>remove_processor</i></b> are called to add or remove a processor
   <i>cpu</i> to/from the tracker which the tracker should start/stop
   tracking. If the tracker is registered as a top level tracker these methods
   will be called by the OS Awareness framework for all processors available
   to the framework when it is enabled or disabled. If the tracker is a guest
   under a hypervisor the hypervisor should call these methods when a
   processor becomes available or unavailable to the guest.
   These functions should return true if a processor was successfully added or
   removed, otherwise the function should return false.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(osa_tracker_control) {
        void (*disable)(conf_object_t *NOTNULL obj);
        bool (*enable)(conf_object_t *NOTNULL obj);
        void (*clear_state)(conf_object_t *NOTNULL obj);
        bool (*add_processor)(conf_object_t *NOTNULL obj,
                              conf_object_t *NOTNULL cpu);
        bool (*remove_processor)(conf_object_t *NOTNULL obj,
                                 conf_object_t *NOTNULL cpu);
};

#define OSA_TRACKER_CONTROL_INTERFACE "osa_tracker_control"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Global Context for <b><i>enable</i></b>, <b><i>disable</i></b> and
   <b><i>clear_state</i></b>.
   Cell Context for <b><i>add_processor</i></b> and
   <b><i>remove_processor</i></b>.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_osa_tracker_state_admin.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_osa_tracker_state_admin.html:__rm_interface_osa_tracker_state_admin">osa_tracker_state_admin</a></h1>
<p>

<a id="__rm_interface_osa_tracker_state_admin.html:osa_tracker_state_admin"></a><a id="__rm_interface_osa_tracker_state_admin.html:osa_tracker_state_admin_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><a id="__rm_interface_osa_tracker_state_admin.html:osa_tracker_state_admin_interface_t2"></a>
<p>
   <a id="__rm_interface_osa_tracker_state_admin.html:beginosa_tracker_state_admin-interface-method"></a> <b><i>begin</i></b>
   is called from the tracker to start a transaction when modifying an entity in
   the node tree. The <i>tracker</i> argument specifies the tracker object
   for which the updates are done for.  The <i>initiator</i> argument
   specifies the processor that initiated the transaction, this can be nil if
   it was not a processor that caused the transaction to begin, when enabling
   the tracker as an example. The <i>initiator</i> is passed as an argument
   to the <b><i>tracker_updated</i></b> function in the
   <code>osa_mapper_admin</code> interface. The function returns an ID that
   is used when calling <b><i>end</i></b>.
</p><p>
   <a id="__rm_interface_osa_tracker_state_admin.html:endosa_tracker_state_admin-interface-method"></a> <b><i>end</i></b> is
   called from the tracker to end a transaction. This should be called at the
   end of a transaction when all entity modifications are done. The
   <i>transaction_id</i> argument should be the value returned from
   <b><i>begin</i></b> that started the transaction.  Stacked calls to
   <b><i>begin</i></b> and <b><i>end</i></b> are possible, then the transaction will
   be ended when the first <b><i>begin</i></b> is ended. The <b><i>begin</i></b>
   methods must be ended in the opposite order that they were called. For
   stacked calls to <b><i>begin</i></b> only the initiator of the first call to
   begin will be used.
</p><p>
   <a id="__rm_interface_osa_tracker_state_admin.html:addosa_tracker_state_admin-interface-method"></a>
   <b><i>add</i></b> adds a new entity with ID <i>entity_id</i> to the node
   tree. The new entity's attributes are set in the <i>attributes</i>
   argument, which is a dictionary.
</p><p>
   <a id="__rm_interface_osa_tracker_state_admin.html:removeosa_tracker_state_admin-interface-method"></a>
   <b><i>remove</i></b> removes the entity with ID <i>entity_id</i> for the
   current tracker from the node tree.
</p><p>
   <a id="__rm_interface_osa_tracker_state_admin.html:remove_allosa_tracker_state_admin-interface-method"></a>
   <b><i>remove_all</i></b> removes all entities for the current tracker from
   the node tree.
</p><p>
   <a id="__rm_interface_osa_tracker_state_admin.html:set_attributeosa_tracker_state_admin-interface-method"></a>
   <b><i>set_attribute</i></b> adds or updates an attribute <i>key</i> for
   the entity with ID <i>entity_id</i>. The new value is specified in
   <i>val</i>.
</p><p>
   <a id="__rm_interface_osa_tracker_state_admin.html:updateosa_tracker_state_admin-interface-method"></a>
   <b><i>update</i></b> updates or adds one or more attributes for the entity with
   ID <i>entity_id</i>. The <i>attributes</i> argument is a dictionary
   with the attributes to be updated.
</p><p>
   In order to remove a property, set the property value to nil when calling
   <b><i>update</i></b> or <b><i>set_attribute</i></b>.
</p><p>
   <a id="__rm_interface_osa_tracker_state_admin.html:eventosa_tracker_state_admin-interface-method"></a>
   <b><i>event</i></b> registers a new event, associated with the given
   <i>entity_id</i> argument. The <i>event_name</i> argument is the
   name of the event. The <i>event_data</i> argument is the data associated
   with the event and it is up to the responsible tracker to document its exact
   form. An event differes from other properties in the way that they are not
   persistent.
</p><p>
   Entity attributes have the limitation that the value of the attribute can
   not be of type data or dictionary. The keys of entity attributes must be of
   string type.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(osa_tracker_state_admin) {
        transaction_id_t (*begin)(conf_object_t *NOTNULL obj,
                                  conf_object_t *NOTNULL tracker,
                                  conf_object_t *initiator);
        void (*end)(conf_object_t *NOTNULL obj, transaction_id_t txid);
        void (*add)(conf_object_t *NOTNULL obj, entity_id_t entity_id,
                    attr_value_t attributes);
        void (*remove)(conf_object_t *NOTNULL obj, entity_id_t entity_id);
        void (*remove_all)(conf_object_t *NOTNULL obj);
        void (*set_attribute)(conf_object_t *NOTNULL obj, entity_id_t entity_id,
                              const char *key, attr_value_t val);
        void (*update)(conf_object_t *NOTNULL obj, entity_id_t entity_id,
                       attr_value_t attributes);
        void (*event)(conf_object_t *NOTNULL obj, entity_id_t entity_id,
                      const char *event_name, attr_value_t event_data);
};

#define OSA_TRACKER_STATE_ADMIN_INTERFACE "osa_tracker_state_admin"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_osa_tracker_state_notification.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_osa_tracker_state_notification.html:__rm_interface_osa_tracker_state_notification">osa_tracker_state_notification</a></h1>
<p>

<a id="__rm_interface_osa_tracker_state_notification.html:osa_tracker_state_notification"></a><a id="__rm_interface_osa_tracker_state_notification.html:osa_tracker_state_notification_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><a id="__rm_interface_osa_tracker_state_notification.html:osa_tracker_state_notification_interface_t2"></a>
<p>
   <a id="__rm_interface_osa_tracker_state_notification.html:subscribe_trackerosa_tracker_state_notification-interface-method"></a>
   <b><i>subscribe_tracker</i></b> is called to make <i>mapper</i> receive
   updates for entities of <i>tracker</i>. When such an update occurs, the
   function <b><i>tracker_updated</i></b> in interface
   <code>osa_mapper_admin</code> will be called.
</p><p>
   <a id="__rm_interface_osa_tracker_state_notification.html:unsubscribe_trackerosa_tracker_state_notification-interface-method"></a>
   <b><i>unsubscribe_tracker</i></b> cancels a subscription of entity
   updates to <i>mapper&gt;</i> that was started by
   <b><i>subscribe_tracker</i></b> for the specified <i>tracker</i>. A tracker
   without guest trackers does not need to call this, as it will be
   automatically done when the framework is disabled. However, a tracker with
   guest trackers, must call this function when a guest is removed.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(osa_tracker_state_notification) {
        void (*subscribe_tracker)(conf_object_t *NOTNULL obj,
                                  conf_object_t *NOTNULL mapper,
                                  conf_object_t *NOTNULL tracker);
        void (*unsubscribe_tracker)(conf_object_t *NOTNULL obj,
                                    conf_object_t *NOTNULL mapper,
                                    conf_object_t *NOTNULL tracker);
};

#define OSA_TRACKER_STATE_NOTIFICATION_INTERFACE \
        "osa_tracker_state_notification"
</pre><p>
</p><p>
    
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_osa_tracker_state_query.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_osa_tracker_state_query.html:__rm_interface_osa_tracker_state_query">osa_tracker_state_query</a></h1>
<p>

<a id="__rm_interface_osa_tracker_state_query.html:osa_tracker_state_query"></a><a id="__rm_interface_osa_tracker_state_query.html:osa_tracker_state_query_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><a id="__rm_interface_osa_tracker_state_query.html:osa_tracker_state_query_interface_t2"></a>
<p>
   <a id="__rm_interface_osa_tracker_state_query.html:get_entitiesosa_tracker_state_query-interface-method"></a>
   <b><i>get_entities</i></b> returns a dictionary of entities that are stored for
   <i>tracker</i>. The dictionary maps entity id to properties, which in
   turn is a dictionary, mapping property name to property value. Returns nil
   if <i>tracker</i> is not known.
</p><p>
   <a id="__rm_interface_osa_tracker_state_query.html:get_entityosa_tracker_state_query-interface-method"></a>
   <b><i>get_entity</i></b> returns the properties for the given entity
   <i>id</i> and <i>tracker</i>, as a dictionary that maps property
   name to property value. Returns nil if the entity can not be found.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(osa_tracker_state_query) {
        attr_value_t (*_deprecated)(conf_object_t *NOTNULL obj);
        attr_value_t (*get_entities)(conf_object_t *NOTNULL obj,
                                     conf_object_t *NOTNULL tracker);
        attr_value_t (*get_entity)(conf_object_t *NOTNULL obj,
                                   conf_object_t *NOTNULL tracker,
                                   entity_id_t id);
};

#define OSA_TRACKER_STATE_QUERY_INTERFACE "osa_tracker_state_query"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_preference.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_preference.html:__rm_interface_preference">preference</a></h1>
<p>

<a id="__rm_interface_preference.html:preference"></a><a id="__rm_interface_preference.html:preference_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem"><a id="__rm_interface_preference.html:preference_interface_t2"></a>
   <a id="__rm_interface_preference.html:get_preference_for_module_key"></a>
   <a id="__rm_interface_preference.html:set_preference_for_module_key"></a>
<p>
   The preference interface is implemented by objects that store preferences
   on the behalf of other modules. Preferences are settings that are persistent
   between sessions. Typically there is a single object implementing the
   preference interface.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(preference) {
        attr_value_t
        (*get_preference_for_module_key)(conf_object_t *NOTNULL prefs,
                                         const char *NOTNULL module,
                                         const char *NOTNULL key);

        void (*set_preference_for_module_key)(conf_object_t *NOTNULL prefs,
                                              attr_value_t value,
                                              const char *NOTNULL module,
                                              const char *NOTNULL key);
};

#define PREFERENCE_INTERFACE "preference"
</pre><p>
</p><p>

   <b>get_preference_for_module_key</b> is called to retrieve a preference for
   a specified <i>module</i> and <i>key</i>. If no value has been set
   an <i>invalid</i> attribute is returned.
</p><p>
   <b>set_preference_for_module_key</b> is called to store a preference for
   a specified <i>module</i> and <i>key</i>. Any attribute type is
   allowed for the value, including nested types. However, the value may no
   contain any invalid attributes.
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Global Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_probe.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_probe.html:__rm_interface_probe">probe</a></h1>
<p>

<a id="__rm_interface_probe.html:probe"></a><a id="__rm_interface_probe.html:probe_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This interface defines a probe in the system. A probe is a mechanism that
   lets a model expose values of interest to a user. By using this interface,
   generic tools can extract these values and present them in different forms,
   like tables and graphs. A probe should always have a meaningful value that
   can be read at any time during the simulation.
<p>
   Probes should be used for user observable values and are not intended for
   model to model communication.
</p><p>
   The <b><i>properties()</i></b> method is typically called once for each tool
   or use-case to get information about the probe. It should return a key/value
   <code>attr_value_t</code> list, i.e., list of lists of two values, with
   probe specific properties. The first value of the inner list represents the
   property key as an Sim_Val_Integer using the enum <code>probe_key_t</code>
   type, and the second value is a key specific data item described below. The
   <code>probe_key_t</code> is defined as:
</p><p>
   
</p><pre class="jdocu_small">typedef enum {
        Probe_Key_Kind = 0,                  /* Identifier of the probe */
        Probe_Key_Name = 0,                  /* Old name of Probe_Key_Kind,
                                                kept for compatibility */

        Probe_Key_Type = 1,                  /* string, any of: {
                                                "int", "float, "fraction",
                                                "histogram", "int128", "string"
                                                } */
        Probe_Key_Categories = 2,            /* list of strings */
        Probe_Key_Cause_Slowdown = 3,        /* bool */

        Probe_Key_Owner_Object = 4,          /* object: owner object */

        Probe_Key_Display_Name = 5,          /* string: short narrow name */
        Probe_Key_Description = 6,           /* string */

        Probe_Key_Float_Percent = 7,
        Probe_Key_Float_Decimals = 8,
        Probe_Key_Metric_Prefix = 9,
        Probe_Key_Unit = 10,
        Probe_Key_Binary_Prefix = 11,
        Probe_Key_Time_Format = 12,
        Probe_Key_Width = 13,

        Probe_Key_Value_Notifier = 14,

        Probe_Key_Aggregates = 17,   /* Defines new probes which aggregate
                                        over this probe:
                                        [list of [list properties]]
                                        Invalid for Type: "string"
                                     */
        Probe_Key_Aggregate_Scope = 18, /* Aggregate over all probes in the
                                           cells or all probes in the system.
                                           String and of ["global", "cell"] */
        Probe_Key_Aggregate_Function = 19, /* How the aggregation should be
                                              done:
                                              "sum",
                                              "weighted-arith-mean",
                                              - only fractions
                                           */
        Probe_Key_Definition = 20,         /* string: how the probe is
                                              calculated */
} probe_key_t;</pre><p>

</p><p>
   The <b><i>value()</i></b> method should return the data for the probe as an
   <code>attr_value_t</code> in accordance of how the property type has been
   defined. This method is called each time a tool/user wants to read the latest
   probe value.
</p><p>
   The property keys are describes here as follows:
</p><p>
   </p><dl><dt id="__rm_interface_probe.html:dt:probe_key_kind"><a href="#__rm_interface_probe.html:dt:probe_key_kind"><b><code>Probe_Key_Kind</code></b></a></dt><dd>Sets the kind of the probe, as a string (Sim_Val_String).
   The probe-kinds are what uniquely define the probes in the system.
<p>
   There can be many probes associated with the same kind,
   but they should all represent the same type of measured data.
</p><p>
   The kind should be named so it is humanly possible to understand what
   you get back when you read it.
</p><p>
   To avoid conflicts, the kind should be an hierarchical name where each level
   is separated with a dot. Probes falling into the same domain should have
   logical names according to this. Currently, there are some defined names on
   the first level that can be used to build the hierarchy. Among them are:
   <i>cpu.</i> that collects probes related to a CPU, <i>dev.</i> that collects
   probes for devices, <i>cell.</i> that collects probes related to cells,
   <i>host.</i> collects probes related to the host environment, and
   <i>sim.</i> that collects probes having to do with the overall simulation
   environment.
</p><p>
   Some examples, include: <i>cpu.cycles</i>,
   <i>cpu.exec_mode.jit_steps</i>, <i>dev.io_access_count</i>,
   <i>cell.steps</i>, <i>host.swap.used</i>, and <i>sim.slowdown</i>.
</p><p>
   Several objects implementing this interface can use the same probe-kind,
   for similar probe values. The probe's unique identifier is a string
   containing the object name then a colon, followed by the probe-kind, e.g.,
   "board.mb.cpu0.cpu[0][0]:cpu.cycles".
</p><p>
   </p></dd><dt id="__rm_interface_probe.html:dt:probe_key_display_name"><a href="#__rm_interface_probe.html:dt:probe_key_display_name"><b><code>Probe_Key_Display_Name</code></b></a></dt><dd>Sets a display name for the probe as a string (Sim_Val_String). This is
   a more human friendly name than the probe name, and a tool can use this name
   in table headings or graph legends. </dd><dt id="__rm_interface_probe.html:dt:probe_key_type"><a href="#__rm_interface_probe.html:dt:probe_key_type"><b><code>Probe_Key_Type</code></b></a></dt><dd>Sets the type of the probe as a string (Sim_Val_String). The following
   types are defined: "int", "float", "string", "fraction", "int128" and
   "histogram". The <code>attr_value_t</code> value that should be returned by
   the value method for these types are as follows:
<p>
   For the int type, an <code>attr_value_t</code> of type Sim_Val_Integer
   should be returned.
</p><p>
   For the float type, return a Sim_Val_Floating value.
</p><p>
   The string type is returned by a Sim_Val_String value. The string typically
   represents some momentarily state. Due to nature of a string, a tool cannot do
   any calculation on the probe value, only show the current string content.
</p><p>
   The fraction type should use a <code>attr_value_t</code> list of two
   Sim_Val_Integer or Sim_Val_Floating values. This represent a mathematical
   fraction value, where the first one is the numerator and and the second
   value is the denominator value. Note however that a float value can be used
   for both of them. To get the proper value for this probe the tool/user
   should divide the numerator with the denominator. Using fraction makes it
   possible for the tool to calculate a mean value for this probe between any
   point in time where the probe was read, e.g., say you have a probe that
   reads the frequency of a simulated processor that varies over time. Then
   this probe can be defined as a fraction between the cycle count and the
   elapsed virtual time (cycles/time = frequency). If the tool saves the cycle
   difference and the time difference between to points in time, it can
   calculate the mean frequency between those point by dividing the
   differences.
</p><p>
   For very large numbers the int128 type can be used, the type is represented
   as a <i>attr_value_t</i> list of two value; the high 64-bit number
   followed by the low 64-bit number.
</p><p>
   The histogram type is represented by a <code>attr_value_t</code> list of
   lists of two values. Where the inner list is used as a tuple of a named
   group as a Sim_Val_String, and its corresponding value as a Sim_Val_Integer
   or Sim_Val_Floating. A tool can then display an histogram of these groups
   and/or calculate the difference between two histograms over time and display
   that.</p></dd>.

   <dt id="__rm_interface_probe.html:dt:probe_key_categories"><a href="#__rm_interface_probe.html:dt:probe_key_categories"><b><code>Probe_Key_Categories</code></b></a></dt><dd>The key is a list of string that defines some categories for the
   probe. This information can be used to search for probes of a specific use
   case.</dd><dt id="__rm_interface_probe.html:dt:probe_key_cause_slowdown"><a href="#__rm_interface_probe.html:dt:probe_key_cause_slowdown"><b><code>Probe_Key_Cause_Slowdown</code></b></a></dt><dd>The value for this key is a Sim_Val_Boolean. True means that using the
   probe can cause a significant slowdown of the simulation. False means it does
   not cause any particular slowdown.</dd><dt id="__rm_interface_probe.html:dt:probe_key_owner_object"><a href="#__rm_interface_probe.html:dt:probe_key_owner_object"><b><code>Probe_Key_Owner_Object</code></b></a></dt><dd>The value for this key is a Sim_Val_Object that should be regarded as
   the owner of the probe instead of the object that implements this interface
   (which is default). This can be useful if some other objects implements
   functionality for the main object.</dd><dt id="__rm_interface_probe.html:dt:probe_key_description"><a href="#__rm_interface_probe.html:dt:probe_key_description"><b><code>Probe_Key_Description</code></b></a></dt><dd>The value for this key is a Sim_Val_String that documents this
   probe in details.</dd><dt id="__rm_interface_probe.html:dt:probe_key_definition"><a href="#__rm_interface_probe.html:dt:probe_key_definition"><b><code>Probe_Key_Definition</code></b></a></dt><dd>"Function" definition string, explaining how the probe is
   being calculated out from other probes. This is automatically created for
   probe aggregates and derivatives. Default is an empty string.</dd><dt id="__rm_interface_probe.html:dt:probe_key_float_decimals"><a href="#__rm_interface_probe.html:dt:probe_key_float_decimals"><b><code>Probe_Key_Float_Decimals</code></b></a></dt><dd>The value for this key is a Sim_Val_Integer that sets the preferred
   number of decimals of this is float probe when a value is displayed.</dd><dt id="__rm_interface_probe.html:dt:probe_key_float_percent"><a href="#__rm_interface_probe.html:dt:probe_key_float_percent"><b><code>Probe_Key_Float_Percent</code></b></a></dt><dd>The value for this key is a Sim_Val_Boolean that sets the preferred
   representation of a float probe as a percent representation, e.g., a value
   of 0.176 will be displayed as 17.6% if the number of decimals are one.</dd><dt id="__rm_interface_probe.html:dt:probe_key_metric_prefix"><a href="#__rm_interface_probe.html:dt:probe_key_metric_prefix"><b><code>Probe_Key_Metric_Prefix</code></b></a></dt><dd>The value for this key is a Sim_Val_String describing a unit name. This
   sets the preferred representation of a float probe to be displayed with a
   metric prefix for the unit given. Supported metric prefixes are: k, M, G, T,
   P, E, Z, Y, for values &gt; 1 and m, , n, p, f, a, z, y for values &lt;
   1. For example if the unit is set to "s" (seconds) and the float value is
   0.0000347, then the displayed representation should be "34.7 s". To
   omit the unit in the output use the empty string, "", as the unit. If the
   value is outside the prefix ranges, an scientific E notation will be used.
   </dd><dt id="__rm_interface_probe.html:dt:probe_key_binary_prefix"><a href="#__rm_interface_probe.html:dt:probe_key_binary_prefix"><b><code>Probe_Key_Binary_Prefix</code></b></a></dt><dd>The value for this key is a Sim_Val_String describing a unit name. This
   sets the preferred representation of an integer probe to be displayed with a
   binary prefix for the unit given. Supported prefixes are: ki, Mi, Gi, Ti,
   Pi, Ei, Zi, and Yi. For example if the unit is set to "B" (representing
   bytes), and the integer value is 10485760 (10*1024*1024), then the displayed
   representation should be "10 MiB".
   .</dd><dt id="__rm_interface_probe.html:dt:probe_key_unit"><a href="#__rm_interface_probe.html:dt:probe_key_unit"><b><code>Probe_Key_Unit</code></b></a></dt><dd>The value for this key is a Sim_Val_String that sets the unit for the
   value. A tool can use this to display the unit for the value.</dd><dt id="__rm_interface_probe.html:dt:probe_key_time_format"><a href="#__rm_interface_probe.html:dt:probe_key_time_format"><b><code>Probe_Key_Time_Format</code></b></a></dt><dd>The value for this key is a Sim_Val_Boolean that sets the preferred
   representation for a float value to a time format, hh:mm:ss.d, where h is
   hours, m minutes, s seconds, and d is fractions of a seconds. The raw value
   returned by the value method is the number of seconds. The
   Probe_Key_Float_Decimals key/value pair controls the number of digits in the
   fraction. If the number of seconds represents more than 99 hours, it should
   continue adding digits for the hours, e.g., 100:44:10.123</dd><dt id="__rm_interface_probe.html:dt:probe_key_width"><a href="#__rm_interface_probe.html:dt:probe_key_width"><b><code>Probe_Key_Width</code></b></a></dt><dd>The value for this key is a Sim_Val_Integer that sets the preferred
   width of a probe value in characters. This can be used to determine the best
   width of columns in a table tool, for instance.</dd><dt id="__rm_interface_probe.html:dt:probe_key_value_notifier"><a href="#__rm_interface_probe.html:dt:probe_key_value_notifier"><b><code>Probe_Key_Value_Notifier</code></b></a></dt><dd>The value for this key is a Sim_Val_String that describes a notifier
   that is triggered when the value changes. This can be used by a tool to
   track all changes of the value. For performance reasons the value should be
   changes infrequently.</dd><dt id="__rm_interface_probe.html:dt:probe_key_global_sum"><a href="#__rm_interface_probe.html:dt:probe_key_global_sum"><b><code>Probe_Key_Global_Sum</code></b></a></dt><dd>Deprecated, use <code>Probe_Key_Aggregates</code> instead.</dd><dt id="__rm_interface_probe.html:dt:probe_key_cell_sum"><a href="#__rm_interface_probe.html:dt:probe_key_cell_sum"><b><code>Probe_Key_Cell_Sum</code></b></a></dt><dd>Deprecated, use <code>Probe_Key_Aggregates</code> instead.</dd><dt id="__rm_interface_probe.html:dt:probe_key_aggregates"><a href="#__rm_interface_probe.html:dt:probe_key_aggregates"><b><code>Probe_Key_Aggregates</code></b></a></dt><dd>Defines lists of new probes which are aggregates of the probe defined.
   Each list-element defines a new probe, specified as a list of the key-value
   properties for the aggregate probe. All properties are inherited from
   the probe being aggregated, except the new name of the aggregate probe which
   must be defined. Probe keys can be redefined if they appear in the
   aggregate scope. For example, it is advisable to change the description
   making it clear what value that is being returned by the aggregate.
<p>
   Only in the aggregate scope, the <code>Probe_Key_Aggregate_Scope</code>
   and <code>Probe_Key_Aggregate_Function</code> key-value pairs are used to further
   define how the aggregation is done.
   Note that aggregates depend on the the type of the underlying probe.
   Some probe types can only be aggregated with certain functions.
   </p></dd><dt id="__rm_interface_probe.html:dt:probe_key_aggregate_scope"><a href="#__rm_interface_probe.html:dt:probe_key_aggregate_scope"><b><code>Probe_Key_Aggregate_Scope</code></b></a></dt><dd>Defines the scope for the aggregate probe. That is, which objects that
   implements the probe, should be part of the aggregation.
   Valid values are "cell" or "global". Default is "global",
   which means that all objects which implements the probe will be part of
   the aggregate and put in the singleton owner object, such as the 'sim' or
   'host' objects.
<p>
   Cell-aggregates are put under the available cell objects
   and will aggregate the probe which belongs to the respective cell object.
   </p></dd><dt id="__rm_interface_probe.html:dt:probe_key_aggregate_function"><a href="#__rm_interface_probe.html:dt:probe_key_aggregate_function"><b><code>Probe_Key_Aggregate_Function</code></b></a></dt><dd>Defines how the aggregate should be generated.
   Valid values are "sum", "min", "max", "arith-mean", "weighted-arith-mean"
   and "median". Default is "sum".
<p>
   For probes of the fraction type, if any denominator contains a zero value
   (division by zero), the calculated value is undefined and [0, 0] is
   returned. This applies to all fraction aggregates except weighted-arith-mean,
   where the zero denominator can be handled.
</p><p>
   </p></dd><dt id="__rm_interface_probe.html:dt:sum"><a href="#__rm_interface_probe.html:dt:sum"><b><code>sum</code></b></a></dt><dd>All probe values are summed together. Not supported on "string" probes.</dd><dt id="__rm_interface_probe.html:dt:min"><a href="#__rm_interface_probe.html:dt:min"><b><code>min</code></b></a></dt><dd>The lowest value among the probe values is returned. Not supported on "string"
   and "histogram" probes.
   For fraction-probes, if any denominator contains a zero value, the calculated sum
   returned is [0, 0].
   </dd><dt id="__rm_interface_probe.html:dt:max"><a href="#__rm_interface_probe.html:dt:max"><b><code>max</code></b></a></dt><dd>The highest value among probe values is returned. Not supported on "string"
   and "histogram" probes.</dd><dt id="__rm_interface_probe.html:dt:arith-mean"><a href="#__rm_interface_probe.html:dt:arith-mean"><b><code>arith-mean</code></b></a></dt><dd>The arithmetic mean is calculated for all the probe values.
   Not supported on "string" and "histogram" probes.</dd><dt id="__rm_interface_probe.html:dt:weighted-arith-mean"><a href="#__rm_interface_probe.html:dt:weighted-arith-mean"><b><code>weighted-arith-mean</code></b></a></dt><dd>Only supported in fraction type probes.
   The denominators are used as weights.
<p>
   Using these weights implies that the weighted arithmetic mean can be
   calculated by adding all numerators and denominators, producing a new
   fraction of these sums.
</p><p>
   For example, when calculating the mean instruction per cycles (IPC)
   on all processors (where the IPC per processor is represented as a
   fraction: instructions / cycles).
   With two processors having [20/30] and [40/50], the total IPC
   becomes [(20+40)/(30+50)] or [60/80] and the IPC value of 0.75.
   </p></dd><dt id="__rm_interface_probe.html:dt:median"><a href="#__rm_interface_probe.html:dt:median"><b><code>median</code></b></a></dt><dd>The median among the probe values is returned.
   Not supported on "fraction", "string" and "histogram" probes.</dd><dt id="__rm_interface_probe.html:dt:object-histogram"><a href="#__rm_interface_probe.html:dt:object-histogram"><b><code>object-histogram</code></b></a></dt><dd>A histogram probe is created using the probe-owner-objects as key
   and their probe-values value. The type of this aggregate probe
   must be set to "histogram".
   Only supported on "int" and "float" probes types.</dd><dt id="__rm_interface_probe.html:dt:class-histogram"><a href="#__rm_interface_probe.html:dt:class-histogram"><b><code>class-histogram</code></b></a></dt><dd>Similar to the object-histogram, but here the histogram uses
   the classname of the owner-object as key, and the value is the
   sum of the probe-values with the same class. The type of this aggregate
   probe must be set to "histogram".
   Only supported on "int" and "float" probes types.</dd></dl></dd></dl><p>All key/value pairs except the Probe_Key_Kind and Probe_Key_Type are
   optional.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(probe) {
        attr_value_t (*value)(conf_object_t *obj);
        attr_value_t (*properties)(conf_object_t *obj);
};
#define PROBE_INTERFACE "probe"
</pre><p>
</p><p>
   

</p><dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Global Context for all methods.
   
</dd>
<p></p></section><section class="page" id="__rm_interface_probe_array.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_probe_array.html:__rm_interface_probe_array">probe_array</a></h1>
<p>

<a id="__rm_interface_probe_array.html:probe_array"></a><a id="__rm_interface_probe_array.html:probe_array_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This interface is similar to the <code>probe_index</code> interface, except
  that an additional <b><i>all_values()</i></b> method returns an
  <code>attr_value_t</code> list of values as individually returned when calling
  <b><i>value(idx)</i></b> on each indexed probe. Using <b><i>all_values()</i></b>
  instead of looping over <b><i>value(idx)</i></b> can provide a significant
  improvement in performance, depending on the number of probes whose values
  need to be read, starting from a couple of probes.
  The <i>probe_sampler</i> objects, provided in the <i>probe-monitor</i>
  extension, make use of the <b><i>all_values()</i></b> method to boost their
  performance when sampling probes implemented with the <code>probe_array</code>
  interface. 
<p>
  </p><pre class="jdocu_small">SIM_INTERFACE(probe_array) {
        int (*num_indices)(conf_object_t *obj);
        attr_value_t (*value)(conf_object_t *obj, int idx);
        attr_value_t (*all_values)(conf_object_t *obj);
        attr_value_t (*properties)(conf_object_t *obj, int idx);
};
#define PROBE_ARRAY_INTERFACE "probe_array"
</pre><p>
</p><p>
  
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Global Context for all methods.
  
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_probe_index.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_probe_index.html:__rm_interface_probe_index">probe_index</a></h1>
<p>

<a id="__rm_interface_probe_index.html:probe_index"></a><a id="__rm_interface_probe_index.html:probe_index_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This interface is similar to the <code>probe</code> interface, except that
  the indexed version allows multiple probes to be defined with a single
  interface. The same index corresponds to the same probe for <b><i>value</i></b>
  and <b><i>properties</i></b> methods. The amount of probes that the interfaces
  supports is returned through the <b><i>num_indices()</i></b> method, which should
  be static.
<p>
  </p><pre class="jdocu_small">SIM_INTERFACE(probe_index) {
        int (*num_indices)(conf_object_t *obj);
        attr_value_t (*value)(conf_object_t *obj, int idx);
        attr_value_t (*properties)(conf_object_t *obj, int idx);
};
#define PROBE_INDEX_INTERFACE "probe_index"
</pre><p>
</p><p>
  
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Global Context for all methods.
  
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_probe_sampler_cache.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_probe_sampler_cache.html:__rm_interface_probe_sampler_cache">probe_sampler_cache</a></h1>
<p>

<a id="__rm_interface_probe_sampler_cache.html:probe_sampler_cache"></a><a id="__rm_interface_probe_sampler_cache.html:probe_sampler_cache_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This interface is implemented by the singleton <b>probes</b>
  object. The interface is expected to be used by either probe-samplers
  (<b><i>enable</i></b>, <b><i>disable</i></b> or by a probe
  which supports caching (<b><i>get_generation_id</i></b>).
<p>
  When a probe-sampler calls the <b><i>enable</i></b> method,
  caching can start. Caching depends on a generation id, this is
  automatically increased by <b><i>enable</i></b>.
</p><p>
  With caching enabled, probes can return the previous value back,
  avoiding expensive calculation, if they are read multiple times
  (either directly, or indirectly from other probes). It can also be
  used to avoid probe values to return a slightly different value the
  next time in the same sample, such as wallclock time.
</p><p>
  A probe which wants to use caching needs to call the
  <b><i>get_generation_id</i></b> method. As long as the generation id is the same
  as the last time the probe-value was returned, the same probe-value can be
  returned. Otherwise a new value needs to be returned.
  Generation id zero, is special, it means that caching is not currently enabled.
</p><p>
  When sampling is finished the probe_sampler calls the <b><i>disable</i></b>
  which will cause the generation id zero to be returned until the
  next sample begins again.
</p><p>
  </p><pre class="jdocu_small">SIM_INTERFACE(probe_sampler_cache) {
        void (*enable)(conf_object_t *obj);
        void (*disable)(conf_object_t *obj);

        uint64 (*get_generation)(conf_object_t *obj);
};
#define PROBE_SAMPLER_CACHE_INTERFACE "probe_sampler_cache"
</pre><p>
</p><p>
  
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Global Context for all methods.
  
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_probe_subscribe.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_probe_subscribe.html:__rm_interface_probe_subscribe">probe_subscribe</a></h1>
<p>

<a id="__rm_interface_probe_subscribe.html:probe_subscribe"></a><a id="__rm_interface_probe_subscribe.html:probe_subscribe_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This is an optional additional probe interface.
  This interface should  be implemented to prevent any slowdown or unwanted
  side-effects if there are no listener on the probe.
  The <b><i>subscribe()</i></b> method should increment a reference count on
  how many subscribers there are, and do any kind of preparation to
  activate the probe when it is being used.
<p>
  Similarly, the <b><i>unsubscribe()</i></b> method should decrement the
  reference count and disable the feature when there is no subscribers
  left.
</p><p>
  The <b><i>num_subscribers()</i></b> method should return the current
  reference count.
</p><p>
  </p><pre class="jdocu_small">SIM_INTERFACE(probe_subscribe) {
        void (*subscribe)(conf_object_t *obj);
        void (*unsubscribe)(conf_object_t *obj);
        int  (*num_subscribers)(conf_object_t *obj);
};
#define PROBE_SUBSCRIBE_INTERFACE "probe_subscribe"
</pre><p>
</p><p>
  
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Global Context for all methods.
  
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_recorder_v2.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_recorder_v2.html:__rm_interface_recorder_v2">recorder_v2</a></h1>
<p>

<a id="__rm_interface_recorder_v2.html:recorder_v2"></a><a id="__rm_interface_recorder_v2.html:recorder_v2_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>recorder_v2</code> interface is implemented by the recorder, and
   can be used by any object interacting with the outside world in order to
   make re-runs of the same simulation behave identically. This is a
   requirement for reverse execution to work. Objects using this interface must
   implement the <code>recorded</code> interface themselves.
<p>
   An object uses it by calling the <b><i>record</i></b> method with itself and
   the data it wishes to record as parameters. The recorder will then save
   the data and call the <b><i>input</i></b> method in the <code>recorded</code>
   interface on the object.
</p><p>
   The <b><i>playback</i></b> method returns whether the recorder is currently
   playing back recorded data. It may be used by the object to determine if
   output to the outside world should be dropped or not.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(recorder_v2) {
        void (*record)(conf_object_t *NOTNULL obj,
                       conf_object_t *NOTNULL sender, bytes_t data);
        bool (*playback)(conf_object_t *NOTNULL obj);
};
#define RECORDER_V2_INTERFACE "recorder_v2"
</pre><p>
</p><p>
   
   The <code>recorded</code> interface is implemented by objects that wish to
   use the <code>recorder_v2</code> interface.
</p><p>
   The <b><i>input</i></b> method is called with data that has been recorded.
   The <i>playback</i> parameter is set if the data came from a
   previous recording, and clear if the data came directly from a call to
   <b><i>record</i></b> in <code>recorder_v2</code> with live data.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(recorded) {
        void (*input)(conf_object_t *NOTNULL obj, bytes_t data, bool playback);
};
#define RECORDED_INTERFACE "recorded"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_register_breakpoint.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_register_breakpoint.html:__rm_interface_register_breakpoint">register_breakpoint</a></h1>
<p>

<a id="__rm_interface_register_breakpoint.html:register_breakpoint"></a><a id="__rm_interface_register_breakpoint.html:register_breakpoint_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This is an optional CPU interface
   allowing the execution to break upon any register change, both explicit by
   the software and implicit changes by the model itself.
<p>
   The <b><i>add_breakpoint</i></b> function adds a new breakpoint. The
   <i>reg_name</i> is the register name. When register becomes the
   <i>value</i>, simulator will stop. The <i>break_upon_change</i>
   means whether simulator should stop upon change of the register value. In
   this case, <i>value</i> is not used. The <i>mask</i> can be used
   when only certain bits are of interest.
</p><p>
   The <b><i>remove_breakpoint</i></b> function removes a breakpoint with a given
   id. If the id is -1, then all breakpoints are removed.
</p><p>
   The function <b><i>get_breakpoints</i></b> returns a list of defined
   breakpoints. Each breakpoint in the list is described by a tuple:
   (breakpoint_id, register_name, break_value, mask). If the breakpoint is
   triggered upon every register value change, then break_value is NIL.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(register_breakpoint) {
        int (*add_breakpoint)(conf_object_t *obj, const char *reg_name,
                              uint64 value, uint64 mask,
                              bool break_upon_change);
        bool (*remove_breakpoint)(conf_object_t *obj, int id);
        attr_value_t (*get_breakpoints)(conf_object_t *obj);
};

#define REGISTER_BREAKPOINT_INTERFACE "register_breakpoint"
</pre><p>
 
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Global Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_screenshot.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_screenshot.html:__rm_interface_screenshot">screenshot</a></h1>
<p>

<a id="__rm_interface_screenshot.html:screenshot"></a><a id="__rm_interface_screenshot.html:screenshot_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>screenshot</code> interface facilitates storing screenshots. It
   is implemented by the graphics console.
<p>
   All screenshots store current screen data, using 24-bit RGB pixel format.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(screenshot) {
        bool (*save_png)(conf_object_t *NOTNULL obj, const char *filename);
        bool (*save_bmp)(conf_object_t *NOTNULL obj, const char *filename);
};
#define SCREENSHOT_INTERFACE "screenshot"
</pre><p>
 
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Global Context
   for all methods
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_serial_console_frontend.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_serial_console_frontend.html:__rm_interface_serial_console_frontend">serial_console_frontend</a></h1>
<p>

<a id="__rm_interface_serial_console_frontend.html:serial_console_frontend"></a><a id="__rm_interface_serial_console_frontend.html:serial_console_frontend_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>serial_console_frontend</code> interface can be implemented by
   devices that want to retrieve the character stream passing through the text
   console. Objects implementing this interface can be attached to a text
   console and will receive output in the same way as a telnet connection.
<p>
   </p><pre class="jdocu_small">SIM_INTERFACE(serial_console_frontend) {
        void (*write)(conf_object_t *NOTNULL obj, uint8 value);
};
#define SERIAL_CONSOLE_FRONTEND_INTERFACE "serial_console_frontend"
</pre><p>
</p><p>
   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Cell Context
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_table.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_table.html:__rm_interface_table">table</a></h1>
<p>

<a id="__rm_interface_table.html:table"></a><a id="__rm_interface_table.html:table_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The table interface can be implemented by objects holding data
   which can be presented in a table by the user interface (through
   Simics CLI command outputs, Eclipse etc.) 
<p>
   By properly implementing the table interface, less object specific code
   is needed to provide the data to the user. Generic Simics commands
   (associated with the table interface) allows the data to sorted on 
   the desired column and printed in a uniform way. 
   Similarly, the data can be exported to a comma separated value (.csv)
   file, making it possible to process the result in a spreadsheet program.
</p><p>
   The <b><i>data()</i></b> method returns the data as an
   <code>attr_value_t</code> array where the outer list contains each row and
   the inner list contains the columns for that row. The number of columns in
   each row must be exactly the same. The data only holds the actual data, not
   the headers for each column, which instead is specified in the
   <b><i>properties()</i></b> method. The data can be unsorted, it is up to the
   user of the interface to sort it in a suitable way.
</p><p>
   The data itself is sufficient for producing a table, but to customize
   the table layout the <b><i>properties</i></b> method can return hints on
   how the table should be presented more in detail. For example, specifying
   which column the table should be sorted on by default, or if a column 
   preferably should  be printed with hexadecimal numbers instead of decimals.
   In addition, the <b><i>properties</i></b> also contains the name of the columns
   as well as additional meta-data such as what each column represents, or 
   what the entire table represents.
</p><p>
   The <b><i>properties</i></b> also returns an <code>attr_value_t</code> type 
   as a list of key/value pairs. Thus, each list-entry should be exactly
   two elements long, but the value part can itself be a new list of key/value
   pairs for some keys.
</p><p>
   The table property keys are of <code>table_key_t</code> type:
   
</p><pre class="jdocu_small">typedef enum {
        /* Table property keys */
        Table_Key_Name = 1,
        Table_Key_Description,
        Table_Key_Default_Sort_Column,
        Table_Key_Columns,
        Table_Key_Extra_Headers,
        Table_Key_Stream_Header_Repeat,
        /* Additional properties might be added in the future.
           Thus, unknown values should be silently ignored. */
} table_key_t;</pre><p>

</p><p>
   This is the definition for each table property:
   </p><dl><dt id="__rm_interface_table.html:dt:table_key_name-string"><a href="#__rm_interface_table.html:dt:table_key_name-string"><b><code>Table_Key_Name</code> <i>String</i></b></a></dt><dd>A short description of what the table represents.</dd><dt id="__rm_interface_table.html:dt:table_key_description-string"><a href="#__rm_interface_table.html:dt:table_key_description-string"><b><code>Table_Key_Description</code> <i>String</i></b></a></dt><dd>A longer description what the table represents.</dd><dt id="__rm_interface_table.html:dt:table_key_default_sort_column-string"><a href="#__rm_interface_table.html:dt:table_key_default_sort_column-string"><b><code>Table_Key_Default_Sort_Column</code> <i>String</i></b></a></dt><dd>References the Column_Key_Name (inside the Table_Key_Columns) to tell
   which column that should be used when sorting the table by
   default. If the Column_Key_Name contains new-line characters,
   replace those with spaces. If not specified, the table will
   be unsorted by default.</dd><dt id="__rm_interface_table.html:dt:table_key_extra_headers-list-of-additional-header-rows"><a href="#__rm_interface_table.html:dt:table_key_extra_headers-list-of-additional-header-rows"><b><code>Table_Key_Extra_Headers</code> <i>List of additional header
   rows</i></b></a></dt><dd>In addition to the column-headers printed, this property allows
   additional header rows to be presented before the column headers. These
   additional header rows can span over multiple columns, providing additional
   explanation and grouping of columns.
<p>
   The format is: list of additional header rows, each identified as a
   <code>Extra_Header_Key_Row</code>.
   Each row is defined by a list of the header-elements where each element
   is a list of the header's key/value pair properties.
</p><p>
   The header property keys are of <code>extra_header_key_t</code> type,
   this is the definition for each extra header property:
   
</p><pre class="jdocu_small">typedef enum {
        /* Header property keys */
        Extra_Header_Key_Row = 2000,
        Extra_Header_Key_Name,
        Extra_Header_Key_Description,
        Extra_Header_Key_First_Column,
        Extra_Header_Key_Last_Column,
} extra_header_key_t;</pre><p>

</p><p>
   </p><dl><dt id="__rm_interface_table.html:dt:extra_header_key_row-list-of-header-elements"><a href="#__rm_interface_table.html:dt:extra_header_key_row-list-of-header-elements"><b><code>Extra_Header_Key_Row</code> <i>List of header elements</i></b></a></dt><dd>Identifies a new header row.</dd><dt id="__rm_interface_table.html:dt:extra_header_key_name-string"><a href="#__rm_interface_table.html:dt:extra_header_key_name-string"><b><code>Extra_Header_Key_Name</code> <i>String</i></b></a></dt><dd>The name printed for the extra header element.</dd><dt id="__rm_interface_table.html:dt:extra_header_key_description-string"><a href="#__rm_interface_table.html:dt:extra_header_key_description-string"><b><code>Extra_Header_Key_Description</code> <i>String</i></b></a></dt><dd>Optional additional text describing the header.</dd><dt id="__rm_interface_table.html:dt:extra_header_key_first_column-string"><a href="#__rm_interface_table.html:dt:extra_header_key_first_column-string"><b><code>Extra_Header_Key_First_Column</code> <i>String</i></b></a></dt><dd>A reference to the column the additional header spans from.</dd><dt id="__rm_interface_table.html:dt:extra_header_key_last_column-string"><a href="#__rm_interface_table.html:dt:extra_header_key_last_column-string"><b><code>Extra_Header_Key_Last_Column</code> <i>String</i></b></a></dt><dd>A reference to the column the additional header spans to.</dd></dl><p></p></dd>If there is only one header element on a row, and neither
   <code>Extra_Header_Key_First_Column</code> and
   <code>Extra_Header_Key_Last_Column</code> are set, the header will span the
   entire table, even if additional columns has been added by the system. In
   all other cases first/last column always needs to be specified.

   <dt id="__rm_interface_table.html:dt:table_key_columns-list-of-columns-with-key-value-pairs"><a href="#__rm_interface_table.html:dt:table_key_columns-list-of-columns-with-key-value-pairs"><b><code>Table_Key_Columns</code> <i>List of columns, with key/value pairs
   </i></b></a></dt><dd>A list of the columns, where each element consists of key/value pairs
   defining each column with various properties.
   The column properties are named with Column_Key_* which are listed below.
   The list size should match the number of columns in the data. List item 1,
   represents key/value definitions for column 1 etc.
<p>
   The column property keys are of <code>column_key_t</code> type:
   
</p><pre class="jdocu_small">typedef enum {                
        /* Column property keys */
        Column_Key_Name = 1000,       /* Other number series than table-keys */
        Column_Key_Description,
        Column_Key_Alignment,
        Column_Key_Int_Radix,
        Column_Key_Float_Percent,
        Column_Key_Float_Decimals,
        Column_Key_Sort_Descending,
        Column_Key_Hide_Homogeneous,
        Column_Key_Generate_Percent_Column,
        Column_Key_Generate_Acc_Percent_Column,
        Column_Key_Footer_Sum,
        Column_Key_Footer_Mean,
        Column_Key_Int_Grouping,
        Column_Key_Int_Pad_Width,
        Column_Key_Metric_Prefix,
        Column_Key_Binary_Prefix,
        Column_Key_Time_Format,
        Column_Key_Unique_Id,
        Column_Key_Width,
        Column_Key_Word_Delimiters,
        /* Additional properties might be added in the future.
           Thus, unknown values should be silently ignored. */        
} column_key_t;</pre><p>

   This is the definition for each column property:
</p><p>
   </p><dl><dt id="__rm_interface_table.html:dt:column_key_name-string"><a href="#__rm_interface_table.html:dt:column_key_name-string"><b><code>Column_Key_Name</code> <i>String</i></b></a></dt><dd>The name for the column, displayed on the first row of the table.
   Preferably these should be as short as possible while still being 
   descriptive. 
   It is possible to break longer strings with a newline character (\n)</dd><dt id="__rm_interface_table.html:dt:column_key_description-string"><a href="#__rm_interface_table.html:dt:column_key_description-string"><b><code>Column_Key_Description</code> <i>String</i></b></a></dt><dd>A longer descriptive text describing the column content.</dd><dt id="__rm_interface_table.html:dt:column_key_alignment-string-left-right-center"><a href="#__rm_interface_table.html:dt:column_key_alignment-string-left-right-center"><b><code>Column_Key_Alignment</code> <i>String: ["left", "right", "center"]</i>
   </b></a></dt><dd>Specifies if the column data should be aligned to the left, right
   or centered for the entire table data. If not specified strings are
   left-aligned and numbers right-aligned.</dd><dt id="__rm_interface_table.html:dt:column_key_word_delimiters-string"><a href="#__rm_interface_table.html:dt:column_key_word_delimiters-string"><b><code>Column_Key_Word_Delimiters</code> <i>String</i></b></a></dt><dd>Overrides the default set of character that will be used for word
   wrapping of long lines. Default is <code>" -_:,."</code>.</dd><dt id="__rm_interface_table.html:dt:column_key_int_radix-integer-2-10-16"><a href="#__rm_interface_table.html:dt:column_key_int_radix-integer-2-10-16"><b><code>Column_Key_Int_Radix</code> <i>Integer: [2,10,16]]</i></b></a></dt><dd>Specifies the default radix which should be used for when displaying
   integers numbers, 2 means binary, 10 decimal and 16 hexadecimal.
   If not specified, the integers will be displayed in the default radix,
   selectable by the <b>output-radix</b> command.</dd><dt id="__rm_interface_table.html:dt:column_key_int_grouping-boolean"><a href="#__rm_interface_table.html:dt:column_key_int_grouping-boolean"><b><code>Column_Key_Int_Grouping</code> <i>Boolean</i></b></a></dt><dd>If False, the current user preferences for integer grouping will be
   ignored. For example, instead of 12_345 the output will read 12345. If not
   specified, default grouping is respected. Grouping is set by the
   <b>output-radix</b> command.</dd><dt id="__rm_interface_table.html:dt:column_key_pad_width-integer"><a href="#__rm_interface_table.html:dt:column_key_pad_width-integer"><b><code>Column_Key_Pad_Width</code> <i>Integer</i></b></a></dt><dd>Zero-extends values up to N characters. This allows similar width of
   the column data regardless of the value in each cell. For example,
   with hexadecimal output and 64-bits value printed, the column might
   be easier to read with a pad-width of 16.
   If not specified, the default size used 1 (no-padding).</dd><dt id="__rm_interface_table.html:dt:column_key_float_percent-boolean"><a href="#__rm_interface_table.html:dt:column_key_float_percent-boolean"><b><code>Column_Key_Float_Percent</code> <i>Boolean</i></b></a></dt><dd>If True, any float data in the column will be printed as a 
   percent value. For example, 0.1234 will be printed as 12.34%.</dd><dt id="__rm_interface_table.html:dt:column_key_float_decimals-integer"><a href="#__rm_interface_table.html:dt:column_key_float_decimals-integer"><b><code>Column_Key_Float_Decimals</code> <i>Integer</i></b></a></dt><dd>Specifies how many decimal digit that should be printed for
   any floating point values in the column. If not specified 2 decimals
   are printed by default.</dd><dt id="__rm_interface_table.html:dt:column_key_metric_prefix-string"><a href="#__rm_interface_table.html:dt:column_key_metric_prefix-string"><b><code>Column_Key_Metric_Prefix</code> <i>String</i></b></a></dt><dd>A metric prefix
   (m, , n, p, f, a, z, y, k, M, G, T, P, E, Z, Y) will be added to the value
   and the value will be adjusted accordingly. If the string is non-empty the
   string will be interpreted as a unit that will be added after the prefix for
   each value.</dd><dt id="__rm_interface_table.html:dt:column_key_binary_prefix-string"><a href="#__rm_interface_table.html:dt:column_key_binary_prefix-string"><b><code>Column_Key_Binary_Prefix</code> <i>String</i></b></a></dt><dd>A binary prefix
   (ki, Mi, Gi, Ti, Pi, Ei, Zi, Yi) will be added to the value
   and the value will be adjusted accordingly. If the string is non-empty the
   string will be interpreted as a unit that will be added after the prefix for
   each value.</dd><dt id="__rm_interface_table.html:dt:column_key_time_format-boolean"><a href="#__rm_interface_table.html:dt:column_key_time_format-boolean"><b><code>Column_Key_Time_Format</code> <i>Boolean</i></b></a></dt><dd>If True
   the value (in seconds) will be formatted as <code>HH:MM:SS.ss</code>,
   where only the used parts are shown.
   The number of seconds decimals formatted is can be controlled by
   <code>Column_Key_Float_Decimals</code> property.
   To compact the width, decimals are dropped when hours are displayed.
   </dd><dt id="__rm_interface_table.html:dt:column_key_unique_id-string"><a href="#__rm_interface_table.html:dt:column_key_unique_id-string"><b><code>Column_Key_Unique_Id</code> <i>String</i></b></a></dt><dd>If the same name is set for multiple columns in a table, this
   property sets a unique name for a specific column, needed when
   referencing the column from extra headers.</dd><dt id="__rm_interface_table.html:dt:column_key_sort_descending-boolean"><a href="#__rm_interface_table.html:dt:column_key_sort_descending-boolean"><b><code>Column_Key_Sort_Descending</code> <i>Boolean</i></b></a></dt><dd>If True, specifies if a column should be sorted with the 
   highest values first. If not specified, this is automatically
   set to True for any numbers and False for other types.</dd><dt id="__rm_interface_table.html:dt:column_key_hide_homogeneous-integer-float-string"><a href="#__rm_interface_table.html:dt:column_key_hide_homogeneous-integer-float-string"><b><code>Column_Key_Hide_Homogeneous</code> <i>Integer/Float/String</i></b></a></dt><dd>If this property is specified and the column consists entirely of the
   given data, the column will not be shown. For example, if the table has a
   column which only consists of empty strings (""), the column can be
   discarded from the resulting table.</dd><dt id="__rm_interface_table.html:dt:column_key_footer_sum-boolean"><a href="#__rm_interface_table.html:dt:column_key_footer_sum-boolean"><b><code>Column_Key_Footer_Sum</code> <i>Boolean</i></b></a></dt><dd>If True, all columns values are summed up and displayed in
   a footer row, below the actual table.</dd><dt id="__rm_interface_table.html:dt:column_key_footer_mean-boolean"><a href="#__rm_interface_table.html:dt:column_key_footer_mean-boolean"><b><code>Column_Key_Footer_Mean</code> <i>Boolean</i></b></a></dt><dd>If True, an arithmetic mean of the column values are calculated
   and displayed in a footer row, below the actual table.</dd><dt id="__rm_interface_table.html:dt:column_key_generate_percent_column-list-of-key-value-pairs-for-new-column"><a href="#__rm_interface_table.html:dt:column_key_generate_percent_column-list-of-key-value-pairs-for-new-column"><b><code>Column_Key_Generate_Percent_Column</code>
   <i>List of key/value pairs for new column.</i></b></a></dt><dd>If this property is set, an additional column will be created 
   (to the right of this column) showing the percent values for each row.
   The list of key/value pairs allows to the created column to be
   customized, however just giving an empty list should give 
   understandable default values.
   </dd><dt id="__rm_interface_table.html:dt:column_key_generate_acc_percent_column-list-of-key-value-pairs-for-new-column"><a href="#__rm_interface_table.html:dt:column_key_generate_acc_percent_column-list-of-key-value-pairs-for-new-column"><b><code>Column_Key_Generate_Acc_Percent_Column</code>
   <i>List of key/value pairs for new column.</i></b></a></dt><dd>If this property is set, an additional column will be created 
   (to the right of this column) showing the accumulated percent values for
   each row.
   The list of key/value pairs allows to the created column to be
   customized, however just giving an empty list should give 
   understandable default values.
   </dd></dl><p></p></dd></dl><p></p><pre class="jdocu_small">SIM_INTERFACE(table) {
        /* Returns all rows and columns in the following format:
           [[[i|f|s|o|n*]*]] where the outer list is the row
           and the inner list is the data for each column. */
        attr_value_t (*data)(conf_object_t *obj);
        
        /* Defines the table structure and meta-data for the table
           using a list of key/value pairs.
           [[[ia]*]*] where the integer is the key taken from the
           table_properties_t. The value is key-specific. */
        attr_value_t (*properties)(conf_object_t *obj);

};
#define TABLE_INTERFACE "table"
</pre><p>
</p><p>

   
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Global Context for all methods.
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_telnet_connection_v2.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_telnet_connection_v2.html:__rm_interface_telnet_connection_v2">telnet_connection_v2</a></h1>
<p>

<a id="__rm_interface_telnet_connection_v2.html:telnet_connection_v2"></a><a id="__rm_interface_telnet_connection_v2.html:telnet_connection_v2_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>telnet_connection_v2</code> interface is used to control the text
   console telnet server.
<p>
   The text console has a built-in telnet server.
</p><p>
   The <b><i>listening</i></b> method indicates whether the server is listening
   for connections.
</p><p>
   The <b><i>connected</i></b> method indicates whether there is a connected
   telnet client.
</p><p>
   The <b><i>disconnect</i></b> method forcibly disconnects any connected client.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(telnet_connection_v2) {
        bool (*listening)(conf_object_t *NOTNULL obj);
        bool (*connected)(conf_object_t *NOTNULL obj);
        void (*disconnect)(conf_object_t *NOTNULL obj);
};
#define TELNET_CONNECTION_V2_INTERFACE "telnet_connection_v2"
</pre><p>
 
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Global Context
   for all methods
   
</dd>
</dl><p></p></section><section class="page" id="__rm_interface_vnc_server_v2.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_interface_vnc_server_v2.html:__rm_interface_vnc_server_v2">vnc_server_v2</a></h1>
<p>

<a id="__rm_interface_vnc_server_v2.html:vnc_server_v2"></a><a id="__rm_interface_vnc_server_v2.html:vnc_server_v2_interface_t"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">The <code>vnc_server_v2</code> interface is used to control the graphics
   console VNC server.
<p>
   The graphics console has a built-in VNC server, supporting any number of
   connected clients.
</p><p>
   The <b><i>listening</i></b> method indicates whether the server is listening
   for connections.
</p><p>
   The <b><i>num_clients</i></b> method returns the number of connected clients.
</p><p>
   The <b><i>disconnect</i></b> method forcibly disconnects any connected client.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(vnc_server_v2) {
        bool (*listening)(conf_object_t *NOTNULL obj);
        int (*num_clients)(conf_object_t *NOTNULL obj);
        void (*disconnect)(conf_object_t *NOTNULL obj);
};
#define VNC_SERVER_V2_INTERFACE "vnc_server_v2"
</pre><p>
 
</p></dd>
<dt class="jdocu_descitem">Execution Context</dt><dd class="jdocu_descitem">Global Context
   for all methods
   
</dd>
</dl><p></p></section><section class="page" id="link-api.html"><h1 class="jdocu"><a id="link-api.html:link-api">8 Link Library API</a></h1>
<p>

</p><p>
    This chapter contains all the types and functions provided by the
    link library. Please see the Link Library Programming Guide for
    more information about the link library and how it works.
</p><p>
    
    
</p></section><section class="page" id="link-library-api.html"><h1 class="jdocu"><a class="not-numbered" id="link-library-api.html:Link-Library-API">Link Library API</a></h1>
<p></p><h2 class="jdocu"><a class="not-numbered" id="link-library-api.html:SIMLINK_config_remove_value">SIMLINK_config_remove_value()</a></h2>
<p>

<a id="link-library-api.html:SIMLINK_config_remove_value2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="link-library-api.html:__jdocu_seealso_SIMLINK_config_remove_value"></a><b>SIMLINK_config_remove_value</b>  remove a link configuration parameter</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIMLINK_config_remove_value(conf_object_t *link, const char *key);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Make sure that all link objects representing <i>link</i> in the
     simulation receive a configuration message to remove the configuration
     parameter <i>key</i>.
<p>
     Note that this function may delay the transmission if it is not possible
     to send the configuration message yet. The message will be buffered and
     send when possible. The ordering of configuration messages is kept when
     buffering them.
</p><p>
     All link objects representing <i>link</i> in the simulation will
     be called via the <b><i>remove_config_value()</i></b> function declared in
     <code>link_type_t</code>, including the one initiating the message.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
None</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
Example from <b>ser_link</b>, where the ID of the endpoints
       present on the link is kept as a configuration parameter:
       <pre class="jdocu_small">static void
ser_link_ep_pre_delete_instance(conf_object_t *ep)
{
        char ep_id[19];
        snprintf(ep_id, sizeof(ep_id), "ep%llx", SIMLINK_endpoint_id(ep));
        SIMLINK_config_remove_value(SIMLINK_endpoint_link(ep), ep_id);
        SIMLINK_endpoint_disconnect(ep);
}</pre><p>

     </p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#link-library-api.html:__jdocu_seealso_SIMLINK_config_update_value">SIMLINK_config_update_value</a>, <a class="jdocu" href="#link-library-api.html:__jdocu_seealso_link_type_t"> link_type_t</a></dd>
</dl><p>
</p><h2 class="jdocu"><a class="not-numbered" id="link-library-api.html:SIMLINK_config_update_value">SIMLINK_config_update_value()</a></h2>
<p>

<a id="link-library-api.html:SIMLINK_config_update_value2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="link-library-api.html:__jdocu_seealso_SIMLINK_config_update_value"></a><b>SIMLINK_config_update_value</b>  update a link configuration parameter</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIMLINK_config_update_value(conf_object_t *link, const char *key,
                            const frags_t *value);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Make sure that all link objects representing <i>link</i> in the
     simulation will receive a configuration message for the new
     <i>value</i> of the configuration parameter
     <i>key</i>. Both <i>key</i> and <i>value</i> are
     completely link-specific and transported as-is to all objects.
<p>
     Note that this function may delay the transmission if it is not possible
     to send the configuration message yet. The message will be buffered and
     send when possible. The ordering of configuration messages is kept when
     buffering them.
</p><p>
     All link objects representing <i>link</i> in the simulation will
     be called via the <b><i>update_config_value()</i></b> function declared in
     <code>link_type_t</code>, including the one initiating the message.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
None</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
Example from <b>ethernet_switch</b>, where the ID of all snooper
       endpoints present on the link are sent as a configuration parameter so
       they are included even when a packet can be sent directly to the
       receiver.
       <pre class="jdocu_small">static void
snoop_ep_finalize_instance(conf_object_t *ep)
{
        ep_finalize_instance(ep);

        /* Tell all endpoints that there's a new snoop in town. */
        char ep_id[17];
        snprintf(ep_id, sizeof(ep_id), "%llx", SIMLINK_endpoint_id(ep));
        frags_t value;
        frags_init(&amp;value); /* empty value, just to put the
                               key in the database */
        SIMLINK_config_update_value(
                SIMLINK_endpoint_link(ep), ep_id, &amp;value);
}</pre><p>

     </p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#link-library-api.html:__jdocu_seealso_SIMLINK_config_remove_value">SIMLINK_config_remove_value</a>, <a class="jdocu" href="#link-library-api.html:__jdocu_seealso_link_type_t"> link_type_t</a></dd>
</dl><p>
</p><h2 class="jdocu"><a class="not-numbered" id="link-library-api.html:SIMLINK_endpoint_clock">SIMLINK_endpoint_clock()</a></h2>
<p>

<a id="link-library-api.html:SIMLINK_endpoint_clock2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="link-library-api.html:__jdocu_seealso_SIMLINK_endpoint_clock"></a><b>SIMLINK_endpoint_clock</b>  return endpoint's clock</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">conf_object_t *
SIMLINK_endpoint_clock(const conf_object_t *ep_obj);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Return the endpoint <i>ep</i>'s associated clock object. It will
     be either the clock object corresponding to the device connected to the
     endpoint, or the clock chosen when using the endpoint for snooping.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
The associated clock object. This function might return
       <code>NULL</code> if the device associated to an endpoint does not
       have its queue attribute set. This indicates a configuration problem, as
       the device would be unable to send or receive link messages.
     </dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#link-library-api.html:__jdocu_seealso_SIMLINK_endpoint_device">SIMLINK_endpoint_device</a></dd>
</dl><p>
</p><h2 class="jdocu"><a class="not-numbered" id="link-library-api.html:SIMLINK_endpoint_dev_name">SIMLINK_endpoint_dev_name()</a></h2>
<p>

<a id="link-library-api.html:SIMLINK_endpoint_dev_name2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="link-library-api.html:__jdocu_seealso_SIMLINK_endpoint_dev_name"></a><b>SIMLINK_endpoint_dev_name</b>  return the name of the device or snooper to which an endpoint
     is connected</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">const char *
SIMLINK_endpoint_dev_name(const conf_object_t *ep_obj, buffer_t scratch);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Return the name of the device or snooper to which the endpoint
     <i>ep</i> is connected. This function takes an additional
     <i>scratch</i> parameter that is meant to provide space for
     putting together the answer when necessary, without allocating any
     memory. If <i>scratch</i> is used by
     <b><i>SIMLINK_endpoint_dev_name()</i></b> but is not long enough, the name
     will be truncated.
<p>
     This function is provided for logging purposes.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
The name of the device or snooper the endpoint is
       connected to</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
Example from <b>ethernet_hub</b>, to print the name of the
       device or snooper to which a frame is delivered:
       <pre class="jdocu_small">#define BUFFER_T(buf) (buffer_t){ .len = sizeof(buf), .data = buf }

static void
deliver_hub(conf_object_t *ep, const link_message_t *msgdata)
{
        uint8 buf[1000];
        SIM_LOG_INFO(3, ep, 0, "delivering to %s",
                     SIMLINK_endpoint_dev_name(ep, BUFFER_T(buf)));</pre><p>

     </p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#link-library-api.html:__jdocu_seealso_SIMLINK_endpoint_is_device">
       SIMLINK_endpoint_is_device</a>, <a class="jdocu" href="#link-library-api.html:__jdocu_seealso_SIMLINK_endpoint_device"> SIMLINK_endpoint_device
     </a></dd>
</dl><p>
</p><h2 class="jdocu"><a class="not-numbered" id="link-library-api.html:SIMLINK_endpoint_device">SIMLINK_endpoint_device()</a></h2>
<p>

<a id="link-library-api.html:SIMLINK_endpoint_device2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="link-library-api.html:__jdocu_seealso_SIMLINK_endpoint_device"></a><b>SIMLINK_endpoint_device</b>  return the device to which an endpoint is connected</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">conf_object_t *
SIMLINK_endpoint_device(const conf_object_t *ep_obj);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Return the device to which the endpoint <i>ep</i> is connected. If
     the endpoint is not connected to a device, this function will trigger an
     assertion failure. This can be checked with
     <b><i>SIMLINK_endpoint_is_device()</i></b>.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
The device to which the endpoint is connected</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
Example from <b>datagram_link</b>:
       <pre class="jdocu_small">static void
deliver(conf_object_t *ep, const link_message_t *lm)
{
        const datagram_link_message_t *m = 
                (const datagram_link_message_t *)lm;
        conf_object_t *dev = SIMLINK_endpoint_device(ep);
        const char *port = SIMLINK_endpoint_port(ep);
        const datagram_link_interface_t *dli =
                SIM_c_get_port_interface(dev, "datagram_link", port);
        if (dli)
                dli-&gt;receive(dev, m-&gt;payload);
        else
                SIM_LOG_ERROR(ep, 0, "Device does not implement"
                              " datagram_link interface");
}</pre><p>

     </p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#link-library-api.html:__jdocu_seealso_SIMLINK_endpoint_is_device">SIMLINK_endpoint_is_device</a>, <a class="jdocu" href="#link-library-api.html:__jdocu_seealso_SIMLINK_endpoint_dev_name">
     SIMLINK_endpoint_dev_name</a></dd>
</dl><p>
</p><h2 class="jdocu"><a class="not-numbered" id="link-library-api.html:SIMLINK_endpoint_disconnect">SIMLINK_endpoint_disconnect()</a></h2>
<p>

<a id="link-library-api.html:SIMLINK_endpoint_disconnect2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="link-library-api.html:__jdocu_seealso_SIMLINK_endpoint_disconnect"></a><b>SIMLINK_endpoint_disconnect</b>  disconnect an endpoint object</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIMLINK_endpoint_disconnect(conf_object_t *ep_obj);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Disconnect the endpoint object <i>ep_obj</i> from its link. This
     function is intended to be called in the <b><i>pre_delete_instance()</i></b>
     method of an endpoint class. It should never be called in other
     circumstances, as endpoint objects should <em>not</em> be reused. Note
     that once the endpoint has been disconnected, it cannot be used for calls
     to Link Library API functions that takes an endpoint as argument.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
None</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
Example from <b>ser_link</b>:
       <pre class="jdocu_small">static void
ser_link_ep_pre_delete_instance(conf_object_t *ep)
{
        char ep_id[19];
        snprintf(ep_id, sizeof(ep_id), "ep%llx", SIMLINK_endpoint_id(ep));
        SIMLINK_config_remove_value(SIMLINK_endpoint_link(ep), ep_id);
        SIMLINK_endpoint_disconnect(ep);
}</pre><p>

     </p></dd>
</dl><p>
</p><h2 class="jdocu"><a class="not-numbered" id="link-library-api.html:SIMLINK_endpoint_finalize">SIMLINK_endpoint_finalize()</a></h2>
<p>

<a id="link-library-api.html:SIMLINK_endpoint_finalize2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="link-library-api.html:__jdocu_seealso_SIMLINK_endpoint_finalize"></a><b>SIMLINK_endpoint_finalize</b>  finalize an endpoint object</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIMLINK_endpoint_finalize(conf_object_t *ep_obj);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Finalize the endpoint object <i>ep_obj</i>. This function is
     intended to be called in the <b><i>finalize_instance()</i></b> method of an
     endpoint class.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
None</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
Example from <b>ser_link</b>:
       <pre class="jdocu_small">static void
ser_link_ep_finalize_instance(conf_object_t *ep)
{
        SIMLINK_endpoint_finalize(ep);
}</pre><p>

     </p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#link-library-api.html:__jdocu_seealso_SIMLINK_endpoint_init">SIMLINK_endpoint_init</a></dd>
</dl><p>
</p><h2 class="jdocu"><a class="not-numbered" id="link-library-api.html:SIMLINK_endpoint_id">SIMLINK_endpoint_id()</a></h2>
<p>

<a id="link-library-api.html:SIMLINK_endpoint_id2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="link-library-api.html:__jdocu_seealso_SIMLINK_endpoint_id"></a><b>SIMLINK_endpoint_id</b>  return endpoint's ID</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">uint64
SIMLINK_endpoint_id(const conf_object_t *ep);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Return the endpoint <i>ep</i>'s ID.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
The endpoint ID</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
In <b>ser_link</b>, the endpoints IDs are kept as configuration
       values so they are known in all link objects:
       <pre class="jdocu_small">static void
ser_link_ep_pre_delete_instance(conf_object_t *ep)
{
        char ep_id[19];
        snprintf(ep_id, sizeof(ep_id), "ep%llx", SIMLINK_endpoint_id(ep));
        SIMLINK_config_remove_value(SIMLINK_endpoint_link(ep), ep_id);
        SIMLINK_endpoint_disconnect(ep);
}</pre><p>

     </p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#link-library-api.html:__jdocu_seealso_SIMLINK_find_endpoint_by_id">SIMLINK_find_endpoint_by_id</a></dd>
</dl><p>
</p><h2 class="jdocu"><a class="not-numbered" id="link-library-api.html:SIMLINK_endpoint_init">SIMLINK_endpoint_init()</a></h2>
<p>

<a id="link-library-api.html:SIMLINK_endpoint_init2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="link-library-api.html:__jdocu_seealso_SIMLINK_endpoint_init"></a><b>SIMLINK_endpoint_init</b>  initialize an endpoint object</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIMLINK_endpoint_init(conf_object_t *obj, bool snoop);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Initialize the endpoint object <i>obj</i>. Whether the endpoint is
     connected to a device or a snooper function is determined by the
     <i>snoop</i> parameter. This function is intended to be called in
     the <b><i>init_object()</i></b> method of an endpoint class.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
None</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
Example from <b>datagram_link</b>:
       <pre class="jdocu_small">static void *
datagram_link_endpoint_init_object(conf_object_t *obj, void *data)
{
        datagram_link_endpoint_t *dlep =
                (datagram_link_endpoint_t *)obj;
        SIMLINK_endpoint_init(&amp;dlep-&gt;obj, false);
        return dlep;
}</pre><p>

     </p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#link-library-api.html:__jdocu_seealso_SIMLINK_register_endpoint_class">
       SIMLINK_register_endpoint_class</a>, <a class="jdocu" href="#link-library-api.html:__jdocu_seealso_SIMLINK_register_snoop_endpoint_class"> SIMLINK_register_snoop_endpoint_class</a>, <a class="jdocu" href="#link-library-api.html:__jdocu_seealso_SIMLINK_endpoint_finalize">
       SIMLINK_endpoint_finalize
     </a></dd>
</dl><p>
</p><h2 class="jdocu"><a class="not-numbered" id="link-library-api.html:SIMLINK_endpoint_is_device">SIMLINK_endpoint_is_device()</a></h2>
<p>

<a id="link-library-api.html:SIMLINK_endpoint_is_device2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="link-library-api.html:__jdocu_seealso_SIMLINK_endpoint_is_device"></a><b>SIMLINK_endpoint_is_device</b>  return whether an endpoint is connected to a device</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">bool
SIMLINK_endpoint_is_device(const conf_object_t *ep);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Return whether the endpoint <i>ep</i> is connected to a device
     (as opposed to a link snooper).</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
<code>true</code> if the endpoint is connected
       to a device, <code>false</code> otherwise</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
Example from <b>ethernet_switch</b>, where frames are delivered
       either to a device endpoint or to a snoop endpoint, using different
       methods:
       <pre class="jdocu_small">static void
switch_deliver_frame(conf_object_t *link, conf_object_t *ep,
                     vlan_tag_t vlan_tag, uint64 src_epid,
                     const frags_t *frame)
{
        eth_frame_crc_status_t crc_status = Eth_Frame_CRC_Match;

        if (SIMLINK_endpoint_is_device(ep)) {
                switch_ep_t *swep = (switch_ep_t *)ep;
                if (frags_len(frame) &gt; 12) {
                        uint8 src_mac[6];
                        frags_extract_slice(frame, src_mac, 6, 6);
                        learn(link, swep, vlan_tag, src_mac, src_epid);
                }
                swep-&gt;cep.ifc-&gt;frame(SIMLINK_endpoint_device(ep), frame,
                                     crc_status);
        } else {
                snoop_ep_t *snoop = (snoop_ep_t *)ep;
                deliver_to_snoop(snoop-&gt;snoop_fun, snoop-&gt;user_data,
                                 SIMLINK_endpoint_clock(ep), frame,
                                 crc_status);
        }
}
</pre><p>

     </p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#link-library-api.html:__jdocu_seealso_SIMLINK_endpoint_device">SIMLINK_endpoint_device</a>, <a class="jdocu" href="#link-library-api.html:__jdocu_seealso_SIMLINK_endpoint_port"> SIMLINK_endpoint_port</a></dd>
</dl><p>
</p><h2 class="jdocu"><a class="not-numbered" id="link-library-api.html:SIMLINK_endpoint_link">SIMLINK_endpoint_link()</a></h2>
<p>

<a id="link-library-api.html:SIMLINK_endpoint_link2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="link-library-api.html:__jdocu_seealso_SIMLINK_endpoint_link"></a><b>SIMLINK_endpoint_link</b>  return endpoint's link</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">conf_object_t *
SIMLINK_endpoint_link(const conf_object_t *ep);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Return the link object to which the endpoint <i>ep</i> is
     connected.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
The link object</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
In <b>ser_link</b>, an endpoint needs to check the maximum size
       of its buffer by querying its link object:
       <pre class="jdocu_small">static void
deliver(conf_object_t *ep, const link_message_t *msgd)
{
        ser_link_endpoint_t *slep = (ser_link_endpoint_t *)ep;
        ser_link_impl_t *slink = (ser_link_impl_t *)SIMLINK_endpoint_link(ep);
        ser_link_message_t *msg = (ser_link_message_t *)msgd;
        switch (msg-&gt;msgtype) {
        case MSG_Char:</pre><p>

     </p></dd>
</dl><p>
</p><h2 class="jdocu"><a class="not-numbered" id="link-library-api.html:SIMLINK_endpoint_port">SIMLINK_endpoint_port()</a></h2>
<p>

<a id="link-library-api.html:SIMLINK_endpoint_port2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="link-library-api.html:__jdocu_seealso_SIMLINK_endpoint_port"></a><b>SIMLINK_endpoint_port</b>  return the device's port to which an endpoint is connected</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">const char *
SIMLINK_endpoint_port(const conf_object_t *ep_obj);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Return the device's port to which the endpoint <i>ep</i> is
     connected. If the endpoint is not connected to a device, this function
     will trigger an assertion failure. This can be checked with
     <b><i>SIMLINK_endpoint_is_device()</i></b>.
<p>
     The port returned might be <code>NULL</code>, which means that the
     device is implementing a classic interface rather than a port interface.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
The device's port to which the endpoint is
       connected, or <code>NULL</code> if no port is used</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
Example from <b>ser_link</b>, where a pointer to the interface
       to call for delivery is kept in the endpoint structure:
       <pre class="jdocu_small">static void
ser_link_ep_finalize_instance(conf_object_t *ep)
{
        SIMLINK_endpoint_finalize(ep);
}</pre><p>

     </p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#link-library-api.html:__jdocu_seealso_SIMLINK_endpoint_is_device">SIMLINK_endpoint_is_device</a>, <a class="jdocu" href="#link-library-api.html:__jdocu_seealso_SIMLINK_endpoint_device">
     SIMLINK_endpoint_device</a></dd>
</dl><p>
</p><h2 class="jdocu"><a class="not-numbered" id="link-library-api.html:SIMLINK_finalize">SIMLINK_finalize()</a></h2>
<p>

<a id="link-library-api.html:SIMLINK_finalize2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="link-library-api.html:__jdocu_seealso_SIMLINK_finalize"></a><b>SIMLINK_finalize</b>  finalize a link object</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIMLINK_finalize(conf_object_t *obj);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Finalize the link object <i>obj</i>. This function is intended to
     be called in the <b><i>finalize_instance()</i></b> method of a link class.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
None</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
Example from <b>ser_link</b>:
       <pre class="jdocu_small">static void
datagram_link_finalize_instance(conf_object_t *obj)
{
        SIMLINK_finalize(obj);
}</pre><p>

     </p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#link-library-api.html:__jdocu_seealso_SIMLINK_init">SIMLINK_init</a></dd>
</dl><p>
</p><h2 class="jdocu"><a class="not-numbered" id="link-library-api.html:SIMLINK_find_endpoint_by_id">SIMLINK_find_endpoint_by_id()</a></h2>
<p>

<a id="link-library-api.html:SIMLINK_find_endpoint_by_id2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="link-library-api.html:__jdocu_seealso_SIMLINK_find_endpoint_by_id"></a><b>SIMLINK_find_endpoint_by_id</b>  return an endpoint object given its ID</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">conf_object_t *
SIMLINK_find_endpoint_by_id(conf_object_t *link, uint64 id);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Return the endpoint object with the ID <i>id</i> if the endpoint
     is connected to the link <i>link</i>, or <code>NULL</code>
     otherwise.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Endpoint object, or <code>NULL</code> if not
       found</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#link-library-api.html:__jdocu_seealso_SIMLINK_endpoint_id">SIMLINK_endpoint_id</a></dd>
</dl><p>
</p><h2 class="jdocu"><a class="not-numbered" id="link-library-api.html:SIMLINK_init">SIMLINK_init()</a></h2>
<p>

<a id="link-library-api.html:SIMLINK_init2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="link-library-api.html:__jdocu_seealso_SIMLINK_init"></a><b>SIMLINK_init</b>  initialize a link object</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIMLINK_init(conf_object_t *obj, const link_type_t *type);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Initialize the link object <i>obj</i>. The link specific functions
     that will be called from the link library are gathered in the
     <code>link_type_t</code> <i>type</i> argument. This function is
     intended to be called in the <b><i>init_object()</i></b> method of a link.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
None</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
Example from <b>ser_link</b>:
       <pre class="jdocu_small">static const link_type_t ser_link_type = {
        .msg_to_attr = msg_to_attr,
        .msg_from_attr = msg_from_attr,
        .free_msg = free_message,
        .marshal = marshal,
        .unmarshal = unmarshal,
        .deliver = deliver,
        .update_config_value = link_config_value_updated,
        .remove_config_value = link_config_value_removed,
        .device_changed = ser_link_ep_device_changed
};

static conf_object_t *
ser_link_alloc_object(void *arg)
{
        ser_link_impl_t *slink = MM_ZALLOC(1, ser_link_impl_t);
        return &amp;slink-&gt;obj;
}

static void *
ser_link_init_object(conf_object_t *obj, void *arg)
{
        ser_link_impl_t *slink = (ser_link_impl_t *)obj;
        SIMLINK_init(&amp;slink-&gt;obj, &amp;ser_link_type);
        slink-&gt;buffer_size = 10; /* a reasonable default value? */
        return obj;
}
</pre><p>
</p><p>
   
     </p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#link-library-api.html:__jdocu_seealso_SIMLINK_register_class">
       SIMLINK_register_class</a>, <a class="jdocu" href="#link-library-api.html:__jdocu_seealso_SIMLINK_finalize"> SIMLINK_finalize</a>, <a class="jdocu" href="#link-library-api.html:__jdocu_seealso_link_type_t"> link_type_t
     </a></dd>
</dl><p>
</p><h2 class="jdocu"><a class="not-numbered" id="link-library-api.html:SIMLINK_init_library">SIMLINK_init_library()</a></h2>
<p>

<a id="link-library-api.html:SIMLINK_init_library2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="link-library-api.html:__jdocu_seealso_SIMLINK_init_library"></a><b>SIMLINK_init_library</b>  initialize the link library</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIMLINK_init_library();
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Initialize the link library. This function is meant to be called in the
     <b><i>init_local()</i></b> function of a module linked to the library.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
None</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
Example from <b>datagram_link</b>:
       <pre class="jdocu_small">void
init_local()
{
        /* The link library must always be initialised first. */
        SIMLINK_init_library();</pre><p>

     </p></dd>
</dl><p>
</p><h2 class="jdocu"><a class="not-numbered" id="link-library-api.html:SIMLINK_init_message">SIMLINK_init_message()</a></h2>
<p>

<a id="link-library-api.html:SIMLINK_init_message2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="link-library-api.html:__jdocu_seealso_SIMLINK_init_message"></a><b>SIMLINK_init_message</b>  initialize a link message</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIMLINK_init_message(link_message_t *msg);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Initialize the generic part of a link message.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
None</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
Example from <b>datagram_link</b>:
       <pre class="jdocu_small">static link_message_t *
new_datagram_message(const uint8 *data, size_t len)
{
        datagram_link_message_t *m = MM_MALLOC(1, datagram_link_message_t);
        SIMLINK_init_message(&amp;m-&gt;common);
        uint8 *d = MM_MALLOC(len, uint8);
        memcpy(d, data, len);
        m-&gt;payload = (bytes_t){.data = d, .len = len};
        return &amp;m-&gt;common;
}
                                                      </pre><p>

     </p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#link-library-api.html:__jdocu_seealso_link_type_t">link_type_t</a></dd>
</dl><p>
</p><h2 class="jdocu"><a class="not-numbered" id="link-library-api.html:SIMLINK_pre_delete">SIMLINK_pre_delete()</a></h2>
<p>

<a id="link-library-api.html:SIMLINK_pre_delete2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="link-library-api.html:__jdocu_seealso_SIMLINK_pre_delete"></a><b>SIMLINK_pre_delete</b>  clean-up before link deletion</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIMLINK_pre_delete(conf_object_t *obj);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Performs clean-up operations before a link object can be safely
     deleted. This function is intended to be called in the
     <b><i>pre_delete_instance()</i></b> method of a link class.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
None</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
Example from <b>ser_link</b>:
       <pre class="jdocu_small">static void
ser_link_pre_delete_instance(conf_object_t *obj)
{
        SIMLINK_pre_delete(obj);
}</pre><p>

     </p></dd>
</dl><p>
</p><h2 class="jdocu"><a class="not-numbered" id="link-library-api.html:SIMLINK_register_class">SIMLINK_register_class()</a></h2>
<p>

<a id="link-library-api.html:SIMLINK_register_class2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="link-library-api.html:__jdocu_seealso_SIMLINK_register_class"></a><b>SIMLINK_register_class</b>  register a link class</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIMLINK_register_class(conf_class_t *cls);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Complete the class <i>cls</i> with the necessary attributes and
     interfaces to be a usable link class. This function is meant to be called
     after <i>cls</i> has been obtained from
     <b><i>SIM_register_class</i></b>.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
None</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
Example from <b>ser_link</b>:
       <pre class="jdocu_small">void
init_local()
{
        SIMLINK_init_library();

        const class_data_t link_cls_funcs = {
                .alloc_object = ser_link_alloc_object,
                .init_object = ser_link_init_object,
                .finalize_instance = ser_link_finalize_instance,
                .pre_delete_instance = ser_link_pre_delete_instance,
                .delete_instance = ser_link_delete_instance,
                .class_desc = "model of serial link",
                .description = "Serial link"
        };
        conf_class_t *link_cls = SIM_register_class("ser-link-impl",
                                                    &amp;link_cls_funcs);
        SIMLINK_register_class(link_cls);
        SIM_register_typed_attribute(
                link_cls, "buffer_size", get_link_buffer_size, NULL,
                set_link_buffer_size, NULL, Sim_Attr_Optional, "i", NULL,
                "The number of characters that the link may buffer. Must"
                " be at least one.");

        const class_data_t ep_cls_funcs = {
                .alloc_object = ser_link_ep_alloc_object,
                .init_object = ser_link_ep_init_object,
                .finalize_instance = ser_link_ep_finalize_instance,
                .pre_delete_instance = ser_link_ep_pre_delete_instance,
                .delete_instance = ser_link_ep_delete_instance,
                .class_desc =  "serial link endpoint",
                .description = "Serial link endpoint"
        };
        conf_class_t *ep_cls = SIM_register_class("ser-link-endpoint",
                                                  &amp;ep_cls_funcs);
        SIMLINK_register_endpoint_class(ep_cls, "[s]|[si]");
        </pre><p>

     </p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#link-library-api.html:__jdocu_seealso_SIMLINK_init">SIMLINK_init</a>, <a class="jdocu" href="#link-library-api.html:__jdocu_seealso_SIMLINK_finalize"> SIMLINK_finalize</a></dd>
</dl><p>
</p><h2 class="jdocu"><a class="not-numbered" id="link-library-api.html:SIMLINK_register_endpoint_class">SIMLINK_register_endpoint_class()</a></h2>
<p>

<a id="link-library-api.html:SIMLINK_register_endpoint_class2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="link-library-api.html:__jdocu_seealso_SIMLINK_register_endpoint_class"></a><b>SIMLINK_register_endpoint_class</b>  register a link endpoint class</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIMLINK_register_endpoint_class(conf_class_t *cls, const char *msg_type);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Complete the class <i>cls</i> with the necessary attributes and
     interfaces to be a usable link endpoint class. This function is meant to
     be called after <i>cls</i> has been obtained from
     <b><i>SIM_register_class</i></b>.
<p>
     <i>msg_type</i> is a string defining the type of the attribute
     representing a link message, as returned by <b><i>msg_to_attr()</i></b> in
     <code>link_type_t</code>.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
None</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
Example from <b>ser_link</b>:
       <pre class="jdocu_small">void
init_local()
{
        SIMLINK_init_library();

        const class_data_t link_cls_funcs = {
                .alloc_object = ser_link_alloc_object,
                .init_object = ser_link_init_object,
                .finalize_instance = ser_link_finalize_instance,
                .pre_delete_instance = ser_link_pre_delete_instance,
                .delete_instance = ser_link_delete_instance,
                .class_desc = "model of serial link",
                .description = "Serial link"
        };
        conf_class_t *link_cls = SIM_register_class("ser-link-impl",
                                                    &amp;link_cls_funcs);
        SIMLINK_register_class(link_cls);
        SIM_register_typed_attribute(
                link_cls, "buffer_size", get_link_buffer_size, NULL,
                set_link_buffer_size, NULL, Sim_Attr_Optional, "i", NULL,
                "The number of characters that the link may buffer. Must"
                " be at least one.");

        const class_data_t ep_cls_funcs = {
                .alloc_object = ser_link_ep_alloc_object,
                .init_object = ser_link_ep_init_object,
                .finalize_instance = ser_link_ep_finalize_instance,
                .pre_delete_instance = ser_link_ep_pre_delete_instance,
                .delete_instance = ser_link_ep_delete_instance,
                .class_desc =  "serial link endpoint",
                .description = "Serial link endpoint"
        };
        conf_class_t *ep_cls = SIM_register_class("ser-link-endpoint",
                                                  &amp;ep_cls_funcs);
        SIMLINK_register_endpoint_class(ep_cls, "[s]|[si]");
        </pre><p>

     </p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#link-library-api.html:__jdocu_seealso_SIMLINK_endpoint_finalize">SIMLINK_endpoint_finalize</a></dd>
</dl><p>
</p><h2 class="jdocu"><a class="not-numbered" id="link-library-api.html:SIMLINK_register_snoop_endpoint_class">SIMLINK_register_snoop_endpoint_class()</a></h2>
<p>

<a id="link-library-api.html:SIMLINK_register_snoop_endpoint_class2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="link-library-api.html:__jdocu_seealso_SIMLINK_register_snoop_endpoint_class"></a><b>SIMLINK_register_snoop_endpoint_class</b>  register a link snoop endpoint class</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIMLINK_register_snoop_endpoint_class(conf_class_t *cls);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Complete the class <i>cls</i> with the necessary attributes and
     interfaces to be a usable link snoop endpoint class. This function is
     meant to be called after <i>cls</i> has been obtained from
     <b><i>SIM_register_class()</i></b>.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
None</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
Example from the new Ethernet links:
       <pre class="jdocu_small">void
init_local()
{
        SIMLINK_init_library();
        init_eth_hub_link();
        init_eth_cable_link();
        init_eth_switch_link();
	init_ethernet_crc_table();

        const class_data_t snoop_ep_cls_funcs = {
                .alloc_object = snoop_ep_alloc_object,
                .init_object = snoop_ep_init_object,
                .finalize_instance = ep_finalize_instance,
                .pre_delete_instance = snoop_ep_pre_delete_instance,
                .delete_instance = snoop_ep_delete_instance,
                .description = "Ethernet link snoop endpoint",
                .class_desc = "an Ethernet link snoop endpoint",
                .kind = Sim_Class_Kind_Pseudo,
        };
        snoop_ep_cls = SIM_register_class("eth-link-snoop-endpoint",
                                          &amp;snoop_ep_cls_funcs);
        SIMLINK_register_snoop_endpoint_class(snoop_ep_cls);
}
</pre><p>

     </p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#link-library-api.html:__jdocu_seealso_SIMLINK_endpoint_finalize">SIMLINK_endpoint_finalize</a></dd>
</dl><p>
</p><h2 class="jdocu"><a class="not-numbered" id="link-library-api.html:SIMLINK_send_message">SIMLINK_send_message()</a></h2>
<p>

<a id="link-library-api.html:SIMLINK_send_message2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="link-library-api.html:__jdocu_seealso_SIMLINK_send_message"></a><b>SIMLINK_send_message</b>  send a link message</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIMLINK_send_message(conf_object_t *src_ep_obj,
                  uint64 dst_id, link_message_t *msg);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Send a message <i>msg</i> from the endpoint
     <i>src_ep_obj</i> to the destination ID <i>dst_id</i>.
     The destination may be any valid endpoint ID on the link or
     <code>LINK_BROADCAST_ID</code>, which will send the message to all
     endpoints on the link except the sender.
<p>
     It is important to note that the ownership of the message
     <i>msg</i> is passed to the link library when calling
     <b><i>SIMLINK_send_message()</i></b>. When returning, <i>msg</i> may
     have been already deallocated and should not be used anymore.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
None</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
Example from <b>datagram_link</b>:
       <pre class="jdocu_small">static void
receive(conf_object_t *NOTNULL ep, bytes_t msg)
{
        SIMLINK_send_message(ep, LINK_BROADCAST_ID, 
                             new_datagram_message(msg.data, msg.len));
}</pre><p>

     </p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#link-library-api.html:__jdocu_seealso_SIMLINK_send_message_multi">
       SIMLINK_send_message_multi</a>, <a class="jdocu" href="#link-library-api.html:__jdocu_seealso_link_message_t"> link_message_t</a>, <a class="jdocu" href="#link-library-api.html:__jdocu_seealso_link_type_t"> link_type_t
     </a></dd>
</dl><p>
</p><h2 class="jdocu"><a class="not-numbered" id="link-library-api.html:SIMLINK_send_message_multi">SIMLINK_send_message_multi()</a></h2>
<p>

<a id="link-library-api.html:SIMLINK_send_message_multi2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="link-library-api.html:__jdocu_seealso_SIMLINK_send_message_multi"></a><b>SIMLINK_send_message_multi</b>  send a link message to multiple recipients</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
SIMLINK_send_message_multi(conf_object_t *src_ep_obj, unsigned num_dsts,
                           const uint64 *dst_ids, link_message_t *msg);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Send a message <i>msg</i> from the endpoint
     <i>src_ep_obj</i> to the destinations IDs <i>dst_ids</i>.
     The length of the <i>dst_ids</i> list is provided by
     <i>num_dsts</i>. Each destination should be a valid endpoint ID on
     the link. It is <em>not</em> allowed to be
     <code>LINK_BROADCAST_ID</code>.
<p>
     It is important to note that the ownership of the message
     <i>msg</i> is passed to the link library when calling
     <b><i>SIMLINK_send_message_multi()</i></b>. When returning,
     <i>msg</i> may have been already deallocated and should not be
     used anymore.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
None</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
Example from <b>signal_link</b>, which keeps a list of endpoints
       to send to and specifically directs its messages to the appropriate
       endpoints:
       <pre class="jdocu_small">static void
send_message(signal_link_endpoint_t *slep, link_message_t *msg)
{
        signal_link_t *slink = 
                (signal_link_t *)SIMLINK_endpoint_link(&amp;slep-&gt;obj);
        int num_dsts = ht_num_entries_int(&amp;slink-&gt;receivers);
        uint64 dst_ids[num_dsts];
        memset(dst_ids, 0, num_dsts * sizeof(uint64));
        int i = 0;
        HT_FOREACH_INT(&amp;slink-&gt;receivers, it)
                dst_ids[i++] = ht_iter_int_key(it);
        SIMLINK_send_message_multi(&amp;slep-&gt;obj, num_dsts, dst_ids, msg);
}</pre><p>

     </p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#link-library-api.html:__jdocu_seealso_SIMLINK_send_message">SIMLINK_send_message</a>, <a class="jdocu" href="#link-library-api.html:__jdocu_seealso_link_message_t"> link_message_t</a>, <a class="jdocu" href="#link-library-api.html:__jdocu_seealso_link_type_t"> link_type_t</a></dd>
</dl><p>
</p><h2 class="jdocu"><a class="not-numbered" id="link-library-api.html:SIMLINK_snoop_endpoint_create">SIMLINK_snoop_endpoint_create()</a></h2>
<p>

<a id="link-library-api.html:SIMLINK_snoop_endpoint_create2"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="link-library-api.html:__jdocu_seealso_SIMLINK_snoop_endpoint_create"></a><b>SIMLINK_snoop_endpoint_create</b>  create a snoop endpoint object</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">conf_object_t *
SIMLINK_snoop_endpoint_create(conf_class_t *cls, conf_object_t *link,
                              conf_object_t *clock,
                              attr_value_t attrs);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This method returns an already created snoop endpoint object. It is meant
     to be used when implementing a <code>snoop_attach</code> interface,
     where endpoints can not be created using components as it is usually done.
     <b><i>SIMLINK_snoop_endpoint_create()</i></b> takes as arguments the class of
     the snoop endpoint object <i>cls</i>, the link object
     <i>link</i>, and a list of attributes to set, in the same form as
     provided to <b><i>SIM_create_object()</i></b>.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
A snoop endpoint object</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
Example from the new Ethernet links:
       <pre class="jdocu_small">static conf_object_t *
default_attach_snoop(conf_object_t *obj, conf_object_t *clock,
                     ethernet_link_snoop_t snoop_fun, lang_void *user_data)
{
        common_link_t *clink = (common_link_t *)obj;
        attach_snoop_helper(clink, clock);
        attr_value_t attrs = SIM_make_attr_list(0);
        snoop_ep_t *snoop = (snoop_ep_t *)SIMLINK_snoop_endpoint_create(
                snoop_ep_cls, &amp;clink-&gt;obj, clock, attrs);
        SIM_attr_free(&amp;attrs);
        snoop-&gt;snoop_fun = snoop_fun;
        snoop-&gt;user_data = user_data;
        return &amp;snoop-&gt;cep.obj;
}</pre><p>

     </p></dd>
</dl><p>
</p><h2 class="jdocu"><a class="not-numbered" id="link-library-api.html:link_message_t">link_message_t</a></h2>
<p>
   
     <a id="link-library-api.html:link_message_t2"></a>
     </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="link-library-api.html:__jdocu_seealso_link_message_t"></a>link_message_t</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
typedef struct link_message link_message_t;
       </dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Generic part of a link message. This structure should always be the
         first member of the link message data structure, so that the link
         library can access the generic part with a simple cast.
       </dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
The <b>datagram_link</b> example defines its link message in
         the following way:
         <pre class="jdocu_small">typedef struct {
        link_message_t common;               /* should always be first */
        /* The actual data in the message - in our case an allocated
           byte string owned by this structure. */
        bytes_t payload;
} datagram_link_message_t;</pre><p>

       </p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#link-library-api.html:__jdocu_seealso_link_type_t">
         link_type_t</a>, <a class="jdocu" href="#link-library-api.html:__jdocu_seealso_SIMLINK_init_message">
         SIMLINK_init_message
       </a></dd>
</dl><p>
   
   </p><h2 class="jdocu"><a class="not-numbered" id="link-library-api.html:link_type_t">link_type_t</a></h2>
<p>
   
   
     <a id="link-library-api.html:link_type_t2"></a>
     </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="link-library-api.html:__jdocu_seealso_link_type_t"></a>link_type_t</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">typedef struct {
        attr_value_t (*msg_to_attr)(conf_object_t *link, 
                                    const link_message_t *msg);
        link_message_t *(*msg_from_attr)(conf_object_t *link, 
                                         attr_value_t attr);
        void (*free_msg)(conf_object_t *link, link_message_t *msg);

        void (*marshal)(conf_object_t *link, const link_message_t *msg,
                        void (*finish)(void *data, const frags_t *msg),
                        void *finish_data);
        link_message_t *(*unmarshal)(conf_object_t *link, 
                                     const frags_t *msg);

        void (*deliver)(conf_object_t *ep, const link_message_t *msg);

        void (*update_config_value)(conf_object_t *link, const char *key,
                                    const frags_t *value);
        void (*remove_config_value)(conf_object_t *link, const char *key);
        void (*device_changed)(conf_object_t *ep, conf_object_t *old_dev);
} link_type_t;</pre><p>
</p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Functions to be defined by the specific link implementation.
<p>
          These functions can be classified in four groups:
</p><p>
          </p><dl><dt id="link-library-api.html:dt:message-links-manipulation"><a href="#link-library-api.html:dt:message-links-manipulation"><b>Message Links Manipulation</b></a></dt><dd>The first five functions are related to the link-specific
          messages.
<p>
          All five functions can be called in any execution context and should
          be thread-safe. They all take the link object as argument, in case it
          contains information necessary to perform the operation. As the link
          object is shared between the cells in which it is connected, it
          should not be modified during execution. Mutable state should be kept
          in the endpoint objects instead.
</p><p>
          <b><i>msg_to_attr()</i></b> transforms the message <i>msg</i>
          into an <code>attr_value_t</code> value. It is used to checkpoint
          in-flight messages waiting to be delivered. The value returned will
          be passed unchanged as argument <i>attr</i> to
          <b><i>msg_from_attr()</i></b> when loading a checkpoint with pending
          link messages. Neither function is expected to return an error,
          although <b><i>msg_from_attr()</i></b> is allowed to return NULL when
          translating a message it does not care to restore. This can be useful
          to keep checkpoint compatibility with older versions of the same link
          that do not always have the same message protocol.
</p><p>
          Using the <b>datagram_link</b> as an example, the
          <b>datagram-link</b> message is defined as:
</p><p>
          </p><pre class="jdocu_small">typedef struct {
        link_message_t common;               /* should always be first */
        /* The actual data in the message - in our case an allocated
           byte string owned by this structure. */
        bytes_t payload;
} datagram_link_message_t;</pre><p>

</p><p>
          <b><i>msg_to_attr()</i></b> and <b><i>msg_from_attr()</i></b> are thus
          defined as:
</p><p>
          </p><pre class="jdocu_small">static attr_value_t
msg_to_attr(conf_object_t *link, const link_message_t *lm)
{
        const datagram_link_message_t *m = 
                (const datagram_link_message_t *)lm;
        return SIM_make_attr_data(m-&gt;payload.len, m-&gt;payload.data);
}</pre><p>

          </p><pre class="jdocu_small">static link_message_t *
msg_from_attr(conf_object_t *link, attr_value_t attr)
{
        return new_datagram_message(SIM_attr_data(attr),
                                    SIM_attr_data_size(attr));
}</pre><p>

</p><p>
          <b><i>free_msg()</i></b> is called when the message <i>msg</i>
          has been delivered to all its destinations and is no longer
          needed. All memory allocated for <i>msg</i> is expected to be
          freed, including <i>msg</i> itself. The
          <b>datagram_link</b> defines <b><i>free_msg()</i></b> as:
</p><p>
          </p><pre class="jdocu_small">static void
free_msg(conf_object_t *link, link_message_t *lm)
{
        datagram_link_message_t *m = (datagram_link_message_t *)lm;
        MM_FREE((uint8 *)m-&gt;payload.data);
        m-&gt;payload.data = NULL;
        MM_FREE(m);
}</pre><p>

</p><p>
          <b><i>marshal()</i></b> is called when the message <i>msg</i>
          should be transmitted over a distributed simulation. Its purpose is
          to serialize the message into a <code>frags_t</code>
          representation. Rather than returning the marshaled message,
          <b><i>marshal()</i></b> takes the <i>finish</i> and
          <i>finish_data</i> arguments, that it is expected to call
          once the message has been marshaled.
</p><p>
          The reason behind this mechanism is that it allows
          <b><i>marshal()</i></b> to perform its operations with a
          <code>frags_t</code> variable allocated on the stack, and thus to
          skip any heap allocation when sending the message. In case memory was
          allocated anyway, it should be freed just after <i>finish</i>
          has returned.
</p><p>
          </p><pre class="jdocu_small">static void
marshal(conf_object_t *link, const link_message_t *lm,
        void (*finish)(void *data, const frags_t *msg), 
        void *finish_data)
{
        const datagram_link_message_t *m = 
                (const datagram_link_message_t *)lm;

        /* Our message just consists of a byte string, 
           so this is very easy. */
        frags_t buf;
        frags_init_add(&amp;buf, m-&gt;payload.data, m-&gt;payload.len);
        finish(finish_data, &amp;buf);
}</pre><p>

</p><p>
          <b><i>unmarshal()</i></b> does the opposite of <b><i>marshal()</i></b>: it
          takes a serialized <code>frags_t</code> representation of the message
          called <i>data</i> and returns a newly allocated link
          message.
</p><p>
          </p><pre class="jdocu_small">static link_message_t *
unmarshal(conf_object_t *link, const frags_t *data)
{
        size_t len = frags_len(data);
        uint8 bytes[len];
        frags_extract(data, bytes);
        return new_datagram_message(bytes, len);
}</pre><p>

</p><p>
          </p></dd><dt id="link-library-api.html:dt:endpoint-configuration"><a href="#link-library-api.html:dt:endpoint-configuration"><b>Endpoint Configuration</b></a></dt><dd>Link endpoints are created as needed by the link
          component. Depending on how they are created, they may not know yet
          which device they are connected to, so it might not be possible yet,
          for example, to cache the device's communication interface in the
          endpoint's <b><i>finalize()</i></b> function. Additionally, there are
          cases where the device the endpoint talks to may be changed, such as
          when inserting a probe object to listen to the traffic.
<p>
          In all of these cases, the <b><i>device_changed()</i></b> callback will
          be called when the endpoint's device attribute is changed
          <em>and</em> the endpoint has reached to finalize phase. In that
          callback, the new device can be obtained via
          <b><i>SIMLINK_endpoint_device()</i></b> and additional operations, such
          as interface caching, can be safely performed. The old device the
          endpoint was connected to is provided for convenience as an argument
          to <b><i>device_changed()</i></b>.
</p><p>
          Note that if no device related operations are necessary, this
          callback may be left unimplemented.
</p><p>
          The <b>ser_link</b> implementation of
          <b><i>device_changed</i></b> is the following:
</p><p>
          </p><pre class="jdocu_small">static void
ser_link_ep_device_changed(conf_object_t *ep, conf_object_t *old_dev)
{
        ser_link_endpoint_t *slep = (ser_link_endpoint_t *)ep;
        slep-&gt;serial_ifc = SIM_c_get_port_interface(
                SIMLINK_endpoint_device(ep), SERIAL_DEVICE_INTERFACE,
                SIMLINK_endpoint_port(ep));
 
        if (!old_dev) {
                char ep_id[19];
                snprintf(ep_id, sizeof(ep_id), "ep%llx", 
                         SIMLINK_endpoint_id(ep));
                frags_t value;
                frags_init(&amp;value);
                SIMLINK_config_update_value(SIMLINK_endpoint_link(ep), 
                                            ep_id, &amp;value);
        }
}
</pre><p>
</p><p>
   
</p><p>
          </p></dd><dt id="link-library-api.html:dt:message-delivery"><a href="#link-library-api.html:dt:message-delivery"><b>Message Delivery</b></a></dt><dd>Messages are delivered to the link by calling the
          <b><i>deliver()</i></b> function. The arguments of <b><i>deliver()</i></b>
          are the endpoint <i>ep</i> that received the message and the
          message <i>msg</i> itself. The implementation of
          <b><i>deliver()</i></b> is expected to call the correct device's
          function to deliver the message.
<p>
          Note that <b><i>deliver()</i></b> can be called in any execution context
          and should be thread-safe. The link object is shared between the
          cells in which it is connected, and should not be modified during
          execution. Mutable state should be kept in the endpoint objects
          instead.
</p><p>
          The <b>datagram_link</b> implementation of
          <b><i>deliver()</i></b> is the following:
</p><p>
          </p><pre class="jdocu_small">static void
deliver(conf_object_t *ep, const link_message_t *lm)
{
        const datagram_link_message_t *m = 
                (const datagram_link_message_t *)lm;
        conf_object_t *dev = SIMLINK_endpoint_device(ep);
        const char *port = SIMLINK_endpoint_port(ep);
        const datagram_link_interface_t *dli =
                SIM_c_get_port_interface(dev, "datagram_link", port);
        if (dli)
                dli-&gt;receive(dev, m-&gt;payload);
        else
                SIM_LOG_ERROR(ep, 0, "Device does not implement"
                              " datagram_link interface");
}</pre><p>

</p><p>
          </p></dd><dt id="link-library-api.html:dt:configuration"><a href="#link-library-api.html:dt:configuration"><b>Configuration</b></a></dt><dd>The last two functions of <code>link_type_t</code> are taking
          care of the link configuration itself. In the same way messages needs
          to be marshaled when sent over a network, the global link
          configuration needs to be agreed upon when running the simulation in
          several processes. 
<p>
          <b><i>update_config_value()</i></b> is called whenever a configuration
          parameter has been added or updated. The configuration parameter's
          name is provided as <i>key</i> and its new value as
          <i>value</i>, encoded as a <code>frags_t</code>.
</p><p>
          <b><i>remove_config_value()</i></b> is called whenever the configuration
          value <i>key</i> has been removed.
</p><p>
          The interpretation of the link configuration messages is link
          specific. The only configuration parameter that is defined by the
          link library itself is <i>goal_latency</i>. This is handled
          entirely internally, although with the same mechanism as exposed
          here. Configuration changes are initiated by the link objects
          themselves with the Link Library API functions
          <b><i>SIMLINK_config_update_value()</i></b> and
          <b><i>SIMLINK_config_remove_value()</i></b>.
</p><p>
          Note that the link object that initiates the configuration change is
          also called back via <b><i>update_config_value()</i></b> and
          <b><i>remove_config_value()</i></b>. Note also that the configuration
          changes may be buffered and sent later if they are initiated too soon
          for the configuration message to propagate.
</p><p>
          Configuration changes should only be initiated while in Global
          Context, so the two configuration functions above will only be called
          in Global Context. This allows them to modify properties of
          the link object itself without needing to care about thread safety.
</p><p>
          As an example, here is how <b>ser_link</b> defines these two
          functions. The serial link keeps track of all endpoints connected to
          it by saving their ID as a configuration parameter. It also uses a
          configurable buffer size.
</p><p>
          Finally, it is important to note that these two callbacks may be
          called from a non-execution thread. They should call the Simics API
          only via <b><i>SIM_thread_safe_callback()</i></b>. This includes calling
          the <b><i>SIM_log_*</i></b> functions.
</p><p>
          </p><pre class="jdocu_small">static void
link_config_value_updated(conf_object_t *link, const char *key, 
                          const frags_t *msg)
{
        ser_link_impl_t *slink = (ser_link_impl_t *)link;
        if (strncmp(key, "ep", 2) == 0) {
                uint64 ep_id = strtoull(key + 2, NULL, 16);
                SIM_LOG_INFO(4, &amp;slink-&gt;obj, 0,
                             "Add endpoint: 0x%llx", ep_id);
                ht_update_int(&amp;slink-&gt;endpoints, ep_id, NULL);
        } else if (strcmp(key, "buffer_size") == 0) {
                slink-&gt;buffer_size = frags_extract_be32(msg, 0);
        } else {
                ASSERT(false);
        }
}
</pre><p>

          </p><pre class="jdocu_small">static void
link_config_value_removed(conf_object_t *link, const char *key)
{
        ser_link_impl_t *slink = (ser_link_impl_t *)link;
        if (strncmp(key, "ep", 2) == 0) {
                uint64 ep_id = strtoull(key + 2, NULL, 16);
                SIM_LOG_INFO(4, &amp;slink-&gt;obj, 0,
                             "Remove endpoint: 0x%llx", ep_id);
                ht_remove_int(&amp;slink-&gt;endpoints, ep_id);
        } else {
                ASSERT(false);
        }
}
</pre><p>

</p><p>
          </p></dd></dl><p></p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#link-library-api.html:__jdocu_seealso_link_message_t">
         link_message_t</a>, <a class="jdocu" href="#link-library-api.html:__jdocu_seealso_SIMLINK_init">
         SIMLINK_init
       </a></dd>
</dl><p>
   </p></section><section class="page" id="link-component-api.html"><h1 class="jdocu"><a class="not-numbered" id="link-component-api.html:Link-Component-API">Link Component API</a></h1>
<p></p><h2 class="jdocu"><a class="not-numbered" id="link-component-api.html:link_components.create_simple">link_components.create_simple()</a></h2>
<p>
  
  <a id="link-component-api.html:create_simple"></a> <a id="link-component-api.html:link_components-Python-modulecreate_simple"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="link-component-api.html:__jdocu_seealso_link_components.create_simple"></a><b>create_simple</b>  create a simple link component class</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">create_simple(link_class, endpoint_class, connector_type,
              class_desc, basename = None, help_categories = [])</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Create a simple link component class based on the following parameters:
<p>
</p><dl><dt id="link-component-api.html:dt:link_class"><a href="#link-component-api.html:dt:link_class"><b>link_class</b></a></dt><dd>Name of the link implementation class</dd><dt id="link-component-api.html:dt:endpoint_class"><a href="#link-component-api.html:dt:endpoint_class"><b>endpoint_class</b></a></dt><dd>Name of the link endpoint class</dd><dt id="link-component-api.html:dt:connector_type"><a href="#link-component-api.html:dt:connector_type"><b>connector_type</b></a></dt><dd>Name of the connector type for component
                             connections</dd><dt id="link-component-api.html:dt:class_desc"><a href="#link-component-api.html:dt:class_desc"><b>class_desc</b></a></dt><dd>Component description</dd><dt id="link-component-api.html:dt:basename"><a href="#link-component-api.html:dt:basename"><b>basename</b></a></dt><dd>Prefix used to create new component names when none
                       is provided</dd></dl><p></p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
A new component class from which to inherit</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
<pre class="jdocu_small">from link_components import create_simple

class datagram_link(
    create_simple(link_class = 'datagram_link_impl',
                  endpoint_class = 'datagram_link_endpoint',
                  connector_type = 'datagram-link',
                  class_desc = "datagram link",
                  basename = 'datagram_link')):
    """The datagram link component creates a datagram-link, which is a simple
    broadcast bus forwarding messages (as sequences of bytes) from a sender
    device to all other devices present of the link. The datagram-link is both
    an example of how to build a link with the Simics Link Library, and a
    simple broadcast link that can be reused when multi-cell communication
    between devices is necessary. Refer to the &lt;cite&gt;Link Library Programming
    Guide&lt;/cite&gt; for more information."""
</pre><p>
</p></dd>
</dl><p></p><h2 class="jdocu"><a class="not-numbered" id="link-component-api.html:link_components.link_component">link_components.link_component</a></h2>
<p><a id="link-component-api.html:link_component"></a> <a id="link-component-api.html:link_components-Python-modulelink_component"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="link-component-api.html:__jdocu_seealso_link_components.link_component"></a><b>link_component</b>  link components base class</dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Class from which to inherit when creating a new custom link component.</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
<pre class="jdocu_small">class ethernet_switch(link_components.link_component):
    """Ethernet switch: this component represents a switched Ethernet network,
    allowing any number of devices to connect and optimizing the packet routing
    according to what is learned about the MAC addresses talking on the link."""

    _class_desc = 'an Ethernet switch component'
    _help_categories = ['Networking']

    class basename(link_components.link_component.basename):
        val = 'ethernet_switch'

    def create_unconnected_endpoint(self, cnt):
        return create_vlan_switch_endpoint(self.get_slot('link'), None,
                                           None, True)

    def register_connector_templates(self):
        self.eth_tmpl = self.add_link_connector_template(
            name = 'ethernet-link-connector',
            type = 'ethernet-link',
            growing = True,
            create_unconnected_endpoint = self.create_unconnected_endpoint)

    def add_objects(self):
        self.add_pre_obj_with_name('link', 'eth-switch-link',
                                   self.get_link_object_name(),
                                   goal_latency = self.goal_latency.val,
                                   global_id = self.global_id.val)
        self.add_link_connector('device', self.eth_tmpl)</pre><p>
</p></dd>
</dl><p></p><h2 class="jdocu"><a class="not-numbered" id="link-component-api.html:link_components.link_component.add_link_connector">link_components.link_component.add_link_connector()</a></h2>
<p><a id="link-component-api.html:add_link_connector"></a> <a id="link-component-api.html:link_components-Python-modulelink_componentadd_link_connector"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="link-component-api.html:__jdocu_seealso_link_components.link_component.add_link_connector"></a><b>add_link_connector</b>  add a new initial connector</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">add_link_connector(self, slot_template, cnt_tmpl)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Add a new initial connector. The <i>slot_template</i>
argument is the name of the connector in the component. The
<i>cnt_tmpl</i> argument is the template used for the
connector, previously registered with
<b><i>add_connector_template()</i></b>.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
None</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
<pre class="jdocu_small">class ethernet_switch(link_components.link_component):
    """Ethernet switch: this component represents a switched Ethernet network,
    allowing any number of devices to connect and optimizing the packet routing
    according to what is learned about the MAC addresses talking on the link."""

    _class_desc = 'an Ethernet switch component'
    _help_categories = ['Networking']

    class basename(link_components.link_component.basename):
        val = 'ethernet_switch'

    def create_unconnected_endpoint(self, cnt):
        return create_vlan_switch_endpoint(self.get_slot('link'), None,
                                           None, True)

    def register_connector_templates(self):
        self.eth_tmpl = self.add_link_connector_template(
            name = 'ethernet-link-connector',
            type = 'ethernet-link',
            growing = True,
            create_unconnected_endpoint = self.create_unconnected_endpoint)

    def add_objects(self):
        self.add_pre_obj_with_name('link', 'eth-switch-link',
                                   self.get_link_object_name(),
                                   goal_latency = self.goal_latency.val,
                                   global_id = self.global_id.val)
        self.add_link_connector('device', self.eth_tmpl)</pre><p>
</p></dd>
</dl><p></p><h2 class="jdocu"><a class="not-numbered" id="link-component-api.html:link_components.link_component.add_link_connector_template">link_components.link_component.add_link_connector_template()</a></h2>
<p><a id="link-component-api.html:add_link_connector_template"></a> <a id="link-component-api.html:link_components-Python-modulelink_componentadd_link_connector_template"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="link-component-api.html:__jdocu_seealso_link_components.link_component.add_link_connector_template"></a><b>add_link_connector_template</b>  add a link connector template</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">add_link_connector_template(self, name, type, growing,
                            create_unconnected_endpoint,
                            get_check_data    = None,
                            get_connect_data  = None,
                            check             = None,
                            connect           = None,
                            disconnect        = None,
                            allow_new_cnt     = lambda: True,
                            allow_destroy_cnt = lambda: True)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This function registers a new connector template for the component.
From this template, connectors will be created either statically, via
the <b><i>add_objects()</i></b> function, or dynamically if requested.
Component templates can be customized through the parameters of
<b><i>add_link_connector_template()</i></b>:
<p>
</p><dl><dt id="link-component-api.html:dt:name"><a href="#link-component-api.html:dt:name"><b>name</b></a></dt><dd>is the name of the template, which will be saved in
  each connector, so that they can find out from which template they
  were created.</dd><dt id="link-component-api.html:dt:type"><a href="#link-component-api.html:dt:type"><b>type</b></a></dt><dd>is the connector type.</dd><dt id="link-component-api.html:dt:growing"><a href="#link-component-api.html:dt:growing"><b>growing</b></a></dt><dd>indicates whether the connector is static, or
  should grow dynamically as connections are made. Static connectors
  must be created in <b><i>add_objects()</i></b>, and will act as classic
  component connectors. A dynamic connector will make sure that there
  is always a free connector of that template available, by increasing
  or decreasing the number of connectors of this template in the link.
  Note that several templates can have the same connector type. Each
  template will make sure that its connectors grow or shrink
  separately.</dd><dt id="link-component-api.html:dt:create_unconnected_endpoint"><a href="#link-component-api.html:dt:create_unconnected_endpoint"><b>create_unconnected_endpoint</b></a></dt><dd>is the function to call when
  a new endpoint pre-conf-object must be created. This endpoint is not
  yet connected to a device.</dd><dt id="link-component-api.html:dt:get_check_data"><a href="#link-component-api.html:dt:get_check_data"><b>get_check_data</b></a></dt><dd>(optional) is called whenever the
  standard <b><i>get_check_data()</i></b> is called. It may return any
  <em>additional</em> data necessary for the check() call. The standard
  <b><i>get_check_data()</i></b> will already return the endpoint
  object.</dd><dt id="link-component-api.html:dt:get_connect_data"><a href="#link-component-api.html:dt:get_connect_data"><b>get_connect_data</b></a></dt><dd>(optional) is similar to
  <b><i>get_check_data</i></b>, but for the <b><i>connect()</i></b>
  call.</dd><dt id="link-component-api.html:dt:check"><a href="#link-component-api.html:dt:check"><b>check</b></a></dt><dd>(optional) is called whenever the standard
  <b><i>check()</i></b> is called. It may return <code>True</code>
  (connection accepted) or <code>False</code> (connection refused).
  The standard implementation returns always <code>True</code>.</dd><dt id="link-component-api.html:dt:connect"><a href="#link-component-api.html:dt:connect"><b>connect</b></a></dt><dd>(optional) is called whenever the standard
  <b><i>connect()</i></b> is called. The standard <b><i>connect()</i></b>
  will set the device attribute in the endpoint. <b><i>connect</i></b> may
  take any additional action it deems necessary.</dd><dt id="link-component-api.html:dt:disconnect"><a href="#link-component-api.html:dt:disconnect"><b>disconnect</b></a></dt><dd>(optional) is called whenever the standard
  <b><i>disconnect()</i></b> is called. The standard
  <b><i>disconnect()</i></b> does not do anything as the endpoint object
  will be destroyed soon after. <b><i>disconnect()</i></b> may take any
  additional action for the disconnection to succeed.</dd><dt id="link-component-api.html:dt:allow_new_nct"><a href="#link-component-api.html:dt:allow_new_nct"><b>allow_new_nct</b></a></dt><dd>(optional) is used only for growing
  connectors. It is called every time a new connection is made to ask
  if creating a new empty connector is allowed. It may return
  <code>True</code> (new connector allowed) or <code>False</code>
  (no new connector). The default function always returns
  <code>True</code> (unlimited number of connectors allowed, with
  always one free).</dd><dt id="link-component-api.html:dt:allow_destroy_cnt"><a href="#link-component-api.html:dt:allow_destroy_cnt"><b>allow_destroy_cnt</b></a></dt><dd>(optional) is used only for growing
  connectors. It is called every time a connection is severed to ask if
  the connector being disconnected should be destroyed. It may return
  <code>True</code> (destroy the connector) or <code>False</code>
  (let the connector). The endpoint object associated will be
  automatically destroyed with the connector, or replaced if the
  connector is left. The default function returns always
  <code>True</code> (unlimited number of connectors allowed, with
  always one free).</dd></dl><p></p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
The registered connector template</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
<pre class="jdocu_small">class ethernet_cable(link_components.link_component):
    """Ethernet cable: this component represents a two-points Ethernet cable,
    allowing two devices to connect to each other."""

    _class_desc = 'an Ethernet cable component'
    _help_categories = ['Networking']

    class basename(link_components.link_component.basename):
        val = 'ethernet_cable'

    class connector_count(SimpleAttribute(0, 'i')):
        """Total number of occupied connectors"""

    def allow_new_connector(self):
        if self.connector_count.val == 2:
            # all connectors are occupied
            return False
        elif self.connector_count.val == 1:
            # there is already one free connector
            self.connector_count.val += 1
            return False
        else:
            self.connector_count.val += 1
            return True

    def allow_destroy_connector(self):
        if self.connector_count.val == 2:
            # two connectors occupied, so let one become free
            self.connector_count.val -= 1
            return False
        else:
            # one connector was occupied, one free, so destroy one
            self.connector_count.val -= 1
            return True

    def create_unconnected_endpoint(self, cnt):
        return create_cable_endpoint(self.get_slot('link'), None)

    def register_connector_templates(self):
        self.eth_tmpl = self.add_link_connector_template(
            name = 'single-ethernet-link-connector',
            type = 'ethernet-link',
            growing = True,
            create_unconnected_endpoint = self.create_unconnected_endpoint,
            allow_new_cnt = self.allow_new_connector,
            allow_destroy_cnt = self.allow_destroy_connector)

    def add_objects(self):
        self.add_pre_obj_with_name('link', 'eth-cable-link',
                                   self.get_link_object_name(),
                                   goal_latency = self.goal_latency.val,
                                   global_id = self.global_id.val)
        self.add_link_connector('device', self.eth_tmpl)</pre><p>
</p></dd>
</dl><p></p><h2 class="jdocu"><a class="not-numbered" id="link-component-api.html:link_components.link_component.add_objects">link_components.link_component.add_objects()</a></h2>
<p><a id="link-component-api.html:add_objects"></a> <a id="link-component-api.html:link_components-Python-modulelink_componentadd_objects"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="link-component-api.html:__jdocu_seealso_link_components.link_component.add_objects"></a><b>add_objects</b>  add link object and initial connectors</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">add_objects(self)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This function should be overridden when inheriting from
<b>link_component</b>. It is expected to create a
pre-conf-object for the link and to add the initial connectors of the
component using <b><i>link_component.add_link_connector()</i></b>.
<b><i>add_objects()</i></b> is only called when creating a component from
scratch; when restoring a checkpoint, objects are assumed to have
already been created.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
None</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
<pre class="jdocu_small">class ethernet_switch(link_components.link_component):
    """Ethernet switch: this component represents a switched Ethernet network,
    allowing any number of devices to connect and optimizing the packet routing
    according to what is learned about the MAC addresses talking on the link."""

    _class_desc = 'an Ethernet switch component'
    _help_categories = ['Networking']

    class basename(link_components.link_component.basename):
        val = 'ethernet_switch'

    def create_unconnected_endpoint(self, cnt):
        return create_vlan_switch_endpoint(self.get_slot('link'), None,
                                           None, True)

    def register_connector_templates(self):
        self.eth_tmpl = self.add_link_connector_template(
            name = 'ethernet-link-connector',
            type = 'ethernet-link',
            growing = True,
            create_unconnected_endpoint = self.create_unconnected_endpoint)

    def add_objects(self):
        self.add_pre_obj_with_name('link', 'eth-switch-link',
                                   self.get_link_object_name(),
                                   goal_latency = self.goal_latency.val,
                                   global_id = self.global_id.val)
        self.add_link_connector('device', self.eth_tmpl)</pre><p>
</p></dd>
</dl><p></p><h2 class="jdocu"><a class="not-numbered" id="link-component-api.html:link_components.link_component.get_link_object_name">link_components.link_component.get_link_object_name()</a></h2>
<p><a id="link-component-api.html:get_link_object_name"></a> <a id="link-component-api.html:link_components-Python-modulelink_componentget_link_object_name"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="link-component-api.html:__jdocu_seealso_link_components.link_component.get_link_object_name"></a><b>get_link_object_name</b>  return a unique link object name</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">get_link_object_name(self)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Return a unique link object name based on the link component name.
This is useful for ensuring that all link components with the same name
in a distributed simulation will indeed represent the same link.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
A unique link name</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
<pre class="jdocu_small">class ethernet_switch(link_components.link_component):
    """Ethernet switch: this component represents a switched Ethernet network,
    allowing any number of devices to connect and optimizing the packet routing
    according to what is learned about the MAC addresses talking on the link."""

    _class_desc = 'an Ethernet switch component'
    _help_categories = ['Networking']

    class basename(link_components.link_component.basename):
        val = 'ethernet_switch'

    def create_unconnected_endpoint(self, cnt):
        return create_vlan_switch_endpoint(self.get_slot('link'), None,
                                           None, True)

    def register_connector_templates(self):
        self.eth_tmpl = self.add_link_connector_template(
            name = 'ethernet-link-connector',
            type = 'ethernet-link',
            growing = True,
            create_unconnected_endpoint = self.create_unconnected_endpoint)

    def add_objects(self):
        self.add_pre_obj_with_name('link', 'eth-switch-link',
                                   self.get_link_object_name(),
                                   goal_latency = self.goal_latency.val,
                                   global_id = self.global_id.val)
        self.add_link_connector('device', self.eth_tmpl)</pre><p>
</p></dd>
</dl><p></p><h2 class="jdocu"><a class="not-numbered" id="link-component-api.html:link_components.link_component.register_connector_templates">link_components.link_component.register_connector_templates()</a></h2>
<p><a id="link-component-api.html:register_connector_templates"></a> <a id="link-component-api.html:link_components-Python-modulelink_componentregister_connector_templates"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="link-component-api.html:__jdocu_seealso_link_components.link_component.register_connector_templates"></a><b>register_connector_templates</b>  register connector templates</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">register_connector_templates(self)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This function should be overridden when inheriting from
<b>link_component</b>. It is expected to register the connector
templates that will be used in <b><i>add_objects()</i></b>. Unlike
<b><i>add_objects()</i></b>, this function is always called when creating
the component, either from scratch or when restoring a checkpoint.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
None</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
<pre class="jdocu_small">class ethernet_switch(link_components.link_component):
    """Ethernet switch: this component represents a switched Ethernet network,
    allowing any number of devices to connect and optimizing the packet routing
    according to what is learned about the MAC addresses talking on the link."""

    _class_desc = 'an Ethernet switch component'
    _help_categories = ['Networking']

    class basename(link_components.link_component.basename):
        val = 'ethernet_switch'

    def create_unconnected_endpoint(self, cnt):
        return create_vlan_switch_endpoint(self.get_slot('link'), None,
                                           None, True)

    def register_connector_templates(self):
        self.eth_tmpl = self.add_link_connector_template(
            name = 'ethernet-link-connector',
            type = 'ethernet-link',
            growing = True,
            create_unconnected_endpoint = self.create_unconnected_endpoint)

    def add_objects(self):
        self.add_pre_obj_with_name('link', 'eth-switch-link',
                                   self.get_link_object_name(),
                                   goal_latency = self.goal_latency.val,
                                   global_id = self.global_id.val)
        self.add_link_connector('device', self.eth_tmpl)</pre><p>
</p></dd>
</dl><p></p></section><section class="page" id="processor-api.html"><h1 class="jdocu"><a id="processor-api.html:Processor-API">9 Processor API</a></h1>
<p>

</p><p>
    Refer to the <em>Processor Model Integration Guide</em> for
    more information.
</p><p>
    
</p><p>
    
</p></section><section class="page" id="interfaces.html"><h1 class="jdocu"><a id="interfaces.html:Interfaces">9.1 Interfaces</a></h1>
<p>

</p><p>
This section lists the interfaces that can be implemented by the
processor model to enable certain Simics features. They are not required,
but implementing them will allow user defined processor models to
support the same generic feature set as Simics standard processor
models. If you intend to plug your model into an existing
Simics-provided platform, then many of these interfaces are actually
required for such a platform to function.
</p><p>
</p><h2 class="jdocu"><a class="not-numbered" id="interfaces.html:Processor-Info-Interface">Processor Info Interface</a></h2>
<p>

<a id="interfaces.html:processor_info"></a>
<a id="interfaces.html:processor_info_v2"></a>
The <code>processor_info_v2</code> interface is implemented by
   processors models. The interface has processor generic functions
   that are architecture independent.
</p><p>
   The <b><i>disassemble</i></b> function returns the disassemble string for an
   instruction at <i>address</i> with opcode according to
   <i>instruction_data</i>. The <i>instruction_data</i> is an
   <em>attr_value_t</em> value of <em>data</em> type with the bytes of the
   opcode. The bytes are in the same order as they are stored in memory. For
   VLIW architectures, <i>sub_operation</i> is used to select which
   sub-operation to disassemble. The sub-operations start at zero, and a
   request for the entire unit including all sub-operations is encoded with
   sub-operation -1. A request for a sub-operation that is not present (for
   example when <i>sub-operation</i> is neither 0 nor -1 for non-VLIW
   architectures) results in the integer part of the return tuple being set to
   zero. If successful, the function should return a tuple with the size of the
   instruction in bytes and the disassembly string. The disassembly string
   should be allocated with MM_MALLOC or similar and is to be freed by the
   caller. If more bytes are needed, then the function should indicate that by
   returning a negative number in the tuple where the absolute value of the
   number is the required number of bytes. The string should be NULL if more
   bytes are needed. The implementor of <code>processor_info_v2</code> is
   allowed to request one additional byte at a time until enough bytes are
   passed to determine what the instruction is. Illegal instructions should
   still result in a valid returned tuple, where the integer part will be used
   by the disassemble command to skip that many bytes before disassembling the
   next instruction. The <i>address</i> can be used to display absolute
   destinations of program counter relative branches.
</p><p>
   The <b><i>set_program_counter</i></b> function sets the program
   counter in the processor. The <b><i>get_program_counter</i></b>
   function returns the current program counter.
</p><p>
   The <b><i>logical_to_physical</i></b> function translates a logical
   <i>address</i> to a physical address of the type defined by
   <i>access_type</i>. The function returns a <em>physical_block_t</em>
   struct with <i>valid</i> bit and the <i>address</i>. The
   address is valid when the valid bit is not <code>0</code>. The
   <b><i>logical_to_physical</i></b> function also returns
   <i>block_start</i> and <i>block_end</i>. The start and end
   of a block has the same logical to physical transformation as the translated
   address. The range is inclusive, so block_end should be the
   address of the last byte of the block.
   This information can be used to figure out how often the
   logical_to_physical function needs to be called. An implementation would
   typically return the page start and end here, but it is free to return any
   power of 2 sized block as long as it includes the translated address.
</p><p>
   The current operating mode of the processor is returned with
   <b><i>get_processor_mode</i></b>.
</p><p>
   The processor can be enabled or disabled with the
   <b><i>enable_processor</i></b> or <b><i>disable_processor</i></b>
   functions. The functions should return <code>0</code> if the processor
   changed from enabled to disabled or from disabled to enabled, and
   <code>1</code> if the processor did not change state. The current state
   is returned by the <b><i>get_enabled</i></b> function. Enabled or
   disabled here refers to the state that the user of the model has
   put the processor into. In particular, it is independent of the
   power mode of the processor. A processor that has powered down does
   not count as disabled in this sense, nor does the
   <b><i>enable_processor</i></b> wake up a processor that is in
   a power-saving sleep state.
</p><p>
   The endianness of the processor is returned by the
   <b><i>get_endian</i></b> function.
</p><p>
   The physical memory object is returned by the
   <b><i>get_physical_memory</i></b> function. The object returned by
   <b><i>get_physical_memory</i></b> is used to set breakpoints by the
   global <b>break</b> command, and to read and write physical
   memory through <b>set</b>, <b>get</b>,
   <b>load-binary</b>, <b>load-file</b>, and the default
   implementation of <b>disassemble</b>. The object returned
   implements the <code>memory_space</code> and
   <code>breakpoint</code> interfaces. The
   <code>memory_space</code> interface for the returned object is
   only be used in inquiry mode corresponding to actions by the
   simulator itself rather than by the simulated software. An
   implementation may return NULL from this method, which will lead to
   the command listed above not being supported when such a processor
   is selected.
</p><p>
   The <b><i>get_logical_address_width</i></b> function returns the
   number of logical/virtual address bits and the
   <b><i>get_physical_address_width</i></b> function returns the number
   of physical address bits.
</p><p>
   The processor architecture is returned by calling the
   <b><i>architecture</i></b> function. The architecture should be one of
   <code>arm</code>, <code>mips32</code>,
   <code>mips64</code>, <code>ppc32</code>, <code>ppc64</code>, <code>sparc-v8</code>,
   <code>sparc-v9</code>, <code>x86</code>, <code>x86-64</code>, or something else
   if none of the listed is a good match.
</p><p>
   All functions in the interface are optional. Each function can be
   set to NULL if it is not supported.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(processor_info_v2) {
        tuple_int_string_t (*disassemble)(conf_object_t *obj,
                                          generic_address_t address,
                                          attr_value_t instruction_data,
                                          int sub_operation);
        void (*set_program_counter)(conf_object_t *obj,
                                    logical_address_t pc);
        logical_address_t (*get_program_counter)(conf_object_t *obj);
        physical_block_t (*logical_to_physical)(conf_object_t *obj,
                                                logical_address_t address,
                                                access_t access_type);
        processor_mode_t (*get_processor_mode)(conf_object_t *obj);
        int (*enable_processor)(conf_object_t *obj);
        int (*disable_processor)(conf_object_t *obj);
        int (*get_enabled)(conf_object_t *obj);

        cpu_endian_t (*get_endian)(conf_object_t *obj);
        conf_object_t *(*get_physical_memory)(conf_object_t *obj);

        int (*get_logical_address_width)(conf_object_t *obj);
        int (*get_physical_address_width)(conf_object_t *obj);

        const char *(*architecture)(conf_object_t *obj);
};

#define PROCESSOR_INFO_V2_INTERFACE "processor_info_v2"
</pre><p>
</p><p>

   Note that the original version of this interface
   (<code>processor_info</code>) must also be implemented. The only
   difference between the two interfaces is that the original version lacks the
   <b><i>get_processor_mode</i></b> function.
</p><p>
   

</p><h2 class="jdocu"><a class="not-numbered" id="interfaces.html:Processor-CLI-Interface">Processor CLI Interface</a></h2>
<p>

<a id="interfaces.html:processor_cli"></a>
Some commands and features in the CLI use the
   <code>processor_cli</code> interface. Those commands will have
   limited functionality if the interface is not fully implemented.
</p><p>
   The first argument to each function is the object to act on. This object
   should implement both the <code>processor_info</code> interface and the
   <code>processor_cli</code> interface.
</p><p>
   The <b><i>get_disassembly</i></b> function is used for the
   <b>disassemble</b> command as well as to disassemble the next
   instruction to be executed, when control is returned to the CLI prompt. For
   most architectures, <b><i>get_disassembly</i></b> can be set to NULL, in which
   case the command will use other interfaces to provide a generic
   disassembly. The <b><i>get_disassembly</i></b> function should return a tuple
   with the length of the instruction in bytes and the disassembly string. The
   <i>addr_prefix</i> parameter selects the address type of the address
   parameter, whether it is a physical address ("p"), a linear address ("l") or
   a virtual address ("v"), just as returned from
   <b><i>get_address_prefix</i></b>. The <i>address</i> parameter is the
   program counter for the instruction to disassemble. If
   <i>print_cpu</i> is non-zero, then the name of the processor should
   be included first in the disassembly line. If <i>mnemonic</i> is not
   NULL, then it should be output instead of the instruction disassemble. The
   mnemonic is used to print exception or interrupt information as returned by
   the <b><i>get_pending_exception_string</i></b> function.
</p><p>
   <b><i>get_pregs</i></b> returns the string to output in the CLI for the
   <b>print-processor-registers</b> command. The <i>all</i>
   parameter is a boolean corresponding to the <i>-all</i> switch to the
   <b>print-processor-registers</b> command.
</p><p>
   The <b><i>diff_regs</i></b> function is used by the <b>stepi</b>
   command when the <i>-r</i> flag is used. The
   <b><i>diff_regs</i></b> function returns a list of register names,
   where each register in that list will be read through the
   <code>int_register</code> interface before and after an
   instruction.
</p><p>
   When returning to the CLI prompt, information about the next
   instruction or step to execute is printed. Normally, that is the
   disassemble of the instruction at the current program counter. The
   <b><i>get_pending_exception_string</i></b> function is called before
   the disassembly to find out if the next step will not be an
   instruction, but rather a taken exception or interrupt. The
   function should inspect the given <i>cpu</i> (an object
   implementing <code>processor_info</code> and
   <code>processor_cli</code>) and return NULL if the next step will
   be the execution of the instruction at the current program
   counter. If the next step will instead be the handling of an
   exception or interrupt, then a string saying that should be
   returned.
</p><p>
   The <b><i>get_address_prefix</i></b> function returns a string with
   the default address prefix for memory related commands. Simics
   defines the generic prefixes "v" for virtual addresses, "l" for
   linear addresses, and "p" for physical addresses. The default if
   <b><i>get_address_prefix</i></b> is NULL is "v" for virtual addresses.
</p><p>
   <b><i>translate_to_physical</i></b> translates an address to a
   physical address. If <b><i>translate_to_physical</i></b> is NULL, then
   the only allowed address prefixes are "v" (virtual) and "p"
   (physical), and the <b><i>logical_to_physical</i></b> function in the
   <code>processor_info</code> interface will be used to translate
   virtual addresses.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(processor_cli) {
	tuple_int_string_t (*get_disassembly)(conf_object_t *obj,
                                              const char *addr_prefix,
                                              generic_address_t address,
                                              bool print_cpu,
                                              const char *mnemonic);
	char *(*get_pregs)(conf_object_t *cpu,
                           bool all);
	attr_value_t (*get_diff_regs)(conf_object_t *obj);
	char *(*get_pending_exception_string)(conf_object_t *obj);
	char *(*get_address_prefix)(conf_object_t *obj);
	physical_block_t (*translate_to_physical)(conf_object_t *obj,
                                                  const char *prefix,
                                                  generic_address_t address);
};

#define PROCESSOR_CLI_INTERFACE "processor_cli"
</pre><p>
</p><p>
   

</p><h2 class="jdocu"><a class="not-numbered" id="interfaces.html:Processor-GUI-Interface">Processor GUI Interface</a></h2>
<p>

<a id="interfaces.html:processor_gui"></a>
The <code>processor_gui</code> interface is implemented by
   processors that support displays in the Simics native GUI. It is
   only registered to indicate support for the displays, and does not
   contain any actual functionality.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(processor_gui) {
        void (*dummy)(conf_object_t *obj);
};

#define PROCESSOR_GUI_INTERFACE "processor_gui"
</pre><p>
</p><p>
   

</p><h2 class="jdocu"><a class="not-numbered" id="interfaces.html:Step-Interface">Step Interface</a></h2>
<p>

<a id="interfaces.html:step"></a>
The <code>step</code> interface is typically implemented by
  processors, but can be implemented by other objects as well. Its
  purpose is to handle step events using a queue.
</p><p>
  The current number of steps for the <i>queue</i> is returned
  when calling <b><i>get_step_count</i></b>.
</p><p>
  The <b><i>post_step</i></b> function will schedule an event that will
  occur after <i>steps</i> (which must be nonnegative)
  counted from local current step at
  <i>queue</i>. An event previously posted can be removed by
  calling <b><i>cancel_step</i></b>. The <b><i>cancel_step</i></b> function takes a
  function <i>pred</i> as argument which is called when a matching
  event is found. The event is only removed if <i>pred</i> returns
  <code>1</code>. The <b><i>find_next_step</i></b> takes the same arguments
  as <b><i>cancel_step</i></b> but only returns the number of cycles before
  the event will occur. The <i>evclass</i> is the event class,
  <i>obj</i> is the object posting the event, and
  <i>user_data</i> is pointer to data used as a parameter when
  calling the callback function defined in the <i>evclass</i>.
  If no matching event was found, <b><i>find_next_step</i></b> returns
  1.
</p><p>
  The <b><i>events</i></b> method returns a list of all pending events in
  expiration order. Each element is a four-element list containing the event
  object, the event class name, the expiration time counted in steps as an
  integer and the event description as given by the event class
  <b><i>describe</i></b> method, or <em>nil</em> for events whose event class do
  not define that method.
</p><p>
  The <b><i>advance</i></b> function will increment the number of steps
  for the queue, decrementing the number of steps to the first event
  to the value defined by <i>steps</i>. The number of steps remaining
  to the next event is returned. It is an error to advance beyond the
  next pending event, so the return value is never negative.
</p><p>
  The implementor of the <code>step</code> interface can use any
  checkpoint representation. The <i>name</i> field in the
  event class data structure is unique, and the attribute setter
  function for checkpoint restore can use
  <b><i>SIM_get_event_class</i></b> to get the event class structure
  corresponding to an event class name.
</p><p>
  </p><pre class="jdocu_small">SIM_INTERFACE(step) {
        pc_step_t (*get_step_count)(conf_object_t *NOTNULL queue);
        void (*post_step)(
                conf_object_t *NOTNULL queue,
                event_class_t *NOTNULL evclass,
                conf_object_t *NOTNULL obj,
                pc_step_t steps,
                lang_void *user_data);
        void (*cancel_step)(
                conf_object_t *NOTNULL queue,
                event_class_t *NOTNULL evclass,
                conf_object_t *NOTNULL obj,
                int (*pred)(lang_void *data, lang_void *match_data),
                lang_void *match_data);
        pc_step_t (*find_next_step)(
                conf_object_t *NOTNULL queue,
                event_class_t *NOTNULL evclass,
                conf_object_t *NOTNULL obj,
                int (*pred)(lang_void *data, lang_void *match_data),
                lang_void *match_data);

        attr_value_t (*events)(conf_object_t *NOTNULL obj);

        pc_step_t (*advance)(conf_object_t *queue, pc_step_t steps);
};

#define STEP_INTERFACE "step"
</pre><p>
</p><p>
  

</p><h2 class="jdocu"><a class="not-numbered" id="interfaces.html:Step-Cycle-Ratio-Interface">Step-Cycle-Ratio Interface</a></h2>
<p>

<a id="interfaces.html:step_cycle_ratio"></a>
The <code>step_cycle_ratio</code> interface is implemented by
  processors that support a changeable ratio between steps and
  cycles. The <b>set-step-rate</b> command uses this interface to
  set the ratio between steps and cycles.
</p><p>
  The <b><i>set_ratio</i></b> sets the ratio between <i>steps</i> and
  <i>cycles</i>. Note that the introduction of stall cycles can
  skew the ratio. The <b><i>get_ratio</i></b> simply returns the current
  ratio.
</p><p>
  The <i>cycles</i> and <i>step</i> arguments must be in the range
  [1..128] and <i>cycles</i> must be a power of two. Implementers of this
  interface may choose to ignore other values of <i>cycles</i> and
  <i>step</i> and may log an error.
</p><p>
  </p><pre class="jdocu_small">typedef struct {
        uint32 steps;
        uint32 cycles;
} step_cycle_ratio_t;

SIM_INTERFACE(step_cycle_ratio) {
        step_cycle_ratio_t (*get_ratio)(conf_object_t *obj);
        void (*set_ratio)(conf_object_t *obj, uint32 steps, uint32 cycles);
};

#define STEP_CYCLE_RATIO_INTERFACE "step_cycle_ratio"
</pre><p>
</p><p>
  

</p><h2 class="jdocu"><a class="not-numbered" id="interfaces.html:Stall-Interface">Stall Interface</a></h2>
<p>

<a id="interfaces.html:stall"></a>
The <code>stall</code> interface can be implemented by objects that also
  implement the <code>cycle</code> and <code>step</code> interfaces. The
  <code>stall</code> interface controls the addition of extra cycles between
  steps.
</p><p>
  The <b><i>get_stall_cycles</i></b> function returns the remaining number of
  stall cycles. The object will advance that number of cycles before starting
  with the next step.
</p><p>
  The <b><i>set_stall_cycles</i></b> function is used to change the number of
  stall cycles before the next step. It is legal to first call this function
  with a large value for <i>cycles</i> and then at a later point reduce the
  cycle count is resume execution earlier than indicated by the first call.
</p><p>
  The <b><i>get_total_stall_cycles</i></b> returns the total accumulated number of
  stall cycles.
</p><p>
  </p><pre class="jdocu_small">SIM_INTERFACE(stall) {
        cycles_t (*get_stall_cycles)(conf_object_t *obj);
        void (*set_stall_cycles)(conf_object_t *obj, cycles_t cycles);
        cycles_t (*get_total_stall_cycles)(conf_object_t *obj);
};
#define STALL_INTERFACE "stall"
</pre><p>
</p><p>
  

</p><h2 class="jdocu"><a class="not-numbered" id="interfaces.html:Register-Interface">Register Interface</a></h2>
<p>

<a id="interfaces.html:int_register"></a>
<a id="interfaces.html:Sim_RegInfo_Catchable"></a>
The <code>int_register</code>
   interface is used for access to registers in a processor.  It
   can be used to access any kind of integer register, not only the
   "normal" registers.  This includes all kinds of control registers,
   hidden registers and anything else that might be useful to access as
   a register.  The only limitation is that the register value should
   be representable as a 64-bit unsigned integer.
</p><p>
   This interface can be implemented by other classes than processors,
   but it is likely to be found mostly in processors.
 </p><p>
   Registers are identified by a number, and there are two functions
   to translate from register names to register numbers and back.  The
   translation need not be one-to-one, which means that one register
   can have several names.  A register name can, however, only
   translate to a single register number.
</p><p>
   Often, registers are grouped in <i>register banks</i>, where
   registers in the bank are numbered from 0 up. Registers in a bank
   should have consecutive numbers (unless their numbering is very sparse).
   This allows a user to deduce register numbers by calling
   <b><i>get_number</i></b> for the first register only.
   The first register numbers should be used for the general-purpose integer 
   registers, if possible (so that integer register <b>r</b>N has number N).
</p><p>
   Using this interface to read or write registers does not cause any
   side effects, such as triggering interrupts or signalling haps.
</p><p>
   <b>get_number</b> translates a register name to its number. Returns -1 if
   the register does not exist.
</p><p>
   <b>get_name</b> translates a register number to its canonical name.
</p><p>
   <b>read</b> reads a register value.
</p><p>
   <b>write</b> writes a new register value.
</p><p>
   <b>all_registers</b> returns a list of all register numbers that can
   be used for this object.
</p><p>
   <b>register_info</b> returns information about a single register.
   The information return depends on the <i>info</i> parameter.
</p><p>
   </p><dl><dt id="interfaces.html:dt:sim_reginfo_catchable"><a href="#interfaces.html:dt:sim_reginfo_catchable"><b>Sim_RegInfo_Catchable</b></a></dt><dd>Return 1 if
   <code>Core_Control_Register_Write</code> and
   <code>Core_Control_Register_Read</code> are triggered when this
   register is written or read.</dd>Return 0 otherwise.

   </dl><p><span class="jdocu_small">
   <a id="interfaces.html:ireg_info_t"></a></span></p><pre class="jdocu_small">typedef enum {
        Sim_RegInfo_Catchable
} ireg_info_t;</pre><p>

</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(int_register) {
        int (*get_number)(conf_object_t *NOTNULL obj,
                          const char *NOTNULL name);
        const char *(*get_name)(conf_object_t *NOTNULL obj, int reg);
        uint64 (*read)(conf_object_t *NOTNULL obj, int reg);
        void (*write)(conf_object_t *NOTNULL obj, int reg, uint64 val);
        attr_value_t (*all_registers)(conf_object_t *NOTNULL obj);
        int (*register_info)(conf_object_t *NOTNULL obj, int reg,
                             ireg_info_t info);
};

#define INT_REGISTER_INTERFACE "int_register"
</pre><p>
</p><p>
   
</p><p>
   

</p><h2 class="jdocu"><a class="not-numbered" id="interfaces.html:Decoder-Interface">Decoder Interface</a></h2>
<p>


   <a id="interfaces.html:decoder_interface_t"></a>
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(decoder) {
        void (*register_decoder)(conf_object_t *obj, 
                                 decoder_t *NOTNULL decoder);
        void (*unregister_decoder)(conf_object_t *obj, 
                                   decoder_t *NOTNULL decoder);
};</pre><p>
</p><p>

   The <code>decoder</code> interface is implemented by processors
   that allows connecting user decoders. This allows a user to
   implement the semantics of instructions that are not available in
   the standard Simics model or change the semantics of instructions
   implemented by Simics. This interface replaces
   <b><i>SIM_register_arch_decoder</i></b> and
   <b><i>SIM_unregister_arch_decoder</i></b> functions.
</p><p>
   The <b><i>register_decoder</i></b> function adds a decoder and
   <b><i>unregister_decoder</i></b> removes a decoder.
</p><p>
   The decoder is installed/removed for every object of the same class as the
   <i>obj</i> argument which must be the same object from
   which the interface was fetched.
</p><p>
   When Simics decodes an instruction, it will first see if any
   instruction decoders are registered for the current CPU class.
   For any decoders it finds, Simics will let it try to decode the
   instruction.  The decoders are called in order, starting with the
   last registered decoder, and if one decoder accepts the instruction,
   the rest of the decoders will not be called.
</p><p>
   The decoder is specified by the <code>decoder_t</code> data structure that the 
   user supplies:
</p><p>
   
   </p><pre class="jdocu_small">typedef struct {
        void *user_data;
        int (*NOTNULL decode)(uint8 *code,
                              int valid_bytes,
                              conf_object_t *cpu,
                              instruction_info_t *ii,
                              void *user_data);
        tuple_int_string_t (*NOTNULL disassemble)(uint8 *code,
                                                  int valid_bytes,
                                                  conf_object_t *cpu,
                                                  void *user_data);
        int (*NOTNULL flush)(instruction_info_t *ii,
                             void *user_data);
} decoder_t;</pre><p>
</p><p>
   <a id="interfaces.html:decoder_t"></a>
</p><p>
   The <b><i>decode</i></b> function is called to decode an instruction
   pointed to by <i>code</i>.  The first byte corresponds to
   the lowest address of the instruction in the simulated
   memory. <i>valid_bytes</i> tells how many bytes can be
   read. The CPU is given in the <i>cpu</i> parameter.  When
   the decoder has successfully decoded an instruction, it should set
   the <i>ii_ServiceRoutine</i>, the <i>ii_Arg</i>, and the
   <i>ii_Type</i> members of the <i>ii</i> structure (see
   below), and returns the number of bytes used in the decoding.  If
   it does not apply to the given instruction, it should return zero.
   If the decoder needs more data than <i>valid_bytes</i> it
   should return a negative number corresponding to the total number
   of bytes it will need to continue the decoding. The underlying
   architecture limits the number of bytes that can be requested,
   e.g. no more than 4 bytes can be requested on most RISC
   architectures. Simics will call the decoder again when more bytes
   are available. This process is repeated until the decoder accepts
   or rejects the instruction.  A decoder should never request more
   data than it needs. For example, if an instructions can be rejected
   by looking at the first byte, the decoder should never ask for more
   bytes.
</p><p>
   The <code>instruction_info_t</code> is defined as follows:
</p><p>
   
   </p><pre class="jdocu_small">typedef struct instruction_info {
        service_routine_t  ii_ServiceRoutine;
        uint64             ii_Arg;
        unsigned int       ii_Type;
        lang_void         *ii_UserData;
        logical_address_t  ii_LogicalAddress;
        physical_address_t ii_PhysicalAddress;
} instruction_info_t;</pre><p>
</p><p>
   <a id="interfaces.html:instruction_info_t"></a>
</p><p>
   <i>ii_ServiceRoutine</i> is a pointer to a function that will
   be called by Simics every time the instruction is executed. It has
   the following prototype:
   </p><p>
   
   </p><pre class="jdocu_small">typedef exception_type_t (*service_routine_t)(conf_object_t *cpu, 
                                              uint64 arg,
                                              lang_void *user_data);</pre><p>
<a id="interfaces.html:service_routine_t"></a>
    
</p><p>
   The service routine function should return an exception when it is
   finished to signal its status. If no exception occurs
   <code>Sim_PE_No_Exception</code> should be returned.
</p><p>
   See <code>exception_type_t</code> in
   <code>src/include/simics/base/memory.h</code> for the different
   exceptions available.
</p><p>
   A special return value, <code>Sim_PE_Default_Semantics</code>, can be
   returned; this signals Simics to run the default semantics for the
   instruction. This is useful if the semantics of an instruction
   should be changed but the user routine does not want to handle it all
   the time.
</p><p>
   Note that in a shared memory multiprocessor, the CPU
   used in decoding may differ from the CPU that executes the
   instruction, since the decoded instructions may be cached.
</p><p>
   <i>ii_Arg</i> is the argument <i>arg</i> that will be
   passed on to the service routine function. Op code bit-fields for
   the instruction such as register numbers or intermediate values can
   be stored here. The <i>ii_UserData</i> field can also be used
   to pass information to the service routine if more data is needed.
</p><p>
   <i>ii_Type</i> is either <code>UD_IT_SEQUENTIAL</code> or
   <code>UD_IT_CONTROL_FLOW</code>.  A sequential type means that the
   instruction does not perform any branches and the update of the
   program counter(s) is handled by Simics. In a control flow
   instruction on the other hand it is up to the user to set the
   program counter(s).
</p><p>
   <i>ii_LogicalAddress</i> and <i>ii_PhysicalAddress</i>
   holds the logical and physical addresses of the instruction to be
   decoded.
</p><p>
   
</p><p>
   The <b><i>disassemble</i></b> function is called to disassemble an
   instruction.  It uses the same <i>code</i>,
   <i>valid_bytes</i>, and <i>cpu</i> parameters as
   the <b><i>decode</i></b> function. If the disassembly is valid, then
   the string part of the returned <code>tuple_int_string_t</code> struct
   should be a MALLOCed string with the disassembly and the integer
   part should be its length in bytes.  The caller is responsible for
   freeing the disassembly string. The string member should be NULL
   and the integer part should be zero if the disassembly is not
   valid.  If the disassemble function needs more data than
   <i>valid_bytes</i> it should return a negative number in
   the integer part in the same way as the <b><i>decode</i></b> function,
   and set the string part to NULL.
</p><p>
   The <b><i>flush</i></b> function is called to free any memory
   allocated when decoding an instruction and any user data associated
   with the instruction.  It should return zero if it does not
   recognize the instruction, and non-zero if it has accepted it.
   Usually, the way to recognize if a decoded instruction is the right
   one to flush is to compare <code>ii-&gt;ii_ServiceRoutine</code> with the
   function that was set in the <i>decode</i> function. Note
   that the <i>cpu</i> parameter is the processor that caused
   the flush. It is more or less an arbitrary processor and should be
   ignored.
</p><p>
   In addition to the function pointers, the
   <code>decoder_t</code> structure contains a
   <i>user_data</i> pointer that is passed to all the
   functions.  This can be used for passing any data to the decoder
   functions.
</p><p>
   
</p><p>
   

</p><h2 class="jdocu"><a class="not-numbered" id="interfaces.html:Exception-Interface">Exception Interface</a></h2>
<p>

<a id="interfaces.html:exception"></a>
<a id="interfaces.html:hapCore_Exception"></a>
</p><p>
The <code>exception</code> interface is used together with the
Core_Exception hap to enable inspection abilities for triggered
exceptions.
</p><p>
The <code>exception</code> interface is used to translate
   exception numbers, as received by the Core_Exception hap, to names,
   and vice versa.
</p><p>
   The <b><i>get_number</i></b> function returns the number associated
   with an exception name, or -1 if the no exception with the given
   name exist. The <b><i>get_name</i></b> returns the name
   associated with an exception number. The <b><i>get_source</i></b>
   function is only used on X86 targets and returns the source for an
   exception, as an exception number can be raised from different
   sources. The <b><i>all_exceptions</i></b> function returns a list of
   all exceptions numbers.
</p><p>
   The exception numbers are architecturally defined, while their
   names are defined by the model.
</p><p>
   </p><pre class="jdocu_small">SIM_INTERFACE(exception) {
        int (*get_number)(conf_object_t *NOTNULL obj,
                          const char *NOTNULL name);
        const char *(*get_name)(conf_object_t *NOTNULL obj, int exc);
        int (*get_source)(conf_object_t *NOTNULL obj, int exc);
        attr_value_t (*all_exceptions)(conf_object_t *NOTNULL obj);
};

#define EXCEPTION_INTERFACE "exception"
</pre><p>
</p><p>
   
   

</p><h2 class="jdocu"><a class="not-numbered" id="interfaces.html:Context-Handler-Interface">Context Handler Interface</a></h2>
<p>

<a id="interfaces.html:context_handler"></a>

   </p><div class="note">
<b>Note:</b>
This interface is not supported, and may change in the future.</div>Get and set current context. The <b><i>set_current_context</i></b> function
   returns zero if the passed object is not of the context class, otherwise
   one is returned.
<p>
   </p><pre class="jdocu_small">SIM_INTERFACE(context_handler) {
        conf_object_t *(*get_current_context)(conf_object_t *obj);
        int (*set_current_context)(conf_object_t *obj, conf_object_t *ctx);
};

#define CONTEXT_HANDLER_INTERFACE "context_handler"
</pre><p>
</p><p>
   

</p><h2 class="jdocu"><a class="not-numbered" id="interfaces.html:Exec-Trace-Interface">Exec Trace Interface</a></h2>
<p>

<a id="interfaces.html:exec_trace"></a>
The <code>exec_trace</code> interface is implemented by processor models
  that support tracing. A trace listener registers itself with the
  <b><i>register_tracer</i></b> call. The <i>tracer</i> callback will be
  called by the processor model
  when each instruction is just about to be executed, passing the
  <i>tracer_data</i> as passed to the <b><i>register_tracer</i></b> function
  in addition to information about the instruction that is executed.
  Invoke <b><i>unregister_tracer</i></b> with the same two pointers to deregister
  the listener.
</p><p>
  
</p><pre class="jdocu_small">typedef void (*instruction_trace_callback_t)(lang_void *tracer_data,
                                             conf_object_t *cpu,
                                             linear_address_t la,
                                             logical_address_t va,
                                             physical_address_t pa,
                                             byte_string_t opcode);</pre><p>

</p><p>
  The <i>pa</i> parameter to the callback will always be valid, but some
  CPU architectures may not support <i>la</i> or <i>va</i>. The
  <i>la</i> argument is typically only valid for x86 CPUs. Lastly, the
  opcode of the instruction is passed in <i>opcode</i>. The
  <i>opcode</i> is passed without endian conversion, meaning that byte X in
  <i>opcode</i> corresponds to the byte at <i>pa</i> + X.
</p><p>
  </p><pre class="jdocu_small">SIM_INTERFACE(exec_trace) {
        void (*register_tracer)(conf_object_t *NOTNULL cpu_obj,
                                instruction_trace_callback_t tracer,
                                lang_void *tracer_data);
        void (*unregister_tracer)(conf_object_t *NOTNULL cpu_obj,
                                  instruction_trace_callback_t tracer,
                                  lang_void *tracer_data);
};

#define EXEC_TRACE_INTERFACE "exec_trace"
</pre><p>
</p><p>
  

</p><h2 class="jdocu"><a class="not-numbered" id="interfaces.html:Opcode-Info-Interface">Opcode Info Interface</a></h2>
<p>

<a id="interfaces.html:opcode_info"></a>
The <code>opcode_info</code> interface is implemented by
   processors that need to communicate information about the encoding
   of instructions to the GUI.
</p><p>
   The <b><i>get_opcode_length</i></b> function returns information about
   instruction encoding in the current operating mode of the
   processor. The <b><i>min_alignment</i></b> field indicates the
   smallest allowed alignment of instructions, typically 4 for regular
   RISC architectures. The <b><i>max_length</i></b> field specifies the
   maximum instruction length in bytes. The <b><i>avg_length</i></b> is
   an approximation of the average instruction size.
</p><p>
   </p><pre class="jdocu_small">typedef struct {
        int min_alignment;
        int max_length;
        int avg_length;
} opcode_length_info_t;

SIM_INTERFACE(opcode_info) {
        opcode_length_info_t (*get_opcode_length_info)(conf_object_t *obj);
};

#define OPCODE_INFO_INTERFACE "opcode_info"
</pre><p>
</p><p>
   

</p><h2 class="jdocu"><a class="not-numbered" id="interfaces.html:Virtual-Data-Breakpoint-Interface">Virtual Data Breakpoint Interface</a></h2>
<p>

<a id="interfaces.html:virtual_data_breakpoint"></a>
Add and remove virtual-address (and, on x86, linear-address) read and
     write breakpoints. On every read access that intersects a read
     breakpoint's interval, the registered callback function is called with the
     object that initiated the read, and the address and size of the read. (The
     interval includes both endpoints; <i>first</i> must be less than
     or equal to <i>last</i>.) Write breakpoints work exactly the same,
     except that the callback is given the actual value being written, not just
     its size.
</p><p>
     The callback is called before the read or write has taken place, but may
     not intervene. If one or more breakpoint callbacks stop the simulation,
     the current instruction is completed before the stop takes effect. If more
     than one breakpoint is triggered by the same read or write, the
     implementation may call their callbacks in any order.
</p><p>
     On x86, the <code>Virtual_Breakpoint_Flag_Linear</code> flag causes the
     breakpoint to use linear rather than virtual addresses. (Adding a
     breakpoint with unsupported flags is illegal.)
</p><p>
     </p><div class="note">
<b>Note:</b>
This interface is preliminary and may change without prior notice.
     </div><a id="interfaces.html:virtual_breakpoint_flags_t"></a>
<pre class="jdocu_small">typedef enum {
        Virtual_Breakpoint_Flag_Linear = 1
} virtual_breakpoint_flags_t;</pre><p>

</p><p>
     </p><pre class="jdocu_small">SIM_INTERFACE(virtual_data_breakpoint) {
        virtual_data_bp_handle_t *NOTNULL (*add_read)(
                conf_object_t *NOTNULL obj,
                generic_address_t first, generic_address_t last,
                void (*NOTNULL callback)(
                        cbdata_call_t data, conf_object_t *NOTNULL initiator,
                        generic_address_t address, unsigned size),
                cbdata_register_t data, uint32 flags);
        virtual_data_bp_handle_t *NOTNULL (*add_write)(
                conf_object_t *NOTNULL obj,
                generic_address_t first, generic_address_t last,
                void (*NOTNULL callback)(
                        cbdata_call_t data, conf_object_t *NOTNULL initiator,
                        generic_address_t address, bytes_t value),
                cbdata_register_t data, uint32 flags);
        void (*remove)(conf_object_t *NOTNULL obj,
                       virtual_data_bp_handle_t *NOTNULL bp_handle);
};
#define VIRTUAL_DATA_BREAKPOINT_INTERFACE "virtual_data_breakpoint"
</pre><p>
</p><p>
   

</p><h2 class="jdocu"><a class="not-numbered" id="interfaces.html:Virtual-Instruction-Breakpoint-Interface">Virtual Instruction Breakpoint Interface</a></h2>
<p>

<a id="interfaces.html:virtual_instruction_breakpoint"></a>
Add and remove virtual-address (and, on x86, linear-address) instruction
     breakpoints. Every time the processor executes an instruction that
     intersects the breakpoint's interval, the callback function is called with
     the processor, and the address and size of the instruction. (The interval
     includes both endpoints; <i>first</i> must be less than or equal
     to <i>last</i>.)
</p><p>
     The callback is called before the instruction is executed. If one or more
     breakpoint callbacks stop the simulation, the stop takes effect before
     the instruction is run. (This means that once the simulation starts
     again, the same breakpoints will trigger immediately again. The callback
     can use <b><i>VT_step_stamp</i></b> to detect re-triggering.) If more than
     one breakpoint is triggered by the same instruction, the implementation
     may call their callbacks in any order.
</p><p>
     If the filter function is non-null and returns false, the callback is not
     called. The filter function is supplied with the instruction opcode (the
     raw bytes of the instruction) and a processor (which may not be the same
     processor that the breakpoint is set on, but is guaranteed to be of the
     same class). The filter may base its decision only on the opcode bytes and
     the string obtained by asking the processor to disassemble the
     instruction; this allows the implementation to cache the result and omit
     future calls to the filter function where the opcode and disassembly
     string would be the same.
</p><p>
     On x86, the <code>Virtual_Breakpoint_Flag_Linear</code> flag causes the
     breakpoint to use linear rather than virtual addresses. Calling with
     unsupported flags is illegal.
</p><p>
     </p><div class="note">
<b>Note:</b>
This interface is preliminary and may change without prior notice.
     </div><a id="interfaces.html:virtual_breakpoint_flags_t2"></a>
<pre class="jdocu_small">typedef enum {
        Virtual_Breakpoint_Flag_Linear = 1
} virtual_breakpoint_flags_t;</pre><p>

</p><p>
     </p><pre class="jdocu_small">SIM_INTERFACE(virtual_instruction_breakpoint) {
        virtual_instr_bp_handle_t *NOTNULL (*add)(
                conf_object_t *NOTNULL obj,
                generic_address_t first, generic_address_t last,
                bool (*filter)(cbdata_call_t filter_data,
                               conf_object_t *NOTNULL cpu, bytes_t opcode),
                cbdata_register_t filter_data,
                void (*NOTNULL callback)(
                        cbdata_call_t callback_data, conf_object_t *NOTNULL cpu,
                        generic_address_t address, unsigned size),
                cbdata_register_t callback_data, uint32 flags);
        void (*remove)(conf_object_t *NOTNULL obj,
                       virtual_instr_bp_handle_t *NOTNULL bp_handle);
};
#define VIRTUAL_INSTRUCTION_BREAKPOINT_INTERFACE \
        "virtual_instruction_breakpoint"
</pre><p>
</p><p>
   

</p><h2 class="jdocu"><a class="not-numbered" id="interfaces.html:Describe-Registers-Interface">Describe Registers Interface</a></h2>
<p>

<a id="interfaces.html:describe_registers"></a>
This interface is used by the Simics debugger to get certain information from
  a processor.
</p><p>
  The <b><i>first_child</i></b> function returns the first description in the
  sequence of child descriptions of parent or NULL if parent has no
  children. Groups can have both registers and groups as children, registers
  can only have fields as children and fields cannot have any children. If
  parent is NULL, return the first description in the sequence of top-level
  descriptions.
</p><p>
  Use <b><i>next_description</i></b> to deallocate the previous description and
  return the next description in the sequence or NULL if there are no more
  descriptions in the current sequence.
</p><p>
  The <b><i>free_description</i></b> function is used to free the description
  without returning the next one in the sequence.
</p><p>
  The <b><i>first_named_value</i></b> function returns the first named value in
  the sequence of named values for parent or NULL if there are no named values
  for parent. Only fields and registers can have named values.
</p><p>
  Use <b><i>next_named_value</i></b> to deallocate the previous named value and
  return the next named value or NULL if there are no more named values in this
  sequence.
</p><p>
  Use <b><i>free_named_value</i></b> to free the named value without returning the
  next one in the sequence.
</p><p>
  The <b><i>get</i></b> and <b><i>set</i></b> functions are used to get and set the
  value of the register. To set the value pass in a bytes_t for the value. The
  value passed in must be long enough to contain the full value of the
  register. If the bytes_t is too long it will be truncated. To get the value
  pass in a buffer_t which is long enough to contain the register's value. The
  value is encoded in little endian byte order.
</p><p>
  <a id="interfaces.html:description_type_t"></a>
</p><pre class="jdocu_small">typedef enum {
        Description_Type_Group,

        Description_Type_Int_Reg,
        Description_Type_Float_Reg,
        Description_Type_Fields_Reg,

        Description_Type_Int_Field,
        Description_Type_Float_Field,
} description_type_t;</pre><p>

  <a id="interfaces.html:reg_role_t"></a>
</p><pre class="jdocu_small">typedef enum {
        Reg_Role_None, /* No special role for the register. */
        Reg_Role_Program_Counter /* The register is the program counter. */
} reg_role_t;</pre><p>

  <a id="interfaces.html:reg_bitorder_t"></a>
</p><pre class="jdocu_small">typedef enum {
        Reg_Bitorder_Little_Endian,
        Reg_Bitorder_Big_Endian
} reg_bitorder_t;</pre><p>

  <a id="interfaces.html:named_value_t"></a>
</p><pre class="jdocu_small">typedef struct {
        const char *name;
        const char *description;
        const bytes_t value; /* Little endian byte order */
} named_value_t;</pre><p>

  <a id="interfaces.html:description_t"></a>
</p><pre class="jdocu_small">typedef struct {
        /* Common fields */
        description_type_t type;
        const char *name;
        const char *description;

        /* Register and field fields */
        int16 dwarf_id;            /* id used by dwarf for this register
                                      or -1 if no such id is defined. This
                                      is ABI specific, but the CPU will
                                      give the ids for the most common ABI
                                      for that architecture. */
        reg_bitorder_t bitorder;   /* Bitorder convention used in the
                                      documentation for this register or
                                      field. */
        reg_role_t role;           /* Role of this register in the ABI/HW. */
        bool memory_mapped;        /* True if the register is memory mapped. */
        uint64 offset;             /* Offset into the bank for memory mapped
                                      registers. */
        bool catchable;            /* True if Core_Control_Register_Write and
                                      Core_Control_Register_Read are triggered
                                      when this register is written or read. */
        int msb, lsb;              /* Most and least significant bit of the
                                      register or field. Always given in le
                                      bitorder. For groups msb == -1 and
                                      lsb == 0. */
        int regsize;               /* Number of bits in the register, or the
                                      register this field is a part of. */
        int reg_id;                /* For registers and fields the id to pass
                                      to the get and set methods to access the
                                      register's value. Fields have the same
                                      reg_id as the register they are a part
                                      of. Not valid for groups.*/
} description_t;</pre><p>

  </p><pre class="jdocu_small">SIM_INTERFACE(describe_registers) {
        const description_t *(*first_child)(
                conf_object_t *NOTNULL obj, const description_t *parent);
        const description_t *(*next_description)(
                conf_object_t *NOTNULL obj, const description_t *prev);
        void (*free_description)(conf_object_t *NOTNULL obj,
                                 const description_t *desc);
        const named_value_t *(*first_named_value)(
                conf_object_t *NOTNULL obj, const description_t *parent);
        const named_value_t *(*next_named_value)(
                conf_object_t *NOTNULL obj, const named_value_t *prev);
        void (*free_named_value)(conf_object_t *NOTNULL obj,
                                 const named_value_t *nv);
        void (*get)(conf_object_t *NOTNULL obj, int reg_id, buffer_t dest);
        void (*set)(conf_object_t *NOTNULL obj, int reg_id, bytes_t value);
};

#define DESCRIBE_REGISTERS_INTERFACE "describe_registers"
</pre><p>
</p><p>
  

</p><p>
</p></section><section class="page" id="simics-api-functions.html"><h1 class="jdocu"><a id="simics-api-functions.html:Simics-API-Functions">9.2 Simics API Functions</a></h1>
<p>

</p><p>
This section lists Simics API functions that a processor model may
need to use beyond what is described in other parts of this document.
Simics API <b><i>SIM_register_clock</i></b> is described in
<em>API Reference Manual</em>.
</p><p>


<a id="simics-api-functions.html:VT_check_async_events"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simics-api-functions.html:__jdocu_seealso_VT_check_async_events"></a><b>VT_check_async_events</b>  check for asynchronous events</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">bool
VT_check_async_events();
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Check if any async events are pending and if so, make the current
   executing object exit in order for them to be handled. Return nonzero
   if there are pending events.
<p>
   The Simics platform will check for asynchronous events between invocations
   of the <b><i>run</i></b> method in the <code>execute</code>. If significant
   time passes between such invocations, which will typically be the case
   unless there are multiple simulated CPUs that are switched between, then the
   implementor of <code>execute</code> needs to either call this method or
   exit pre-maturely from <b><i>run</i></b> to allow asynchronous events to be
   handled. If neither is performed, then interactive performance will suffer
   as user input would be waiting significant time before being processed.
</p><p>
   If only the async event state is requested, the faster
   <b><i>VT_async_events_pending</i></b> should be used instead.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>



<a id="simics-api-functions.html:VT_new_code_block"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simics-api-functions.html:__jdocu_seealso_VT_new_code_block"></a><b>VT_new_code_block</b>  inform platform of new code block</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
VT_new_code_block(void *start, size_t len);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This function informs the Simics platform that there is a <i>len</i>
   bytes block at <i>start</i> that can be executed from. The call should
   be made before the passed code area is executed from. This information is
   used by Simics to communicate with systems like Pin or Valgrind that do not
   automatically detect run-time generated code. If modifications are done to a
   block, then a new call to this function is needed to inform the platform of
   that.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>



<a id="simics-api-functions.html:VT_set_object_clock"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simics-api-functions.html:__jdocu_seealso_VT_set_object_clock"></a><b>VT_set_object_clock</b>  set clock association for object</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
VT_set_object_clock(conf_object_t *NOTNULL obj, conf_object_t *clock);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The simulation infrastructure keeps track of clock associations for every
   object. For most objects, this is initialized through the queue attribute.
<p>
   An object that is itself a clock needs to call this function to initialize
   the clock coupling to itself. The call to initialize the coupling should be
   made from the <b><i>init</i></b> method registered for the class in its 
   <code>class_info_t</code> (or <b><i>init_object</i></b> if registered using
   <code>class_data_t</code>).</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
</dl><p>



<a id="simics-api-functions.html:VT_clock_frequency_about_to_change"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simics-api-functions.html:__jdocu_seealso_VT_clock_frequency_about_to_change"></a><b>VT_clock_frequency_about_to_change</b>  inform before clock frequency change</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
VT_clock_frequency_about_to_change(conf_object_t *obj);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
To be called by a clock prior to a clock frequency change, with
   events and cycles reflecting the frequency before the change.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>



<a id="simics-api-functions.html:VT_clock_frequency_change"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simics-api-functions.html:__jdocu_seealso_VT_clock_frequency_change"></a><b>VT_clock_frequency_change</b>  inform after clock frequency change</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
VT_clock_frequency_change(conf_object_t *obj, uint64 cycles_per_second);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
To be called by a clock when the clock frequency has changed, with
   events and cycles reflecting the frequency after the change.</dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>



<a id="simics-api-functions.html:VT_stop_event_processing"></a>
</p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="simics-api-functions.html:__jdocu_seealso_VT_stop_event_processing"></a><b>VT_stop_event_processing</b>  stop event processing</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">void
VT_stop_event_processing(conf_object_t *clock);
</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This method is to be called by a clock when it has received a stop request
   through the execute interface and the clock is about to return from the run
   method in the execute interface.
<p>
   In the future, the simulation framework may keep track of this thus
   relieving the clock from the duty of having to call this method.</p></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Cell Context</dd>
</dl><p>

</p><p>
</p></section><section class="page" id="python-api.html"><h1 class="jdocu"><a id="python-api.html:python-api">10 Python API</a></h1>
<p>

</p><p>
    This chapter contains a description of the part of the Simics API that is
    available in Python only. The Python modules described here may contain
    functions, classes, types and similar than are not documented although
    visible when inspecting the modules. If not documented, they are internal
    to Simics and not part of the supported API.
</p><p>
    
    
    
    
    
    
    
    
        
</p><p>
    
</p></section><section class="page" id="simics-types-in-python.html"><h1 class="jdocu"><a id="simics-types-in-python.html:Simics-Types-in-Python">10.1 Simics Types in Python</a></h1>
<p>
    
    When writing code in Python, almost all Simics API functions can be
    used. Since not all C/C++ types are available in Python, Simics supplies
    the following special type mappings.
</p><p>
    <table>

      <tbody><tr>
        <td class="jdocu_border"><b>C/C++</b></td>
        <td class="jdocu_border"><b>Python</b></td>
      </tr>

      <tr>
        <td class="jdocu_border"><code>attr_value_t (string)</code></td>
        <td class="jdocu_border"><code>str</code> (a Python string)</td>
      </tr>

      <tr>
        <td class="jdocu_border"><code>attr_value_t (integer)</code></td>
        <td class="jdocu_border"><code>int</code> or <code>long</code></td>
      </tr>

      <tr>
        <td class="jdocu_border"><code>attr_value_t (floating)</code></td>
        <td class="jdocu_border"><code>float</code></td>
      </tr>

      <tr>
        <td class="jdocu_border"><code>attr_value_t (list)</code></td>
        <td class="jdocu_border"><code>list</code></td>
      </tr>

      <tr>
        <td class="jdocu_border"><code>attr_value_t (data)</code></td>
        <td class="jdocu_border"><code>tuple</code> of integers (bytes)</td>
      </tr>

      <tr>
        <td class="jdocu_border"><code>attr_value_t (nil)</code></td>
        <td class="jdocu_border"><code>None</code></td>
      </tr>

      <tr>
        <td class="jdocu_border"><code>attr_value_t (object)</code></td>
        <td class="jdocu_border">An object from the <b>conf</b> namespace.</td>
      </tr>

      <tr>
        <td class="jdocu_border"><code>attr_value_t (dict)</code></td>
        <td class="jdocu_border"><code>dict</code></td>
      </tr>

      <tr>
        <td class="jdocu_border"><code>attr_value_t (boolean)</code></td>
        <td class="jdocu_border"><code>bool</code></td>
      </tr>

      <tr>
        <td class="jdocu_border"><code>conf_class_t *</code></td>
        <td class="jdocu_border"><code>A conf_class_t object</code></td>
      </tr>

      <tr>
        <td class="jdocu_border"><code>conf_object_t *</code></td>
        <td class="jdocu_border">An object from the <b>conf</b> namespace</td>
      </tr>

    </tbody></table>
</p></section><section class="page" id="command-line-interface.html"><h1 class="jdocu"><a id="command-line-interface.html:Command-Line-Interface">10.2 Command Line Interface</a></h1>
<p>

    </p><h2 class="jdocu"><a class="not-numbered" id="command-line-interface.html:CLI-Arguments-Types">CLI Arguments Types</a></h2>
<p></p><h3 class="jdocu"><a class="not-numbered" id="command-line-interface.html:addr_t">addr_t</a></h3>
<p>
 
 Accepts a target machine address, optionally with an address space
 prefix, such as <code>v:</code> for virtual addresses or <code>p:</code> for
 physical.
 </p><h3 class="jdocu"><a class="not-numbered" id="command-line-interface.html:bool_ttrue_str-false_str">bool_t(true_str, false_str)</a></h3>
<p>
 
</p><p>
 Generator function for boolean arguments. A boolean argument accepts
 the strings "TRUE" and "FALSE", as well as boolean integers (that
 is, the values 0 and 1). In addition, if the optional strings
 <i>true_str</i> and <i>false_str</i> are given, the boolean
 argument will accept them as well.  The argument passes True or
 False to the command function depending on which string (or value)
 was given.
</p><p>
 </p><h3 class="jdocu"><a class="not-numbered" id="command-line-interface.html:filename_tdirsFalse-existFalse-simpathFalse-checkpointFalse">filename_t(dirs=False, exist=False, simpath=False, checkpoint=False)</a></h3>
<p>
 
 Generator function for filename arguments. If the <i>dirs</i>
 argument is false (which is default), no directories will be
 accepted. The <i>exist</i> flag, when set, forces the file to
 actually exist. If <i>simpath</i> is true, files will be checked for
 existence using <code>SIM_lookup_file()</code>, searching the Simics
 search path. <i>simpath</i> implies <i>exist</i>. On Windows, if Cygwin path
 conversion is performed (see <code>SIM_native_path()</code> for details), the
 filename will be converted to host native format.
 The <i>checkpoint</i> flag will constrain the argument to checkpoints,
 and treat existing checkpoints as opaque entities.
 </p><h3 class="jdocu"><a class="not-numbered" id="command-line-interface.html:flag_t">flag_t</a></h3>
<p>
 
 Passes <code>True</code> to command function when flag is provided, <code>False</code>
 when flag is not provided.
 </p><h3 class="jdocu"><a class="not-numbered" id="command-line-interface.html:float_t">float_t</a></h3>
<p>
 
 Accepts floating-point numbers.
 </p><h3 class="jdocu"><a class="not-numbered" id="command-line-interface.html:int16_t">int16_t</a></h3>
<p>
 
 Accepts any unsigned integer that fits in 16 bits, modulo-reducing values
 outside into that range.
 </p><h3 class="jdocu"><a class="not-numbered" id="command-line-interface.html:int32_t">int32_t</a></h3>
<p>
 
 Accepts any unsigned integer that fits in 32 bits, modulo-reducing values
 outside into that range.
 </p><h3 class="jdocu"><a class="not-numbered" id="command-line-interface.html:int64_t">int64_t</a></h3>
<p>
 
 Accepts any unsigned integer that fits in 64 bits, modulo-reducing values
 outside into that range.
 </p><h3 class="jdocu"><a class="not-numbered" id="command-line-interface.html:int8_t">int8_t</a></h3>
<p>
 
 Accepts any unsigned integer that fits in 8 bits, modulo-reducing values
 outside into that range.
 </p><h3 class="jdocu"><a class="not-numbered" id="command-line-interface.html:int_t">int_t</a></h3>
<p>
 
 Accepts any integer (regardless of size).
 </p><h3 class="jdocu"><a class="not-numbered" id="command-line-interface.html:integer_t">integer_t</a></h3>
<p>
 
 Accepts any unsigned integer that fits in 64 bits, modulo-reducing values
 outside into that range.
 </p><h3 class="jdocu"><a class="not-numbered" id="command-line-interface.html:ip_port_t">ip_port_t</a></h3>
<p>
 
</p><p>
 Accepts integers that are valid IP port numbers (that is, integers
 between 0 and 65535 inclusive).</p><h3 class="jdocu"><a class="not-numbered" id="command-line-interface.html:list_t">list_t</a></h3>
<p>
 
 Accepts a comma separated list of CLI types. Can also be given to
 any CLI argument that accepts more than one value as input.
 </p><h3 class="jdocu"><a class="not-numbered" id="command-line-interface.html:nil_t">nil_t</a></h3>
<p>
 
</p><p>
 Nil argument. Accepts NIL, zero or the empty string, and passes None to
 the command function. Not so usable by itself, but see e.g.
 <b><i>poly_t</i></b>.
</p><p>
 </p><h3 class="jdocu"><a class="not-numbered" id="command-line-interface.html:obj_tdesc-kind--None-want_port--False">obj_t(desc, kind = None, want_port = False)</a></h3>
<p>
 
 Returns an argument which accepts any object.
</p><p>
 <i>desc</i> is the string returned as a description of the argument.
 <i>kind</i> can be used to limit the accepted objects to only allow
 objects of a certain kind.  This parameter can either be a class
 name that the object should be an instance of, or the name of an
 interface that the object must implement, or a tuple of
 kinds. <i>want_port</i> indicates whether it should be allowed to
 specify an object and a port name, separated with a colon.  If a
 port is wanted, the argument will be a list [obj, port] instead of
 only the object.  </p><h3 class="jdocu"><a class="not-numbered" id="command-line-interface.html:poly_tdesc-type1-type2-...">poly_t(desc, type1, type2, ...)</a></h3>
<p>
 
</p><p>
 Generates an argument with the given description that will match any
 of the given types; they will be tried one by one, in the order
 specified, and the first one that accepts the input will be used.
</p><p>
 </p><h3 class="jdocu"><a class="not-numbered" id="command-line-interface.html:range_tmin-max-desc-moduloFalse">range_t(min, max, desc, modulo=False)</a></h3>
<p>
 
</p><p>
 Returns an argument which accepts any integer <i>x</i> between
 <i>min</i> and <i>max</i> inclusively. <i>desc</i> is the string
 returned as a description of the argument.
</p><p>
 Values outside the interval cause an error to be signalled if
 <i>modulo</i> is false, and a modulo-reduction to the specified
 interval otherwise.
 </p><h3 class="jdocu"><a class="not-numbered" id="command-line-interface.html:sint16_t">sint16_t</a></h3>
<p>
 
 Accepts any signed integer that fits in 16 bits, modulo-reducing values
 outside into that range.
 </p><h3 class="jdocu"><a class="not-numbered" id="command-line-interface.html:sint32_t">sint32_t</a></h3>
<p>
 
 Accepts any signed integer that fits in 32 bits, modulo-reducing values
 outside into that range.
 </p><h3 class="jdocu"><a class="not-numbered" id="command-line-interface.html:sint64_t">sint64_t</a></h3>
<p>
 
 Accepts any signed integer that fits in 64 bits, modulo-reducing values
 outside into that range.
 </p><h3 class="jdocu"><a class="not-numbered" id="command-line-interface.html:sint8_t">sint8_t</a></h3>
<p>
 
 Accepts any signed integer that fits in 8 bits, modulo-reducing values
 outside into that range.
 </p><h3 class="jdocu"><a class="not-numbered" id="command-line-interface.html:str_t">str_t</a></h3>
<p>
 
 Accepts any one word or quoted string.
 </p><h3 class="jdocu"><a class="not-numbered" id="command-line-interface.html:string_set_tstrings">string_set_t(strings)</a></h3>
<p>
 
</p><p>
 Accepts only strings from the given set. <i>strings</i> can be any
 iterable, such as a tuple, list, or set, in which case the return
 value is the exact string the user gave; or a dictionary mapping
 acceptable user input strings to return values.
</p><p>
 The optional parameter <i>visible</i> is a list of strings. If
 given, only strings in this list will be suggested by the expander.
</p><p>
 </p><h3 class="jdocu"><a class="not-numbered" id="command-line-interface.html:uint16_t">uint16_t</a></h3>
<p>
 
 Accepts any unsigned integer that fits in 16 bits, modulo-reducing values
 outside into that range.
 </p><h3 class="jdocu"><a class="not-numbered" id="command-line-interface.html:uint32_t">uint32_t</a></h3>
<p>
 
 Accepts any unsigned integer that fits in 32 bits, modulo-reducing values
 outside into that range.
 </p><h3 class="jdocu"><a class="not-numbered" id="command-line-interface.html:uint64_t">uint64_t</a></h3>
<p>
 
 Accepts any unsigned integer that fits in 64 bits, modulo-reducing values
 outside into that range.
 </p><h3 class="jdocu"><a class="not-numbered" id="command-line-interface.html:uint8_t">uint8_t</a></h3>
<p>
 
 Accepts any unsigned integer that fits in 8 bits, modulo-reducing values
 outside into that range.
 </p><h3 class="jdocu"><a class="not-numbered" id="command-line-interface.html:uint_t">uint_t</a></h3>
<p>
 
 Accepts any unsigned (that is, non-negative) integer (regardless of
 size).
 
    </p><h2 class="jdocu"><a class="not-numbered" id="command-line-interface.html:CLI-Classes-and-Functions">CLI Classes and Functions</a></h2>
<p></p><h3 class="jdocu"><a class="not-numbered" id="command-line-interface.html:cli.CliError">cli.CliError</a></h3>
<p>
  
  <a id="command-line-interface.html:CliError"></a> <a id="command-line-interface.html:cli-Python-moduleCliError"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="command-line-interface.html:__jdocu_seealso_cli.CliError"></a><b>CliError</b>  error in CLI command</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">CliError(args)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This exception can be raised whenever a command can
not complete successfully.</dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="command-line-interface.html:cli.arg">cli.arg</a></h3>
<p><a id="command-line-interface.html:arg"></a> <a id="command-line-interface.html:cli-Python-modulearg"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="command-line-interface.html:__jdocu_seealso_cli.arg"></a><b>arg</b>  class defining a command argument</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">            arg(handler, name = "", spec = "1", default = None,
            data = None, doc = "", expander = None, pars = [])</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Define a CLI command argument when using <b><i>new_command</i></b>. A
complete explanation of <b><i>new_command</i></b> and <b><i>arg</i></b> is
available in <em>Simics Model Builder User's Guide</em>, in the
<em>Adding New Commands</em> chapter.</dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="command-line-interface.html:cli.command_quiet_return">cli.command_quiet_return</a></h3>
<p><a id="command-line-interface.html:command_quiet_return"></a> <a id="command-line-interface.html:cli-Python-modulecommand_quiet_return"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="command-line-interface.html:__jdocu_seealso_cli.command_quiet_return"></a><b>command_quiet_return</b>  suppress interactive messages from commands</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">command_quiet_return(value)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Use this class to return from a command that returns a value but should
not print anything when used interactively.
<p>
<i>value</i> should either be the value returned, or a function
taking no arguments that returns the actual value.
</p><p>
Note that <i>value</i> can only be of types directly supported by
CLI.</p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#command-line-interface.html:__jdocu_seealso_cli.command_return">cli.command_return</a></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="command-line-interface.html:cli.command_return">cli.command_return</a></h3>
<p><a id="command-line-interface.html:command_return"></a> <a id="command-line-interface.html:cli-Python-modulecommand_return"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="command-line-interface.html:__jdocu_seealso_cli.command_return"></a><b>command_return</b>  return interactive messages from commands</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">            command_return(message = None, value = None)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Use this class to return from a command that returns one value
(<i>value</i>) but (may) print something else
(<i>message</i>) when run interactive.
<p>
<i>message</i> and <i>value</i> may both be functions that
take no arguments and return the message (a string) or a value,
respectively.
</p><p>
If it is a function, <i>message</i> is only evaluated if needed.
</p><p>
Note that <i>value</i> (or, when a function, its return value) can
only be of types directly supported by CLI.</p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#command-line-interface.html:__jdocu_seealso_cli.command_quiet_return">cli.command_quiet_return</a>, <a class="jdocu" href="#command-line-interface.html:__jdocu_seealso_cli.command_verbose_return"> cli.command_verbose_return</a></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="command-line-interface.html:cli.command_verbose_return">cli.command_verbose_return</a></h3>
<p><a id="command-line-interface.html:command_verbose_return"></a> <a id="command-line-interface.html:cli-Python-modulecommand_verbose_return"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="command-line-interface.html:__jdocu_seealso_cli.command_verbose_return"></a><b>command_verbose_return</b>  always print return messages from commands</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">command_verbose_return(message = None, value = None)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Use this class to return from a command that returns a value or message
that should be printed even when used non-interactively, but not when used
in an expression.
<p>
The <i>value</i> and <i>message</i> parameters are
identical to the same as for <b>cli.command_return</b>.</p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#command-line-interface.html:__jdocu_seealso_cli.command_return">cli.command_return</a></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="command-line-interface.html:cli.get_available_object_name">cli.get_available_object_name()</a></h3>
<p><a id="command-line-interface.html:get_available_object_name"></a> <a id="command-line-interface.html:cli-Python-moduleget_available_object_name"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="command-line-interface.html:__jdocu_seealso_cli.get_available_object_name"></a><b>get_available_object_name</b>  return a non-allocated object name</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">get_available_object_name(prefix)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Return an object name suitable for creating a new object (i.e., that has
not been used yet) by adding a suffix to <i>prefix</i>.</dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="command-line-interface.html:cli.get_component_object">cli.get_component_object()</a></h3>
<p><a id="command-line-interface.html:get_component_object"></a> <a id="command-line-interface.html:cli-Python-moduleget_component_object"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="command-line-interface.html:__jdocu_seealso_cli.get_component_object"></a><b>get_component_object</b>  return an object in a component</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">get_component_object(cmp_obj, slot)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Return the object named <i>slot</i> inside the
<i>cmp_obj</i> component. The <i>slot</i> parameter is
the name by which the component knows the object, not the global name of
the object.
<p>
The function will raise a <em>CliError</em> if the object can not be found
in the component.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
object or pre-object</dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="command-line-interface.html:cli.global_cmds">cli.global_cmds</a></h3>
<p><a id="command-line-interface.html:global_cmds"></a> <a id="command-line-interface.html:cli-Python-moduleglobal_cmds"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="command-line-interface.html:__jdocu_seealso_cli.global_cmds"></a><b>global_cmds</b>  Namespace with functions to run global CLI commands</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">global_cmds.<i>wrapper_function(...)</i></pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The namespace provides wrapper Python functions to run global
Simics CLI commands. A wrapper function name
is usually the same as a name of the command it executes
with hyphens replaced with underscores. The parameters of
the wrapper functions are the same as of the corresponding command (again,
with hyphens replaced with underscores). Command flags (the names of
the corresponding function parameters start with an underscore)
could be passes as Python Boolean values. In the rare cases that a wrapper
function name or a wrapper function parameter name turns out to be
a Python keyword, the <code>_cmd</code> suffix is added
to the wrapper function name
and the function parameter gets the <code>_</code> suffix.
Wrapper functions return the value returned by the command
which they execute.
<p>
Please consult the docstring
of the wrapper function and the respective command documentation
for the information about function arguments and the returned value.</p></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="command-line-interface.html:cli.interactive_command">cli.interactive_command()</a></h3>
<p><a id="command-line-interface.html:interactive_command"></a> <a id="command-line-interface.html:cli-Python-moduleinteractive_command"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="command-line-interface.html:__jdocu_seealso_cli.interactive_command"></a><b>interactive_command</b>  check if current command is run interactively</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">interactive_command()</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns true if the current command was run interactively by the user
and false if run from a script. This function may only be called by CLI
commands.</dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="command-line-interface.html:cli.new_command">cli.new_command()</a></h3>
<p><a id="command-line-interface.html:new_command"></a> <a id="command-line-interface.html:cli-Python-modulenew_command"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="command-line-interface.html:__jdocu_seealso_cli.new_command"></a><b>new_command</b>  define a new CLI command</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">new_command(name, fun, args = [], **kwargs)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Define a new CLI command. A complete explanation of
<b><i>new_command</i></b> and its parameters is available in
<em>Simics Model Builder User's Guide</em>, in the
<em>Adding New Commands</em> chapter.</dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="command-line-interface.html:cli.new_info_command">cli.new_info_command()</a></h3>
<p><a id="command-line-interface.html:new_info_command"></a> <a id="command-line-interface.html:cli-Python-modulenew_info_command"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="command-line-interface.html:__jdocu_seealso_cli.new_info_command"></a><b>new_info_command</b>  define a new info command</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">new_info_command(cls, get_info, ctype = None, doc = None)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Define a new <b>info</b> command for a given object.
<i>cls</i> is the class for which the <b>info</b> command
should be registered. <i>get_info</i> is a function returning the
information to be printed. <i>get_info()</i> should return a data
structure of the following kind:
<pre class="jdocu_small">  [(SectionName1, [(DataName1.1, DataValue1.1),
                   (DataName1.2, DataValue1.2), ...]),
   (SectionName2, [(DataName2.1, DataValue2.1),
                   (DataName2.2, DataValue2.2), ...]),
   ...]</pre><p>
</p><p>
Each section will be printed separately. Each piece of data will be printed
on one line. If no sections are necessary, just provide <code>None</code> as
the only section's name, followed by the list of data.</p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#command-line-interface.html:__jdocu_seealso_cli.new_status_command">cli.new_status_command</a></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="command-line-interface.html:cli.new_status_command">cli.new_status_command()</a></h3>
<p><a id="command-line-interface.html:new_status_command"></a> <a id="command-line-interface.html:cli-Python-modulenew_status_command"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="command-line-interface.html:__jdocu_seealso_cli.new_status_command"></a><b>new_status_command</b>  define a new status command</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">new_status_command(cls, get_status, ctype = None, doc = None)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Define a new <b>status</b> command for a given object.
<i>cls</i> is the class for which the <b>status</b> command
should be registered. <i>get_status</i> is a function returning the
information to be printed. <i>get_status()</i> should return a data
structure of the same kind as in <b><i>new_info_command()</i></b>.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#command-line-interface.html:__jdocu_seealso_cli.new_info_command">cli.new_info_command</a></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="command-line-interface.html:cli.new_tech_preview_command">cli.new_tech_preview_command()</a></h3>
<p><a id="command-line-interface.html:new_tech_preview_command"></a> <a id="command-line-interface.html:cli-Python-modulenew_tech_preview_command"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="command-line-interface.html:__jdocu_seealso_cli.new_tech_preview_command"></a><b>new_tech_preview_command</b>  define a new CLI tech preview command</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">new_tech_preview_command(name, feature, fun, args=[], doc="", **kwargs)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Define a new tech preview CLI command.</dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="command-line-interface.html:cli.new_unsupported_command">cli.new_unsupported_command()</a></h3>
<p><a id="command-line-interface.html:new_unsupported_command"></a> <a id="command-line-interface.html:cli-Python-modulenew_unsupported_command"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="command-line-interface.html:__jdocu_seealso_cli.new_unsupported_command"></a><b>new_unsupported_command</b>  define a new unsupported CLI command</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">new_unsupported_command(name, feature, fun, args = [], doc = "", **kwargs)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Define a new unsupported CLI command.</dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="command-line-interface.html:cli.number_str">cli.number_str()</a></h3>
<p><a id="command-line-interface.html:number_str"></a> <a id="command-line-interface.html:cli-Python-modulenumber_str"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="command-line-interface.html:__jdocu_seealso_cli.number_str"></a><b>number_str</b>  return a ready-to-print representation of a number</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">number_str(val, radix=None, group=None, use_prefix=True, precision=1)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Return a ready-to-print representation of the number
<i>val</i> in a given base (<i>radix</i>) or the
current base by default, using the current settings for number
representation as set by the <b>output-radix</b> and
<b>digit-grouping</b> commands.
<p>
The default digit grouping can be overridden with the
<i>group</i> parameter, where 0 means no grouping.
The radix prefix can be removed
by specifying <i>use_prefix</i> as <code>False</code>.
</p><p>
The minimum number of digits to be printed is specified by
<i>precision</i>. If <i>precision</i> is negative,
the precision is taken to be zero. Regardless of the radix, a
value of zero with zero precision will always return the empty
string.
</p><p>
Negative numbers that fit in a signed 64-bit integer are treated
as such. Other negative numbers are prefixed with a minus
("-").</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
A string representing the number.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#command-line-interface.html:__jdocu_seealso_cli.str_number">cli.str_number</a></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="command-line-interface.html:cli.object_expander">cli.object_expander()</a></h3>
<p><a id="command-line-interface.html:object_expander"></a> <a id="command-line-interface.html:cli-Python-moduleobject_expander"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="command-line-interface.html:__jdocu_seealso_cli.object_expander"></a><b>object_expander</b>  standard expander for an object argument</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">object_expander(kind)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
For command writing: standard expander that can be use to provide
argument completion on all objects of a given class or matching a given
interface (<i>kind</i>).
<p>
For example, to expand a string with the list of processor available in the
machine, you would write:
</p><pre class="jdocu_small">  arg(str_t, "cpu", expander =  object_expander("processor_info"))
</pre><p>
</p><p>
To expand a string to all <b>gcache</b> objects:
</p><pre class="jdocu_small">  arg(str_t, "cache", expander = object_expander("gcache"))
</pre><p></p></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="command-line-interface.html:cli.quiet_run_command">cli.quiet_run_command()</a></h3>
<p><a id="command-line-interface.html:quiet_run_command"></a> <a id="command-line-interface.html:cli-Python-modulequiet_run_command"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="command-line-interface.html:__jdocu_seealso_cli.quiet_run_command"></a><b>quiet_run_command</b>  run a CLI command and return output</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">quiet_run_command(text, output_mode = output_modes.formatted_text)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Runs a CLI command, or a CLI expression, as if it has been
entered at the prompt. Errors are reported using CliError
exception.
<p>
The <b><i>quiet_run_command</i></b> function is similar to
<b><i>run_command</i></b> but returns a tuple with the command
return value as first entry, and the command output text as the second.
Please note that sometimes unrelated output might be included, e.g.,
for commands that advance the virtual time or in some other way may allow
other commands to run in parallel with them.
</p><p>
Set 'output_mode' to one of the output modes:
</p><dl><dt id="command-line-interface.html:dt:output_modes-regular"><a href="#command-line-interface.html:dt:output_modes-regular"><b><b>output_modes.regular</b></b></a></dt><dd>formatted text with Simics-internal markup</dd><dt id="command-line-interface.html:dt:output_modes-formatted_text"><a href="#command-line-interface.html:dt:output_modes-formatted_text"><b><b>output_modes.formatted_text</b></b></a></dt><dd>formatted text without markup</dd><dt id="command-line-interface.html:dt:output_modes-unformatted_text"><a href="#command-line-interface.html:dt:output_modes-unformatted_text"><b><b>output_modes.unformatted_text</b></b></a></dt><dd>unformatted text without markup</dd></dl><p></p></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="command-line-interface.html:cli.register_command_category">cli.register_command_category()</a></h3>
<p><a id="command-line-interface.html:register_command_category"></a> <a id="command-line-interface.html:cli-Python-moduleregister_command_category"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="command-line-interface.html:__jdocu_seealso_cli.register_command_category"></a><b>register_command_category</b>  register a command category</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">register_command_category(name = None)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Register a command category for the 'type' argument given to the
<b><i>new_command</i></b> function. Command categories are optional but may
be useful if many commands are defined for a particular use case that is
of general interest.
<p>
<i>name</i> should be at least 3 characters long and preferably
just one capitalized word, a noun.
</p><p>
<em>Notice</em>: Do not register any command category for a class, as those
are listed on the class itself.
</p><p>
Invoke this function without any argument to print the standard
categories, assuming no modules or targets have been loaded.</p></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="command-line-interface.html:cli.run_command">cli.run_command()</a></h3>
<p><a id="command-line-interface.html:run_command"></a> <a id="command-line-interface.html:cli-Python-modulerun_command"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="command-line-interface.html:__jdocu_seealso_cli.run_command"></a><b>run_command</b>  run a CLI command</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">run_command(text)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Runs a CLI command, or a CLI expression, as if it has been entered at the
prompt. Errors are reported using CliError exception, and any return value
from the command is returned by this function to Python.
<p>
Use <b><i>quiet_run_command</i></b> if you need to suppress or catch
messages printed.</p></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="command-line-interface.html:cli.simenv">cli.simenv</a></h3>
<p><a id="command-line-interface.html:simenv"></a> <a id="command-line-interface.html:cli-Python-modulesimenv"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="command-line-interface.html:__jdocu_seealso_cli.simenv"></a><b>simenv</b>  CLI variable namespace</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">simenv.<i>variable</i></pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The <b>simenv</b> namespace provides access to the CLI variables
in the Simics Python interpreter. If the variable <i>$foo</i> was
defined in CLI, <i>simenv.foo</i> will represent the same variable in
Python.
<p>
Running <code>del simenv.foo</code> will unset that variable. The return value
from the <b><i>dir</i></b> function will also include defined variables. The
<b><i>repr</i></b> function will return the dictionary of variable and value
pairs as a string.</p></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="command-line-interface.html:cli.str_number">cli.str_number()</a></h3>
<p><a id="command-line-interface.html:str_number"></a> <a id="command-line-interface.html:cli-Python-modulestr_number"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="command-line-interface.html:__jdocu_seealso_cli.str_number"></a><b>str_number</b>  convert a string to a number</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">str_number(text)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Converts a string returned from <b><i>number_str</i></b> back to
an integer.
<p>
Raises ValueError for invalid arguments.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
A number representing the string.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#command-line-interface.html:__jdocu_seealso_cli.number_str">cli.number_str</a></dd>
</dl><p>
</p></section><section class="page" id="configuration.html"><h1 class="jdocu"><a id="configuration.html:Configuration">10.3 Configuration</a></h1>
<p>

    </p><h2 class="jdocu"><a class="not-numbered" id="configuration.html:pyobj-Python-Module">pyobj Python Module</a></h2>
<p></p><h3 class="jdocu"><a class="not-numbered" id="configuration.html:pyobj.Attribute">pyobj.Attribute</a></h3>
<p>
  
  <a id="configuration.html:Attribute"></a> <a id="configuration.html:pyobj-Python-moduleAttribute"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="configuration.html:__jdocu_seealso_pyobj.Attribute"></a><b>Attribute</b>  a Simics attribute</dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The <b>pyobj.Attribute</b> class defines an attribute that will
be registered for the containing <b>ConfObject</b> class. The
attribute will be registered with Simics using the
<b><i>SIM_register_attribute</i></b> function. See documentation for
<b><i>SIM_register_attribute</i></b> for detailed information about
attributes.
<p>
The arguments to <b><i>SIM_register_attribute</i></b> is taken from the
class members. The <i>attrattr</i> member is an
<code>attr_attr_t</code> type and its default value is
<code>Sim_Attr_Optional</code>. The <i>attrtype</i> member is a string
defining the type of the attribute, default value is <em>'a'</em>.
</p><p>
The class methods named <b><i>getter</i></b> and <b><i>setter</i></b> will be
used as <b><i>get_attr</i></b> and <b><i>set_attr</i></b> functions when
registering the attribute. The methods are optional. An attribute without a
<b><i>getter</i></b> can not be read. An attribute without a <b><i>setter</i></b>
can not be written.
</p><p>
The attribute description is the same as the Python class description.
</p><p>
The <b><i>_initialize</i></b> method can be defined if special initialization
behavior is required. This can for instance be used to set the default
value.</p></dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
<pre class="jdocu_small">class wee(pyobj.Attribute):
    """Documentation for the attribute goes here."""
    attrattr = simics.Sim_Attr_Pseudo
    attrtype = 'i'
    def _initialize(self):
        self.val = 4711
    def getter(self):
        self.val += 3
        return self.val
    def setter(self, val):
        self.val = val</pre><p></p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#configuration.html:__jdocu_seealso_pyobj.SimpleAttribute">pyobj.SimpleAttribute</a>, <a class="jdocu" href="#configuration.html:__jdocu_seealso_pyobj.ClassAttribute"> pyobj.ClassAttribute</a>, <a class="jdocu" href="#configuration.html:__jdocu_seealso_pyobj.ConfObject"> pyobj.ConfObject</a></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="configuration.html:pyobj.ClassAttribute">pyobj.ClassAttribute</a></h3>
<p><a id="configuration.html:ClassAttribute"></a> <a id="configuration.html:pyobj-Python-moduleClassAttribute"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="configuration.html:__jdocu_seealso_pyobj.ClassAttribute"></a><b>ClassAttribute</b>  a Simics class attribute</dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The <b>pyobj.ClassAttribute</b> class defines an attribute that
will be registered for the containing <b>ConfObject</b> class. The
attribute will be registered with Simics using the
<b><i>SIM_register_class_attribute</i></b> function. See documentation
for <b><i>SIM_register_class_attribute</i></b> for detailed information
about class attributes.
<p>
The value stored in the class should always be stored in the
attribute named <code>val</code>. This is to avoid problems when a
class that defines a <b>pyobj.Attribute</b> class is
inherited by more than one class.
</p><p>
The <b>pyobj.ClassAttribute</b> class is very similar to the
<b>pyobj.Attribute</b> class. See the documentation for the
<b>pyobj.Attribute</b> class for how to use this class.</p></dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
<pre class="jdocu_small">class wee(pyobj.ClassAttribute):
    """Documentation for the attribute goes here."""
    attrtype = 'i'
    val = 4711
    @classmethod
    def getter(cls): return cls.val
    @classmethod
    def setter(cls, val): cls.val = val</pre><p></p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#configuration.html:__jdocu_seealso_pyobj.Attribute">pyobj.Attribute</a>, <a class="jdocu" href="#configuration.html:__jdocu_seealso_pyobj.ConfObject"> pyobj.ConfObject</a></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="configuration.html:pyobj.ConfObject">pyobj.ConfObject</a></h3>
<p><a id="configuration.html:ConfObject"></a> <a id="configuration.html:pyobj-Python-moduleConfObject"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="configuration.html:__jdocu_seealso_pyobj.ConfObject"></a><b>ConfObject</b>  a Simics configuration object</dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The <b>pyobj.ConfObject</b> class defines a new Simics class
using the <b><i>SIM_register_class</i></b> function. You could call
<b><i>SIM_register_class</i></b> and all the related functions for
attribute and interface registration yourself, but
<b>ConfObject</b> will make your code much more concise.
<p>
The name of the Simics class is identical to the Python
class. The class description is the same as the Python class
description.
</p><p>
The class implements the methods <b><i>_initialize</i></b>,
<b><i>_finalize</i></b>, <b><i>_pre_delete</i></b>, <b><i>_info</i></b>, and
<b><i>_status</i></b>. All of these methods can be overridden if
required.
</p><p>
The <b><i>_initialize</i></b> method is called when an object of the
class is instantiated. The <b><i>_finalize</i></b> method is called
when the object is finalized. The <b><i>_pre_delete</i></b> method is
called right before an object of the class is deleted.
</p><p>
The <b><i>_info</i></b> and <b><i>_status</i></b> methods provide data for
the class's <b>info</b> and <b>status</b> commands; the
format of their return value is documented with
<b><i>cli.new_info_command</i></b> and
<b><i>cli.new_status_command</i></b>.
</p><p>
If you need to get hold of the Simics <code>conf_object_t</code> object
associated with a <b>ConfObject</b> instancefor
example, in order to call a Simics API functionyou can find
it in the <i>obj</i> member.
</p><p>
The <b>pyobj.ConfObject</b> class can contain inner classes
that define attributes, interfaces, etc. See
<b>pyobj.Port</b>, <b>pyobj.Attribute</b>,
<b>pyobj.ClassAttribute</b>, and
<b>pyobj.Interface</b> for more documentation. An inner
class has a reference to the class that contains it in its
<i>_up</i> member.
</p><p>
By default, a Simics class is registered automatically whenever a
subclass of <b>pyobj.ConfObject</b> is declared. Sometimes
this is not desirable; e.g., the class may be a base class, or you
may want to allow importing the containing Python file without
side-effects. The automatic registration of a Simics class can
then be suppressed by setting the member <code>_do_not_init</code> to
<code>object()</code>. That will cause it to not be registered as a
Simics class (but its subclasses will be, unless they too employ
the same trick).
</p><p>
The class method <b><i>register</i></b> may be called once on each
<b>pyobj.ConfObject</b> subclass, to register the Simics
class. For a class that doesn't suppress automatic registration, the
method currently does nothing.
</p><p>
In future Simics versions, a Simics class will no longer be
registered automatically, and an explicit call to the
<b><i>register</i></b> method will be required for that.
</p><p>
The <i>_class_kind</i> member tells Simics whether objects of
this class should be saved when a checkpoint is created.
The value is passed to <b><i>SIM_register_class</i></b>, as the
<i>kind</i> field of the <code>class_data_t</code> structure.
The default value is <code>Sim_Class_Kind_Vanilla</code>.
See the documentation of <b><i>SIM_register_class</i></b> for details.</p></dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
<pre class="jdocu_small">class foo(pyobj.ConfObject):
    """This is the long-winded documentation for this Simics class.
    It can be as long as you want."""
    _class_desc = 'One-line doc for the class'

    def _initialize(self):
        super()._initialize()
        self.my_val = 4711

    def _info(self):
         return [("Python device info", [("my_val", self.my_val)])]

    def _status(self):
         return [("Python device status",
                  [("woot", self.woot.val),
                   ("signal", self.signal.val)])]

    class woot(pyobj.SimpleAttribute(0, 'i|n')):
        """A four-letter attribute"""

    class lost(pyobj.Attribute):
        """A pseudo attribute"""
        attrattr = simics.Sim_Attr_Pseudo
        def getter(self):
            return self._up.my_val

    class signal(pyobj.Interface):
        def signal_raise(self): self.val = True
        def signal_lower(self): self.val = False
        def _initialize(self): self.val = False</pre><p></p></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="configuration.html:pyobj.Event">pyobj.Event</a></h3>
<p><a id="configuration.html:Event"></a> <a id="configuration.html:pyobj-Python-moduleEvent"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="configuration.html:__jdocu_seealso_pyobj.Event"></a><b>Event</b>  a Simics event</dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<b>pyobj.Event</b> defines an event that will be registered
for the containing <b>ConfObject</b> class. Internally,
registration is done with <b><i>SIM_register_event</i></b>; see the
documentation for that API function for detailed information.
<p>
Events are posted with the <b><i>post(clock, data,
&lt;duration&gt;)</i></b> method. <i>clock</i> determines which
clock the event is posted on, and <i>data</i> is the event
data. The duration is the number of <i>seconds</i>,
<i>cycles</i>, or <i>steps</i> until the event triggers,
specified with the appropriate keyword argument:
</p><p>
</p><pre class="jdocu_small">ev.post(a_clock, some_data, seconds=4.711)
ev.post(a_clock, some_data, cycles=4711)
ev.post(a_clock, some_data, steps=4711)
</pre><p>
</p><p>
Events can be cancelled before they trigger with either
<b><i>cancel_time(clock, match_fun)</i></b> or <b><i>cancel_step(clock,
match_fun)</i></b> (depending on whether the event duration was
specified in steps or not). The <i>match_fun</i> argument is
optional: if given, it should be a function that accepts an event
data parameter, and returns true for the events that should be
cancelled; if not given, all events are cancelled.
</p><p>
A subclass may define the following methods:
</p><p>
</p><dl><dt id="configuration.html:dt:callback-data"><a href="#configuration.html:dt:callback-data"><b><b><i>callback(data)</i></b></b></a></dt><dd>Called when the event
triggers. Overriding this method is not optional.</dd><dt id="configuration.html:dt:destroy-data"><a href="#configuration.html:dt:destroy-data"><b><b><i>destroy(data)</i></b></b></a></dt><dd>Called when the event is
removed from the queue without being called. The method is not
allowed to use any event API calls; it is mainly intended for
freeing event data.</dd><dt id="configuration.html:dt:get_value-data-and-set_value-val"><a href="#configuration.html:dt:get_value-data-and-set_value-val"><b><b><i>get_value(data)</i></b> and <b><i>set_value(val)</i></b></b></a></dt><dd>Converts the given event data to an <code>attr_value_t</code> value,
and the other way around. If the event carries no data that needs
checkpointing, you may omit these methods.</dd><dt id="configuration.html:dt:describe-data"><a href="#configuration.html:dt:describe-data"><b><b><i>describe(data)</i></b></b></a></dt><dd>Called to generate a
human-readable description of the event to be used in the
print-event-queue command. If you do not supply this method, the
event's name will be used.</dd></dl><p>Additionally, it may set the <i>flags</i> parameter to
<code>Sim_EC_Notsaved</code>, if the event should not be checkpointed.
In this case, neither <b><i>get_value</i></b> nor <b><i>set_value</i></b>
should be defined.</p></dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
<pre class="jdocu_small">class foo(pyobj.ConfObject):
    class ev1(pyobj.Event):
        def callback(self, data):
            do_something(data)
    class ev2(pyobj.Event):
        def callback(self, data):
            self.do_something_else(data)
        def get_value(self, data):
            return str(data)
        def set_value(self, val):
            return int(val)
        def describe(self, data):
            return 'ev2 with %s' % data
    class ev3(pyobj.Event):
        flags = simics.Sim_EC_Notsaved
        def callback(self, data):
            self._up.do_this_third_thing(data)</pre><p></p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_register_event">SIM_register_event</a>, <a class="jdocu" href="#configuration.html:__jdocu_seealso_pyobj.ConfObject"> pyobj.ConfObject</a></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="configuration.html:pyobj.Interface">pyobj.Interface</a></h3>
<p><a id="configuration.html:Interface"></a> <a id="configuration.html:pyobj-Python-moduleInterface"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="configuration.html:__jdocu_seealso_pyobj.Interface"></a><b>Interface</b>  a Simics interface</dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The <b>pyobj.Interface</b> class implements a Simics
interface for the containing <b>ConfObject</b> class. The
interface is registered using the <b><i>SIM_register_interface</i></b>
function. The interface name is taken from the class name.
<p>
The <b><i>_initialize</i></b> method can be overridden if special
initialization behavior is required.
</p><p>
To implement port interfaces instead of regular interfaces, place
one or more <b>pyobj.Interface</b> subclasses inside a
<b>pyobj.Port</b> class.</p></dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
<pre class="jdocu_small">class signal(pyobj.Interface):
    def signal_raise(self): self.val = True
    def signal_lower(self): self.val = False
    def _initialize(self): self.val = False</pre><p></p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#configuration.html:__jdocu_seealso_pyobj.Port">pyobj.Port</a>, <a class="jdocu" href="#configuration.html:__jdocu_seealso_pyobj.ConfObject"> pyobj.ConfObject</a></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="configuration.html:pyobj.Port">pyobj.Port</a></h3>
<p><a id="configuration.html:Port"></a> <a id="configuration.html:pyobj-Python-modulePort"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="configuration.html:__jdocu_seealso_pyobj.Port"></a><b>Port</b>  a Simics port</dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
To have your <b>ConfObject</b>-based Simics object implement
port interfaces, put a subclass of <b>pyobj.Port</b> as an inner
class of your <b>ConfObject</b>, and put one or more
<b>pyobj.Interface</b> subclasses inside it. The
<b>pyobj.Interface</b> subclasses will work just as if they were at
the top level, except that they will be registered with
<b><i>SIM_register_port_interface</i></b> instead of
<b><i>SIM_register_interface</i></b>.
<p>
The <b><i>_initialize</i></b> method can be overridden if special
initialization behavior is required.</p></dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
<pre class="jdocu_small">class wee(pyobj.Port):
    class signal(pyobj.Interface):
        def signal_raise(self): self.val = 2
        def signal_lower(self): self.val = 1
        def _initialize(self): self.val = 0</pre><p></p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#configuration.html:__jdocu_seealso_pyobj.Interface">pyobj.Interface</a>, <a class="jdocu" href="#configuration.html:__jdocu_seealso_pyobj.ConfObject"> pyobj.ConfObject</a></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="configuration.html:pyobj.PortObject">pyobj.PortObject</a></h3>
<p><a id="configuration.html:PortObject"></a> <a id="configuration.html:pyobj-Python-modulePortObject"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="configuration.html:__jdocu_seealso_pyobj.PortObject"></a><b>PortObject</b>  a Simics port object</dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The <b>pyobj.PortObject</b> class defines a port object class
that will be registered as a port object for the containing
<b>ConfObject</b> class.
<p>
The port object will be registered with the name "port.&lt;name&gt;",
but this can be changed by defining <i>namespace</i> to something other
than "port". One possibility is the empty string.
</p><p>
If <i>classname</i> is set, then the port object will be
an instance of this external class rather than defining the class
locally. The external class cannot be modified by adding e.g.
an interface definition inside the <b>PortObject</b> definition.</p></dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
<pre class="jdocu_small">class portname(pyobj.PortObject):
    """Documentation for the port object goes here."""
    class signal(pyobj.Interface):
        def signal_raise(self): self.val = 2
        def signal_lower(self): self.val = 1
        def _initialize(self): self.val = 0</pre><p></p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#configuration.html:__jdocu_seealso_pyobj.ConfObject">pyobj.ConfObject</a></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="configuration.html:pyobj.SimpleAttribute">pyobj.SimpleAttribute()</a></h3>
<p><a id="configuration.html:SimpleAttribute"></a> <a id="configuration.html:pyobj-Python-moduleSimpleAttribute"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="configuration.html:__jdocu_seealso_pyobj.SimpleAttribute"></a><b>SimpleAttribute</b>  a simple Simics attribute</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">SimpleAttribute(init, type = 'a', attr = simics.Sim_Attr_Optional)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The <b><i>pyobj.SimpleAttribute</i></b> function returns a new subclass of
<b>pyobj.Attribute</b>, with predefined getter and setter functions
that simply store and retrieve the value without further side effects. The
value is stored in the <code>val</code> member.
<p>
The <i>init</i> argument is the initial value, <i>type</i> is the
attribute type string, <i>attr</i> is the attribute type. If
<i>init</i> is callable, it will be called, and the return value is the
initial value; otherwise, <i>init</i> itself is the initial value.
</p><p>
The attribute value is stored in the <i>val</i> member of the class.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
pyobj.Attribute class</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
<pre class="jdocu_small">class wee(pyobj.SimpleAttribute(17, 'i')):
    """Documentation for the attribute goes here."""</pre><p></p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#configuration.html:__jdocu_seealso_pyobj.Attribute">pyobj.Attribute</a>, <a class="jdocu" href="#configuration.html:__jdocu_seealso_pyobj.ConfObject"> pyobj.ConfObject</a></dd>
</dl><p>
    </p><h2 class="jdocu"><a class="not-numbered" id="configuration.html:comp-Python-Module">comp Python Module</a></h2>
<p></p><h3 class="jdocu"><a class="not-numbered" id="configuration.html:comp.ConfigAttribute">comp.ConfigAttribute</a></h3>
<p>
  
  <a id="configuration.html:ConfigAttribute"></a> <a id="configuration.html:comp-Python-moduleConfigAttribute"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="configuration.html:__jdocu_seealso_comp.ConfigAttribute"></a><b>ConfigAttribute</b>  component configuration attribute</dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The <b>ConfigAttribute</b> class inherits the
<b>pyobj.Attribute</b> class. The
<b>ConfigAttribute</b> class just adds the special property
to the <b>pyobj.Attribute</b> class that it is a config
attribute.
<p>
A config attribute defines how the component should be
configured. Therefore, all config attributes are also arguments to the
<b>new-</b> and <b>create-</b> commands that are used to
instantiate the component.
</p><p>
Because of this, the config attribute must always be documented
and the default value of the <i>attrattr</i> member is
<code>Sim_Attr_Optional</code>.
</p><p>
The <b>ConfigAttribute</b> class contains the
<i>valid</i> member, which is a list of valid values for the
config attribute. The list gives the user a hint about valid
values when creating a component. There is no check that the value
written to the attribute is a value in the list of valid values.
The list of valid value(s) does not need to contain the default
initial value for the config attribute, but it usually does. The
valid list should at least contain one valid value even if several
values are valid.</p></dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
<pre class="jdocu_small">class foo(ConfigAttribute):
    """The foo attribute."""
    valid = [667, 4711]
    def _initialize(self): self.val = 4711
    def getter(self): return self.val
    def setter(self, val): self.val = val</pre><p></p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#configuration.html:__jdocu_seealso_pyobj.Attribute">pyobj.Attribute</a></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="configuration.html:comp.SimpleConfigAttribute">comp.SimpleConfigAttribute()</a></h3>
<p><a id="configuration.html:SimpleConfigAttribute"></a> <a id="configuration.html:comp-Python-moduleSimpleConfigAttribute"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="configuration.html:__jdocu_seealso_comp.SimpleConfigAttribute"></a><b>SimpleConfigAttribute</b>  simple component configuration attribute</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">SimpleConfigAttribute(init, type, attr = simics.Sim_Attr_Optional, val = [])</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The <b><i>pyobj.SimpleConfigAttribute</i></b> method creates an
attribute using the <b>comp.ConfigAttribute</b> class. The
purpose of the method is to make it easier and faster to create a
simple config attribute.
<p>
A config attribute defines how the component should be
configured. Therefore, all config attributes are also arguments to the
<b>new-</b> and <b>create-</b> commands that are used to
instantiate the component.
</p><p>
The <i>init</i> argument is the initial value for the
attribute. The type of the attribute is defined by the
<i>type</i> string (currently objects 'o' and dictionaries 'D'
are not supported). The <i>attr</i> argument sets the
attribute kind. The default value for <i>attr</i> is
<code>Sim_Attr_Optional</code>.
The valid value(s) for the
<b>comp.ConfigAttribute</b> class is set by the
<i>val</i> argument. See the documentation for
<b><i>SIM_register_attribute</i></b> for more information about
the arguments.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
comp.ConfigAttribute class</dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
<pre class="jdocu_small">class cpu_frequency(SimpleConfigAttribute(
        None, 'i', simics.Sim_Attr_Required)):
    """Processor frequency in MHz."""</pre><p></p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#configuration.html:__jdocu_seealso_pyobj.Attribute">pyobj.Attribute</a>, <a class="jdocu" href="#configuration.html:__jdocu_seealso_pyobj.ConfObject"> pyobj.ConfObject</a></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="configuration.html:comp.StandardComponent">comp.StandardComponent</a></h3>
<p><a id="configuration.html:StandardComponent"></a> <a id="configuration.html:comp-Python-moduleStandardComponent"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="configuration.html:__jdocu_seealso_comp.StandardComponent"></a><b>StandardComponent</b>  base class for components</dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The <b>StandardComponent</b> class is the base class for
components written in Python. It is a subclass of
<b>pyobj.ConfObject</b>.
<p>
The class will automatically register the
required component attributes. Any attribute may be overridden;
however, overriding the internal attributes is not recommended.
</p><p>
The automatically registered attributes are:
</p><dl><dt id="configuration.html:dt:basename"><a href="#configuration.html:dt:basename"><b>basename</b></a></dt><dd>String to prepend to component name when creating
 components when not specifying name.</dd><dt id="configuration.html:dt:component_icon"><a href="#configuration.html:dt:component_icon"><b>component_icon</b></a></dt><dd>String with the name of the component
 icon.</dd><dt id="configuration.html:dt:component_queue"><a href="#configuration.html:dt:component_queue"><b>component_queue</b></a></dt><dd>The default queue object for this
 component.</dd><dt id="configuration.html:dt:top_level"><a href="#configuration.html:dt:top_level"><b>top_level</b></a></dt><dd>Default set to <code>False</code>.</dd><dt id="configuration.html:dt:system_icon"><a href="#configuration.html:dt:system_icon"><b>system_icon</b></a></dt><dd>The system icon.</dd><dt id="configuration.html:dt:machine_icon"><a href="#configuration.html:dt:machine_icon"><b>machine_icon</b></a></dt><dd>The machine icon.</dd><dt id="configuration.html:dt:cpu_list"><a href="#configuration.html:dt:cpu_list"><b>cpu_list</b></a></dt><dd>List of processors in the component tree.</dd><dt id="configuration.html:dt:static_slots"><a href="#configuration.html:dt:static_slots"><b>static_slots</b></a></dt><dd>Internal.</dd><dt id="configuration.html:dt:dynamic_slots"><a href="#configuration.html:dt:dynamic_slots"><b>dynamic_slots</b></a></dt><dd>Internal.</dd><dt id="configuration.html:dt:object_list"><a href="#configuration.html:dt:object_list"><b>object_list</b></a></dt><dd>Internal.</dd><dt id="configuration.html:dt:object_prefix"><a href="#configuration.html:dt:object_prefix"><b>object_prefix</b></a></dt><dd>Internal.</dd><dt id="configuration.html:dt:top_component"><a href="#configuration.html:dt:top_component"><b>top_component</b></a></dt><dd>Internal.</dd><dt id="configuration.html:dt:instantiated"><a href="#configuration.html:dt:instantiated"><b>instantiated</b></a></dt><dd>Internal.</dd><dt id="configuration.html:dt:pending_cell_object_factories"><a href="#configuration.html:dt:pending_cell_object_factories"><b>pending_cell_object_factories</b></a></dt><dd>Internal.</dd><dt id="configuration.html:dt:config_attributes"><a href="#configuration.html:dt:config_attributes"><b>config_attributes</b></a></dt><dd>Internal.</dd><dt id="configuration.html:dt:system_info"><a href="#configuration.html:dt:system_info"><b>system_info</b></a></dt><dd>Internal.</dd><dt id="configuration.html:dt:components"><a href="#configuration.html:dt:components"><b>components</b></a></dt><dd>Internal.</dd><dt id="configuration.html:dt:domain"><a href="#configuration.html:dt:domain"><b>domain</b></a></dt><dd>Internal.</dd></dl><p>The class will automatically implement the <code>component</code>
interface. The individual methods of this interface are user-overridable.
</p><p>
Components will automatically get <b>new-</b> and <b>create-</b>
commands that can be used to create and instantiate the component. It is
possible to override this by setting <em>_no_create_command</em> or
<em>_no_new_command</em> to <em>object()</em> to avoid to automatically get
<b>create-</b> or <b>new-</b> commands.</p></dd>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
<pre class="jdocu_small">class my_comp(StandardComponent):
    """The my_comp component."""
    _class_desc = "my_comp"

    class bar(SimpleConfigAttribute(
            None, 'i', simics.Sim_Attr_Required)):
        """My favorite bar."""

class my_comp(StandardComponent):
    """The my_comp component."""
    _class_desc = "my_comp"
    _no_create_command = object()</pre><p></p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#configuration.html:__jdocu_seealso_pyobj.ConfObject">pyobj.ConfObject</a></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="configuration.html:comp.StandardComponent-Methods">comp.StandardComponent Methods</a></h3>
<p></p><h4 class="jdocu"><a class="not-numbered" id="configuration.html:comp.StandardComponent.add_component">comp.StandardComponent.add_component()</a></h4>
<p><a id="configuration.html:add_component"></a> <a id="configuration.html:comp-Python-moduleStandardComponentadd_component"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="configuration.html:__jdocu_seealso_comp.StandardComponent.add_component"></a><b>add_component</b>  add sub component to component</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">add_component(self, slot, cls, attr, name = '')</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Add a subcomponent or arrays of subcomponents to the
component. The subcomponent(s) will be created immediately when
the method is called.
<p>
The <i>slot</i> argument is the slot name concatenated with
a nested array string, defining the number of subcomponents to
create. Setting <i>slot</i> to <em>foo</em> will create one
subcomponent in the slot <em>foo</em>, setting <i>slot</i>
to <em>foo[3]</em> will create an array of three subcomponents
in the slot <em>foo</em>, setting <i>slot</i> to
<em>foo[3][2]</em> will create an array of three arrays of two
arrays with subcomponents in the slot <em>foo</em>.
</p><p>
The <i>cls</i> is the component class, <i>attr</i> is
arguments to the component, and <i>name</i> is an optional
name.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
arrays of conf_object_t component object</dd>
</dl><p></p><h4 class="jdocu"><a class="not-numbered" id="configuration.html:comp.StandardComponent.add_connector">comp.StandardComponent.add_connector()</a></h4>
<p><a id="configuration.html:add_connector"></a> <a id="configuration.html:comp-Python-moduleStandardComponentadd_connector"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="configuration.html:__jdocu_seealso_comp.StandardComponent.add_connector"></a><b>add_connector</b>  add connector to component</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">add_connector(self, slot, type, hotpluggable, required,
              multi, direction)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Add a connector or nested array of connectors to the component. The
connector(s) will be created immediately when the method is called.
<p>
The <i>slot</i> argument is the slot name concatenated with a
nested array string, defining the number of connectors to create.
Setting <i>slot</i> to <em>foo</em> will create one connector in
the slot <em>foo</em>, setting <i>slot</i> to <em>foo[3]</em> will
create an array of three connectors in the slot <em>foo</em>, setting
<i>slot</i> to <em>foo[3][2]</em> will create an array of three
arrays of two arrays with connectors in the slot <em>foo</em>.
</p><p>
The <i>type</i> is the type of connection as a string,
<i>hotpluggable</i> is <code>True</code> or <code>False</code> depending on
whether the connector is hot-pluggable, <i>required</i> is
<code>True</code> if the connector must be connected before the component
is instantiated, <i>multi</i> is <code>True</code> if the connector
supports multiple connections, <i>direction</i> is a
<code>connector_direction_t</code> which is <code>up</code>, <code>down</code>,
or <code>any</code>.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
arrays of conf_object connector objects</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#configuration.html:__jdocu_seealso_comp.StandardComponent.get_slot">comp.StandardComponent.get_slot</a></dd>
</dl><p></p><h4 class="jdocu"><a class="not-numbered" id="configuration.html:comp.StandardComponent.add_pre_obj">comp.StandardComponent.add_pre_obj()</a></h4>
<p><a id="configuration.html:add_pre_obj"></a> <a id="configuration.html:comp-Python-moduleStandardComponentadd_pre_obj"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="configuration.html:__jdocu_seealso_comp.StandardComponent.add_pre_obj"></a><b>add_pre_obj</b>  add pre_conf_obj to component</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">add_pre_obj(self, slot, cls, name = '', **attr)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Add pre conf objects to the component. The pre conf objects will
be converted to regular conf objects when the component is
instantiated.
<p>
The <i>slot</i> argument is the slot name concatenated with
a nested array string, defining the number of pre objects to
create. Setting <i>slot</i> to <em>foo</em> will create one
pre object in the slot <em>foo</em>, setting <i>slot</i> to
<em>foo[3]</em> will create an array of three pre objects in
the slot <em>foo</em>, setting <i>slot</i> to
<em>foo[3][2]</em> will create an array of three arrays of two
arrays with pre objects in the slot <em>foo</em>. The
<i>cls</i> argument is the type of object class to
create. The <i>name</i> argument is deprecated. The
<i>attr</i> argument is optional attribute values for the
object(s).</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
arrays of pre conf objects</dd>
</dl><p></p><h4 class="jdocu"><a class="not-numbered" id="configuration.html:comp.StandardComponent.add_slot">comp.StandardComponent.add_slot()</a></h4>
<p><a id="configuration.html:add_slot"></a> <a id="configuration.html:comp-Python-moduleStandardComponentadd_slot"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="configuration.html:__jdocu_seealso_comp.StandardComponent.add_slot"></a><b>add_slot</b>  add slot to component</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">add_slot(self, slot, val)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Add a slot to the component. <i>slot</i> is the slot name and
<i>val</i> is the value. The value must be a conf object,
a pre conf object, or None, or nested lists of these types.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
new slot value, i.e. <i>val</i></dd>
</dl><p></p><h4 class="jdocu"><a class="not-numbered" id="configuration.html:comp.StandardComponent.connect">comp.StandardComponent.connect()</a></h4>
<p><a id="configuration.html:connect"></a> <a id="configuration.html:comp-Python-moduleStandardComponentconnect"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="configuration.html:__jdocu_seealso_comp.StandardComponent.connect"></a><b>connect</b>  connect connectors</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">connect(self, cnt0, cnt1)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Connect two connectors <i>cnt0</i> and <i>cnt1</i>. The
connectors must be connector objects. A <code>CompException</code>
exception will be raised if the connection failed.</dd>
</dl><p></p><h4 class="jdocu"><a class="not-numbered" id="configuration.html:comp.StandardComponent.copy_connector">comp.StandardComponent.copy_connector()</a></h4>
<p><a id="configuration.html:copy_connector"></a> <a id="configuration.html:comp-Python-moduleStandardComponentcopy_connector"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="configuration.html:__jdocu_seealso_comp.StandardComponent.copy_connector"></a><b>copy_connector</b>  copy connector to component</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">copy_connector(self, slot, src)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Copy connectors from another component. The <i>slot</i> argument
is the new slot name for the connector in this component. The
<i>src</i> argument is the name of the slot with connectors to
copy. The <i>src</i> can be a relative slot name, see the
<b><i>get_slot</i></b> method.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
arrays of conf_object connector objects</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#configuration.html:__jdocu_seealso_comp.StandardComponent.get_slot">comp.StandardComponent.get_slot</a></dd>
</dl><p></p><h4 class="jdocu"><a class="not-numbered" id="configuration.html:comp.StandardComponent.del_slot">comp.StandardComponent.del_slot()</a></h4>
<p><a id="configuration.html:del_slot"></a> <a id="configuration.html:comp-Python-moduleStandardComponentdel_slot"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="configuration.html:__jdocu_seealso_comp.StandardComponent.del_slot"></a><b>del_slot</b>  delete slot in component</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">del_slot(self, slot)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Delete slot in component. The <i>slot</i> argument is the
slot name. The function returns the slot value if the slot
exists. All connectors in the slot will be converted to pre conf
objects and the original connectors will be deleted when
returning the slot value. A <code>CompException</code> exception
will be raised if the slot does not exist, the slot contains
non connector conf objects, or the slot contains connectors that
have been copied with the <b><i>copy_connector</i></b>
method. Slots with sub components can not be deleted.</dd>
</dl><p></p><h4 class="jdocu"><a class="not-numbered" id="configuration.html:comp.StandardComponent.get_slot">comp.StandardComponent.get_slot()</a></h4>
<p><a id="configuration.html:get_slot"></a> <a id="configuration.html:comp-Python-moduleStandardComponentget_slot"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="configuration.html:__jdocu_seealso_comp.StandardComponent.get_slot"></a><b>get_slot</b>  get slot from component</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">get_slot(self, slot)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Get a slot from the component. <i>slot</i> is the slot name.
<i>slot</i> can be a slot in this component or a
hierarchical slot; e.g., looking up <i>foo.bar</i> will
return the slot <i>bar</i> from the component in slot
<i>foo</i> from this component. If the lookup fails, a
<code>CompException</code> exception will be raised.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
slot value</dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="configuration.html:comp.StandardConnectorComponent">comp.StandardConnectorComponent</a></h3>
<p>
  
  <a id="configuration.html:StandardConnectorComponent"></a> <a id="configuration.html:comp-Python-moduleStandardConnectorComponent"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="configuration.html:__jdocu_seealso_comp.StandardConnectorComponent"></a><b>StandardConnectorComponent</b>  convenience class for connector components</dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The <b>StandardConnectorComponent</b> is a convenience class for
connector components. It is a subclass of
<b>comp.StandardComponent</b> and implements the
<code>component_connector</code> interface.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#configuration.html:__jdocu_seealso_comp.StandardComponent">comp.StandardComponent</a></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="configuration.html:comp.StandardConnectorComponent-Methods">comp.StandardConnectorComponent Methods</a></h3>
<p></p><h4 class="jdocu"><a class="not-numbered" id="configuration.html:comp.StandardConnectorComponent.add_connector">comp.StandardConnectorComponent.add_connector()</a></h4>
<p><a id="configuration.html:add_connector2"></a> <a id="configuration.html:comp-Python-moduleStandardConnectorComponentadd_connector"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="configuration.html:__jdocu_seealso_comp.StandardConnectorComponent.add_connector"></a><b>add_connector</b>  create a connector component</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">add_connector(self, slot, cls)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Create a connector component.
<p>
The <i>slot</i> argument is the slot name for the connector.
</p><p>
The <i>cls</i> argument is an instance of a connector class.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
the conf_object connector component</dd>
</dl><p>
    </p><h2 class="jdocu"><a class="not-numbered" id="configuration.html:Checkpoints">Checkpoints</a></h2>
<p></p><h3 class="jdocu"><a class="not-numbered" id="configuration.html:update_checkpoint.SIM_register_class_update">update_checkpoint.SIM_register_class_update()</a></h3>
<p>
  
  <a id="configuration.html:SIM_register_class_update"></a> <a id="configuration.html:update_checkpoint-Python-moduleSIM_register_class_update"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="configuration.html:__jdocu_seealso_update_checkpoint.SIM_register_class_update"></a><b>SIM_register_class_update</b>  register a class update function</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">SIM_register_class_update(build_id, classname, function)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Register the class update function <i>function</i> for class
<i>classname</i>, to be run when updating a checkpoint to build-id
<i>build_id</i>.
<p>
The <i>function</i> acts on a single object of a given class. It
will be called for all matching objects with the current object as
argument. It doesn't need to return anything, however it can't create or
destroy objects, only change the attributes of the object it got as
parameter, except the object name.</p></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="configuration.html:update_checkpoint.SIM_register_generic_update">update_checkpoint.SIM_register_generic_update()</a></h3>
<p><a id="configuration.html:SIM_register_generic_update"></a> <a id="configuration.html:update_checkpoint-Python-moduleSIM_register_generic_update"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="configuration.html:__jdocu_seealso_update_checkpoint.SIM_register_generic_update"></a><b>SIM_register_generic_update</b>  register a generic update function</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">SIM_register_generic_update(build_id, function)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Register the generic update function <i>function</i> to be run
when updating a checkpoint to build-id <i>build_id</i>. The
<i>function</i> acts on one or several objects of various classes,
and may rename, create or destroy objects. When the checkpoint reaches the
required build-id, the <i>function</i> will be called once with the
complete set of objects that constitute the checkpoint as a parameter. It
is expected to return three lists of pre_conf_objects: (deleted objects,
changed objects, added objects). Deleted objects must have been removed
from the configuration, changed objects can have any attribute changed
(including their class or their name). Added objects must have been added
to the configuration.
<p>
When renaming an object, the <i>function</i> is expected to remove
the object from the checkpoint set under its old name and to add it again
under its new name. The object should be reported in the changed object
list.</p></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="configuration.html:update_checkpoint.SIM_register_post_update">update_checkpoint.SIM_register_post_update()</a></h3>
<p><a id="configuration.html:SIM_register_post_update"></a> <a id="configuration.html:update_checkpoint-Python-moduleSIM_register_post_update"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="configuration.html:__jdocu_seealso_update_checkpoint.SIM_register_post_update"></a><b>SIM_register_post_update</b>  register a generic update function</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">SIM_register_post_update(function)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Register the generic update function <i>function</i> to be run
when updating a checkpoint to build-id <i>build_id</i>. after all
build-id based update functions have run, but before the checkpoint is
loaded. The <i>function</i> should behave as functions added with
<b><i>SIM_register_generic_update</i></b>.</dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="configuration.html:update_checkpoint.all_objects">update_checkpoint.all_objects()</a></h3>
<p><a id="configuration.html:all_objects"></a> <a id="configuration.html:update_checkpoint-Python-moduleall_objects"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="configuration.html:__jdocu_seealso_update_checkpoint.all_objects"></a><b>all_objects</b>  return all objects of a given class</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">all_objects(set, classname)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This function should only be used while updating checkpoints, as
described in <em>Model Builder User's Guide</em>, in the
<em>Checkpoint Compatibility</em> chapter.
<p>
Return a list of all objects of class <i>classname</i> present in
the checkpoint <i>set</i>.</p></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="configuration.html:update_checkpoint.for_all_objects">update_checkpoint.for_all_objects()</a></h3>
<p><a id="configuration.html:for_all_objects"></a> <a id="configuration.html:update_checkpoint-Python-modulefor_all_objects"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="configuration.html:__jdocu_seealso_update_checkpoint.for_all_objects"></a><b>for_all_objects</b>  apply a function on all objects of a given class</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">for_all_objects(set, classname, function)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This function should only be used while updating checkpoints, as
described in <em>Model Builder User's Guide</em>, in the
<em>Checkpoint Compatibility</em> chapter.
<p>
Apply the function <i>function</i> on all objects of class
<i>classname</i> present in <i>set</i>.
<i>function</i> is defined as:
</p><p>
</p><pre class="jdocu_small">function(config, object)</pre><p>
</p><p>
where <i>config</i> is the Python dictionary containing all
objects, and object is an object of class <i>classname</i>.</p></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="configuration.html:update_checkpoint.remove_attr">update_checkpoint.remove_attr()</a></h3>
<p><a id="configuration.html:remove_attr"></a> <a id="configuration.html:update_checkpoint-Python-moduleremove_attr"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="configuration.html:__jdocu_seealso_update_checkpoint.remove_attr"></a><b>remove_attr</b>  remove an attribute</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">remove_attr(obj, name)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This function should only be used while updating checkpoints, as
described in <em>Model Builder User's Guide</em>, in the
<em>Checkpoint Compatibility</em> chapter.
<p>
Remove the attribute <i>name</i> from the object
<i>obj</i>.</p></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="configuration.html:update_checkpoint.remove_class">update_checkpoint.remove_class()</a></h3>
<p><a id="configuration.html:remove_class"></a> <a id="configuration.html:update_checkpoint-Python-moduleremove_class"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="configuration.html:__jdocu_seealso_update_checkpoint.remove_class"></a><b>remove_class</b>  remove all instances of a class</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">remove_class(set, classname)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This function should only be used while updating checkpoints, as
described in <em>Model Builder User's Guide</em>, in the
<em>Checkpoint Compatibility</em> chapter.
<p>
In the checkpoint <i>set</i>, remove all objects of class
<i>classname</i>.</p></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="configuration.html:update_checkpoint.remove_class_attr">update_checkpoint.remove_class_attr()</a></h3>
<p><a id="configuration.html:remove_class_attr"></a> <a id="configuration.html:update_checkpoint-Python-moduleremove_class_attr"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="configuration.html:__jdocu_seealso_update_checkpoint.remove_class_attr"></a><b>remove_class_attr</b>  remove a class attribute</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">remove_class_attr(set, classname, name)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This function should only be used while updating checkpoints, as
described in <em>Model Builder User's Guide</em>, in the
<em>Checkpoint Compatibility</em> chapter.
<p>
In the checkpoint <i>set</i>, remove the class attribute
<i>name</i> from all objects of class <i>classname</i>.</p></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="configuration.html:update_checkpoint.rename_attr">update_checkpoint.rename_attr()</a></h3>
<p><a id="configuration.html:rename_attr"></a> <a id="configuration.html:update_checkpoint-Python-modulerename_attr"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="configuration.html:__jdocu_seealso_update_checkpoint.rename_attr"></a><b>rename_attr</b>  rename an attribute</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">rename_attr(obj, new_attr, old_attr)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This function should only be used while updating checkpoints, as
described in <em>Model Builder User's Guide</em>, in the
<em>Checkpoint Compatibility</em> chapter.
<p>
Rename the attribute <i>old_attr</i> to <i>new_attr</i> in
the object <i>obj</i>.</p></dd>
</dl><p>
    </p><h2 class="jdocu"><a class="not-numbered" id="configuration.html:configuration.OBJ">configuration.OBJ</a></h2>
<p>
  
  <a id="configuration.html:OBJ"></a> <a id="configuration.html:configuration-Python-moduleOBJ"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="configuration.html:__jdocu_seealso_configuration.OBJ"></a><b>OBJ</b>  class for referring to another object, existing or not</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">OBJ(name)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<b><i>OBJ</i></b> is only used together with the
<b><i>SIM_set_configuration</i></b> API function. <b><i>OBJ</i></b> is
used when a configuration attribute needs to refer to another
object. The other object can either be present in an existing
configuration, or it can be an object that will be created as a
result of the same call to <b><i>SIM_set_configuration</i></b>. See
<b><i>SIM_set_configuration</i></b> for an example.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<b><i>SIM_set_configuration</i></b></dd>
</dl><p></p><h2 class="jdocu"><a class="not-numbered" id="configuration.html:simics.pre_conf_object">simics.pre_conf_object</a></h2>
<p><a id="configuration.html:pre_conf_object"></a> <a id="configuration.html:simics-Python-modulepre_conf_object"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="configuration.html:__jdocu_seealso_simics.pre_conf_object"></a><b>pre_conf_object</b>  class for Simics configuration object to instantiate</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">pre_conf_object(object_name, class_name, build_id = None)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
A class representing a future Simics configuration object named
<i>object_name</i>, of class <i>class_name</i>. If
<i>object_name</i> is <code>None</code>, a unique name will be
generated.
<p>
The <i>build-id</i> of the object can be specified when using the
<code>pre_conf_object</code> class during checkpoints update. Refer to
<em>Model Builder User's Guide</em> for more information.
</p><p>
Future configuration attributes are set using normal Python class members:
</p><pre class="jdocu_small">  a = pre_conf_object("test_object", "test-class")
  a.value = 42</pre><p>
</p><p>
After using a <b>pre_conf_object</b> object to create a
configuration object, the created object can be obtained by passing the
<b>pre_conf_object</b>'s <code>name</code> member to
<b><i>SIM_get_object()</i></b>.</p></dd>
</dl><p>
</p></section><section class="page" id="hypersim.html"><h1 class="jdocu"><a id="hypersim.html:Hypersim">10.4 Hypersim</a></h1>
<p>

    </p><h2 class="jdocu"><a id="hypersim.html:hypersim_patterns.add">10.4.1 hypersim_patterns.add()</a></h2>
<p>
  
  <a id="hypersim.html:add"></a> <a id="hypersim.html:hypersim_patterns-Python-moduleadd"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="hypersim.html:__jdocu_seealso_hypersim_patterns.add"></a><b>add</b>  register a hypersim-pattern</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">add(name, arch,
    target_list = None,
    own_info_cmd = False,
    own_status_cmd = False)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The simics_start.py script for all pattern modules should call
this function to register its pattern classes. The patterns will
be automatically installed on the processor types it supports.
<p>
Function arguments:
</p><dl><dt id="hypersim.html:dt:name"><a href="#hypersim.html:dt:name"><b><i>name</i></b></a></dt><dd>class name</dd><dt id="hypersim.html:dt:arch"><a href="#hypersim.html:dt:arch"><b><i>arch</i></b></a></dt><dd>architecture it supports (cpu-&gt;architecture ppc32, ppc64)</dd><dt id="hypersim.html:dt:target_list"><a href="#hypersim.html:dt:target_list"><b><i>target_list</i></b></a></dt><dd>optional list of classnames that are supported.
        If target_list is omitted or None, the pattern will be used by all
        CPUs of <i>arch</i> architecture.</dd><dt id="hypersim.html:dt:own_info_cmd"><a href="#hypersim.html:dt:own_info_cmd"><b><i>own_info_cmd</i></b></a></dt><dd>Legacy parameter, must always be overridden to True</dd><dt id="hypersim.html:dt:own_status_cmd"><a href="#hypersim.html:dt:own_status_cmd"><b><i>own_status_cmd</i></b></a></dt><dd>Legacy parameter, must always be overridden to True</dd></dl><p></p></dd>
</dl><p></p><h2 class="jdocu"><a id="hypersim.html:hypersim_patterns.register_std_info_command">10.4.2 hypersim_patterns.register_std_info_command()</a></h2>
<p><a id="hypersim.html:register_std_info_command"></a> <a id="hypersim.html:hypersim_patterns-Python-moduleregister_std_info_command"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="hypersim.html:__jdocu_seealso_hypersim_patterns.register_std_info_command"></a><b>register_std_info_command</b>  register standard info command</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">register_std_info_command(cls)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Register a basic info command implementation for the hypersim
pattern class named <i>cls</i></dd>
</dl><p></p><h2 class="jdocu"><a id="hypersim.html:hypersim_patterns.register_std_status_command">10.4.3 hypersim_patterns.register_std_status_command()</a></h2>
<p><a id="hypersim.html:register_std_status_command"></a> <a id="hypersim.html:hypersim_patterns-Python-moduleregister_std_status_command"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="hypersim.html:__jdocu_seealso_hypersim_patterns.register_std_status_command"></a><b>register_std_status_command</b>  register standard status command</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">register_std_status_command(cls)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Register a basic status command implementation for the hypersim
pattern class named <i>cls</i></dd>
</dl><p>
</p></section><section class="page" id="flash-memory.html"><h1 class="jdocu"><a id="flash-memory.html:Flash-Memory">10.5 Flash Memory</a></h1>
<p>

    </p><h2 class="jdocu"><a class="not-numbered" id="flash-memory.html:Flash-Memory-Classes-and-Functions">Flash Memory Classes and Functions</a></h2>
<p></p><h3 class="jdocu"><a class="not-numbered" id="flash-memory.html:flash_memory.flash_add_model">flash_memory.flash_add_model()</a></h3>
<p>
  
  <a id="flash-memory.html:flash_add_model"></a> <a id="flash-memory.html:flash_memory-Python-moduleflash_add_model"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="flash-memory.html:__jdocu_seealso_flash_memory.flash_add_model"></a><b>flash_add_model</b>  add a new flash model</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">flash_add_model(product_no, config, complete_func)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Adds a new flash model. Instances of the new flash can then be created
with the <b><i>flash_create_memory</i></b> and
<b><i>flash_create_memory_anon</i></b> functions.
<p>
These are the arguments:
</p><dl><dt id="flash-memory.html:dt:product_no"><a href="#flash-memory.html:dt:product_no"><b><i>product_no</i></b></a></dt><dd>Product number; e.g., "28F___C3_". Underscores act as wild cards
        and will match any character.</dd><dt id="flash-memory.html:dt:config"><a href="#flash-memory.html:dt:config"><b><i>config</i></b></a></dt><dd>Dictionary containing <i>attribute</i>: value pairs. These
         attributes are <b>generic-flash-memory</b> attributes;
         information on available attributes and how to configure them can
         be found in the reference manual.</dd><dt id="flash-memory.html:dt:complete_fun"><a href="#flash-memory.html:dt:complete_fun"><b><i>complete_fun</i></b></a></dt><dd>Function of type <b><i>complete_fun(product_no, config)</i></b> that
         will be called just before a flash memory is instantiated.
         <i>product_no</i> is the product number specified by the
         user. <i>config</i> is the same <i>config</i>
         dictionary as passed to the <b><i>flash_add_model</i></b> function.
         The <b><i>complete_fun</i></b> can modify the attribute values, add
         new attributes or remove attributes from the configuration, based
         on e.g. the <i>product_no</i>. The <b><i>complete_fun</i></b>
         should return either an error message (i.e. a string), or a tuple
         (<i>updated_config</i>, <i>size</i>) where
         <i>size</i> is the size of one flash chip, in bytes.</dd></dl><p></p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
True if the flash model was successfully added,
or False if it failed.</dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="flash-memory.html:flash_memory.flash_create_memory">flash_memory.flash_create_memory()</a></h3>
<p><a id="flash-memory.html:flash_create_memory"></a> <a id="flash-memory.html:flash_memory-Python-moduleflash_create_memory"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="flash-memory.html:__jdocu_seealso_flash_memory.flash_create_memory"></a><b>flash_create_memory</b>  create a list of objects representing a flash memory</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">flash_create_memory(name, product_no, interleave, bus_width,
                    files = [],
                    queue = None,
                    accept_smaller_reads = 1,
                    accept_smaller_writes = 0,
                    big_endian = 0)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns a list of pre_objects suitable as input for
<b><i>SIM_add_configuration</i></b> and the total size in bytes of the flash
memory. The list and the size is returned as a tuple.
<p>
The flash objects will be named, which makes them suitable for use in legacy
components. New components should use the function
<b><i>flash_create_memory_anon</i></b> instead.
</p><p>
Function arguments:
</p><dl><dt id="flash-memory.html:dt:name"><a href="#flash-memory.html:dt:name"><b><i>name</i></b></a></dt><dd>Base name for all objects (flash, ram, and image).</dd><dt id="flash-memory.html:dt:product_no-2"><a href="#flash-memory.html:dt:product_no-2"><b><i>product_no</i></b></a></dt><dd>Product name; e.g., "28F160C3T".</dd><dt id="flash-memory.html:dt:interleave"><a href="#flash-memory.html:dt:interleave"><b><i>interleave</i></b></a></dt><dd>Byte interleaving; one of 1, 2, 4, and 8.</dd><dt id="flash-memory.html:dt:bus_width"><a href="#flash-memory.html:dt:bus_width"><b><i>bus_width</i></b></a></dt><dd>Bus width; one of 8, 16, 32, and 64.</dd><dt id="flash-memory.html:dt:files"><a href="#flash-memory.html:dt:files"><b><i>files</i></b></a></dt><dd>Same as the <i>file</i> attribute of <b>image</b>
     objects. Defaults to the empty list.</dd><dt id="flash-memory.html:dt:queue"><a href="#flash-memory.html:dt:queue"><b><i>queue</i></b></a></dt><dd>Queue object to use.</dd><dt id="flash-memory.html:dt:accept_smaller_reads"><a href="#flash-memory.html:dt:accept_smaller_reads"><b><i>accept_smaller_reads</i></b></a></dt><dd>If 1 (default), the flash device will accept reads smaller than
         the bus width. if 0, the flash device will complain when receiving
         smaller reads.
     </dd><dt id="flash-memory.html:dt:accept_smaller_writes"><a href="#flash-memory.html:dt:accept_smaller_writes"><b><i>accept_smaller_writes</i></b></a></dt><dd>If 1, the flash device will accept writes smaller than the bus
         width. If 0 (default), the flash device will complain when
         receiving smaller writes.
     </dd><dt id="flash-memory.html:dt:big_endian"><a href="#flash-memory.html:dt:big_endian"><b><i>big_endian</i></b></a></dt><dd>If set, the flash device will behave as a big endian device. If
         not set (default), it will behave as a little endian device.
     </dd></dl><p></p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
tuple(object dict, total size in bytes)</dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="flash-memory.html:flash_memory.flash_create_memory_anon">flash_memory.flash_create_memory_anon()</a></h3>
<p><a id="flash-memory.html:flash_create_memory_anon"></a> <a id="flash-memory.html:flash_memory-Python-moduleflash_create_memory_anon"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="flash-memory.html:__jdocu_seealso_flash_memory.flash_create_memory_anon"></a><b>flash_create_memory_anon</b>  create a list of objects representing a flash memory</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">flash_create_memory_anon(product_no, interleave, bus_width,
                         files = [],
                         queue = None,
                         accept_smaller_reads = 1,
                         accept_smaller_writes = 0,
                         big_endian = 0)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns an list of pre_objects suitable as input for
<b><i>SIM_add_configuration</i></b> and the total size in bytes of the flash
memory. The list and the size is returned as a tuple.
<p>
The flash objects will be anonymous, which makes them suitable for use in
new components. Legacy components should use the function
<b><i>flash_create_memory</i></b> instead.
</p><p>
Function arguments:
</p><dl><dt id="flash-memory.html:dt:product_no-3"><a href="#flash-memory.html:dt:product_no-3"><b><i>product_no</i></b></a></dt><dd>Product name; e.g., "28F160C3T".</dd><dt id="flash-memory.html:dt:interleave-2"><a href="#flash-memory.html:dt:interleave-2"><b><i>interleave</i></b></a></dt><dd>Byte interleaving; one of 1, 2, 4, and 8.</dd><dt id="flash-memory.html:dt:bus_width-2"><a href="#flash-memory.html:dt:bus_width-2"><b><i>bus_width</i></b></a></dt><dd>Bus width; one of 8, 16, 32, and 64.</dd><dt id="flash-memory.html:dt:files-2"><a href="#flash-memory.html:dt:files-2"><b><i>files</i></b></a></dt><dd>Same as the <i>file</i> attribute of <b>image</b>
     objects. Defaults to the empty list.</dd><dt id="flash-memory.html:dt:queue-2"><a href="#flash-memory.html:dt:queue-2"><b><i>queue</i></b></a></dt><dd>Queue object to use.</dd><dt id="flash-memory.html:dt:accept_smaller_reads-2"><a href="#flash-memory.html:dt:accept_smaller_reads-2"><b><i>accept_smaller_reads</i></b></a></dt><dd>If 1 (default), the flash device will accept reads smaller than
         the bus width. if 0, the flash device will complain when receiving
         smaller reads.
     </dd><dt id="flash-memory.html:dt:accept_smaller_writes-2"><a href="#flash-memory.html:dt:accept_smaller_writes-2"><b><i>accept_smaller_writes</i></b></a></dt><dd>If 1, the flash device will accept writes smaller than the bus
         width. If 0 (default), the flash device will complain when
         receiving smaller writes.
     </dd><dt id="flash-memory.html:dt:big_endian-2"><a href="#flash-memory.html:dt:big_endian-2"><b><i>big_endian</i></b></a></dt><dd>If set, the flash device will behave as a big endian device. If
         not set (default), it will behave as a little endian device.
     </dd></dl><p></p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
tuple(object list, total size in bytes)</dd>
</dl><p>
</p></section><section class="page" id="system-panel.html"><h1 class="jdocu"><a id="system-panel.html:System-Panel">10.6 System Panel</a></h1>
<p>
  
</p><p>
  The System Panel API is a set of Python functions and classes that is used to
  create system panels.  Further documentation can be found in the <em>Model
  Builder User's Guide</em>, chapter <em>Creating a System Panel</em>.
</p><p>
  The <em>API</em> section covers the generic API for the system panel
  infrastructure and a couple of helper functions; the <em>Widget Types</em>
  section describes the specifics of each type of widget that can be included
  in a panel.
</p><p>
  </p><h2 class="jdocu"><a class="not-numbered" id="system-panel.html:API">API</a></h2>
<p></p><h3 class="jdocu"><a class="not-numbered" id="system-panel.html:Standard-Widgets-Colors">Standard Widgets Colors</a></h3>
<p>
 
 </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="system-panel.html:__jdocu_seealso_Standard-Widgets-Colors"></a>standard color names</dd>
<dt class="jdocu_descitem">NAMESPACE</dt><dd>
<code>systempanel.widgets</code></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The standard widgets colors are used for creating LED widgets with
    different colors.
  </dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">systempanel.widgets.BLUE
systempanel.widgets.GREEN
systempanel.widgets.PURPLE
systempanel.widgets.RED
systempanel.widgets.WHITE
systempanel.widgets.YELLOW
    </pre><p>
  </p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#system-panel.html:__jdocu_seealso_systempanel.widgets.Led">systempanel.widgets.Led</a></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="system-panel.html:systempanel.SystemPanel">systempanel.SystemPanel</a></h3>
<p><a id="system-panel.html:SystemPanel"></a> <a id="system-panel.html:systempanel-Python-moduleSystemPanel"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="system-panel.html:__jdocu_seealso_systempanel.SystemPanel"></a><b>SystemPanel</b>  Base class for system panel components</dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
A base class for system panels. A system panel class should
inherit from this and set the 'layout' class variable to describe
the contents of the panel.</dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="system-panel.html:systempanel.SystemPanelException">systempanel.SystemPanelException</a></h3>
<p><a id="system-panel.html:SystemPanelException"></a> <a id="system-panel.html:systempanel-Python-moduleSystemPanelException"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="system-panel.html:__jdocu_seealso_systempanel.SystemPanelException"></a><b>SystemPanelException</b>  System panel error</dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Exception thrown for various errors in the system_panel module</dd>
</dl><p>
  </p><h2 class="jdocu"><a class="not-numbered" id="system-panel.html:Widget-Types">Widget Types</a></h2>
<p></p><h3 class="jdocu"><a class="not-numbered" id="system-panel.html:systempanel.widgets.BitfieldImageOutput">systempanel.widgets.BitfieldImageOutput</a></h3>
<p>
  
  <a id="system-panel.html:BitfieldImageOutput"></a> <a id="system-panel.html:systempanelwidgets-Python-moduleBitfieldImageOutput"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="system-panel.html:__jdocu_seealso_systempanel.widgets.BitfieldImageOutput"></a><b>BitfieldImageOutput</b>  Multiple two-state image outputs driven by a single integer state</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">BitfieldImageOutput(obj_name, contents)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
An output consisting of multiple two-state images, driven by a
single integer state. such that each two-state image is driven by
a single bit in the integer.  Useful e.g. when creating 7-segment
displays.
<p>
The <i>contents</i> parameter is a list of tuples <code>(mask, x, y,
[off_filename, on_filename])</code>, where the integer <code>mask</code> is a
power of two, <code>x</code> and <code>y</code> are integer offsets, and
<code>off_filename</code> and <code>on_filename</code> are file names given on the
same form as in the <b>Image</b> class. The <code>off_filename</code>
image is shown at the given offset whenever the bit indicated by
<code>mask</code> is 0; <code>on_filename</code> is shown otherwise.</p></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="system-panel.html:systempanel.widgets.BitmapButton">systempanel.widgets.BitmapButton</a></h3>
<p><a id="system-panel.html:BitmapButton"></a> <a id="system-panel.html:systempanelwidgets-Python-moduleBitmapButton"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="system-panel.html:__jdocu_seealso_systempanel.widgets.BitmapButton"></a><b>BitmapButton</b>  A bitmap-based button</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">BitmapButton(obj_name, off_bitmap, on_bitmap)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
A bitmap-based button. Similar to the standard <b>Button</b>
class, but can be put inside a <b>Canvas</b>, and the appearance is
based on custom images. The bitmap parameters are filenames of the same
type as in the <b>Image</b> class.</dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="system-panel.html:systempanel.widgets.BitmapLed">systempanel.widgets.BitmapLed</a></h3>
<p><a id="system-panel.html:BitmapLed"></a> <a id="system-panel.html:systempanelwidgets-Python-moduleBitmapLed"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="system-panel.html:__jdocu_seealso_systempanel.widgets.BitmapLed"></a><b>BitmapLed</b>  A bitmap-based LED</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">BitmapLed(obj_name, off_bitmap, on_bitmap)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
A bitmap-based LED. Same as the standard <b>Led</b> class, but
can be put inside a <b>Canvas</b>, and custom images can be
supplied.  The bitmap constructor parameters are file names of the same
type as in the <b>Image</b> class.</dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="system-panel.html:systempanel.widgets.BitmapToggleButton">systempanel.widgets.BitmapToggleButton</a></h3>
<p><a id="system-panel.html:BitmapToggleButton"></a> <a id="system-panel.html:systempanelwidgets-Python-moduleBitmapToggleButton"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="system-panel.html:__jdocu_seealso_systempanel.widgets.BitmapToggleButton"></a><b>BitmapToggleButton</b>  A bitmap-based toggle button</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">BitmapToggleButton(obj_name, off_bitmap, on_bitmap)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
A bitmap-based toggle button. Similar to the standard
<b>ToggleButton</b> class, but can be put inside a
<b>Canvas</b>, and the appearance is based on custom images. The
bitmap parameters are file names of the same type as in the
<b>Image</b> class.</dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="system-panel.html:systempanel.widgets.Button">systempanel.widgets.Button</a></h3>
<p><a id="system-panel.html:Button"></a> <a id="system-panel.html:systempanelwidgets-Python-moduleButton"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="system-panel.html:__jdocu_seealso_systempanel.widgets.Button"></a><b>Button</b>  A standard button</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">Button(obj_name, label)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
A button, that can be pressed. The button state is propagated using the
<code>signal</code> interface, and can be raised or lowered. Raising and
lowering the signal is frontend specific.</dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="system-panel.html:systempanel.widgets.Canvas">systempanel.widgets.Canvas</a></h3>
<p><a id="system-panel.html:Canvas"></a> <a id="system-panel.html:systempanelwidgets-Python-moduleCanvas"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="system-panel.html:__jdocu_seealso_systempanel.widgets.Canvas"></a><b>Canvas</b>  A canvas (i.e bitmap container)</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">Canvas(contents)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
A canvas for painting bitmap-based widgets.  A canvas contains multiple
bitmap-based widgets, each drawn at a specified offset.  The
<i>contents</i> parameter is a list of elements on the form
<i>(x, y, widget)</i>.  Here <i>x</i> and <i>y</i>
are integers, and <i>widget</i> is an instance of one of
<b>Image</b>, <b>BitmapLed</b>, <b>BitmapButton</b>,
<b>BitmapToggleButton</b>,
<b>MultiImageOutput</b>, <b>Canvas</b>, or a subclass
thereof.  The items are rendered in the same order as they appear in the
list; this means that if any widgets overlap, the last one will be drawn on
top.</dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="system-panel.html:systempanel.widgets.Column">systempanel.widgets.Column</a></h3>
<p><a id="system-panel.html:Column"></a> <a id="system-panel.html:systempanelwidgets-Python-moduleColumn"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="system-panel.html:__jdocu_seealso_systempanel.widgets.Column"></a><b>Column</b>  A one-dimensional widget container</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">Column(contents)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
A container for normal (non bitmap-based) widgets. The
<b>Column</b> container is a special case of <b>Grid</b>
container; the contained widgets are laid out vertically.</dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="system-panel.html:systempanel.widgets.Empty">systempanel.widgets.Empty</a></h3>
<p><a id="system-panel.html:Empty"></a> <a id="system-panel.html:systempanelwidgets-Python-moduleEmpty"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="system-panel.html:__jdocu_seealso_systempanel.widgets.Empty"></a><b>Empty</b>  An empty widget</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">Empty()</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
An empty widget, used to fill containers for layout purposes.</dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="system-panel.html:systempanel.widgets.Grid">systempanel.widgets.Grid</a></h3>
<p><a id="system-panel.html:Grid"></a> <a id="system-panel.html:systempanelwidgets-Python-moduleGrid"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="system-panel.html:__jdocu_seealso_systempanel.widgets.Grid"></a><b>Grid</b>  A two-dimensional widget container</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">Grid(contents, columns)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
A two-dimensional widget container.  Containers are used to group other
widgets, and enforce a specific layout scheme.  The <i>contents</i>
constructor parameter is a list of widget objects; it can contain any other
widget except for bitmap-based ones.  Widgets are laid out from left to
right, top to bottom. Use the <b>Empty</b> class to fill empty
cells. The number of rows in a <b>Grid</b> container is implicitly
defined by the length of the <i>contents</i> list and the number of
columns specified when creating the container.  See also the
<b>Column</b> and <b>Row</b> containers, which are
convenience classes for the one-dimensional cases. Containers can contain
other containers.</dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="system-panel.html:systempanel.widgets.Image">systempanel.widgets.Image</a></h3>
<p><a id="system-panel.html:Image"></a> <a id="system-panel.html:systempanelwidgets-Python-moduleImage"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="system-panel.html:__jdocu_seealso_systempanel.widgets.Image"></a><b>Image</b>  An image</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">Image(filename)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
An image, that can be put inside a <b>Canvas</b>
class. Currently the only supported file format is PNG, but with full
support for transparency. See <b>Canvas</b> class for more
information.</dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="system-panel.html:systempanel.widgets.Label">systempanel.widgets.Label</a></h3>
<p><a id="system-panel.html:Label"></a> <a id="system-panel.html:systempanelwidgets-Python-moduleLabel"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="system-panel.html:__jdocu_seealso_systempanel.widgets.Label"></a><b>Label</b>  An label</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">Label(label)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
A label, used to present static text.</dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="system-panel.html:systempanel.widgets.LabeledBox">systempanel.widgets.LabeledBox</a></h3>
<p><a id="system-panel.html:LabeledBox"></a> <a id="system-panel.html:systempanelwidgets-Python-moduleLabeledBox"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="system-panel.html:__jdocu_seealso_systempanel.widgets.LabeledBox"></a><b>LabeledBox</b>  A container with a label and box drawn around it</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">LabeledBox(label, container)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
A single-element container with a text label and a box drawn around
it. The single widget given by the <i>container</i> parameter can
be of any widget type, but it is typically of a container type.</dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="system-panel.html:systempanel.widgets.Led">systempanel.widgets.Led</a></h3>
<p><a id="system-panel.html:Led"></a> <a id="system-panel.html:systempanelwidgets-Python-moduleLed"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="system-panel.html:__jdocu_seealso_systempanel.widgets.Led"></a><b>Led</b>  A standard LED</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">Led(obj_name, color=None)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
A LED, which can be on or off. Driven by the <code>signal</code>
interface. The parameter <i>color</i> specifies the color of
the LED, all supported colors are described in <em>Standard Widgets
Colors</em>. The look-and-feel of the LED is frontend specific.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#system-panel.html:__jdocu_seealso_Standard-Widgets-Colors">Standard Widgets Colors</a></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="system-panel.html:systempanel.widgets.MultiImageOutput">systempanel.widgets.MultiImageOutput</a></h3>
<p><a id="system-panel.html:MultiImageOutput"></a> <a id="system-panel.html:systempanelwidgets-Python-moduleMultiImageOutput"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="system-panel.html:__jdocu_seealso_systempanel.widgets.MultiImageOutput"></a><b>MultiImageOutput</b>  A bitmap-based output that toggles between multiple images</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">MultiImageOutput(obj_name, images)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
An output that toggles between multiple custom images.  This
can be used, among other things, for multi-coloured LEDs or
seven-segment display elements.  The <i>images</i>
parameter is a list of paths to image filenames, each one given on
the same form as in the <b>Image</b> class.  Numeric input
to the panel object via the <code>uint64_state</code> interface
is used as a 0-based index in the image list.</dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="system-panel.html:systempanel.widgets.NumberInput">systempanel.widgets.NumberInput</a></h3>
<p><a id="system-panel.html:NumberInput"></a> <a id="system-panel.html:systempanelwidgets-Python-moduleNumberInput"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="system-panel.html:__jdocu_seealso_systempanel.widgets.NumberInput"></a><b>NumberInput</b>  An input text field for integer numbers</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">NumberInput(obj_name)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
An input text field for integer numbers, provided by the panel user. The
value is propagated to the model using the <code>uint64_state</code>
interface.</dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="system-panel.html:systempanel.widgets.NumberOutput">systempanel.widgets.NumberOutput</a></h3>
<p><a id="system-panel.html:NumberOutput"></a> <a id="system-panel.html:systempanelwidgets-Python-moduleNumberOutput"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="system-panel.html:__jdocu_seealso_systempanel.widgets.NumberOutput"></a><b>NumberOutput</b>  An output text field for integer numbers</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">NumberOutput(obj_name)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
An output text field for integer numbers, presenting integer state from
the model. Driven by the <code>uint64_state</code> interface.</dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="system-panel.html:systempanel.widgets.Row">systempanel.widgets.Row</a></h3>
<p><a id="system-panel.html:Row"></a> <a id="system-panel.html:systempanelwidgets-Python-moduleRow"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="system-panel.html:__jdocu_seealso_systempanel.widgets.Row"></a><b>Row</b>  A one-dimensional widget container</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">Row(contents)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
A container for normal (non bitmap-based) widgets. The
<b>Row</b> container is a special case of <b>Grid</b>
container; the contained widgets are laid out horizontally.</dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="system-panel.html:systempanel.widgets.ToggleButton">systempanel.widgets.ToggleButton</a></h3>
<p><a id="system-panel.html:ToggleButton"></a> <a id="system-panel.html:systempanelwidgets-Python-moduleToggleButton"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="system-panel.html:__jdocu_seealso_systempanel.widgets.ToggleButton"></a><b>ToggleButton</b>  A toggle button</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">ToggleButton(obj_name, label)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
A toggle button, that can be pressed or released. The button state is
propagated using the <code>signal</code> interface. When button is
pressed, signal is raised. When button is released, signal is lowered. The
button must have a label indicating its purpose.</dd>
</dl><p>
</p></section><section class="page" id="python-api-testing.html"><h1 class="jdocu"><a id="python-api-testing.html:python-api-testing">10.7 Testing</a></h1>
<p>

  </p><h2 class="jdocu"><a id="python-api-testing.html:__pymodstest">10.7.1 stest</a></h2>
<p>


 
 Utilities for testing simics.
 
</p><h3 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyfunstest.fail">fail</a></h3>
<p>

</p><dl class="jdocu_di">
<dt class="jdocu_descitem">Synopsis</dt><dd class="jdocu_descitem"><pre class="jdocu_small">fail(msg)</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Signal a failure in a test.
<p>
 Takes a string describing the failure as its single argument.
 If called in collect failures mode this will collect the failure for later
 checking with <b><i>check_failures</i></b>. If called outside collect failures
 mode it will immediately raise a <b>TestFailure</b> exception
 instead.
 </p></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyfunstest.collect_failures">collect_failures</a></h3>
<p></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Synopsis</dt><dd class="jdocu_descitem"><pre class="jdocu_small">collect_failures()</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Change the behavior of stest to collect failures instead of terminating on
 the first failure detected.
<p>
 If you use this you have to call <b><i>check_failures</i></b> at the end of
 your test script to check if it signaled any failures.
 </p></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyfunstest.check_failures">check_failures</a></h3>
<p></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Synopsis</dt><dd class="jdocu_descitem"><pre class="jdocu_small">check_failures()</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Check if any failures have occurred and leave collect failures mode.
<p>
 If any failures have occurred this function will report the failures and
 raise a <b>TestFailure</b> exception.
 If called outside collect failures mode this function will fail.
 </p></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyfunstest.trap_log">trap_log</a></h3>
<p></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Synopsis</dt><dd class="jdocu_descitem"><pre class="jdocu_small">trap_log(logtype, obj = None)</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Configure Simics to trap a type of log messages, and cause Simics
 to quit with a test failure on any such log message.
<p>
 By default the stest trap 'error' and 'spec-viol' log messages.
</p><p>
 <b><i>trap_log</i></b> without an object sets the default handling for the
 given log type. Object specific settings always take precedence over
 the default handling.
</p><p>
 Arguments:
 </p><dl><dt id="python-api-testing.html:dt:logtype"><a href="#python-api-testing.html:dt:logtype"><b>logtype</b></a></dt><dd>the type of log messages to trap, one of 'info', 'error', 'undef',
     'spec-viol', and 'unimpl'</dd><dt id="python-api-testing.html:dt:obj"><a href="#python-api-testing.html:dt:obj"><b>obj</b></a></dt><dd>the configuration object whose log messages to trap, defaults to None,
     which means that all log messages of the right type are trapped</dd></dl><p></p></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyfunstest.untrap_log">untrap_log</a></h3>
<p></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Synopsis</dt><dd class="jdocu_descitem"><pre class="jdocu_small">untrap_log(logtype, obj = None)</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Explicitly allow messages of a given log type. Can be used to undo
 a previous <b><i>trap_log</i></b> or to filter objects from a default
 trap.
<p>
 <b><i>untrap_log</i></b> without an object sets the default behavior for the
 given log type. Object specific settings always take precedence over
 the default handling.
</p><p>
 Arguments:
 </p><dl><dt id="python-api-testing.html:dt:logtype-2"><a href="#python-api-testing.html:dt:logtype-2"><b>logtype</b></a></dt><dd>the type of log messages to untrap, one of 'info', 'error', 'undef',
     'spec-viol', and 'unimpl'</dd><dt id="python-api-testing.html:dt:obj-2"><a href="#python-api-testing.html:dt:obj-2"><b>obj</b></a></dt><dd>the configuration object whose log messages to untrap, defaults to None,
     which means that all log messages of the right type are untrapped</dd></dl><p></p></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyfunstest.expect_true">expect_true</a></h3>
<p></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Synopsis</dt><dd class="jdocu_descitem"><pre class="jdocu_small">expect_true(cond, msg = 'expectation failed')</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Check if a condition is true and cause a test failure if it is not.
<p>
 Arguments:
 </p><dl><dt id="python-api-testing.html:dt:cond"><a href="#python-api-testing.html:dt:cond"><b>cond</b></a></dt><dd>the condition to test</dd><dt id="python-api-testing.html:dt:msg"><a href="#python-api-testing.html:dt:msg"><b>msg</b></a></dt><dd>a message explaining the failure</dd></dl><p></p></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyfunstest.expect_false">expect_false</a></h3>
<p></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Synopsis</dt><dd class="jdocu_descitem"><pre class="jdocu_small">expect_false(cond, msg = 'expectation failed')</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Check if a condition is false and cause a test failure if it is not.
<p>
 Arguments:
 </p><dl><dt id="python-api-testing.html:dt:cond-2"><a href="#python-api-testing.html:dt:cond-2"><b>cond</b></a></dt><dd>the condition to test</dd><dt id="python-api-testing.html:dt:msg-2"><a href="#python-api-testing.html:dt:msg-2"><b>msg</b></a></dt><dd>a message explaining the failure</dd></dl><p></p></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyfunstest.expect_equal">expect_equal</a></h3>
<p></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Synopsis</dt><dd class="jdocu_descitem"><pre class="jdocu_small">expect_equal(got, expected, msg = 'expectation failed')</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Checks if a value is equal to an expectation and cause a test failure if it
 is not.
<p>
 Arguments:
 </p><dl><dt id="python-api-testing.html:dt:got"><a href="#python-api-testing.html:dt:got"><b>got</b></a></dt><dd>the value to check</dd><dt id="python-api-testing.html:dt:expected"><a href="#python-api-testing.html:dt:expected"><b>expected</b></a></dt><dd>what to compare the value with</dd><dt id="python-api-testing.html:dt:msg-3"><a href="#python-api-testing.html:dt:msg-3"><b>msg</b></a></dt><dd>a message explaining the failure</dd></dl><p></p></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyfunstest.expect_different">expect_different</a></h3>
<p></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Synopsis</dt><dd class="jdocu_descitem"><pre class="jdocu_small">expect_different(got, unexpected, msg = 'expectation failed')</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Checks if a value is different to an expectation and cause a test failure if
 it is not.
<p>
 Arguments:
 </p><dl><dt id="python-api-testing.html:dt:got-2"><a href="#python-api-testing.html:dt:got-2"><b>got</b></a></dt><dd>the value to check</dd><dt id="python-api-testing.html:dt:unexpected"><a href="#python-api-testing.html:dt:unexpected"><b>unexpected</b></a></dt><dd>what to compare the value with</dd><dt id="python-api-testing.html:dt:msg-4"><a href="#python-api-testing.html:dt:msg-4"><b>msg</b></a></dt><dd>a message explaining the failure</dd></dl><p></p></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyfunstest.expect_log">expect_log</a></h3>
<p></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Synopsis</dt><dd class="jdocu_descitem"><pre class="jdocu_small">expect_log(fun, args = [], obj = None, log_type = 'error', msg = None, regex = '', with_log_level = None)</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Call a function and verify that a particular log message is emitted.
 Returns the called function's return value.
 Arguments:
 <dl><dt id="python-api-testing.html:dt:fun"><a href="#python-api-testing.html:dt:fun"><b>fun</b></a></dt><dd>the function to be called</dd><dt id="python-api-testing.html:dt:args"><a href="#python-api-testing.html:dt:args"><b>args</b></a></dt><dd>the arguments with which to call <i>fun</i></dd>All other arguments are identical to <b><i>expect_log_mgr</i></b>
 </dl><p></p></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyfunstest.expect_log_mgr">expect_log_mgr</a></h3>
<p></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Synopsis</dt><dd class="jdocu_descitem"><pre class="jdocu_small">expect_log_mgr(*args, **kwds)</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Context manager, verifying that, on exit from the with-statement, a
 particular log message has been emitted.
 Arguments:
 <dl><dt id="python-api-testing.html:dt:obj-3"><a href="#python-api-testing.html:dt:obj-3"><b>obj</b></a></dt><dd>optional object from which a log is expected,
     default is None which accepts any object</dd><dt id="python-api-testing.html:dt:log_type"><a href="#python-api-testing.html:dt:log_type"><b>log_type</b></a></dt><dd>optional log type which the emitted log must belong to,
     one of "error" (default), "unimpl", "info", "spec-viol"
     or "undefined"</dd><dt id="python-api-testing.html:dt:msg-5"><a href="#python-api-testing.html:dt:msg-5"><b>msg</b></a></dt><dd>optional message emitted on failure</dd><dt id="python-api-testing.html:dt:regex"><a href="#python-api-testing.html:dt:regex"><b>regex</b></a></dt><dd>optional regular expression object or a string
     containing a regular expression suitable for use by
     <code>re.search()</code>, which the emitted log must match
 </dd><dt id="python-api-testing.html:dt:with_log_level"><a href="#python-api-testing.html:dt:with_log_level"><b>with_log_level</b></a></dt><dd>optional log level to apply inside the context</dd></dl><p>Example usage:
 </p><pre class="jdocu_small">with stest.expect_log_mgr(log_type="spec-viol",
                          msg="Check warning on read-only fields"):
    reg_compute_units.write(0xffff_ffff_ffff_ffff)
 </pre><p>
 </p></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyfunstest.expect_exception">expect_exception</a></h3>
<p></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Synopsis</dt><dd class="jdocu_descitem"><pre class="jdocu_small">expect_exception(fun, args, exc)</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Call function fun with arguments args, and verify that it raises an
 exception of type exc. If fun does not raise exc, cause a failure.
 </dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyfunstest.expect_exception_mgr">expect_exception_mgr</a></h3>
<p></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Synopsis</dt><dd class="jdocu_descitem"><pre class="jdocu_small">expect_exception_mgr(*args, **kwds)</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Context manager verifying that the body of with-statement throws an
 exception of the specified type.
<p>
 Arguments:
 </p><dl><dt id="python-api-testing.html:dt:exc"><a href="#python-api-testing.html:dt:exc"><b>exc</b></a></dt><dd>exception type</dd></dl><p>Example usage:
 </p><pre class="jdocu_small">with stest.expect_exception_mgr(simics.SimExc_AttrNotWritable):
    dev.read_only_attribute = False
 </pre><p>
 </p></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyfunstest.deprecation_level">deprecation_level</a></h3>
<p></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Synopsis</dt><dd class="jdocu_descitem"><pre class="jdocu_small">deprecation_level(*args, **kwds)</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Context manager for temporarily setting a deprecation level and restore it
 when exiting the context.
<p>
 Arguments:
 </p><dl><dt id="python-api-testing.html:dt:level"><a href="#python-api-testing.html:dt:level"><b>level</b></a></dt><dd>deprecation level in context</dd></dl><p>Example usage:
 </p><pre class="jdocu_small"> with stest.deprecation_level(2)
    stest.expect_equal(conf.sim.deprecation_level, 2)
 </pre><p>
 </p></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyclassstest.TestFailure">TestFailure</a></h3>
<p></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Superclasses</dt><dd class="jdocu_descitem">builtins.Exception</dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Exception class used to signal failures in Simics tests.
<p>
 Use the <b><i>fail</i></b> function instead of raising this exception yourself.
 </p></dd>
</dl><p>
</p><h2 class="jdocu"><a id="python-api-testing.html:__pymoddev_util">10.7.2 dev_util</a></h2>
<p>


 
</p><p>
 A Python module for writing device model tests. Has three major
 parts: classes for accessing device registers, classes for writing
 device stubs, and classes for handling simulated memory and data
 structures in it. It also contains some auxiliary utilities.
</p><p>
 It uses the Simics API and can only be used by Python code running
 in Simics.
</p><p>
 
</p><h3 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyfundev_util.bank_regs">bank_regs</a></h3>
<p>

</p><dl class="jdocu_di">
<dt class="jdocu_descitem">Synopsis</dt><dd class="jdocu_descitem"><pre class="jdocu_small">bank_regs(bank, inquiry = False, prefix = '')</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Given a bank object, return a structure containing
 objects to access its registers.  The returned structure can be a
 hierarchy of objects; e.g., if a register instance is named
 <code>"g[2][3].r[1]"</code>, and the returned structure is <code>o</code>,
 then the corresponding register object can be obtained as
 <code>o.g[2][3].g[1]</code>.  The set of registers is extracted using
 the <code>register_view</code> interface, and uses offsets and
 bitfields as returned by that interface.
 The <code>inquiry</code> argument is deprecated and should not be used.
 If <code>prefix</code> is
 given, then the returned structure will only contain registers whose
 full name matches this prefix.
<p>
 The returned register objects have methods <code>read()</code> and
 <code>write()</code> that work like their <code>AbstractRegister</code>
 counterparts, reading and writing the register with side-effects.
 The register value can be read and written without side-effects
 objects by getting and setting a property <code>.val</code>, or by
 calling a method <code>set()</code>. The latter accepts keyword
 arguments for fields just like the <code>write()</code> method; bits not
 covered by fields are retrieved by reading <code>.val</code>.  The
 positional argument of the <code>write()</code> method is required and
 may be either an integer, or <code>READ</code> to denote that previous
 values are retrieved using <code>read()</code>, or <code>VAL</code> to denote that
 they are retrieved using <code>.val</code>.
</p><p>
 In addition to the <code>val</code> property and <code>set</code>,
 <code>read</code> and <code>write</code> methods mentioned above, register
 objects also have the following properties:
 </p><ul>
   <li><code>bank</code>: The Simics configuration object of the bank</li>
   <li><code>size</code>, <code>offset</code>: the register's location within
       the bank</li>
   <li><code>bitfield</code>: a <code>dev_util.Bitfield</code> describing the </li>
   <li><code>name</code>: the name of the register, relative to the bank.</li>
 </ul>
<p>
 Objects that represent the fields of a register can be retrieved as
 <code>reg.field.FIELDNAME</code>; e.g., if a register <code>reg</code> has a
 field named <code>"a.b[2]"</code> then the field object is accessed as
 <code>reg.field.a.b[2]</code>. The field object has one method
 <code>read()</code> for performing a full-register read with
 side-effects and returning the bits corresponding to the field, and
 a property <code>.val</code> that allows side-effect free access to the
 field's bits. Field objects provide a <code>read</code> method, which reads
 the parent register and returns the bits corresponding to the field,
 but it does not have a <code>write</code> method;
 writes must be done from the register object to ensure that
 remaining bits are explicitly specified. Field objects also provide
 the following properties:
 </p><ul>
   <li><code>reg</code>: The parent register object</li>
   <li><code>lsb</code>, <code>bits</code>: the bit range within the parent register</li>
   <li><code>name</code>: the name of the field, relative to the parent register</li>
 </ul>
 </dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyfundev_util.iface">iface</a></h3>
<p></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Synopsis</dt><dd class="jdocu_descitem"><pre class="jdocu_small">iface(name)</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Deprecated.
 </dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyfundev_util.value_to_tuple_be">value_to_tuple_be</a></h3>
<p></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Synopsis</dt><dd class="jdocu_descitem"><pre class="jdocu_small">value_to_tuple_be(val, bytes)</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Deprecated, use <code>tuple(val.to_bytes(bytes, 'big'))</code> instead.
 </dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyfundev_util.value_to_tuple_le">value_to_tuple_le</a></h3>
<p></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Synopsis</dt><dd class="jdocu_descitem"><pre class="jdocu_small">value_to_tuple_le(val, bytes)</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Deprecated, use <code>tuple(val.to_bytes(bytes, 'little'))</code> instead.
 </dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyfundev_util.tuple_to_value_be">tuple_to_value_be</a></h3>
<p></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Synopsis</dt><dd class="jdocu_descitem"><pre class="jdocu_small">tuple_to_value_be(t)</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Deprecated, use <code>int.from_bytes(t, 'big')</code> instead.
 </dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyfundev_util.tuple_to_value_le">tuple_to_value_le</a></h3>
<p></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Synopsis</dt><dd class="jdocu_descitem"><pre class="jdocu_small">tuple_to_value_le(t)</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Deprecated, use <code>int.from_bytes(t, 'little')</code> instead.
 </dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyclassdev_util.Error">Error</a></h3>
<p></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Superclasses</dt><dd class="jdocu_descitem">builtins.Exception</dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Baseclass of all exceptions specified in this module.
 </dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyclassdev_util.InvalidBitfieldException">InvalidBitfieldException</a></h3>
<p></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Superclasses</dt><dd class="jdocu_descitem">dev_util.Error</dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Signals that a bitfield's parameters are invalid.
 </dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyclassdev_util.RangeError">RangeError</a></h3>
<p></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Superclasses</dt><dd class="jdocu_descitem">dev_util.Error</dd>
<dt class="jdocu_descitem">Constructor</dt><dd class="jdocu_descitem"><pre class="jdocu_small">RangeError(msg, re = None)</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Signals that a value is out of range for a bitfield.
 </dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyclassdev_util.MemoryError">MemoryError</a></h3>
<p></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Superclasses</dt><dd class="jdocu_descitem">dev_util.Error</dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Signals that a memory operation failed.
 </dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyclassdev_util.Bitfield">Bitfield</a></h3>
<p></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Superclasses</dt><dd class="jdocu_descitem">builtins.object</dd>
<dt class="jdocu_descitem">Constructor</dt><dd class="jdocu_descitem"><pre class="jdocu_small">Bitfield(fields = None, ones = 0, little_endian = True, bits = None, **kwargs)</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Utility for bitfield manipulations.
 
 Constructor arguments:
 <dl><dt id="python-api-testing.html:dt:fields"><a href="#python-api-testing.html:dt:fields"><b>fields</b></a></dt><dd>a dict on the following format,
 where sub-field is of type fields:
 <pre class="jdocu_small"> {'field-name' : bit-number,
  'field-name' : (start-bit, stop-bit),
  'field-name' : (start-bit, sub-field)
 }
 </pre><p>
 </p></dd><dt id="python-api-testing.html:dt:ones"><a href="#python-api-testing.html:dt:ones"><b>ones</b></a></dt><dd>a bitmask that will be OR:ed in the complete bitfield value</dd><dt id="python-api-testing.html:dt:little-endian"><a href="#python-api-testing.html:dt:little-endian"><b>little-endian</b></a></dt><dd>set to True for a little-endian bitorder field and False for
     big-endian bitorder fields</dd><dt id="python-api-testing.html:dt:bits"><a href="#python-api-testing.html:dt:bits"><b>bits</b></a></dt><dd>the total size (in bits) of the fields; required by, as well as
     only allowed for, big-endian fields</dd><dt id="python-api-testing.html:dt:kwargs"><a href="#python-api-testing.html:dt:kwargs"><b>**kwargs</b></a></dt><dd>as <i>fields</i>, but specified using keyword arguments</dd></dl><p></p></dd>
</dl><p></p><h4 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyfundev_util.Bitfield.fields">fields</a></h4>
<p></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Synopsis</dt><dd class="jdocu_descitem"><pre class="jdocu_small">obj.fields(value)</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Returns a dict consisting of all fields and their values,
 taken from the value argument.
 </dd>
</dl><p></p><h4 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyfundev_util.Bitfield.mask">mask</a></h4>
<p></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Synopsis</dt><dd class="jdocu_descitem"><pre class="jdocu_small">obj.mask(**dict)</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Returns a mask from the fields in dict.
 </dd>
</dl><p></p><h4 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyfundev_util.Bitfield.mk_bitfield_map">mk_bitfield_map</a></h4>
<p></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Synopsis</dt><dd class="jdocu_descitem"><pre class="jdocu_small">obj.mk_bitfield_map(m, prefix = '', oset = 0)</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Convert a nested layout type to a map suitable for construction
 of a dev_util.Bitfield object.
 </dd>
</dl><p></p><h4 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyfundev_util.Bitfield.value">value</a></h4>
<p></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Synopsis</dt><dd class="jdocu_descitem"><pre class="jdocu_small">obj.value(*args, **kwargs)</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Returns the value of the
 fields given by **kwargs. For example, pass <code>foo=5</code> to
 return the value when field <code>"foo"</code> is 5. If the value is
 a list or dict rather than an integer, then a field array is
 assumed; e.g. <code>foo=[1,2]</code> is a shorthand for setting
 field <code>"foo[0]"</code> to 1 and field <code>"foo[1]"</code> to 2,
 and <code>foo={1:4}</code> is a shorthand for setting field
 <code>"foo[1]"</code> to 4.
<p>
 An optional positional argument can be
 supplied, to provide the values of bits not covered by the given
 fields.
 </p></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyclassdev_util.Bitfield_LE">Bitfield_LE</a></h3>
<p>

</p><dl class="jdocu_di">
<dt class="jdocu_descitem">Superclasses</dt><dd class="jdocu_descitem">dev_util.Bitfield</dd>
<dt class="jdocu_descitem">Constructor</dt><dd class="jdocu_descitem"><pre class="jdocu_small">Bitfield_LE(fields = None, ones = 0, **kwargs)</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Constructor arguments:
 <dl><dt id="python-api-testing.html:dt:fields-2"><a href="#python-api-testing.html:dt:fields-2"><b>fields</b></a></dt><dd>a dict on the following format,
 where sub-field is of type fields:
 <pre class="jdocu_small"> {'field-name' : bit-number,
  'field-name' : (start-bit, stop-bit),
  'field-name' : (start-bit, sub-field)
 }
 </pre><p>
 </p></dd><dt id="python-api-testing.html:dt:ones-2"><a href="#python-api-testing.html:dt:ones-2"><b>ones</b></a></dt><dd>a bitmask that will be OR:ed in the complete bitfield value</dd><dt id="python-api-testing.html:dt:kwargs-2"><a href="#python-api-testing.html:dt:kwargs-2"><b>**kwargs</b></a></dt><dd>as <i>fields</i>, but specified using keyword arguments</dd></dl><p></p></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyclassdev_util.Bitfield_BE">Bitfield_BE</a></h3>
<p></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Superclasses</dt><dd class="jdocu_descitem">dev_util.Bitfield</dd>
<dt class="jdocu_descitem">Constructor</dt><dd class="jdocu_descitem"><pre class="jdocu_small">Bitfield_BE(fields = None, ones = 0, bits = None, **kwargs)</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Bit-endian bitfield.
 
 Constructor arguments:
 <dl><dt id="python-api-testing.html:dt:fields-3"><a href="#python-api-testing.html:dt:fields-3"><b>fields</b></a></dt><dd>a dict on the following format,
 where sub-field is of type fields:
 <pre class="jdocu_small"> {'field-name' : bit-number,
  'field-name' : (start-bit, stop-bit),
  'field-name' : (start-bit, sub-field)
 }
 </pre><p>
 </p></dd><dt id="python-api-testing.html:dt:ones-3"><a href="#python-api-testing.html:dt:ones-3"><b>ones</b></a></dt><dd>a bitmask that will be OR:ed in the complete bitfield value</dd><dt id="python-api-testing.html:dt:bits-2"><a href="#python-api-testing.html:dt:bits-2"><b>bits</b></a></dt><dd>the total size (in bits) of the fields; required by big-endian
     fields</dd><dt id="python-api-testing.html:dt:kwargs-3"><a href="#python-api-testing.html:dt:kwargs-3"><b>**kwargs</b></a></dt><dd>as <i>fields</i>, but specified using keyword arguments</dd></dl><p></p></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyclassdev_util.AbstractRegister">AbstractRegister</a></h3>
<p></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Superclasses</dt><dd class="jdocu_descitem">builtins.object</dd>
<dt class="jdocu_descitem">Constructor</dt><dd class="jdocu_descitem"><pre class="jdocu_small">AbstractRegister(size = 4, bitfield = None, little_endian = True)</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Abstract register class.
<p>
 This class handles generic register stuff, like bitfield mapping
 and value construction/deconstruction. It depends on a subclass to
 implement the backend for data storage.
</p><p>
 Subclasses are expected to implement two functions:
</p><p>
 </p><dl><dt id="python-api-testing.html:dt:raw_read-self"><a href="#python-api-testing.html:dt:raw_read-self"><b>raw_read(self)</b></a></dt><dd>should return a byte string from storage</dd><dt id="python-api-testing.html:dt:raw_write-self-bytes"><a href="#python-api-testing.html:dt:raw_write-self-bytes"><b>raw_write(self, bytes)</b></a></dt><dd>should write the <i>bytes</i> byte string to storage</dd></dl><p>Optionally, a bitfield can be applied to a register. For such a register,
 a specific field can be read through <code>reg.field.FIELDNAME.read()</code>. The
 <b><i>write()</i></b> method also has support for bitfields. Please see the
 documentation for <b><i>write()</i></b> for more information.
</p><p>
 There is an alternative deprecated shorthand for accessing fields:
 <code>reg.FIELDNAME</code> triggers a read that filters out the given
 field, and similarly, <code>reg.FIELDNAME = value</code> reads the
 field, adjusts the given field, and writes back the value. This
 syntax is deprecated, because it is not consistent with the API
 exposed by register objects that both support accesses with and
 without side-effects.
</p><p>
 
 Constructor arguments:
 </p><dl><dt id="python-api-testing.html:dt:size"><a href="#python-api-testing.html:dt:size"><b>size</b></a></dt><dd>the size in bytes of the register</dd><dt id="python-api-testing.html:dt:bitfield"><a href="#python-api-testing.html:dt:bitfield"><b>bitfield</b></a></dt><dd>optional, if set should be an instance of Bitfield</dd><dt id="python-api-testing.html:dt:little_endian"><a href="#python-api-testing.html:dt:little_endian"><b>little_endian</b></a></dt><dd>should be set to True for a little-endian byte-order
     register, or False for a big-endian register</dd></dl><p></p></dd>
</dl><p></p><h4 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyfundev_util.AbstractRegister.fields">fields</a></h4>
<p></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Synopsis</dt><dd class="jdocu_descitem"><pre class="jdocu_small">obj.fields()</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Shortcut to read the bitfield representation of a device register.
 </dd>
</dl><p></p><h4 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyfundev_util.AbstractRegister.read">read</a></h4>
<p></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Synopsis</dt><dd class="jdocu_descitem"><pre class="jdocu_small">obj.read()</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Read value.
 </dd>
</dl><p></p><h4 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyfundev_util.AbstractRegister.write">write</a></h4>
<p></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Synopsis</dt><dd class="jdocu_descitem"><pre class="jdocu_small">obj.write(*args, **fields)</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Write value. The value will be truncated to the register size.
<p>
 You can either pass a single integer, or pass the fields as
 arguments, i.e., <code>write(field0=1, field1=23)</code>. For field
 arrays, the syntax <code>write(field=[1,23])</code> or
 <code>write(field={0: 1, 1: 23})</code> can be used to set the fields named
 <code>field[0]</code> and <code>field[1]</code>.
</p><p>
 If only a subset of fields is given, a positional arg should
 also be passed for the base value, which defines what to write to
 remaining bits. The value READ denotes that the <code>read()</code> method is
 called to retrieve the base value.
 </p></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyclassdev_util.Register">Register</a></h3>
<p>

</p><dl class="jdocu_di">
<dt class="jdocu_descitem">Superclasses</dt><dd class="jdocu_descitem">dev_util.AbstractRegister</dd>
<dt class="jdocu_descitem">Constructor</dt><dd class="jdocu_descitem"><pre class="jdocu_small">Register(*args, **kwargs)</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This class allows you to easily access a device register.
 
 The bank argument is normally the bank object. However, for
 backward compatibility it can also be a tuple (obj, bank, ofs);
 in this case the <i>offset</i> argument should be left
 out. The tuple denotes:
 <dl><dt id="python-api-testing.html:dt:obj-4"><a href="#python-api-testing.html:dt:obj-4"><b>obj</b></a></dt><dd>the (simics) object implementing the register</dd><dt id="python-api-testing.html:dt:bank"><a href="#python-api-testing.html:dt:bank"><b>bank</b></a></dt><dd>the port-name or function number of the bank containing the
     register (function 0 if omitted).</dd><dt id="python-api-testing.html:dt:offset"><a href="#python-api-testing.html:dt:offset"><b>offset</b></a></dt><dd>the register offset in said bank</dd></dl><p>The tuple syntax was useful in old Simics versions where
 banks were not separate objects. It should be avoided in new versions.
</p><p>
 The initiator argument denotes the initiator of transactions
 accessing the register.
 See the AbstractRegister documentation for information about the rest
 of the parameters.
 </p></dd>
</dl><p></p><h4 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyfundev_util.Register.raw_read">raw_read</a></h4>
<p></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Synopsis</dt><dd class="jdocu_descitem"><pre class="jdocu_small">obj.raw_read()</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Read raw data from the register.
 </dd>
</dl><p></p><h4 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyfundev_util.Register.raw_write">raw_write</a></h4>
<p></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Synopsis</dt><dd class="jdocu_descitem"><pre class="jdocu_small">obj.raw_write(val)</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Write raw data to the register.
 </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyclassdev_util.Register_LE">Register_LE</a></h3>
<p>

</p><dl class="jdocu_di">
<dt class="jdocu_descitem">Superclasses</dt><dd class="jdocu_descitem">dev_util.Register</dd>
<dt class="jdocu_descitem">Constructor</dt><dd class="jdocu_descitem"><pre class="jdocu_small">Register_LE(*args, **kwargs)</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Little-endian device register.
 
 All arguments have the same semantics as in dev_util.Register.
 </dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyclassdev_util.Register_BE">Register_BE</a></h3>
<p></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Superclasses</dt><dd class="jdocu_descitem">dev_util.Register</dd>
<dt class="jdocu_descitem">Constructor</dt><dd class="jdocu_descitem"><pre class="jdocu_small">Register_BE(*args, **kwargs)</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Big-endian device register.
 
 All arguments have the same semantics as in dev_util.Register.
 </dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyclassdev_util.GRegister">GRegister</a></h3>
<p></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Superclasses</dt><dd class="jdocu_descitem">dev_util.AbstractRegister</dd>
<dt class="jdocu_descitem">Constructor</dt><dd class="jdocu_descitem"><pre class="jdocu_small">GRegister(size = 4, bitfield = None, init = 0)</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This class allows provides a standalone register.
 </dd>
</dl><p></p><h4 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyfundev_util.GRegister.raw_read">raw_read</a></h4>
<p></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Synopsis</dt><dd class="jdocu_descitem"><pre class="jdocu_small">obj.raw_read()</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Reads the raw contents of the register.
 </dd>
</dl><p></p><h4 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyfundev_util.GRegister.raw_write">raw_write</a></h4>
<p></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Synopsis</dt><dd class="jdocu_descitem"><pre class="jdocu_small">obj.raw_write(value)</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Write the raw contents of the register.
 </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyclassdev_util.IRegister">IRegister</a></h3>
<p>

</p><dl class="jdocu_di">
<dt class="jdocu_descitem">Superclasses</dt><dd class="jdocu_descitem">dev_util.AbstractRegister</dd>
<dt class="jdocu_descitem">Constructor</dt><dd class="jdocu_descitem"><pre class="jdocu_small">IRegister(data, size = None, bitfield = None)</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This class allows you to easily access registers through the
 <code>int_register</code> interface. If the object <b>obj</b> does
 not implement the <code>processor_info</code> you have to specify the
 size in <i>size</i>.
 </dd>
</dl><p></p><h4 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyfundev_util.IRegister.raw_read">raw_read</a></h4>
<p></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Synopsis</dt><dd class="jdocu_descitem"><pre class="jdocu_small">obj.raw_read()</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Reads the raw contents of the register.
 </dd>
</dl><p></p><h4 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyfundev_util.IRegister.raw_write">raw_write</a></h4>
<p></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Synopsis</dt><dd class="jdocu_descitem"><pre class="jdocu_small">obj.raw_write(value)</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Write the raw contents of the register.
 </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyclassdev_util_internal.Dev">Dev</a></h3>
<p>

</p><dl class="jdocu_di">
<dt class="jdocu_descitem">Superclasses</dt><dd class="jdocu_descitem">builtins.object</dd>
<dt class="jdocu_descitem">Constructor</dt><dd class="jdocu_descitem"><pre class="jdocu_small">Dev(iface_list = [], create_sim_obj = True, name = None)</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">A Simics class with a single instance.
 Implements zero or more interfaces based on instances of
 <b>Iface</b>. Presents zero or
 more ports, implementing one or more interfaces each.
<p>
 The <i>obj</i> attribute contains the instance of the Simics
 class, and the <i>cls_name</i> attribute contains the name of
 the Simics class.
 
 Constructor arguments:
 </p><dl><dt id="python-api-testing.html:dt:iface_list"><a href="#python-api-testing.html:dt:iface_list"><b>iface_list</b></a></dt><dd>a list of interface classes or pairs of
     (port, interface-class)</dd><dt id="python-api-testing.html:dt:create_sim_obj"><a href="#python-api-testing.html:dt:create_sim_obj"><b>create_sim_obj</b></a></dt><dd>if False, no Simics object will be created, but the
 class will be registered along with all the interfaces, useful
 e.g. when loading a checkpoint containing fake objects</dd><dt id="python-api-testing.html:dt:name"><a href="#python-api-testing.html:dt:name"><b>name</b></a></dt><dd>if given, specifies the name to use for the fake class and
 the fake object; otherwise a name will be guessed based on the
 implemented interfaces</dd></dl><p>Each interface will be instantiated and can be accessed through
 <em>dev</em>.<em>iface-name</em>,
 or <em>dev</em>.<em>port</em>.<em>iface-name</em>.
</p><p>
 Example:
 </p><pre class="jdocu_small"> dev = Dev([SimpleInterrupt,
            ('sreset', Signal),
            ('hreset', Signal)])

 dev.simple_interrupt
 dev.sreset.signal
 dev.hreset.signal
 </pre><p>
 </p></dd>
</dl><p></p><h4 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyfundev_util_internal.Dev.configure_pre_object">configure_pre_object</a></h4>
<p></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Synopsis</dt><dd class="jdocu_descitem"><pre class="jdocu_small">obj.configure_pre_object(pre_obj)</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Called before <b><i>SIM_add_configuration</i></b>.
 Override to e.g. set attributes.
 </dd>
</dl><p></p><h4 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyfundev_util_internal.Dev.finalize">finalize</a></h4>
<p></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Synopsis</dt><dd class="jdocu_descitem"><pre class="jdocu_small">obj.finalize()</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Called after the Simics object has been instantiated.
 </dd>
</dl><p></p><h4 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyfundev_util_internal.Dev.register_simics_class">register_simics_class</a></h4>
<p></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Synopsis</dt><dd class="jdocu_descitem"><pre class="jdocu_small">obj.register_simics_class()</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Register the Simics class created by this object.
 </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyclassdev_util_internal.Iface">Iface</a></h3>
<p>

</p><dl class="jdocu_di">
<dt class="jdocu_descitem">Superclasses</dt><dd class="jdocu_descitem">dev_util_internal.BasicIface</dd>
<dt class="jdocu_descitem">Constructor</dt><dd class="jdocu_descitem"><pre class="jdocu_small">Iface()</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Base class for fake interfaces. To create an interface, inherit
 this class, define a class variable iface to the interface name, and
 define all methods that the interface defines.
 </dd>
</dl><p></p><h4 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyfundev_util_internal.Iface.fail">fail</a></h4>
<p></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Synopsis</dt><dd class="jdocu_descitem"><pre class="jdocu_small">obj.fail(msg)</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Signal a failure when running an interface method.
<p>
 Called by the default method stubs.
 </p></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyclassdev_util.Memory">Memory</a></h3>
<p>

</p><dl class="jdocu_di">
<dt class="jdocu_descitem">Superclasses</dt><dd class="jdocu_descitem">builtins.object</dd>
<dt class="jdocu_descitem">Constructor</dt><dd class="jdocu_descitem"><pre class="jdocu_small">Memory()</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Deprecated.
 Legacy wrapper around an instance of the <code>sparse-memory</code> class.
 Provides an interface compatible with the deprecated Memory class.
<p>
 The <i>obj</i> attribute contains an instance of <code>memory-space</code>,
 mapping to the memory. The <i>real_obj</i> attribute contains
 an instance of the 'sparse-memory' class. The <i>mem</i>
 attribute is an alias to the <i>mem</i> attribute of
 <i>real_obj</i>.
 </p></dd>
</dl><p></p><h4 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyfundev_util.Memory.clear">clear</a></h4>
<p></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Synopsis</dt><dd class="jdocu_descitem"><pre class="jdocu_small">obj.clear(*args)</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Clear the contents of the memory.
 </dd>
</dl><p></p><h4 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyfundev_util.Memory.is_range_touched">is_range_touched</a></h4>
<p></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Synopsis</dt><dd class="jdocu_descitem"><pre class="jdocu_small">obj.is_range_touched(start, length)</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Return True if any of this memory's slots in the range contain data.
 </dd>
</dl><p></p><h4 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyfundev_util.Memory.read">read</a></h4>
<p></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Synopsis</dt><dd class="jdocu_descitem"><pre class="jdocu_small">obj.read(addr, n)</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Read bytes from this memory.
<p>
 Arguments:
 </p><dl><dt id="python-api-testing.html:dt:addr"><a href="#python-api-testing.html:dt:addr"><b>addr</b></a></dt><dd>the start address of the range to read</dd><dt id="python-api-testing.html:dt:n"><a href="#python-api-testing.html:dt:n"><b>n</b></a></dt><dd>length in bytes of the range to read</dd></dl><p>Throws an exception if any byte in the read range is empty.
 </p></dd>
</dl><p></p><h4 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyfundev_util.Memory.write">write</a></h4>
<p></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Synopsis</dt><dd class="jdocu_descitem"><pre class="jdocu_small">obj.write(addr, data)</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Write bytes to this memory.
<p>
 Arguments:
 </p><dl><dt id="python-api-testing.html:dt:addr-2"><a href="#python-api-testing.html:dt:addr-2"><b>addr</b></a></dt><dd>the start address of the range to write</dd><dt id="python-api-testing.html:dt:data"><a href="#python-api-testing.html:dt:data"><b>data</b></a></dt><dd>the bytes to write</dd></dl><p>Fills in empty slots in the memory and overwrites already existing data.
 </p></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyclassdev_util.Layout">Layout</a></h3>
<p>

</p><dl class="jdocu_di">
<dt class="jdocu_descitem">Superclasses</dt><dd class="jdocu_descitem">builtins.object</dd>
<dt class="jdocu_descitem">Constructor</dt><dd class="jdocu_descitem"><pre class="jdocu_small">Layout(mem, ofs, regs, little_endian)</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This class implements a memory layout.
<p>
 Testing devices that does DMA transfers usually requires setting up
 DMA descriptors. These can often be seen as register sets located in
 memory. This class allows you to define the layout of those registers,
 including bitfields within the registers.
</p><p>
 Registers without bitfields can be accessed through:
 </p><pre class="jdocu_small"><em>layout</em>.<em>reg-name</em></pre><p>
</p><p>
 while registers with bitfields can be accessed through:
 </p><pre class="jdocu_small"><em>layout</em>.<em>reg-name</em>.<em>field-name</em></pre><p>
 or
 </p><pre class="jdocu_small"> <em>layout</em>.<em>reg-name</em>.read(),
 <em>layout</em>.<em>reg-name</em>.write()
 </pre><p>
</p><p>
 Layouts are mapped ontop of Memory, i.e. NOT ontop of normal Simics RAM.
 
 Constructor arguments:
 </p><dl><dt id="python-api-testing.html:dt:mem"><a href="#python-api-testing.html:dt:mem"><b>mem</b></a></dt><dd>An object that is a valid "map target"</dd><dt id="python-api-testing.html:dt:ofs"><a href="#python-api-testing.html:dt:ofs"><b>ofs</b></a></dt><dd>the byte offset (i.e. the location of the layout)</dd><dt id="python-api-testing.html:dt:little_endian-2"><a href="#python-api-testing.html:dt:little_endian-2"><b>little_endian</b></a></dt><dd>determines the byte order of the registers in the layout</dd><dt id="python-api-testing.html:dt:regs"><a href="#python-api-testing.html:dt:regs"><b>regs</b></a></dt><dd>a dictionary on the following form:
 <pre class="jdocu_small"> {'reg-name' : (offset, size),
  'reg-name' : (offset, size, bitfield)}
 </pre><p>
 </p></dd><dt id="python-api-testing.html:dt:offset-2"><a href="#python-api-testing.html:dt:offset-2"><b>offset</b></a></dt><dd>the register offset into the layout</dd><dt id="python-api-testing.html:dt:size-2"><a href="#python-api-testing.html:dt:size-2"><b>size</b></a></dt><dd>the size in bytes of the register</dd><dt id="python-api-testing.html:dt:bitfield-2"><a href="#python-api-testing.html:dt:bitfield-2"><b>bitfield</b></a></dt><dd>optional and should be an instance of Bitfield</dd></dl><p></p></dd>
</dl><p></p><h4 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyfundev_util.Layout.clear">clear</a></h4>
<p></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Synopsis</dt><dd class="jdocu_descitem"><pre class="jdocu_small">obj.clear()</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Set all of the fields in this layout to 0.
 </dd>
</dl><p></p><h4 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyfundev_util.Layout.read">read</a></h4>
<p></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Synopsis</dt><dd class="jdocu_descitem"><pre class="jdocu_small">obj.read(ofs, size)</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Returns the value at <i>ofs</i>.
 </dd>
</dl><p></p><h4 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyfundev_util.Layout.write">write</a></h4>
<p></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Synopsis</dt><dd class="jdocu_descitem"><pre class="jdocu_small">obj.write(ofs, value, size)</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Writes <i>value</i> to <i>ofs</i>.
 </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyclassdev_util.Layout_LE">Layout_LE</a></h3>
<p>

</p><dl class="jdocu_di">
<dt class="jdocu_descitem">Superclasses</dt><dd class="jdocu_descitem">dev_util.Layout</dd>
<dt class="jdocu_descitem">Constructor</dt><dd class="jdocu_descitem"><pre class="jdocu_small">Layout_LE(mem, ofs, regs)</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Little-endian layout.
 </dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyclassdev_util.Layout_BE">Layout_BE</a></h3>
<p></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Superclasses</dt><dd class="jdocu_descitem">dev_util.Layout</dd>
<dt class="jdocu_descitem">Constructor</dt><dd class="jdocu_descitem"><pre class="jdocu_small">Layout_BE(mem, ofs, regs)</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Big-endian layout.
 </dd>
</dl><p>
</p><h2 class="jdocu"><a id="python-api-testing.html:__pymoddev_util_internal">10.7.3 dev_util_internal</a></h2>
<p>


 
</p><p>
 Internal and/or legacy classes removed from dev_util.py
</p><p>
 
</p><h3 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyfundev_util_internal.iface">iface</a></h3>
<p>

</p><dl class="jdocu_di">
<dt class="jdocu_descitem">Synopsis</dt><dd class="jdocu_descitem"><pre class="jdocu_small">iface(name)</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Returns an Iface subclass which implements the interface <i>name</i>.
<p>
 All the interface methods in the class will raise an exception when
 called. Convenient when creating a fake device that is required to
 implement an interface, but you know that the interface should be
 unused in the given test.  </p></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyclassdev_util_internal.Dev2">Dev</a></h3>
<p></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Superclasses</dt><dd class="jdocu_descitem">builtins.object</dd>
<dt class="jdocu_descitem">Constructor</dt><dd class="jdocu_descitem"><pre class="jdocu_small">Dev(iface_list = [], create_sim_obj = True, name = None)</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">A Simics class with a single instance.
 Implements zero or more interfaces based on instances of
 <b>Iface</b>. Presents zero or
 more ports, implementing one or more interfaces each.
<p>
 The <i>obj</i> attribute contains the instance of the Simics
 class, and the <i>cls_name</i> attribute contains the name of
 the Simics class.
 
 Constructor arguments:
 </p><dl><dt id="python-api-testing.html:dt:iface_list-2"><a href="#python-api-testing.html:dt:iface_list-2"><b>iface_list</b></a></dt><dd>a list of interface classes or pairs of
     (port, interface-class)</dd><dt id="python-api-testing.html:dt:create_sim_obj-2"><a href="#python-api-testing.html:dt:create_sim_obj-2"><b>create_sim_obj</b></a></dt><dd>if False, no Simics object will be created, but the
 class will be registered along with all the interfaces, useful
 e.g. when loading a checkpoint containing fake objects</dd><dt id="python-api-testing.html:dt:name-2"><a href="#python-api-testing.html:dt:name-2"><b>name</b></a></dt><dd>if given, specifies the name to use for the fake class and
 the fake object; otherwise a name will be guessed based on the
 implemented interfaces</dd></dl><p>Each interface will be instantiated and can be accessed through
 <em>dev</em>.<em>iface-name</em>,
 or <em>dev</em>.<em>port</em>.<em>iface-name</em>.
</p><p>
 Example:
 </p><pre class="jdocu_small"> dev = Dev([SimpleInterrupt,
            ('sreset', Signal),
            ('hreset', Signal)])

 dev.simple_interrupt
 dev.sreset.signal
 dev.hreset.signal
 </pre><p>
 </p></dd>
</dl><p></p><h4 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyfundev_util_internal.Dev.configure_pre_object2">configure_pre_object</a></h4>
<p></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Synopsis</dt><dd class="jdocu_descitem"><pre class="jdocu_small">obj.configure_pre_object(pre_obj)</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Called before <b><i>SIM_add_configuration</i></b>.
 Override to e.g. set attributes.
 </dd>
</dl><p></p><h4 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyfundev_util_internal.Dev.finalize2">finalize</a></h4>
<p></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Synopsis</dt><dd class="jdocu_descitem"><pre class="jdocu_small">obj.finalize()</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Called after the Simics object has been instantiated.
 </dd>
</dl><p></p><h4 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyfundev_util_internal.Dev.register_simics_class2">register_simics_class</a></h4>
<p></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Synopsis</dt><dd class="jdocu_descitem"><pre class="jdocu_small">obj.register_simics_class()</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Register the Simics class created by this object.
 </dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyclassdev_util_internal.Iface2">Iface</a></h3>
<p>

</p><dl class="jdocu_di">
<dt class="jdocu_descitem">Superclasses</dt><dd class="jdocu_descitem">dev_util_internal.BasicIface</dd>
<dt class="jdocu_descitem">Constructor</dt><dd class="jdocu_descitem"><pre class="jdocu_small">Iface()</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Base class for fake interfaces. To create an interface, inherit
 this class, define a class variable iface to the interface name, and
 define all methods that the interface defines.
 </dd>
</dl><p></p><h4 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyfundev_util_internal.Iface.fail2">fail</a></h4>
<p></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Synopsis</dt><dd class="jdocu_descitem"><pre class="jdocu_small">obj.fail(msg)</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Signal a failure when running an interface method.
<p>
 Called by the default method stubs.
 </p></dd>
</dl><p>
</p><h3 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyclassdev_util_internal.Memory">Memory</a></h3>
<p>

</p><dl class="jdocu_di">
<dt class="jdocu_descitem">Superclasses</dt><dd class="jdocu_descitem">dev_util_internal.Dev</dd>
<dt class="jdocu_descitem">Constructor</dt><dd class="jdocu_descitem"><pre class="jdocu_small">Memory(test = False)</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">A Simics memory space in which every slot can contain a byte, or be empty.
<p>
 Each byte sized slot in this memory can either contain a byte of data or
 be empty. Empty slots cannot be read.
</p><p>
 The <i>obj</i> attribute contains the object implementing the Simics
 interface to the memory. It implements the <code>memory_space</code>
 interface.
 
 Constructor arguments:
 </p><dl><dt id="python-api-testing.html:dt:test"><a href="#python-api-testing.html:dt:test"><b>test</b></a></dt><dd>set to True to not create any Simics objects, optional,
     defaults to False</dd></dl><p></p></dd>
</dl><p></p><h4 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyfundev_util_internal.Memory.clear">clear</a></h4>
<p></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Synopsis</dt><dd class="jdocu_descitem"><pre class="jdocu_small">obj.clear()</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Clear the contents of the memory.
 </dd>
</dl><p></p><h4 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyfundev_util_internal.Memory.is_range_touched">is_range_touched</a></h4>
<p></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Synopsis</dt><dd class="jdocu_descitem"><pre class="jdocu_small">obj.is_range_touched(start, length)</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Return True if any of this memory's slots in the range contain data.
 </dd>
</dl><p></p><h4 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyfundev_util_internal.Memory.read">read</a></h4>
<p></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Synopsis</dt><dd class="jdocu_descitem"><pre class="jdocu_small">obj.read(addr, n)</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Read bytes from this memory.
<p>
 Arguments:
 </p><dl><dt id="python-api-testing.html:dt:addr-3"><a href="#python-api-testing.html:dt:addr-3"><b>addr</b></a></dt><dd>the start address of the range to read</dd><dt id="python-api-testing.html:dt:n-2"><a href="#python-api-testing.html:dt:n-2"><b>n</b></a></dt><dd>length in bytes of the range to read</dd></dl><p>This method throws an exception if any byte in the read range is empty.
 </p></dd>
</dl><p></p><h4 class="jdocu"><a class="not-numbered" id="python-api-testing.html:__pyfundev_util_internal.Memory.write">write</a></h4>
<p></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Synopsis</dt><dd class="jdocu_descitem"><pre class="jdocu_small">obj.write(addr, bytes)</pre><p></p></dd>
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Write bytes to this memory.
<p>
 Arguments:
 </p><dl><dt id="python-api-testing.html:dt:addr-4"><a href="#python-api-testing.html:dt:addr-4"><b>addr</b></a></dt><dd>the start address of the range to write</dd><dt id="python-api-testing.html:dt:n-3"><a href="#python-api-testing.html:dt:n-3"><b>n</b></a></dt><dd>the bytes to write</dd></dl><p>Fills in empty slots in the memory and overwrites already existing data.
 </p></dd>
</dl><p>


</p></section><section class="page" id="python-api-script-branch.html"><h1 class="jdocu"><a id="python-api-script-branch.html:python-api-script-branch">10.8 Script branches</a></h1>
<p>

</p><p>
The Script Branch API is a set of Python functions for controlling
script branches. This API is used when implementing CLI commands that
make use of script branches, and also when waiting for simulator
events via corresponding <code>wait-for-</code> CLI commands. See
the <em>Simics User's Guide</em> for an introduction and examples
of using the API.
</p><p>
</p><h2 class="jdocu"><a class="not-numbered" id="python-api-script-branch.html:script_branch-Python-Module">script_branch Python Module</a></h2>
<p></p><h3 class="jdocu"><a class="not-numbered" id="python-api-script-branch.html:script_branch.sb_create">script_branch.sb_create()</a></h3>
<p>
  
  <a id="python-api-script-branch.html:sb_create"></a> <a id="python-api-script-branch.html:script_branch-Python-modulesb_create"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="python-api-script-branch.html:__jdocu_seealso_script_branch.sb_create"></a><b>sb_create</b>  create a script branch</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">sb_create(func, desc = None)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Create a script branch that will start executing <i>func</i>
(which should not take any arguments). The <b><i>sb_create</i></b>
function returns a unique script-branch identifier, that can be
used with <b><i>sb_interrupt_branch</i></b>. It may be called from a
script branch to create a new parallel branch. The current branch
will resume execution when the new script branch is suspended.
<p>
The optional <i>desc</i> argument will be displayed by
<b>list-script-branches</b> as a description of the script
branch.</p></dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
script-branch identifier</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#python-api-script-branch.html:__jdocu_seealso_script_branch.sb_wait">script_branch.sb_wait</a>, <a class="jdocu" href="#python-api-script-branch.html:__jdocu_seealso_script_branch.sb_interrupt_branch"> script_branch.sb_interrupt_branch</a>, <a class="jdocu" href="#python-api-script-branch.html:__jdocu_seealso_script_branch.sb_run_in_main_branch"> script_branch.sb_run_in_main_branch</a></dd>
<dt class="jdocu_descitem">EXECUTION CONTEXT</dt><dd>
Global Context</dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="python-api-script-branch.html:script_branch.sb_get_wait_id">script_branch.sb_get_wait_id()</a></h3>
<p><a id="python-api-script-branch.html:sb_get_wait_id"></a> <a id="python-api-script-branch.html:script_branch-Python-modulesb_get_wait_id"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="python-api-script-branch.html:__jdocu_seealso_script_branch.sb_get_wait_id"></a><b>sb_get_wait_id</b>  obtain script branch wait ID</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">sb_get_wait_id()</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Return a new unique script-branch wait-identifier that can be
used when suspending a script-branch using <b><i>sb_wait</i></b>.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
script branch wait-identifier</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#python-api-script-branch.html:__jdocu_seealso_script_branch.sb_wait">script_branch.sb_wait</a>, <a class="jdocu" href="#python-api-script-branch.html:__jdocu_seealso_script_branch.sb_signal_waiting"> script_branch.sb_signal_waiting</a></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="python-api-script-branch.html:script_branch.sb_in_main_branch">script_branch.sb_in_main_branch()</a></h3>
<p><a id="python-api-script-branch.html:sb_in_main_branch"></a> <a id="python-api-script-branch.html:script_branch-Python-modulesb_in_main_branch"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="python-api-script-branch.html:__jdocu_seealso_script_branch.sb_in_main_branch"></a><b>sb_in_main_branch</b>  indicate if the main branch is running</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">sb_in_main_branch()</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Return <code>true</code> if the main branch is currently active, and not
one of the script branches.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#python-api-script-branch.html:__jdocu_seealso_script_branch.sb_run_in_main_branch">script_branch.sb_run_in_main_branch</a></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="python-api-script-branch.html:script_branch.sb_interrupt_branch">script_branch.sb_interrupt_branch()</a></h3>
<p><a id="python-api-script-branch.html:sb_interrupt_branch"></a> <a id="python-api-script-branch.html:script_branch-Python-modulesb_interrupt_branch"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="python-api-script-branch.html:__jdocu_seealso_script_branch.sb_interrupt_branch"></a><b>sb_interrupt_branch</b>  interrupt suspended script branch</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">sb_interrupt_branch(branch_id)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Interrupt a script branch that is currently suspended. The
<i>branch_id</i> should be the script-branch identifier
(returned by <b><i>sb_create</i></b>) of a suspended script branch,
otherwise an exception is raised.
<p>
As a side effect, the <b><i>sb_wait</i></b> function called in the
script branch will raise a <code>CliQuietError</code> exception.</p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#python-api-script-branch.html:__jdocu_seealso_script_branch.sb_create">script_branch.sb_create</a>, <a class="jdocu" href="#python-api-script-branch.html:__jdocu_seealso_script_branch.sb_wait"> script_branch.sb_wait</a></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="python-api-script-branch.html:script_branch.sb_run_in_main_branch">script_branch.sb_run_in_main_branch()</a></h3>
<p><a id="python-api-script-branch.html:sb_run_in_main_branch"></a> <a id="python-api-script-branch.html:script_branch-Python-modulesb_run_in_main_branch"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="python-api-script-branch.html:__jdocu_seealso_script_branch.sb_run_in_main_branch"></a><b>sb_run_in_main_branch</b>  run function in the main thread</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">sb_run_in_main_branch(command, func)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Schedule <i>func</i> (which should not take
any arguments) to run in the main thread and block the calling script-branch
thread until the function has run. A <code>CliError</code> exception will
be raised if an error occurs while running <i>func</i>, otherwise
its return value is returned.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
return value of <i>func</i></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#python-api-script-branch.html:__jdocu_seealso_script_branch.sb_create">script_branch.sb_create</a>, <a class="jdocu" href="#python-api-script-branch.html:__jdocu_seealso_script_branch.sb_in_main_branch"> script_branch.sb_in_main_branch</a></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="python-api-script-branch.html:script_branch.sb_signal_waiting">script_branch.sb_signal_waiting()</a></h3>
<p><a id="python-api-script-branch.html:sb_signal_waiting"></a> <a id="python-api-script-branch.html:script_branch-Python-modulesb_signal_waiting"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="python-api-script-branch.html:__jdocu_seealso_script_branch.sb_signal_waiting"></a><b>sb_signal_waiting</b>  wake up a suspended script branch</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">sb_signal_waiting(wait_id)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Wake up a suspended script-branch, with <i>wait_id</i> as wait
identifier, letting it run again.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#python-api-script-branch.html:__jdocu_seealso_script_branch.sb_wait">script_branch.sb_wait</a>, <a class="jdocu" href="#python-api-script-branch.html:__jdocu_seealso_script_branch.sb_get_wait_id"> script_branch.sb_get_wait_id</a></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="python-api-script-branch.html:script_branch.sb_wait">script_branch.sb_wait()</a></h3>
<p><a id="python-api-script-branch.html:sb_wait"></a> <a id="python-api-script-branch.html:script_branch-Python-modulesb_wait"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="python-api-script-branch.html:__jdocu_seealso_script_branch.sb_wait"></a><b>sb_wait</b>  suspend a script branch</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">sb_wait(command, wait_id, reverse=None, always=None, wait_data=None,
        use_obj=None)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Suspend a script branch in the <i>command</i> command (a
descriptive string) until <b><i>sb_signal_waiting</i></b> is called
with <i>wait_id</i> as argument. The <i>reverse</i> and
<i>always</i> should not be used. The <i>wait_data</i> argument
is a string describing the data being waited for, or
<code>None</code>. The <i>use_obj</i> argument is deprecated and
should never be specified.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#python-api-script-branch.html:__jdocu_seealso_script_branch.sb_create">script_branch.sb_create</a>, <a class="jdocu" href="#python-api-script-branch.html:__jdocu_seealso_script_branch.sb_get_wait_id"> script_branch.sb_get_wait_id</a>, <a class="jdocu" href="#python-api-script-branch.html:__jdocu_seealso_script_branch.sb_signal_waiting"> script_branch.sb_signal_waiting</a></dd>
</dl><p>
</p></section><section class="page" id="python-api-probes.html"><h1 class="jdocu"><a id="python-api-probes.html:python-api-probes">10.9 Probes</a></h1>
<p>

The <code>probes</code> Python package allows convenient methods for accessing
all probes which has been registered in Simics.
</p><p>
When probes are enabled with the <code>enable-probes</code> command the probe
framework will create Python ProbeProxy objects for all existing
probes in the system. Any additional created objects with probes will
also automatically get ProbeProxy objects.
</p><p>
</p><h2 class="jdocu"><a class="not-numbered" id="python-api-probes.html:Probes-Python-Module">Probes Python Module</a></h2>
<p></p><h3 class="jdocu"><a class="not-numbered" id="python-api-probes.html:probes.CellFormatter">probes.CellFormatter</a></h3>
<p>
  
  <a id="python-api-probes.html:CellFormatter"></a> <a id="python-api-probes.html:probes-Python-moduleCellFormatter"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="python-api-probes.html:__jdocu_seealso_probes.CellFormatter"></a><b>CellFormatter</b>  helper object for various format properties</dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Helper Class for summary-probe formatting. Simply holds various
formatting properties together, in one class object.</dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="python-api-probes.html:probes.ProbeProxy">probes.ProbeProxy</a></h3>
<p><a id="python-api-probes.html:ProbeProxy"></a> <a id="python-api-probes.html:probes-Python-moduleProbeProxy"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="python-api-probes.html:__jdocu_seealso_probes.ProbeProxy"></a><b>ProbeProxy</b>  wrapper class of probes that exists in Simics</dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The ProbeProxy class represents a Python object for the detected
probes in the system. The object wrapping allows easier access
to the probe objects through the different probe interfaces.
<p>
Object implementing the indexed probe interface, will get a
dedicated ProbeProxy object per index.
</p><p>
The formatting of the different types of probes are also
automatically handled by this class.</p></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="python-api-probes.html:probes.get_all_probe_kinds">probes.get_all_probe_kinds()</a></h3>
<p><a id="python-api-probes.html:get_all_probe_kinds"></a> <a id="python-api-probes.html:probes-Python-moduleget_all_probe_kinds"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="python-api-probes.html:__jdocu_seealso_probes.get_all_probe_kinds"></a><b>get_all_probe_kinds</b>  get all registered probe-kinds in the system</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">get_all_probe_kinds()</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns all registered probe-kinds in the system. The probe-kind is
the unique probe identifier, not including the objects associated
with it.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#python-api-probes.html:__jdocu_seealso_probes.get_probes">probes.get_probes</a>, <a class="jdocu" href="#python-api-probes.html:__jdocu_seealso_probes.get_all_probes"> probes.get_all_probes</a></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="python-api-probes.html:probes.get_all_probes">probes.get_all_probes()</a></h3>
<p><a id="python-api-probes.html:get_all_probes"></a> <a id="python-api-probes.html:probes-Python-moduleget_all_probes"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="python-api-probes.html:__jdocu_seealso_probes.get_all_probes"></a><b>get_all_probes</b>  get all ProbeProxy instances</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">get_all_probes()</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns all Python 'ProbeProxy' objects that exists currently.
These objects can be used to access the probe interfaces in a
convenient way by using methods in them.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#python-api-probes.html:__jdocu_seealso_probes.get_all_probe_kinds">probes.get_all_probe_kinds</a>, <a class="jdocu" href="#python-api-probes.html:__jdocu_seealso_probes.get_probes"> probes.get_probes</a></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="python-api-probes.html:probes.get_probe_by_object">probes.get_probe_by_object()</a></h3>
<p><a id="python-api-probes.html:get_probe_by_object"></a> <a id="python-api-probes.html:probes-Python-moduleget_probe_by_object"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="python-api-probes.html:__jdocu_seealso_probes.get_probe_by_object"></a><b>get_probe_by_object</b>  get the ProbeProxy instance for an object </dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">get_probe_by_object(kind, obj)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns the 'ProbeProxy' Python object for a probe-kind in a
specific conf object.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#python-api-probes.html:__jdocu_seealso_probes.get_all_probe_kinds">probes.get_all_probe_kinds</a>, <a class="jdocu" href="#python-api-probes.html:__jdocu_seealso_probes.get_probes"> probes.get_probes</a></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="python-api-probes.html:probes.get_probes">probes.get_probes()</a></h3>
<p><a id="python-api-probes.html:get_probes"></a> <a id="python-api-probes.html:probes-Python-moduleget_probes"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="python-api-probes.html:__jdocu_seealso_probes.get_probes"></a><b>get_probes</b>  get hold of all ProbeProxy instances implementing a specific probe-kind</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">get_probes(kind)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns the Python 'ProbeProxy' objects, for probes matching the specific
probe-kind.
These objects can be used to access the probe interfaces in a
convenient way by using methods in them.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#python-api-probes.html:__jdocu_seealso_probes.get_all_probe_kinds">probes.get_all_probe_kinds</a>, <a class="jdocu" href="#python-api-probes.html:__jdocu_seealso_probes.get_all_probes"> probes.get_all_probes</a></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="python-api-probes.html:probes.register_probe_delete_cb">probes.register_probe_delete_cb()</a></h3>
<p><a id="python-api-probes.html:register_probe_delete_cb"></a> <a id="python-api-probes.html:probes-Python-moduleregister_probe_delete_cb"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="python-api-probes.html:__jdocu_seealso_probes.register_probe_delete_cb"></a><b>register_probe_delete_cb</b>  request a callback when a probe is deleted</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">register_probe_delete_cb(cb)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Register a function which will be called when a probe is deleted from
the system. The function only takes a single argument; the ProbeProxy
instances that is about to be deleted.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#python-api-probes.html:__jdocu_seealso_probes.unregister_probe_delete_cb">probes.unregister_probe_delete_cb</a></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="python-api-probes.html:probes.unregister_probe_delete_cb">probes.unregister_probe_delete_cb()</a></h3>
<p><a id="python-api-probes.html:unregister_probe_delete_cb"></a> <a id="python-api-probes.html:probes-Python-moduleunregister_probe_delete_cb"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="python-api-probes.html:__jdocu_seealso_probes.unregister_probe_delete_cb"></a><b>unregister_probe_delete_cb</b>  cancel a callback for probe deletion</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">unregister_probe_delete_cb(cb)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Unregister a function callback when probes are deleted.
Typically needed when a python module itself is removed.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#python-api-probes.html:__jdocu_seealso_probes.register_probe_delete_cb">probes.register_probe_delete_cb</a></dd>
</dl><p>
</p></section><section class="page" id="other.html"><h1 class="jdocu"><a id="other.html:Other">10.10 Other</a></h1>
<p>

    </p><h2 class="jdocu"><a class="not-numbered" id="other.html:Other-Python-specific-Classes-and-Functions">Other Python-specific Classes and Functions</a></h2>
<p></p><h3 class="jdocu"><a class="not-numbered" id="other.html:simics.CriticalErrors">simics.CriticalErrors</a></h3>
<p>
  
  <a id="other.html:CriticalErrors"></a> <a id="other.html:simics-Python-moduleCriticalErrors"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="other.html:__jdocu_seealso_simics.CriticalErrors"></a><b>CriticalErrors</b>  represents critical errors caused by C code called from Python</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">CriticalErrors(args)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This exception is raised when returning to Python from a C function
that directly or indirectly caused one or more serious, but
recoverable, errors. Elaborate error descriptions are
printed when the errors occur, but because of error recovery, the
C function will be able to continue without being aware of the error.
<p>
A C function can cause more than one error; all these are combined
into a single Python exception. The main purpose of the exception
is to aid debugging, usually by providing a nice Python traceback.</p></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="other.html:table.column_names">table.column_names()</a></h3>
<p><a id="other.html:column_names"></a> <a id="other.html:table-Python-modulecolumn_names"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="other.html:__jdocu_seealso_table.column_names"></a><b>column_names</b>  get hold of column names from a property list</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">column_names(prop_list)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Help function to retrieve the column names embedded in
the list of table properties.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#other.html:__jdocu_seealso_table.show">table.show</a></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="other.html:table.default_table_args">table.default_table_args()</a></h3>
<p><a id="other.html:default_table_args"></a> <a id="other.html:table-Python-moduledefault_table_args"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="other.html:__jdocu_seealso_table.default_table_args"></a><b>default_table_args</b>  get default table arguments</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">default_table_args(set_dict={})</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Return the tuple representing the default table arguments. The
set_dict can contain key/value elements overriding the default
value. The key is the same as the name of the table argument in
the command.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#other.html:__jdocu_seealso_table.new_table_command">table.new_table_command</a>, <a class="jdocu" href="#other.html:__jdocu_seealso_table.get"> table.get</a></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="other.html:table.get">table.get()</a></h3>
<p><a id="other.html:get"></a> <a id="other.html:table-Python-moduleget"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="other.html:__jdocu_seealso_table.get"></a><b>get</b>  fetch the formatted table</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">get(properties, data, *table_args)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Similar to the <b><i>table.show</i></b> but this function returns the
table as a multi-line string.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#other.html:__jdocu_seealso_table.new_table_command">table.new_table_command</a>, <a class="jdocu" href="#other.html:__jdocu_seealso_table.get"> table.get</a></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="other.html:table.get_table_arg_value">table.get_table_arg_value()</a></h3>
<p><a id="other.html:get_table_arg_value"></a> <a id="other.html:table-Python-moduleget_table_arg_value"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="other.html:__jdocu_seealso_table.get_table_arg_value"></a><b>get_table_arg_value</b>  retrieve the value for a table command argument</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">get_table_arg_value(arg, table_values)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Allows the user command to look at a certain named parameter to get
its value. For example, to internally make use of the
<code>-verbose</code> flag.
The <i>arg</i> argument specifies the argument to fetch the
value of. The <i>table_values</i> argument is the tuple of table
arguments received in the <b><i>table.new_table_command()</i></b>
callback function.</dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="other.html:table.new_table_command">table.new_table_command()</a></h3>
<p><a id="other.html:new_table_command"></a> <a id="other.html:table-Python-modulenew_table_command"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="other.html:__jdocu_seealso_table.new_table_command"></a><b>new_table_command</b>  register a new command which prints a table</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">new_table_command(command_name,
                  cmd_func,
                  args = None,
                  doc = "",
                  sortable_columns = None,
                  **kwargs)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Register a specific command for printing the table, with
all the command arguments from the <b>&lt;table&gt;.print-table</b>
commands, but extendable with personalized argument handling.
For example, a dedicated command could print out additional data, or
filter out certain rows from the table and only print those.
<p>
All arguments here are similar to the <b><i>cli.new_command()</i></b> function
except the <i>sortable_columns</i> argument.
</p><p>
The <i>cmd_func</i> function will be called with additional table
argument last. The function should use the <b><i>table.show()</i></b>
to produce the table output according to the user arguments.
</p><p>
If the <i>sortable_columns</i> argument is supplied, it should contain
a list of the column namnes which can be used for sorting. This is
only used for the expander function. If this argument is not set, the
default expander will try to use the table interface to retrieve the
column names.</p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#command-line-interface.html:__jdocu_seealso_cli.new_command">cli.new_command</a>, <a class="jdocu" href="#other.html:__jdocu_seealso_table.show"> table.show</a></dd>
</dl><p></p><h3 class="jdocu"><a class="not-numbered" id="other.html:table.show">table.show()</a></h3>
<p><a id="other.html:show"></a> <a id="other.html:table-Python-moduleshow"></a>
  </p><dl class="jdocu_di">
<dt class="jdocu_descitem">NAME</dt><dd>
<a id="other.html:__jdocu_seealso_table.show"></a><b>show</b>  format and print the table</dd>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small">show(properties, data, *table_args)</pre><p></p></dd>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This function should be used from a command function registered
through the <b><i>table.new_table_command()</i></b> function to
print out the table according to the user arguments.
The <i>properties</i> argument is a list of key/value pairs
setting table properties for the table.
The <i>data</i> argument contains the two-dimensional data
to be printed where the inner list contains the columns and the
outer list the rows of the table.
See the <code>table</code> interface for more information.
<p>
The <i>*table_args</i> argument represents the standard table
arguments, received last in the <b><i>table.new_table_command()</i></b>
callback function.</p></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#other.html:__jdocu_seealso_table.new_table_command">table.new_table_command</a>, <a class="jdocu" href="#other.html:__jdocu_seealso_table.get"> table.get</a></dd>
</dl><p>
</p></section><section class="page" id="complete-list.html"><h1 class="jdocu"><a id="complete-list.html:Complete-List">11 Complete List</a></h1>
<p><table>
<tbody><tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_ATOM_flags">ATOM_completion</a></td><td class="jdocu_noborder">transaction atom's constructor</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_ATOM_flags">ATOM_data</a></td><td class="jdocu_noborder">transaction atom's constructor</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_ATOM_flags">ATOM_flags</a></td><td class="jdocu_noborder">transaction atom's constructor</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_ATOM_flags">ATOM_initiator</a></td><td class="jdocu_noborder">transaction atom's constructor</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_ATOM_flags">ATOM_list_end</a></td><td class="jdocu_noborder">transaction atom's constructor</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_ATOM_flags">ATOM_size</a></td><td class="jdocu_noborder">transaction atom's constructor</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_MM_FREE">MM_FREE</a></td><td class="jdocu_noborder">free allocation</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_MM_MALLOC">MM_MALLOC</a></td><td class="jdocu_noborder">allocate memory</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_MM_REALLOC">MM_REALLOC</a></td><td class="jdocu_noborder">reallocate memory</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_MM_STRDUP">MM_STRDUP</a></td><td class="jdocu_noborder">duplicate a string</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#link-library-api.html:__jdocu_seealso_SIMLINK_config_remove_value">SIMLINK_config_remove_value</a></td><td class="jdocu_noborder">remove a link configuration parameter</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#link-library-api.html:__jdocu_seealso_SIMLINK_config_update_value">SIMLINK_config_update_value</a></td><td class="jdocu_noborder">update a link configuration parameter</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#link-library-api.html:__jdocu_seealso_SIMLINK_endpoint_clock">SIMLINK_endpoint_clock</a></td><td class="jdocu_noborder">return endpoint's clock</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#link-library-api.html:__jdocu_seealso_SIMLINK_endpoint_dev_name">SIMLINK_endpoint_dev_name</a></td><td class="jdocu_noborder">return the name of the device or snooper to which an endpoint
     is connected</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#link-library-api.html:__jdocu_seealso_SIMLINK_endpoint_device">SIMLINK_endpoint_device</a></td><td class="jdocu_noborder">return the device to which an endpoint is connected</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#link-library-api.html:__jdocu_seealso_SIMLINK_endpoint_disconnect">SIMLINK_endpoint_disconnect</a></td><td class="jdocu_noborder">disconnect an endpoint object</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#link-library-api.html:__jdocu_seealso_SIMLINK_endpoint_finalize">SIMLINK_endpoint_finalize</a></td><td class="jdocu_noborder">finalize an endpoint object</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#link-library-api.html:__jdocu_seealso_SIMLINK_endpoint_id">SIMLINK_endpoint_id</a></td><td class="jdocu_noborder">return endpoint's ID</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#link-library-api.html:__jdocu_seealso_SIMLINK_endpoint_init">SIMLINK_endpoint_init</a></td><td class="jdocu_noborder">initialize an endpoint object</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#link-library-api.html:__jdocu_seealso_SIMLINK_endpoint_is_device">SIMLINK_endpoint_is_device</a></td><td class="jdocu_noborder">return whether an endpoint is connected to a device</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#link-library-api.html:__jdocu_seealso_SIMLINK_endpoint_link">SIMLINK_endpoint_link</a></td><td class="jdocu_noborder">return endpoint's link</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#link-library-api.html:__jdocu_seealso_SIMLINK_endpoint_port">SIMLINK_endpoint_port</a></td><td class="jdocu_noborder">return the device's port to which an endpoint is connected</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#link-library-api.html:__jdocu_seealso_SIMLINK_finalize">SIMLINK_finalize</a></td><td class="jdocu_noborder">finalize a link object</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#link-library-api.html:__jdocu_seealso_SIMLINK_find_endpoint_by_id">SIMLINK_find_endpoint_by_id</a></td><td class="jdocu_noborder">return an endpoint object given its ID</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#link-library-api.html:__jdocu_seealso_SIMLINK_init">SIMLINK_init</a></td><td class="jdocu_noborder">initialize a link object</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#link-library-api.html:__jdocu_seealso_SIMLINK_init_library">SIMLINK_init_library</a></td><td class="jdocu_noborder">initialize the link library</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#link-library-api.html:__jdocu_seealso_SIMLINK_init_message">SIMLINK_init_message</a></td><td class="jdocu_noborder">initialize a link message</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#link-library-api.html:__jdocu_seealso_SIMLINK_pre_delete">SIMLINK_pre_delete</a></td><td class="jdocu_noborder">clean-up before link deletion</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#link-library-api.html:__jdocu_seealso_SIMLINK_register_class">SIMLINK_register_class</a></td><td class="jdocu_noborder">register a link class</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#link-library-api.html:__jdocu_seealso_SIMLINK_register_endpoint_class">SIMLINK_register_endpoint_class</a></td><td class="jdocu_noborder">register a link endpoint class</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#link-library-api.html:__jdocu_seealso_SIMLINK_register_snoop_endpoint_class">SIMLINK_register_snoop_endpoint_class</a></td><td class="jdocu_noborder">register a link snoop endpoint class</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#link-library-api.html:__jdocu_seealso_SIMLINK_send_message">SIMLINK_send_message</a></td><td class="jdocu_noborder">send a link message</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#link-library-api.html:__jdocu_seealso_SIMLINK_send_message_multi">SIMLINK_send_message_multi</a></td><td class="jdocu_noborder">send a link message to multiple recipients</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#link-library-api.html:__jdocu_seealso_SIMLINK_snoop_endpoint_create">SIMLINK_snoop_endpoint_create</a></td><td class="jdocu_noborder">create a snoop endpoint object</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_ASSERT_CELL_CONTEXT">SIM_ASSERT_CELL_CONTEXT</a></td><td class="jdocu_noborder">assert Cell Context</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_ASSERT_OBJECT_LOCK">SIM_ASSERT_OBJECT_LOCK</a></td><td class="jdocu_noborder">assert thread domain is held</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_STC_flush_cache">SIM_STC_flush_cache</a></td><td class="jdocu_noborder">flush or remove entries in the STCs of a cpu</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_acquire_cell">SIM_acquire_cell</a></td><td class="jdocu_noborder">enter Cell Context</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_acquire_object">SIM_acquire_object</a></td><td class="jdocu_noborder">acquire thread domain</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_acquire_object_for_execution">SIM_acquire_object_for_execution</a></td><td class="jdocu_noborder">acquire object lock for execution</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_acquire_target">SIM_acquire_target</a></td><td class="jdocu_noborder">conditionally enter Cell Context</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_add_configuration">SIM_add_configuration</a></td><td class="jdocu_noborder">set configuration from Python</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_add_directory">SIM_add_directory</a></td><td class="jdocu_noborder">add directory to search path</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_add_global_notifier">SIM_add_global_notifier</a></td><td class="jdocu_noborder">add a global notifier callback</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_add_global_notifier_once">SIM_add_global_notifier_once</a></td><td class="jdocu_noborder">add a global notifier callback</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_add_module_dir">SIM_add_module_dir</a></td><td class="jdocu_noborder">add loadable module search path</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_add_notifier">SIM_add_notifier</a></td><td class="jdocu_noborder">add a notifier callback</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_add_output_handler">SIM_add_output_handler</a></td><td class="jdocu_noborder">add or remove output handler</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_alloc_attr_dict">SIM_alloc_attr_dict</a></td><td class="jdocu_noborder">create empty attribute dictionary</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_alloc_attr_list">SIM_alloc_attr_list</a></td><td class="jdocu_noborder">create uninitialized attribute list</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_arm_mem_trans_from_generic">SIM_arm_mem_trans_from_generic</a></td><td class="jdocu_noborder">convert generic transaction to CPU specific</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_attr_scanf">SIM_ascanf</a></td><td class="jdocu_noborder">parse list attribute values</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_attr_integer">SIM_attr_boolean</a></td><td class="jdocu_noborder">extract values stored in <code>attr_value_t</code> values</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_attr_copy">SIM_attr_copy</a></td><td class="jdocu_noborder">copy attribute value</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_attr_integer">SIM_attr_data</a></td><td class="jdocu_noborder">extract values stored in <code>attr_value_t</code> values</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_attr_integer">SIM_attr_data_size</a></td><td class="jdocu_noborder">extract values stored in <code>attr_value_t</code> values</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_attr_integer">SIM_attr_dict_key</a></td><td class="jdocu_noborder">extract values stored in <code>attr_value_t</code> values</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_attr_dict_resize">SIM_attr_dict_resize</a></td><td class="jdocu_noborder">resize dict attribute value</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_attr_dict_set_item">SIM_attr_dict_set_item</a></td><td class="jdocu_noborder">set dict attribute element</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_attr_integer">SIM_attr_dict_size</a></td><td class="jdocu_noborder">extract values stored in <code>attr_value_t</code> values</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_attr_integer">SIM_attr_dict_value</a></td><td class="jdocu_noborder">extract values stored in <code>attr_value_t</code> values</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_attr_integer">SIM_attr_floating</a></td><td class="jdocu_noborder">extract values stored in <code>attr_value_t</code> values</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_attr_free">SIM_attr_free</a></td><td class="jdocu_noborder">free attribute</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_attr_integer">SIM_attr_integer</a></td><td class="jdocu_noborder">extract values stored in <code>attr_value_t</code> values</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_attr_is_integer">SIM_attr_is_boolean</a></td><td class="jdocu_noborder"><code>attr_value_t</code> type predicates</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_attr_is_integer">SIM_attr_is_data</a></td><td class="jdocu_noborder"><code>attr_value_t</code> type predicates</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_attr_is_integer">SIM_attr_is_dict</a></td><td class="jdocu_noborder"><code>attr_value_t</code> type predicates</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_attr_is_integer">SIM_attr_is_floating</a></td><td class="jdocu_noborder"><code>attr_value_t</code> type predicates</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_attr_is_integer">SIM_attr_is_int64</a></td><td class="jdocu_noborder"><code>attr_value_t</code> type predicates</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_attr_is_integer">SIM_attr_is_integer</a></td><td class="jdocu_noborder"><code>attr_value_t</code> type predicates</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_attr_is_integer">SIM_attr_is_invalid</a></td><td class="jdocu_noborder"><code>attr_value_t</code> type predicates</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_attr_is_integer">SIM_attr_is_list</a></td><td class="jdocu_noborder"><code>attr_value_t</code> type predicates</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_attr_is_integer">SIM_attr_is_nil</a></td><td class="jdocu_noborder"><code>attr_value_t</code> type predicates</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_attr_is_integer">SIM_attr_is_object</a></td><td class="jdocu_noborder"><code>attr_value_t</code> type predicates</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_attr_is_integer">SIM_attr_is_string</a></td><td class="jdocu_noborder"><code>attr_value_t</code> type predicates</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_attr_is_integer">SIM_attr_is_uint64</a></td><td class="jdocu_noborder"><code>attr_value_t</code> type predicates</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_attr_integer">SIM_attr_list</a></td><td class="jdocu_noborder">extract values stored in <code>attr_value_t</code> values</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_attr_integer">SIM_attr_list_item</a></td><td class="jdocu_noborder">extract values stored in <code>attr_value_t</code> values</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_attr_list_resize">SIM_attr_list_resize</a></td><td class="jdocu_noborder">resize list attribute value</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_attr_list_set_item">SIM_attr_list_set_item</a></td><td class="jdocu_noborder">set list attribute element</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_attr_integer">SIM_attr_list_size</a></td><td class="jdocu_noborder">extract values stored in <code>attr_value_t</code> values</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_attr_integer">SIM_attr_object</a></td><td class="jdocu_noborder">extract values stored in <code>attr_value_t</code> values</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_attr_integer">SIM_attr_object_or_nil</a></td><td class="jdocu_noborder">extract values stored in <code>attr_value_t</code> values</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_attr_scanf">SIM_attr_scanf</a></td><td class="jdocu_noborder">parse list attribute values</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_attr_integer">SIM_attr_string</a></td><td class="jdocu_noborder">extract values stored in <code>attr_value_t</code> values</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_attr_integer">SIM_attr_string_detach</a></td><td class="jdocu_noborder">extract values stored in <code>attr_value_t</code> values</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_attribute_error">SIM_attribute_error</a></td><td class="jdocu_noborder">specify reason for attribute error</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_break_cycle">SIM_break_cycle</a></td><td class="jdocu_noborder">insert breakpoint in time queue</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_break_message">SIM_break_message</a></td><td class="jdocu_noborder">stop the simulation</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_break_simulation">SIM_break_simulation</a></td><td class="jdocu_noborder">stop the simulation</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_break_step">SIM_break_step</a></td><td class="jdocu_noborder">set a step breakpoint</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_breakpoint">SIM_breakpoint</a></td><td class="jdocu_noborder">set breakpoint</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_breakpoint_remove">SIM_breakpoint_remove</a></td><td class="jdocu_noborder">delete breakpoint range</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_attribute_error">SIM_c_attribute_error</a></td><td class="jdocu_noborder">specify reason for attribute error</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_get_interface">SIM_c_get_class_interface</a></td><td class="jdocu_noborder">get interface</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_get_interface">SIM_c_get_class_port_interface</a></td><td class="jdocu_noborder">get interface</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_get_interface">SIM_c_get_interface</a></td><td class="jdocu_noborder">get interface</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_c_get_mem_op_value_buf">SIM_c_get_mem_op_value_buf</a></td><td class="jdocu_noborder">get value for a memory operation</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_get_interface">SIM_c_get_port_interface</a></td><td class="jdocu_noborder">get interface</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_hap_occurred_always">SIM_c_hap_occurred</a></td><td class="jdocu_noborder">trigger a hap occurrence</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_hap_occurred_always">SIM_c_hap_occurred_always</a></td><td class="jdocu_noborder">trigger a hap occurrence</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_hap_occurred_always">SIM_c_hap_occurred_always_vararg</a></td><td class="jdocu_noborder">trigger a hap occurrence</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_hap_occurred_always">SIM_c_hap_occurred_vararg</a></td><td class="jdocu_noborder">trigger a hap occurrence</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_c_set_mem_op_value_buf">SIM_c_set_mem_op_value_buf</a></td><td class="jdocu_noborder">set value for a memory operation</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_call_python_function">SIM_call_python_function</a></td><td class="jdocu_noborder">call a Python named function</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_cancel_realtime_event">SIM_cancel_realtime_event</a></td><td class="jdocu_noborder">cancel callback in host time</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_cbdata_data">SIM_cbdata_data</a></td><td class="jdocu_noborder">get cbdata data pointer</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_cbdata_type">SIM_cbdata_type</a></td><td class="jdocu_noborder">get cbdata type pointer</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_class_has_attribute">SIM_class_has_attribute</a></td><td class="jdocu_noborder">check if class implements attribute</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_class_has_notifier">SIM_class_has_notifier</a></td><td class="jdocu_noborder">query class for notifier</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_class_port">SIM_class_port</a></td><td class="jdocu_noborder">check if class has specified port object</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_clear_augmentation_bit">SIM_clear_augmentation_bit</a></td><td class="jdocu_noborder">convenience functions to work with augmented memory bits</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_clear_directories">SIM_clear_directories</a></td><td class="jdocu_noborder">clear the search path</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_clear_exception">SIM_clear_exception</a></td><td class="jdocu_noborder">clear pending exception</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_complete_transaction">SIM_complete_transaction</a></td><td class="jdocu_noborder">complete a deferred transaction</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_continue">SIM_continue</a></td><td class="jdocu_noborder">run the simulation</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_copy_class">SIM_copy_class</a></td><td class="jdocu_noborder">create a copy of an existing class</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_version">SIM_copyright</a></td><td class="jdocu_noborder">get Simics version and license/copyright information</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_create_class">SIM_create_class</a></td><td class="jdocu_noborder">create class</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_create_object">SIM_create_object</a></td><td class="jdocu_noborder">create and initialize object</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_current_checkpoint_dir">SIM_current_checkpoint_dir</a></td><td class="jdocu_noborder">directory of checkpoint being loaded</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_current_clock">SIM_current_clock</a></td><td class="jdocu_noborder">return current clock</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_cycle_count">SIM_cycle_count</a></td><td class="jdocu_noborder">read cycle counter</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_defer_owned_transaction">SIM_defer_owned_transaction</a></td><td class="jdocu_noborder">defer transaction completion using an existing transaction</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_defer_transaction">SIM_defer_transaction</a></td><td class="jdocu_noborder">defer transaction completion</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_delete_breakpoint">SIM_delete_breakpoint</a></td><td class="jdocu_noborder">delete breakpoint</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_delete_global_notifier">SIM_delete_global_notifier</a></td><td class="jdocu_noborder">delete global notifier callback</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_delete_notifier">SIM_delete_notifier</a></td><td class="jdocu_noborder">delete notifier callback</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_delete_objects">SIM_delete_object</a></td><td class="jdocu_noborder">delete a list of objects</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_delete_objects">SIM_delete_objects</a></td><td class="jdocu_noborder">delete a list of objects</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_delete_snapshot">SIM_delete_snapshot</a></td><td class="jdocu_noborder">delete a snapshot</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_describe_notifier">SIM_describe_notifier</a></td><td class="jdocu_noborder">set short description</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_describe_pseudo_exception">SIM_describe_pseudo_exception</a></td><td class="jdocu_noborder">return pseudo exception description</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_disable_breakpoint">SIM_disable_breakpoint</a></td><td class="jdocu_noborder">disable breakpoint</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_disassemble_address">SIM_disassemble_address</a></td><td class="jdocu_noborder">disassemble address</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_drop_thread_domains">SIM_drop_thread_domains</a></td><td class="jdocu_noborder">temporarily release all held thread domains</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_disable_breakpoint">SIM_enable_breakpoint</a></td><td class="jdocu_noborder">disable breakpoint</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_ensure_partial_attr_order">SIM_ensure_partial_attr_order</a></td><td class="jdocu_noborder">ensure attribute order</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_event_cancel_time">SIM_event_cancel_step</a></td><td class="jdocu_noborder">cancel an event before expiration</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_event_cancel_time">SIM_event_cancel_time</a></td><td class="jdocu_noborder">cancel an event before expiration</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_event_class_flags">SIM_event_class_flags</a></td><td class="jdocu_noborder">get event class flags</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_event_find_next_cycle">SIM_event_find_next_cycle</a></td><td class="jdocu_noborder">find event expiration time</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_event_find_next_cycle">SIM_event_find_next_step</a></td><td class="jdocu_noborder">find event expiration time</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_event_find_next_cycle">SIM_event_find_next_time</a></td><td class="jdocu_noborder">find event expiration time</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_event_post_time">SIM_event_post_cycle</a></td><td class="jdocu_noborder">post an event</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_event_post_time">SIM_event_post_step</a></td><td class="jdocu_noborder">post an event</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_event_post_time">SIM_event_post_time</a></td><td class="jdocu_noborder">post an event</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_extend_class">SIM_extend_class</a></td><td class="jdocu_noborder">extend class with contents from an extension class</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_extension_data">SIM_extension_data</a></td><td class="jdocu_noborder">get class extension data</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_write">SIM_flush</a></td><td class="jdocu_noborder">text output routines</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_STC_flush_cache">SIM_flush_D_STC_logical</a></td><td class="jdocu_noborder">flush or remove entries in the STCs of a cpu</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_STC_flush_cache">SIM_flush_D_STC_physical</a></td><td class="jdocu_noborder">flush or remove entries in the STCs of a cpu</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_STC_flush_cache">SIM_flush_I_STC_logical</a></td><td class="jdocu_noborder">flush or remove entries in the STCs of a cpu</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_STC_flush_cache">SIM_flush_I_STC_physical</a></td><td class="jdocu_noborder">flush or remove entries in the STCs of a cpu</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_flush_all_caches">SIM_flush_all_caches</a></td><td class="jdocu_noborder">clear Simics's internal caches</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_flush_cell_caches">SIM_flush_cell_caches</a></td><td class="jdocu_noborder">clear internal caches for a given cell</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_attr_free">SIM_free_attribute</a></td><td class="jdocu_noborder">free attribute</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_free_cbdata">SIM_free_cbdata</a></td><td class="jdocu_noborder">free cbdata</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_free_map_target">SIM_free_map_target</a></td><td class="jdocu_noborder">free a map target</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_get_all_classes">SIM_get_all_classes</a></td><td class="jdocu_noborder">get list of all loaded classes</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_get_all_failed_modules">SIM_get_all_failed_modules</a></td><td class="jdocu_noborder">return a list of all modules that failed to load</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_get_all_hap_types">SIM_get_all_hap_types</a></td><td class="jdocu_noborder">get list of all hap types</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_get_all_modules">SIM_get_all_modules</a></td><td class="jdocu_noborder">return a list of all modules</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_get_all_objects">SIM_get_all_objects</a></td><td class="jdocu_noborder">get list of all objects</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_get_all_processors">SIM_get_all_processors</a></td><td class="jdocu_noborder">get list of all processors</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_get_api_function">SIM_get_api_function</a></td><td class="jdocu_noborder">return an API function by name</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_get_attribute">SIM_get_attribute</a></td><td class="jdocu_noborder">get attribute</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_get_attribute_attributes">SIM_get_attribute_attributes</a></td><td class="jdocu_noborder">get attribute flags</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_get_attribute">SIM_get_attribute_idx</a></td><td class="jdocu_noborder">get attribute</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_clear_augmentation_bit">SIM_get_augmentation_bit</a></td><td class="jdocu_noborder">convenience functions to work with augmented memory bits</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_get_batch_mode">SIM_get_batch_mode</a></td><td class="jdocu_noborder">return setting of the batch-mode</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_get_class">SIM_get_class</a></td><td class="jdocu_noborder">get class</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_get_class_attribute">SIM_get_class_attribute</a></td><td class="jdocu_noborder">get class attribute</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_get_class_attribute">SIM_get_class_attribute_idx</a></td><td class="jdocu_noborder">get class attribute</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_get_class_data">SIM_get_class_data</a></td><td class="jdocu_noborder">get class data</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_get_interface">SIM_get_class_interface</a></td><td class="jdocu_noborder">get interface</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_get_class_name">SIM_get_class_name</a></td><td class="jdocu_noborder">get class name</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_get_interface">SIM_get_class_port_interface</a></td><td class="jdocu_noborder">get interface</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_get_debugger">SIM_get_debugger</a></td><td class="jdocu_noborder">return the debugger object</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_get_directories">SIM_get_directories</a></td><td class="jdocu_noborder">get the current search path</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_get_event_class">SIM_get_event_class</a></td><td class="jdocu_noborder">get the event class</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_get_global_message">SIM_get_global_message</a></td><td class="jdocu_noborder">obtain current global message</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_get_init_arg_string">SIM_get_init_arg_boolean</a></td><td class="jdocu_noborder">get an argument that the Simics core was initialized with</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_get_init_arg_string">SIM_get_init_arg_string</a></td><td class="jdocu_noborder">get an argument that the Simics core was initialized with</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_get_interface">SIM_get_interface</a></td><td class="jdocu_noborder">get interface</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_set_mem_op_exception">SIM_get_mem_op_exception</a></td><td class="jdocu_noborder">get/set transaction exception</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_set_mem_op_initiator">SIM_get_mem_op_ini_type</a></td><td class="jdocu_noborder">get/set transaction initiator</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_set_mem_op_initiator">SIM_get_mem_op_initiator</a></td><td class="jdocu_noborder">get/set transaction initiator</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_set_mem_op_inquiry">SIM_get_mem_op_inquiry</a></td><td class="jdocu_noborder">get/set transaction inquiry flag</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_get_mem_op_page_cross">SIM_get_mem_op_page_cross</a></td><td class="jdocu_noborder">detect transaction split</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_set_mem_op_physical_address">SIM_get_mem_op_physical_address</a></td><td class="jdocu_noborder">get or set transaction address</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_get_mem_op_size">SIM_get_mem_op_size</a></td><td class="jdocu_noborder">get transaction size</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_get_mem_op_type">SIM_get_mem_op_type</a></td><td class="jdocu_noborder">get type of transaction</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_get_mem_op_type_name">SIM_get_mem_op_type_name</a></td><td class="jdocu_noborder">get name of memory operation type</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_set_mem_op_user_data">SIM_get_mem_op_user_data</a></td><td class="jdocu_noborder">get/set transaction user data</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_c_get_mem_op_value_buf">SIM_get_mem_op_value_be</a></td><td class="jdocu_noborder">get value for a memory operation</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_c_get_mem_op_value_buf">SIM_get_mem_op_value_buf</a></td><td class="jdocu_noborder">get value for a memory operation</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_c_get_mem_op_value_buf">SIM_get_mem_op_value_cpu</a></td><td class="jdocu_noborder">get value for a memory operation</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_c_get_mem_op_value_buf">SIM_get_mem_op_value_le</a></td><td class="jdocu_noborder">get value for a memory operation</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_set_mem_op_physical_address">SIM_get_mem_op_virtual_address</a></td><td class="jdocu_noborder">get or set transaction address</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_get_object">SIM_get_object</a></td><td class="jdocu_noborder">get object</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_get_pending_exception">SIM_get_pending_exception</a></td><td class="jdocu_noborder">get current pending exception</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_get_interface">SIM_get_port_interface</a></td><td class="jdocu_noborder">get interface</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_get_processor">SIM_get_processor</a></td><td class="jdocu_noborder">get processor pointer from number</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_get_processor_number">SIM_get_processor_number</a></td><td class="jdocu_noborder">get the number of a processor</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_get_python_interface_type">SIM_get_python_interface_type</a></td><td class="jdocu_noborder">get Python interface type</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_get_quiet">SIM_get_quiet</a></td><td class="jdocu_noborder">return setting of the quiet flag</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_get_snapshot_info">SIM_get_snapshot_info</a></td><td class="jdocu_noborder">get information about a snapshot</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_get_transaction_bytes">SIM_get_transaction_bytes</a></td><td class="jdocu_noborder">get transaction data payload</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_get_transaction_bytes">SIM_get_transaction_bytes_offs</a></td><td class="jdocu_noborder">get transaction data payload</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_get_transaction_id">SIM_get_transaction_id</a></td><td class="jdocu_noborder">obtain checkpoint ID for a deferred a transaction</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_get_transaction_bytes">SIM_get_transaction_value_be</a></td><td class="jdocu_noborder">get transaction data payload</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_get_transaction_bytes">SIM_get_transaction_value_le</a></td><td class="jdocu_noborder">get transaction data payload</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_get_verbose">SIM_get_verbose</a></td><td class="jdocu_noborder">get the verbose flag</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_hap_add_callback">SIM_hap_add_callback</a></td><td class="jdocu_noborder">install callback on a hap</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_hap_add_callback">SIM_hap_add_callback_index</a></td><td class="jdocu_noborder">install callback on a hap</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_hap_add_callback">SIM_hap_add_callback_obj</a></td><td class="jdocu_noborder">install callback on a hap</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_hap_add_callback">SIM_hap_add_callback_obj_index</a></td><td class="jdocu_noborder">install callback on a hap</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_hap_add_callback">SIM_hap_add_callback_obj_range</a></td><td class="jdocu_noborder">install callback on a hap</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_hap_add_callback">SIM_hap_add_callback_range</a></td><td class="jdocu_noborder">install callback on a hap</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_hap_add_type">SIM_hap_add_type</a></td><td class="jdocu_noborder">register a new hap type</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_hap_delete_callback">SIM_hap_delete_callback</a></td><td class="jdocu_noborder">delete installed hap callback</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_hap_delete_callback">SIM_hap_delete_callback_id</a></td><td class="jdocu_noborder">delete installed hap callback</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_hap_delete_callback">SIM_hap_delete_callback_obj</a></td><td class="jdocu_noborder">delete installed hap callback</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_hap_delete_callback">SIM_hap_delete_callback_obj_id</a></td><td class="jdocu_noborder">delete installed hap callback</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_hap_get_name">SIM_hap_get_name</a></td><td class="jdocu_noborder">get hap name by number</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_hap_get_number">SIM_hap_get_number</a></td><td class="jdocu_noborder">get hap number by name</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_hap_is_active">SIM_hap_is_active</a></td><td class="jdocu_noborder">check if hap has callbacks</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_hap_is_active">SIM_hap_is_active_obj</a></td><td class="jdocu_noborder">check if hap has callbacks</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_hap_is_active">SIM_hap_is_active_obj_idx</a></td><td class="jdocu_noborder">check if hap has callbacks</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_hap_occurred_always">SIM_hap_occurred</a></td><td class="jdocu_noborder">trigger a hap occurrence</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_hap_occurred_always">SIM_hap_occurred_always</a></td><td class="jdocu_noborder">trigger a hap occurrence</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_hap_remove_type">SIM_hap_remove_type</a></td><td class="jdocu_noborder">remove a hap type</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_has_notifier">SIM_has_notifier</a></td><td class="jdocu_noborder">query object for notifier</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_init_command_line">SIM_init_command_line</a></td><td class="jdocu_noborder">initialize the Simics command line</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_init_environment">SIM_init_environment</a></td><td class="jdocu_noborder">perform early initialization of the simulator</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_init_simulator2">SIM_init_simulator2</a></td><td class="jdocu_noborder">perform initialization of the simulator</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_inspect_address_routing">SIM_inspect_address_routing</a></td><td class="jdocu_noborder">track the route of a transaction through memory hierarchy</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_inspect_breakpoints">SIM_inspect_breakpoints</a></td><td class="jdocu_noborder">find out breakpoints that a transaction would trigger</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#obsolete-device-api-types-and-functions.html:__jdocu_seealso_SIM_is_loading_micro_checkpoint">SIM_is_loading_micro_checkpoint</a></td><td class="jdocu_noborder">obsolete API function</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_is_restoring_snapshot">SIM_is_restoring_snapshot</a></td><td class="jdocu_noborder">check if a snapshot is currently being restored</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_is_restoring_state">SIM_is_restoring_state</a></td><td class="jdocu_noborder">check if state restoring phase</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_issue_read_transaction">SIM_issue_read_transaction</a></td><td class="jdocu_noborder">functions for issuing <code>transaction_t</code> transactions</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_issue_transaction">SIM_issue_transaction</a></td><td class="jdocu_noborder">issue transaction</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_issue_read_transaction">SIM_issue_write_transaction</a></td><td class="jdocu_noborder">functions for issuing <code>transaction_t</code> transactions</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_iter_next">SIM_iter_addr</a></td><td class="jdocu_noborder">Iterate over address profile counters</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_iter_next">SIM_iter_free</a></td><td class="jdocu_noborder">Iterate over address profile counters</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_iter_next">SIM_iter_next</a></td><td class="jdocu_noborder">Iterate over address profile counters</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_last_error">SIM_last_error</a></td><td class="jdocu_noborder">get error message from last frontend exception</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_version">SIM_license</a></td><td class="jdocu_noborder">get Simics version and license/copyright information</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_version">SIM_license_file</a></td><td class="jdocu_noborder">get Simics version and license/copyright information</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_list_snapshots">SIM_list_snapshots</a></td><td class="jdocu_noborder">list snapshots</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_load_binary">SIM_load_binary</a></td><td class="jdocu_noborder">read an executable file into memory</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_load_file">SIM_load_file</a></td><td class="jdocu_noborder">read a file into memory</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_load_module">SIM_load_module</a></td><td class="jdocu_noborder">load a module</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_load_target">SIM_load_target</a></td><td class="jdocu_noborder">load Simics target from file</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_log_info">SIM_log_critical</a></td><td class="jdocu_noborder">output log message</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_log_info">SIM_log_error</a></td><td class="jdocu_noborder">output log message</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_log_info">SIM_log_info</a></td><td class="jdocu_noborder">output log message</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_log_level">SIM_log_level</a></td><td class="jdocu_noborder">set and get log level</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_log_info">SIM_log_message</a></td><td class="jdocu_noborder">output log message</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_log_info">SIM_log_message_vararg</a></td><td class="jdocu_noborder">output log message</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_log_register_groups">SIM_log_register_groups</a></td><td class="jdocu_noborder">register names of log groups</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_log_info">SIM_log_spec_violation</a></td><td class="jdocu_noborder">output log message</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_log_info">SIM_log_unimplemented</a></td><td class="jdocu_noborder">output log message</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_lookup_file">SIM_lookup_file</a></td><td class="jdocu_noborder">find a file using simics search path</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_main_loop">SIM_main_loop</a></td><td class="jdocu_noborder">run the Simics main loop</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_make_attr_boolean">SIM_make_attr_boolean</a></td><td class="jdocu_noborder">make boolean attribute</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_make_attr_data">SIM_make_attr_data</a></td><td class="jdocu_noborder">create raw data attribute</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_make_attr_data">SIM_make_attr_data_adopt</a></td><td class="jdocu_noborder">create raw data attribute</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_make_attr_floating">SIM_make_attr_floating</a></td><td class="jdocu_noborder">make floating point attribute</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_make_attr_int64">SIM_make_attr_int64</a></td><td class="jdocu_noborder">make integer attribute</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_make_attr_invalid">SIM_make_attr_invalid</a></td><td class="jdocu_noborder">make invalid attribute</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_make_attr_list">SIM_make_attr_list</a></td><td class="jdocu_noborder">make list attribute</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_make_attr_list">SIM_make_attr_list_vararg</a></td><td class="jdocu_noborder">make list attribute</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_make_attr_nil">SIM_make_attr_nil</a></td><td class="jdocu_noborder">make nil attribute</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_make_attr_object">SIM_make_attr_object</a></td><td class="jdocu_noborder">make object attribute</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_make_attr_string">SIM_make_attr_string</a></td><td class="jdocu_noborder">make string attribute</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_make_attr_string">SIM_make_attr_string_adopt</a></td><td class="jdocu_noborder">make string attribute</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_make_attr_int64">SIM_make_attr_uint64</a></td><td class="jdocu_noborder">make integer attribute</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_make_cbdata">SIM_make_cbdata</a></td><td class="jdocu_noborder">create cbdata</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_make_mem_op_write">SIM_make_mem_op_read</a></td><td class="jdocu_noborder">create a memory transaction</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_make_mem_op_write">SIM_make_mem_op_write</a></td><td class="jdocu_noborder">create a memory transaction</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_make_simple_cbdata">SIM_make_simple_cbdata</a></td><td class="jdocu_noborder">create untyped cbdata</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_map_target_flush">SIM_map_target_flush</a></td><td class="jdocu_noborder">ensure that old translations are not used</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_map_target_object">SIM_map_target_object</a></td><td class="jdocu_noborder">inspect a map target</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_map_target_object">SIM_map_target_port</a></td><td class="jdocu_noborder">inspect a map target</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_map_target_object">SIM_map_target_target</a></td><td class="jdocu_noborder">inspect a map target</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_marked_for_deletion">SIM_marked_for_deletion</a></td><td class="jdocu_noborder">is object being deleted</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_mem_op_ensure_future_visibility">SIM_mem_op_ensure_future_visibility</a></td><td class="jdocu_noborder">request transaction visibility</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_mem_op_is_atomic">SIM_mem_op_is_atomic</a></td><td class="jdocu_noborder">detect transaction atomicity</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_mem_op_is_control">SIM_mem_op_is_control</a></td><td class="jdocu_noborder">transaction control predicates</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_mem_op_is_data">SIM_mem_op_is_data</a></td><td class="jdocu_noborder">transaction data/instruction predicates</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_mem_op_is_from_cache">SIM_mem_op_is_from_cache</a></td><td class="jdocu_noborder">Cache initiated transaction</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_mem_op_is_from_cpu">SIM_mem_op_is_from_cpu</a></td><td class="jdocu_noborder">CPU initiated transaction</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_mem_op_is_from_cpu_arch">SIM_mem_op_is_from_cpu_arch</a></td><td class="jdocu_noborder">CPU initiated transaction</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_mem_op_is_from_device">SIM_mem_op_is_from_device</a></td><td class="jdocu_noborder">Device initiated transaction</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_mem_op_is_data">SIM_mem_op_is_instruction</a></td><td class="jdocu_noborder">transaction data/instruction predicates</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_mem_op_is_prefetch">SIM_mem_op_is_prefetch</a></td><td class="jdocu_noborder">transaction control predicates</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_mem_op_is_read">SIM_mem_op_is_read</a></td><td class="jdocu_noborder">transaction read/write predicates</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_mem_op_is_read">SIM_mem_op_is_write</a></td><td class="jdocu_noborder">transaction read/write predicates</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_mem_op_may_stall">SIM_mem_op_may_stall</a></td><td class="jdocu_noborder">detect transaction stall possibility</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_arm_mem_trans_from_generic">SIM_mips_mem_trans_from_generic</a></td><td class="jdocu_noborder">convert generic transaction to CPU specific</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_module_list_refresh">SIM_module_list_refresh</a></td><td class="jdocu_noborder">refresh list of loadable modules</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_monitor_transaction">SIM_monitor_chained_transaction</a></td><td class="jdocu_noborder">monitor a transaction for deferred completion</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_monitor_transaction">SIM_monitor_transaction</a></td><td class="jdocu_noborder">monitor a transaction for deferred completion</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_native_path">SIM_native_path</a></td><td class="jdocu_noborder">convert path to its native form</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_new_map_target">SIM_new_map_target</a></td><td class="jdocu_noborder">create a map target</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_describe_notifier">SIM_notifier_description</a></td><td class="jdocu_noborder">set short description</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_notifier_type">SIM_notifier_type</a></td><td class="jdocu_noborder">get notifier type</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_notify">SIM_notify</a></td><td class="jdocu_noborder">trigger notification callbacks</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_notify_on_socket">SIM_notify_on_descriptor</a></td><td class="jdocu_noborder">register notification on host I/O events</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_notify_on_socket">SIM_notify_on_object</a></td><td class="jdocu_noborder">register notification on host I/O events</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_notify_on_socket">SIM_notify_on_socket</a></td><td class="jdocu_noborder">register notification on host I/O events</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_number_processors">SIM_number_processors</a></td><td class="jdocu_noborder">number of processors</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_object_class">SIM_object_class</a></td><td class="jdocu_noborder">get object class</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_object_clock">SIM_object_clock</a></td><td class="jdocu_noborder">get object clock</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_object_data">SIM_object_data</a></td><td class="jdocu_noborder">get object-specific data pointer</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_object_descendant">SIM_object_descendant</a></td><td class="jdocu_noborder">return a descendant of the specified object</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_object_id">SIM_object_id</a></td><td class="jdocu_noborder">get object identifier</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_object_is_configured">SIM_object_is_configured</a></td><td class="jdocu_noborder">get/set configured status</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_object_is_processor">SIM_object_is_processor</a></td><td class="jdocu_noborder">test if object is a processor</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_object_iterator">SIM_object_iterator</a></td><td class="jdocu_noborder">start object iteration</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_object_iterator_for_class">SIM_object_iterator_for_class</a></td><td class="jdocu_noborder">start class instance iteration</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_object_iterator_for_interface">SIM_object_iterator_for_interface</a></td><td class="jdocu_noborder">start class instance iteration</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_object_iterator_next">SIM_object_iterator_next</a></td><td class="jdocu_noborder">get next object</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_object_name">SIM_object_name</a></td><td class="jdocu_noborder">get object name</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_object_parent">SIM_object_parent</a></td><td class="jdocu_noborder">get object parent</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_arm_mem_trans_from_generic">SIM_pci_mem_trans_from_generic</a></td><td class="jdocu_noborder">convert generic transaction to CPU specific</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_picosecond_clock">SIM_picosecond_clock</a></td><td class="jdocu_noborder">get object picosecond clock</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_poll_transaction">SIM_poll_transaction</a></td><td class="jdocu_noborder">check if a transaction has completed</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_port_object_parent">SIM_port_object_parent</a></td><td class="jdocu_noborder">get object parent</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_arm_mem_trans_from_generic">SIM_ppc_mem_trans_from_generic</a></td><td class="jdocu_noborder">convert generic transaction to CPU specific</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_write">SIM_printf</a></td><td class="jdocu_noborder">text output routines</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_printf_error">SIM_printf_error</a></td><td class="jdocu_noborder">print error message</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_printf_error">SIM_printf_error_vararg</a></td><td class="jdocu_noborder">print error message</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_write">SIM_printf_vararg</a></td><td class="jdocu_noborder">text output routines</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_printf_warning">SIM_printf_warning</a></td><td class="jdocu_noborder">print warning message</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_printf_warning">SIM_printf_warning_vararg</a></td><td class="jdocu_noborder">print warning message</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_process_work">SIM_process_pending_work</a></td><td class="jdocu_noborder">run the Simics main loop</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_process_work">SIM_process_work</a></td><td class="jdocu_noborder">run the Simics main loop</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_processor_privilege_level">SIM_processor_privilege_level</a></td><td class="jdocu_noborder">return the current privilege level for a processor</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_write">SIM_putchar</a></td><td class="jdocu_noborder">text output routines</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_write">SIM_puts</a></td><td class="jdocu_noborder">text output routines</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_quit">SIM_quit</a></td><td class="jdocu_noborder">quit Simics</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_drop_thread_domains">SIM_reacquire_thread_domains</a></td><td class="jdocu_noborder">temporarily release all held thread domains</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_read_byte">SIM_read_byte</a></td><td class="jdocu_noborder">read/write byte from a memory space</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_read_configuration">SIM_read_configuration</a></td><td class="jdocu_noborder">read configuration</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_read_phys_memory">SIM_read_phys_memory</a></td><td class="jdocu_noborder">read data from a physical address</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_read_phys_memory_tags">SIM_read_phys_memory_tags</a></td><td class="jdocu_noborder">access auxiliary bits in physical memory</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_realtime_event">SIM_realtime_event</a></td><td class="jdocu_noborder">schedule callback in host time</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_reconnect_transaction">SIM_reconnect_transaction</a></td><td class="jdocu_noborder">register that a deferred transaction has been restored</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_register_attribute">SIM_register_attribute</a></td><td class="jdocu_noborder">register attribute</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_register_attribute">SIM_register_attribute_with_user_data</a></td><td class="jdocu_noborder">register attribute</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_register_class">SIM_register_class</a></td><td class="jdocu_noborder">register class</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_register_class_alias">SIM_register_class_alias</a></td><td class="jdocu_noborder">register class alias</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_register_attribute">SIM_register_class_attribute</a></td><td class="jdocu_noborder">register attribute</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_register_attribute">SIM_register_class_attribute_with_user_data</a></td><td class="jdocu_noborder">register attribute</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_register_clock">SIM_register_clock</a></td><td class="jdocu_noborder">register mandatory interface and attributes for clock objects</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_register_compatible_interfaces">SIM_register_compatible_interfaces</a></td><td class="jdocu_noborder">register earlier versions of interface</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_register_context_handler">SIM_register_context_handler</a></td><td class="jdocu_noborder">register mandatory interface and attribute for context handler
   objects</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_register_copyright">SIM_register_copyright</a></td><td class="jdocu_noborder">register copyright information</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_register_event">SIM_register_event</a></td><td class="jdocu_noborder">register an event</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_register_interface">SIM_register_interface</a></td><td class="jdocu_noborder">register interface</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_register_notifier">SIM_register_notifier</a></td><td class="jdocu_noborder">register notifier</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_register_port">SIM_register_port</a></td><td class="jdocu_noborder">register port class</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_register_interface">SIM_register_port_interface</a></td><td class="jdocu_noborder">register interface</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_register_python_atom_type">SIM_register_python_atom_type</a></td><td class="jdocu_noborder">register an atom type which takes plain Python objects</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_register_simple_port">SIM_register_simple_port</a></td><td class="jdocu_noborder">register port</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_register_notifier">SIM_register_tracked_notifier</a></td><td class="jdocu_noborder">register notifier</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_register_typed_attribute">SIM_register_typed_attribute</a></td><td class="jdocu_noborder">register attribute</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_register_typed_attribute">SIM_register_typed_class_attribute</a></td><td class="jdocu_noborder">register attribute</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_register_work">SIM_register_work</a></td><td class="jdocu_noborder">register function to be called in Global Context</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_acquire_cell">SIM_release_cell</a></td><td class="jdocu_noborder">enter Cell Context</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_acquire_object">SIM_release_object</a></td><td class="jdocu_noborder">acquire thread domain</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_acquire_target">SIM_release_target</a></td><td class="jdocu_noborder">conditionally enter Cell Context</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_add_output_handler">SIM_remove_output_handler</a></td><td class="jdocu_noborder">add or remove output handler</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_replace_transaction">SIM_replace_transaction</a></td><td class="jdocu_noborder">replace transaction</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_require_object">SIM_require_object</a></td><td class="jdocu_noborder">make sure an object is fully configured</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_reset_processor">SIM_reset_processor</a></td><td class="jdocu_noborder">reset the processor</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_restore_snapshot">SIM_restore_snapshot</a></td><td class="jdocu_noborder">restore a snapshot of the configuration state</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_register_work">SIM_run_alone</a></td><td class="jdocu_noborder">register function to be called in Global Context</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_run_async_work">SIM_run_async_work</a></td><td class="jdocu_noborder">launch asynchronous work in a separate thread</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_run_command">SIM_run_command</a></td><td class="jdocu_noborder">evaluate a CLI command</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_run_command_file">SIM_run_command_file</a></td><td class="jdocu_noborder">read CLI commands from file</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_run_command_file">SIM_run_command_file_params</a></td><td class="jdocu_noborder">read CLI commands from file</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_run_in_thread">SIM_run_in_thread</a></td><td class="jdocu_noborder">run function in a separate thread</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_run_python">SIM_run_python</a></td><td class="jdocu_noborder">run a Python expression</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_run_unrestricted">SIM_run_unrestricted</a></td><td class="jdocu_noborder">run callback after current instruction</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_set_attribute">SIM_set_attribute</a></td><td class="jdocu_noborder">set attribute</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_set_attribute_default">SIM_set_attribute_default</a></td><td class="jdocu_noborder">set default value for an attribute in a child object</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_set_attribute">SIM_set_attribute_idx</a></td><td class="jdocu_noborder">set attribute</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_clear_augmentation_bit">SIM_set_augmentation_bit</a></td><td class="jdocu_noborder">convenience functions to work with augmented memory bits</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_set_class_attribute">SIM_set_class_attribute</a></td><td class="jdocu_noborder">set class attribute</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_set_class_attribute">SIM_set_class_attribute_idx</a></td><td class="jdocu_noborder">set class attribute</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_set_class_data">SIM_set_class_data</a></td><td class="jdocu_noborder">set class data</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_set_configuration">SIM_set_configuration</a></td><td class="jdocu_noborder">set configuration from data</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_set_frontend_context">SIM_set_frontend_context</a></td><td class="jdocu_noborder">register a stack context buffer for Simics to longjmp back to</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_log_level">SIM_set_log_level</a></td><td class="jdocu_noborder">set and get log level</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_set_mem_op_exception">SIM_set_mem_op_exception</a></td><td class="jdocu_noborder">get/set transaction exception</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_set_mem_op_initiator">SIM_set_mem_op_initiator</a></td><td class="jdocu_noborder">get/set transaction initiator</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_set_mem_op_inquiry">SIM_set_mem_op_inquiry</a></td><td class="jdocu_noborder">get/set transaction inquiry flag</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_set_mem_op_physical_address">SIM_set_mem_op_physical_address</a></td><td class="jdocu_noborder">get or set transaction address</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_set_mem_op_reissue">SIM_set_mem_op_reissue</a></td><td class="jdocu_noborder">request transaction reissue</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_set_mem_op_type">SIM_set_mem_op_type</a></td><td class="jdocu_noborder">set type of transaction</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_set_mem_op_user_data">SIM_set_mem_op_user_data</a></td><td class="jdocu_noborder">get/set transaction user data</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_c_set_mem_op_value_buf">SIM_set_mem_op_value_be</a></td><td class="jdocu_noborder">set value for a memory operation</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_c_set_mem_op_value_buf">SIM_set_mem_op_value_buf</a></td><td class="jdocu_noborder">set value for a memory operation</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_c_set_mem_op_value_buf">SIM_set_mem_op_value_cpu</a></td><td class="jdocu_noborder">set value for a memory operation</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_c_set_mem_op_value_buf">SIM_set_mem_op_value_le</a></td><td class="jdocu_noborder">set value for a memory operation</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_set_mem_op_physical_address">SIM_set_mem_op_virtual_address</a></td><td class="jdocu_noborder">get or set transaction address</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_object_is_configured">SIM_set_object_configured</a></td><td class="jdocu_noborder">get/set configured status</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_set_quiet">SIM_set_quiet</a></td><td class="jdocu_noborder">enable/disable quiet mode</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_set_transaction_bytes">SIM_set_transaction_bytes</a></td><td class="jdocu_noborder">set transaction data payload</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_set_transaction_bytes">SIM_set_transaction_bytes_constant</a></td><td class="jdocu_noborder">set transaction data payload</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_set_transaction_bytes">SIM_set_transaction_bytes_offs</a></td><td class="jdocu_noborder">set transaction data payload</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_set_transaction_bytes">SIM_set_transaction_value_be</a></td><td class="jdocu_noborder">set transaction data payload</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_set_transaction_bytes">SIM_set_transaction_value_le</a></td><td class="jdocu_noborder">set transaction data payload</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_set_verbose">SIM_set_verbose</a></td><td class="jdocu_noborder">enable/disable verbose mode</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_shallow_object_iterator">SIM_shallow_object_iterator</a></td><td class="jdocu_noborder">start object iteration</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_shutdown">SIM_shutdown</a></td><td class="jdocu_noborder">shutdown Simics</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_simics_is_running">SIM_simics_is_running</a></td><td class="jdocu_noborder">check if simulation is running</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_source_python">SIM_source_python</a></td><td class="jdocu_noborder">execute Python source file</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_source_python">SIM_source_python_in_module</a></td><td class="jdocu_noborder">execute Python source file</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_stall_cycle">SIM_stall</a></td><td class="jdocu_noborder">stall execution a specified number of cycles</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_stall_count">SIM_stall_count</a></td><td class="jdocu_noborder">get number of cycles a processor has been stalled</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_stall_cycle">SIM_stall_cycle</a></td><td class="jdocu_noborder">stall execution a specified number of cycles</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_stalled_until">SIM_stalled_until</a></td><td class="jdocu_noborder">query how many cycles that remains of stall</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_step_count">SIM_step_count</a></td><td class="jdocu_noborder">get step count</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_take_snapshot">SIM_take_snapshot</a></td><td class="jdocu_noborder">take snapshot of the current configuration</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_register_work">SIM_thread_safe_callback</a></td><td class="jdocu_noborder">register function to be called in Global Context</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_time">SIM_time</a></td><td class="jdocu_noborder">get current simulated time</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_transaction_flags">SIM_transaction_flags</a></td><td class="jdocu_noborder">return transaction type</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_transaction_initiator">SIM_transaction_initiator</a></td><td class="jdocu_noborder">return transaction initiator</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_transaction_is_deferrable">SIM_transaction_is_deferrable</a></td><td class="jdocu_noborder">check if a transaction can be deferred for later completion</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_transaction_flags">SIM_transaction_is_fetch</a></td><td class="jdocu_noborder">return transaction type</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_transaction_flags">SIM_transaction_is_inquiry</a></td><td class="jdocu_noborder">return transaction type</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_transaction_flags">SIM_transaction_is_read</a></td><td class="jdocu_noborder">return transaction type</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_transaction_flags">SIM_transaction_is_write</a></td><td class="jdocu_noborder">return transaction type</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_transaction_size">SIM_transaction_size</a></td><td class="jdocu_noborder">return transaction size</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_transaction_wait">SIM_transaction_wait</a></td><td class="jdocu_noborder">wait for transaction completion</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_translation_changed">SIM_translation_changed</a></td><td class="jdocu_noborder">ensure that old translations are not used</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_trigger_global_message">SIM_trigger_global_message</a></td><td class="jdocu_noborder">queue up a global message</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_version">SIM_version</a></td><td class="jdocu_noborder">get Simics version and license/copyright information</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_version">SIM_version_base</a></td><td class="jdocu_noborder">get Simics version and license/copyright information</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_version">SIM_version_major</a></td><td class="jdocu_noborder">get Simics version and license/copyright information</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_version">SIM_vmxmon_version</a></td><td class="jdocu_noborder">get Simics version and license/copyright information</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_write">SIM_write</a></td><td class="jdocu_noborder">text output routines</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_read_byte">SIM_write_byte</a></td><td class="jdocu_noborder">read/write byte from a memory space</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_write_configuration_to_file">SIM_write_configuration_to_file</a></td><td class="jdocu_noborder">write configuration</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_write_persistent_state">SIM_write_persistent_state</a></td><td class="jdocu_noborder">save persistent state</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_write_phys_memory">SIM_write_phys_memory</a></td><td class="jdocu_noborder">write data to a physical address</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_read_phys_memory_tags">SIM_write_phys_memory_tags</a></td><td class="jdocu_noborder">access auxiliary bits in physical memory</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_SIM_arm_mem_trans_from_generic">SIM_x86_mem_trans_from_generic</a></td><td class="jdocu_noborder">convert generic transaction to CPU specific</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simulator-api-functions.html:__jdocu_seealso_SIM_yield_thread_domains">SIM_yield_thread_domains</a></td><td class="jdocu_noborder">yield held thread domains</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simics-api-functions.html:__jdocu_seealso_VT_check_async_events">VT_check_async_events</a></td><td class="jdocu_noborder">check for asynchronous events</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simics-api-functions.html:__jdocu_seealso_VT_clock_frequency_about_to_change">VT_clock_frequency_about_to_change</a></td><td class="jdocu_noborder">inform before clock frequency change</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simics-api-functions.html:__jdocu_seealso_VT_clock_frequency_change">VT_clock_frequency_change</a></td><td class="jdocu_noborder">inform after clock frequency change</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simics-api-functions.html:__jdocu_seealso_VT_new_code_block">VT_new_code_block</a></td><td class="jdocu_noborder">inform platform of new code block</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simics-api-functions.html:__jdocu_seealso_VT_set_object_clock">VT_set_object_clock</a></td><td class="jdocu_noborder">set clock association for object</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#simics-api-functions.html:__jdocu_seealso_VT_stop_event_processing">VT_stop_event_processing</a></td><td class="jdocu_noborder">stop event processing</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#obsolete-device-api-types-and-functions.html:__jdocu_seealso_dbuffer_append">dbuffer_append</a></td><td class="jdocu_noborder">Add data to a dbuffer</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#obsolete-device-api-types-and-functions.html:__jdocu_seealso_dbuffer_append_external_data">dbuffer_append_external_data</a></td><td class="jdocu_noborder">Add static data</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#obsolete-device-api-types-and-functions.html:__jdocu_seealso_dbuffer_append_value">dbuffer_append_value</a></td><td class="jdocu_noborder">Add data with uniform content</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#obsolete-device-api-types-and-functions.html:__jdocu_seealso_dbuffer_clone">dbuffer_clone</a></td><td class="jdocu_noborder">Make a full copy of another buffer</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#obsolete-device-api-types-and-functions.html:__jdocu_seealso_dbuffer_copy_append">dbuffer_copy_append</a></td><td class="jdocu_noborder">Copy data from a dbuffer</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#obsolete-device-api-types-and-functions.html:__jdocu_seealso_dbuffer_copy_append">dbuffer_copy_prepend</a></td><td class="jdocu_noborder">Copy data from a dbuffer</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#obsolete-device-api-types-and-functions.html:__jdocu_seealso_dbuffer_free">dbuffer_free</a></td><td class="jdocu_noborder">Release a dbuffer</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#obsolete-device-api-types-and-functions.html:__jdocu_seealso_dbuffer_append">dbuffer_insert</a></td><td class="jdocu_noborder">Add data to a dbuffer</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#obsolete-device-api-types-and-functions.html:__jdocu_seealso_dbuffer_len">dbuffer_len</a></td><td class="jdocu_noborder">Get the size of a dbuffer</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#obsolete-device-api-types-and-functions.html:__jdocu_seealso_dbuffer_append">dbuffer_prepend</a></td><td class="jdocu_noborder">Add data to a dbuffer</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#obsolete-device-api-types-and-functions.html:__jdocu_seealso_dbuffer_append_external_data">dbuffer_prepend_external_data</a></td><td class="jdocu_noborder">Add static data</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#obsolete-device-api-types-and-functions.html:__jdocu_seealso_dbuffer_append_value">dbuffer_prepend_value</a></td><td class="jdocu_noborder">Add data with uniform content</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#obsolete-device-api-types-and-functions.html:__jdocu_seealso_dbuffer_read">dbuffer_read</a></td><td class="jdocu_noborder">Extract data for reading</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#obsolete-device-api-types-and-functions.html:__jdocu_seealso_dbuffer_read">dbuffer_read_all</a></td><td class="jdocu_noborder">Extract data for reading</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#obsolete-device-api-types-and-functions.html:__jdocu_seealso_dbuffer_read">dbuffer_read_some</a></td><td class="jdocu_noborder">Extract data for reading</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#obsolete-device-api-types-and-functions.html:__jdocu_seealso_dbuffer_remove">dbuffer_remove</a></td><td class="jdocu_noborder">Remove data from a dbuffer</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#obsolete-device-api-types-and-functions.html:__jdocu_seealso_dbuffer_remove">dbuffer_remove_head</a></td><td class="jdocu_noborder">Remove data from a dbuffer</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#obsolete-device-api-types-and-functions.html:__jdocu_seealso_dbuffer_remove">dbuffer_remove_tail</a></td><td class="jdocu_noborder">Remove data from a dbuffer</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#obsolete-device-api-types-and-functions.html:__jdocu_seealso_dbuffer_replace">dbuffer_replace</a></td><td class="jdocu_noborder">Replace data</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#obsolete-device-api-types-and-functions.html:__jdocu_seealso_dbuffer_replace">dbuffer_replace_all</a></td><td class="jdocu_noborder">Replace data</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#obsolete-device-api-types-and-functions.html:__jdocu_seealso_dbuffer_replace">dbuffer_replace_some</a></td><td class="jdocu_noborder">Replace data</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#obsolete-device-api-types-and-functions.html:__jdocu_seealso_dbuffer_split">dbuffer_split</a></td><td class="jdocu_noborder">Split a dbuffer</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#obsolete-device-api-types-and-functions.html:__jdocu_seealso_dbuffer_update">dbuffer_update</a></td><td class="jdocu_noborder">Extract data for updating</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#obsolete-device-api-types-and-functions.html:__jdocu_seealso_dbuffer_update">dbuffer_update_all</a></td><td class="jdocu_noborder">Extract data for updating</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#obsolete-device-api-types-and-functions.html:__jdocu_seealso_dbuffer_update">dbuffer_update_some</a></td><td class="jdocu_noborder">Extract data for updating</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_frags_add">frags_add</a></td><td class="jdocu_noborder">add data to a <code>frags_t</code></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_frags_add_from_frags">frags_add_from_frags</a></td><td class="jdocu_noborder">append an existing <code>frags_t</code> to another</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_frags_extract">frags_extract</a></td><td class="jdocu_noborder">extract the contents of a <code>frags_t</code></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_frags_extract_8">frags_extract_8</a></td><td class="jdocu_noborder">extract a value</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_frags_extract_alloc">frags_extract_alloc</a></td><td class="jdocu_noborder">return a copy of the contents of a <code>frags_t</code></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_frags_extract_8">frags_extract_be16</a></td><td class="jdocu_noborder">extract a value</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_frags_extract_8">frags_extract_be32</a></td><td class="jdocu_noborder">extract a value</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_frags_extract_8">frags_extract_be64</a></td><td class="jdocu_noborder">extract a value</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_frags_extract_8">frags_extract_le16</a></td><td class="jdocu_noborder">extract a value</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_frags_extract_8">frags_extract_le32</a></td><td class="jdocu_noborder">extract a value</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_frags_extract_8">frags_extract_le64</a></td><td class="jdocu_noborder">extract a value</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_frags_extract_slice">frags_extract_slice</a></td><td class="jdocu_noborder">extract a slice of a <code>frags_t</code></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_frags_extract_slice_alloc">frags_extract_slice_alloc</a></td><td class="jdocu_noborder">return a partial copy of the contents of a
     <code>frags_t</code></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_frags_init">frags_init</a></td><td class="jdocu_noborder">initialize a <code>frags_t</code></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_frags_init_add">frags_init_add</a></td><td class="jdocu_noborder">initialize a <code>frags_t</code> with an initial value</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_frags_init_add_from_frags">frags_init_add_from_frags</a></td><td class="jdocu_noborder">initialize a <code>frags_t</code> from another</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_frags_it">frags_it</a></td><td class="jdocu_noborder">return an iterator</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_frags_it_data">frags_it_data</a></td><td class="jdocu_noborder">return the data of the current fragment</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_frags_it_end">frags_it_end</a></td><td class="jdocu_noborder">return whether an iterator is finished</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_frags_it_len">frags_it_len</a></td><td class="jdocu_noborder">return the length of the current fragment</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_frags_it_next">frags_it_next</a></td><td class="jdocu_noborder">return the next fragment's iterator</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_frags_len">frags_len</a></td><td class="jdocu_noborder">return the total data length</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_frags_prefix">frags_prefix</a></td><td class="jdocu_noborder">prefix a <code>frags_t</code> with a header</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#device-api-functions.html:__jdocu_seealso_frags_suffix">frags_suffix</a></td><td class="jdocu_noborder">append a suffix to a <code>frags_t</code></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#obsolete-device-api-types-and-functions.html:__jdocu_seealso_new_dbuffer">new_dbuffer</a></td><td class="jdocu_noborder">Create a new dbuffer</td></tr>
</tbody></table></p></section><section class="page" id="haps-chapter.html"><h1 class="jdocu"><a id="haps-chapter.html:haps-chapter">12 Haps</a></h1>
<p>

</p><p>
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
</p><p>
</p></section><section class="page" id="__rm_hap_arinc429_word.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_arinc429_word.html:__rm_hap_Arinc429_Word">Arinc429_Word</a></h1>
<p>

<a id="__rm_hap_arinc429_word.html:Arinc429_Word"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This hap is triggered on every word sent on a arinc429_bus object. In the hap handler, the last_word attribute can be read or modified. Setting it to -1 will drop the packet.</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj);</pre><p>
</p></dd>
</dl><p></p></section><section class="page" id="__rm_hap_cli_command_added.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_cli_command_added.html:__rm_hap_CLI_Command_Added">CLI_Command_Added</a></h1>
<p>

<a id="__rm_hap_cli_command_added.html:CLI_Command_Added"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered when a CLI command is defined.</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj, char *command_name);</pre><p>
</p></dd>
</dl><p></p></section><section class="page" id="__rm_hap_component_change.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_component_change.html:__rm_hap_Component_Change">Component_Change</a></h1>
<p>

<a id="__rm_hap_component_change.html:Component_Change"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Internal: Similar to Component_Hierarchy_Change but also triggered for components that are not part of any complete hierarchy including non-instantiated components.</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj);</pre><p>
</p></dd>
</dl><p></p></section><section class="page" id="__rm_hap_component_hierarchy_change.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_component_hierarchy_change.html:__rm_hap_Component_Hierarchy_Change">Component_Hierarchy_Change</a></h1>
<p>

<a id="__rm_hap_component_hierarchy_change.html:Component_Hierarchy_Change"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Internal: Triggered when an instantiated component hierarchy is modified. The hap is associated with the top-level component of the modified hierarchy.</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj, 
         conf_object_t *top_level_component);</pre><p>
</p></dd>
</dl><p></p></section><section class="page" id="__rm_hap_console_break_string.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_console_break_string.html:__rm_hap_Console_Break_String">Console_Break_String</a></h1>
<p>

<a id="__rm_hap_console_break_string.html:Console_Break_String"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered when the output matches a string set to break on. The <i>break_id</i> is the number associated with the string breakpoint.</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj, char *break_string);</pre><p>
</p></dd>
<dt class="jdocu_descitem"><b>Index</b></dt><dd class="jdocu_descitem">break_id</dd>
</dl><p></p></section><section class="page" id="__rm_hap_core_address_not_mapped.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_core_address_not_mapped.html:__rm_hap_Core_Address_Not_Mapped">Core_Address_Not_Mapped</a></h1>
<p>

<a id="__rm_hap_core_address_not_mapped.html:Core_Address_Not_Mapped"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered when an access to a memory-space has no target and the access does not match any entry in the <i>outside_memory_whitelist</i> CPU attribute. The default handler for this hap will signal an error and stop the simulation.</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj, 
         int64 physical_address, int64 access_type, 
         int64 size);</pre><p>
</p></dd>
</dl><p></p></section><section class="page" id="__rm_hap_core_asynchronous_trap.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_core_asynchronous_trap.html:__rm_hap_Core_Asynchronous_Trap">Core_Asynchronous_Trap</a></h1>
<p>

<a id="__rm_hap_core_asynchronous_trap.html:Core_Asynchronous_Trap"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">SPARC: Triggered when an asynchronous trap occurs. This is either an external interrupt <i>trap number</i> == 0x60 or interrupt level n <i>trap number</i> 0x41 - 0x4F, or an asynchronous trap initiated by the user calling trap_cpu in the sparc-interrupt interface. The Core_External_Interrupt can also be used to catch interrupts, the difference is that Core_Asynchronous_Trap is only triggered if interrupts are enabled.</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj, int64 trap_number);</pre><p>
</p></dd>
<dt class="jdocu_descitem"><b>Index</b></dt><dd class="jdocu_descitem">trap_number</dd>
</dl><p></p></section><section class="page" id="__rm_hap_core_at_exit.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_core_at_exit.html:__rm_hap_Core_At_Exit">Core_At_Exit</a></h1>
<p>

<a id="__rm_hap_core_at_exit.html:Core_At_Exit"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered, typically by <b><i>SIM_quit</i></b>, when Simics exits. The Simics API is not allowed to be used in the hap callbacks (see the Core_Clean_At_Exit hap description if access to the Simics API is needed).</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj);</pre><p>
</p></dd>
</dl><p></p></section><section class="page" id="__rm_hap_core_breakpoint_change.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_core_breakpoint_change.html:__rm_hap_Core_Breakpoint_Change">Core_Breakpoint_Change</a></h1>
<p>

<a id="__rm_hap_core_breakpoint_change.html:Core_Breakpoint_Change"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered on an object when breakpoints attached to that object are inserted, deleted or changed in any way.</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj);</pre><p>
</p></dd>
</dl><p></p></section><section class="page" id="__rm_hap_core_breakpoint_memop.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_core_breakpoint_memop.html:__rm_hap_Core_Breakpoint_Memop">Core_Breakpoint_Memop</a></h1>
<p>

<a id="__rm_hap_core_breakpoint_memop.html:Core_Breakpoint_Memop"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered when a breakpoint is triggered. <i>breakpoint_number</i> is the breakpoint number (as returned by <b><i>SIM_breakpoint</i></b>). If there are multiple breakpoints on an instruction then all installed haps will be run before control is transferred to the frontend (when applicable). The supplied <i>memop</i> can be used to figure out details about the transaction.</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj, 
         int64 breakpoint_number, 
         generic_transaction_t *memop);</pre><p>
</p></dd>
<dt class="jdocu_descitem"><b>Index</b></dt><dd class="jdocu_descitem">breakpoint_number</dd>
</dl><p></p></section><section class="page" id="__rm_hap_core_clean_at_exit.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_core_clean_at_exit.html:__rm_hap_Core_Clean_At_Exit">Core_Clean_At_Exit</a></h1>
<p>

<a id="__rm_hap_core_clean_at_exit.html:Core_Clean_At_Exit"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered, typically by <b><i>SIM_quit</i></b>, if Simics exits cleanly, i.e. in Global Context. The Simics API is available. Cleanup code should typically run in the Core_At_Exit hap callbacks instead if possible.</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj);</pre><p>
</p></dd>
</dl><p></p></section><section class="page" id="__rm_hap_core_conf_class_register.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_core_conf_class_register.html:__rm_hap_Core_Conf_Class_Register">Core_Conf_Class_Register</a></h1>
<p>

<a id="__rm_hap_core_conf_class_register.html:Core_Conf_Class_Register"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered when a new configuration class has been registered. Called in Global Context.</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj, char *class_name);</pre><p>
</p></dd>
</dl><p></p></section><section class="page" id="__rm_hap_core_conf_class_unregister.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_core_conf_class_unregister.html:__rm_hap_Core_Conf_Class_Unregister">Core_Conf_Class_Unregister</a></h1>
<p>

<a id="__rm_hap_core_conf_class_unregister.html:Core_Conf_Class_Unregister"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered when a configuration class has been unregistered. Called in Global Context.</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj, char *class_name);</pre><p>
</p></dd>
</dl><p></p></section><section class="page" id="__rm_hap_core_conf_clock_change_cell.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_core_conf_clock_change_cell.html:__rm_hap_Core_Conf_Clock_Change_Cell">Core_Conf_Clock_Change_Cell</a></h1>
<p>

<a id="__rm_hap_core_conf_clock_change_cell.html:Core_Conf_Clock_Change_Cell"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered when a clock object changes cell</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj, 
         conf_object_t *old_cell, conf_object_t *new_cell);</pre><p>
</p></dd>
</dl><p></p></section><section class="page" id="__rm_hap_core_conf_object_change_clock.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_core_conf_object_change_clock.html:__rm_hap_Core_Conf_Object_Change_Clock">Core_Conf_Object_Change_Clock</a></h1>
<p>

<a id="__rm_hap_core_conf_object_change_clock.html:Core_Conf_Object_Change_Clock"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered when an object's reference clock is changed</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj, 
         conf_object_t *old_clock, 
         conf_object_t *new_clock);</pre><p>
</p></dd>
</dl><p></p></section><section class="page" id="__rm_hap_core_conf_object_create.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_core_conf_object_create.html:__rm_hap_Core_Conf_Object_Create">Core_Conf_Object_Create</a></h1>
<p>

<a id="__rm_hap_core_conf_object_create.html:Core_Conf_Object_Create"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered when a new configuration object's <b><i>init_object</i></b> method returns successfully, but before the object's attributes are set and before the object's <b><i>finalize_instance</i></b> method is called. Since the object is not fully created hap callbacks must not access any of the object's attributes or call any methods on the object's interfaces. Callbacks are called in Global Context.</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj);</pre><p>
</p></dd>
</dl><p></p></section><section class="page" id="__rm_hap_core_conf_object_created.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_core_conf_object_created.html:__rm_hap_Core_Conf_Object_Created">Core_Conf_Object_Created</a></h1>
<p>

<a id="__rm_hap_core_conf_object_created.html:Core_Conf_Object_Created"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered when a configuration object has been created and finalized. This hap will always be followed by a Core_Conf_Objects_Created hap, but this hap can be triggered for more than one object before the Core_Conf_Objects_Created hap.</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj);</pre><p>
</p></dd>
</dl><p></p></section><section class="page" id="__rm_hap_core_conf_object_delete.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_core_conf_object_delete.html:__rm_hap_Core_Conf_Object_Delete">Core_Conf_Object_Delete</a></h1>
<p>

<a id="__rm_hap_core_conf_object_delete.html:Core_Conf_Object_Delete"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered after a configuration object has been deleted. Called in Global Context.</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj, char *object_name);</pre><p>
</p></dd>
</dl><p></p></section><section class="page" id="__rm_hap_core_conf_object_pre_delete.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_core_conf_object_pre_delete.html:__rm_hap_Core_Conf_Object_Pre_Delete">Core_Conf_Object_Pre_Delete</a></h1>
<p>

<a id="__rm_hap_core_conf_object_pre_delete.html:Core_Conf_Object_Pre_Delete"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered just before a configuration object is deleted. Called in Global Context.</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj);</pre><p>
</p></dd>
</dl><p></p></section><section class="page" id="__rm_hap_core_conf_object_rename.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_core_conf_object_rename.html:__rm_hap_Core_Conf_Object_Rename">Core_Conf_Object_Rename</a></h1>
<p>

<a id="__rm_hap_core_conf_object_rename.html:Core_Conf_Object_Rename"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered after an object's name has changed. Called in Global Context.</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj, char *old_name);</pre><p>
</p></dd>
</dl><p></p></section><section class="page" id="__rm_hap_core_conf_objects_created.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_core_conf_objects_created.html:__rm_hap_Core_Conf_Objects_Created">Core_Conf_Objects_Created</a></h1>
<p>

<a id="__rm_hap_core_conf_objects_created.html:Core_Conf_Objects_Created"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered if and only if at least one Core_Conf_Object_Created hap has been triggered.</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj);</pre><p>
</p></dd>
</dl><p></p></section><section class="page" id="__rm_hap_core_conf_objects_deleted.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_core_conf_objects_deleted.html:__rm_hap_Core_Conf_Objects_Deleted">Core_Conf_Objects_Deleted</a></h1>
<p>

<a id="__rm_hap_core_conf_objects_deleted.html:Core_Conf_Objects_Deleted"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered when one or more objects have been deleted from the configuration after the Core_Conf_Object_Delete hap has been triggered for all of the objects. Called in Global Context.</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj);</pre><p>
</p></dd>
</dl><p></p></section><section class="page" id="__rm_hap_core_configuration_loaded.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_core_configuration_loaded.html:__rm_hap_Core_Configuration_Loaded">Core_Configuration_Loaded</a></h1>
<p>

<a id="__rm_hap_core_configuration_loaded.html:Core_Configuration_Loaded"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered when a configuration has been loaded. This hap can be triggered several times during a session since it is possible to append a new configuration to the existing one. In most cases it is better to use the <b><i>finalize_instance</i></b> function in the <code>class_data_t</code> instead. That function is called when the object creation is finished. Callbacks are called in Global Context.</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj);</pre><p>
</p></dd>
</dl><p></p></section><section class="page" id="__rm_hap_core_context_activate.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_core_context_activate.html:__rm_hap_Core_Context_Activate">Core_Context_Activate</a></h1>
<p>

<a id="__rm_hap_core_context_activate.html:Core_Context_Activate"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered when this context replaces another context as the current context of a processor.</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj, 
         conf_object_t *other_ctx, conf_object_t *cpu);</pre><p>
</p></dd>
</dl><p></p></section><section class="page" id="__rm_hap_core_context_change.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_core_context_change.html:__rm_hap_Core_Context_Change">Core_Context_Change</a></h1>
<p>

<a id="__rm_hap_core_context_change.html:Core_Context_Change"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered when the context is set to the current context for a processor.</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj, conf_object_t *cpu);</pre><p>
</p></dd>
</dl><p></p></section><section class="page" id="__rm_hap_core_context_deactivate.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_core_context_deactivate.html:__rm_hap_Core_Context_Deactivate">Core_Context_Deactivate</a></h1>
<p>

<a id="__rm_hap_core_context_deactivate.html:Core_Context_Deactivate"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered when another context replaces this context as the current context of a processor.</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj, 
         conf_object_t *other_ctx, conf_object_t *cpu);</pre><p>
</p></dd>
</dl><p></p></section><section class="page" id="__rm_hap_core_context_updated.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_core_context_updated.html:__rm_hap_Core_Context_Updated">Core_Context_Updated</a></h1>
<p>

<a id="__rm_hap_core_context_updated.html:Core_Context_Updated"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered when the context is updated in some way.</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj);</pre><p>
</p></dd>
</dl><p></p></section><section class="page" id="__rm_hap_core_continuation.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_core_continuation.html:__rm_hap_Core_Continuation">Core_Continuation</a></h1>
<p>

<a id="__rm_hap_core_continuation.html:Core_Continuation"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered at the (re)start of the simulation. The <code>Core_Simulation_Stopped</code> hap is called when the simulation is stopped. Callbacks are called in Global Context.</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj);</pre><p>
</p></dd>
</dl><p></p></section><section class="page" id="__rm_hap_core_control_register_read.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_core_control_register_read.html:__rm_hap_Core_Control_Register_Read">Core_Control_Register_Read</a></h1>
<p>

<a id="__rm_hap_core_control_register_read.html:Core_Control_Register_Read"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered when a control register is read. The hap is called before the read is performed; thus no registers have been modified.
<p>
Note that if the callback routine breaks to the frontend by raising an exception, the instruction will be replayed possibly causing repeated memory operations.
</p><p>
For x86 processors, this hap is triggered when a control register is read using a <code>mov</code> or <code>smsw</code> instruction (i.e. only explicit reads). Also the hap is triggered when MSRs are read with <code>rdmsr</code>, <code>rdtsc</code> or <code>rdtscp</code> instructions.
</p><p>
For PowerPC processors, this hap is triggered by the <code>mfspr</code>, <code>mfmsr</code> <code>mfsr</code> and <code>mfsrin</code> instructions (i.e. only explicit reads).</p></dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj, int64 register_number);</pre><p>
</p></dd>
<dt class="jdocu_descitem"><b>Index</b></dt><dd class="jdocu_descitem">register_number</dd>
</dl><p></p></section><section class="page" id="__rm_hap_core_control_register_write.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_core_control_register_write.html:__rm_hap_Core_Control_Register_Write">Core_Control_Register_Write</a></h1>
<p>

<a id="__rm_hap_core_control_register_write.html:Core_Control_Register_Write"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered when a control register is written. Note that <i>value</i> is not (necessarily) the final contents in the register. When the callback is called, the processor register has not yet been updated with the new value.
<p>
If the callback routine breaks to the frontend by raising an exception, the instruction will be replayed possibly causing repeated memory operations.
</p><p>
For x86 processors, this hap is triggered by <code>clts</code>, <code>lmsw</code>, and <code>mov</code>. Also the hap is triggered when MSRs are written with <code>wrmsr</code> instruction. Page fault updates of CR2 should be caught with the Core_Exception hap.
</p><p>
For PowerPC processors, this hap is triggered by the <code>mtspr</code>, <code>mtmsr</code>, <code>mtsr</code> and <code>mtsrin</code> instructions (i.e. only explicit writes).</p></dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj, int64 register_number, 
         int64 value);</pre><p>
</p></dd>
<dt class="jdocu_descitem"><b>Index</b></dt><dd class="jdocu_descitem">register_number</dd>
</dl><p></p></section><section class="page" id="__rm_hap_core_device_access_memop.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_core_device_access_memop.html:__rm_hap_Core_Device_Access_Memop">Core_Device_Access_Memop</a></h1>
<p>

<a id="__rm_hap_core_device_access_memop.html:Core_Device_Access_Memop"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered when a device access is performed.</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj, 
         generic_transaction_t *memop);</pre><p>
</p></dd>
</dl><p></p></section><section class="page" id="__rm_hap_core_dstc_flush_counter.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_core_dstc_flush_counter.html:__rm_hap_Core_DSTC_Flush_Counter">Core_DSTC_Flush_Counter</a></h1>
<p>

<a id="__rm_hap_core_dstc_flush_counter.html:Core_DSTC_Flush_Counter"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered when the DSTC flushes a line's hit counter. It reports how many hits the STC recorded since the line was inserted.</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj, int64 type, 
         int64 virtual_address, int64 physical_address, 
         int64 counter);</pre><p>
</p></dd>
</dl><p></p></section><section class="page" id="__rm_hap_core_exception.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_core_exception.html:__rm_hap_Core_Exception">Core_Exception</a></h1>
<p>

<a id="__rm_hap_core_exception.html:Core_Exception"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered when an exception/trap is taken by a processor. The hap occurs before side-effects, control transfers included, have taken place.
<p>
Interrupting the simulation by calling <b><i>SIM_break_simulation</i></b> inside the hap will cause the simulation to stop right before the exception (and the trapping instruction, if any). The simulation state will then be as it was prior to the execution of the instruction or exception. Continuing the simulation will then re-run the exception, this time without calling hap functions.
</p><p>
Depending on the processor model, some state may actually have changed in an idempotent way when the hap occurs, but this should not be relied upon.
</p><p>
The exact meaning of the exception number depends on the simulated processor architecture. The <code>exception</code> interface can be used to translate the number to an exception name.</p></dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj, 
         int64 exception_number);</pre><p>
</p></dd>
<dt class="jdocu_descitem"><b>Index</b></dt><dd class="jdocu_descitem">exception_number</dd>
</dl><p></p></section><section class="page" id="__rm_hap_core_exception_return.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_core_exception_return.html:__rm_hap_Core_Exception_Return">Core_Exception_Return</a></h1>
<p>

<a id="__rm_hap_core_exception_return.html:Core_Exception_Return"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered when an exception/trap handler finishes execution. The hap is triggered before any processor state has changed.
<p>
The following instructions trigger this hap (by processor class):
</p><p>
MIPS: <code>eret</code> and <code>deret</code>
</p><p>
PowerPC (32): <code>rfi</code> and <code>rfci</code>
</p><p>
PowerPC (64): <code>rfi</code>, <code>rfid</code> and <code>hrfid</code>
</p><p>
SH: <code>rte</code>
</p><p>
SPARC: <code>done</code> and <code>retry</code>
</p><p>
x86/x86-64: The <code>iret</code> family.
</p><p>
The <i>exception_number</i> parameter is only valid for SPARC processors.</p></dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj, 
         int64 exception_number);</pre><p>
</p></dd>
<dt class="jdocu_descitem"><b>Index</b></dt><dd class="jdocu_descitem">exception_number</dd>
</dl><p></p></section><section class="page" id="__rm_hap_core_external_interrupt.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_core_external_interrupt.html:__rm_hap_Core_External_Interrupt">Core_External_Interrupt</a></h1>
<p>

<a id="__rm_hap_core_external_interrupt.html:Core_External_Interrupt"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">(SPARC only) Triggered when a processor receives an external interrupt. The trigger object is the receiving cpu, and <i>source_mid</i> is the mid of the sending cpu/device. The hap will be triggered even if interrupts are disabled, but not if the interrupt logic is busy.</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj, int64 source_mid);</pre><p>
</p></dd>
<dt class="jdocu_descitem"><b>Index</b></dt><dd class="jdocu_descitem">source_mid</dd>
</dl><p></p></section><section class="page" id="__rm_hap_core_frequency_changed.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_core_frequency_changed.html:__rm_hap_Core_Frequency_Changed">Core_Frequency_Changed</a></h1>
<p>

<a id="__rm_hap_core_frequency_changed.html:Core_Frequency_Changed"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered when the frequency of a cycle queue has changed. Parameters are the old and new frequencies in Hz.</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj, int64 old_freq, 
         int64 new_freq);</pre><p>
</p></dd>
</dl><p></p></section><section class="page" id="__rm_hap_core_hap_callback_installed.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_core_hap_callback_installed.html:__rm_hap_Core_Hap_Callback_Installed">Core_Hap_Callback_Installed</a></h1>
<p>

<a id="__rm_hap_core_hap_callback_installed.html:Core_Hap_Callback_Installed"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered before a callback is installed. The callback called by this hap is not allowed to install any hap callbacks.</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj, int64 hap_number, 
         int64 range_low, int64 range_high);</pre><p>
</p></dd>
<dt class="jdocu_descitem"><b>Index</b></dt><dd class="jdocu_descitem">hap_number</dd>
</dl><p></p></section><section class="page" id="__rm_hap_core_hap_callback_removed.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_core_hap_callback_removed.html:__rm_hap_Core_Hap_Callback_Removed">Core_Hap_Callback_Removed</a></h1>
<p>

<a id="__rm_hap_core_hap_callback_removed.html:Core_Hap_Callback_Removed"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered after a callback has been unregistered. The callback called by this hap is not allowed to remove any hap callbacks.</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj, int64 hap_number, 
         int64 range_low, int64 range_high);</pre><p>
</p></dd>
<dt class="jdocu_descitem"><b>Index</b></dt><dd class="jdocu_descitem">hap_number</dd>
</dl><p></p></section><section class="page" id="__rm_hap_core_hap_type_added.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_core_hap_type_added.html:__rm_hap_Core_Hap_Type_Added">Core_Hap_Type_Added</a></h1>
<p>

<a id="__rm_hap_core_hap_type_added.html:Core_Hap_Type_Added"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered when a new hap type is added to the simulator. The hap is not triggered for the initial set of core haps. Callbacks called in Global Context.</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj, char *hap_name);</pre><p>
</p></dd>
</dl><p></p></section><section class="page" id="__rm_hap_core_image_activity.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_core_image_activity.html:__rm_hap_Core_Image_Activity">Core_Image_Activity</a></h1>
<p>

<a id="__rm_hap_core_image_activity.html:Core_Image_Activity"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered on I/O activity in an image object.</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj, int type, int onoff);</pre><p>
</p></dd>
</dl><p></p></section><section class="page" id="__rm_hap_core_log_groups_change.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_core_log_groups_change.html:__rm_hap_Core_Log_Groups_Change">Core_Log_Groups_Change</a></h1>
<p>

<a id="__rm_hap_core_log_groups_change.html:Core_Log_Groups_Change"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered when the active log groups of an object changes</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj, int log_group_mask);</pre><p>
</p></dd>
</dl><p></p></section><section class="page" id="__rm_hap_core_log_level_change.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_core_log_level_change.html:__rm_hap_Core_Log_Level_Change">Core_Log_Level_Change</a></h1>
<p>

<a id="__rm_hap_core_log_level_change.html:Core_Log_Level_Change"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered when the log level of an object changes</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj, int new_log_level);</pre><p>
</p></dd>
</dl><p></p></section><section class="page" id="__rm_hap_core_log_message.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_core_log_message.html:__rm_hap_Core_Log_Message">Core_Log_Message</a></h1>
<p>

<a id="__rm_hap_core_log_message.html:Core_Log_Message"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered when a log message is registered that is supposed to be logged, i.e. with matching type and group(s) and level.</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj, int type, 
         char *message);</pre><p>
</p></dd>
<dt class="jdocu_descitem"><b>Index</b></dt><dd class="jdocu_descitem">log type</dd>
</dl><p></p></section><section class="page" id="__rm_hap_core_log_message_always.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_core_log_message_always.html:__rm_hap_Core_Log_Message_Always">Core_Log_Message_Always</a></h1>
<p>

<a id="__rm_hap_core_log_message_always.html:Core_Log_Message_Always"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered always when a log message is registered regardless of the current log level</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj, int type, 
         char *message, int level, int64 group);</pre><p>
</p></dd>
</dl><p></p></section><section class="page" id="__rm_hap_core_log_message_extended.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_core_log_message_extended.html:__rm_hap_Core_Log_Message_Extended">Core_Log_Message_Extended</a></h1>
<p>

<a id="__rm_hap_core_log_message_extended.html:Core_Log_Message_Extended"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered when a log message is registered that is supposed to be logged according to the log level.</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj, int type, 
         char *message, int level, int64 group);</pre><p>
</p></dd>
</dl><p></p></section><section class="page" id="__rm_hap_core_log_message_filtered.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_core_log_message_filtered.html:__rm_hap_Core_Log_Message_Filtered">Core_Log_Message_Filtered</a></h1>
<p>

<a id="__rm_hap_core_log_message_filtered.html:Core_Log_Message_Filtered"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered when a log message is registered that is supposed to be logged, i.e. with matching type and group(s) and level.</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj, int type, 
         char *message, int level, int64 group);</pre><p>
</p></dd>
</dl><p></p></section><section class="page" id="__rm_hap_core_magic_instruction.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_core_magic_instruction.html:__rm_hap_Core_Magic_Instruction">Core_Magic_Instruction</a></h1>
<p>

<a id="__rm_hap_core_magic_instruction.html:Core_Magic_Instruction"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered when Simics executes a magic instruction. The parameter is taken from the instruction and is architecture-dependent.</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj, int64 parameter);</pre><p>
</p></dd>
<dt class="jdocu_descitem"><b>Index</b></dt><dd class="jdocu_descitem">parameter</dd>
</dl><p></p></section><section class="page" id="__rm_hap_core_memory_space_map_changed.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_core_memory_space_map_changed.html:__rm_hap_Core_Memory_Space_Map_Changed">Core_Memory_Space_Map_Changed</a></h1>
<p>

<a id="__rm_hap_core_memory_space_map_changed.html:Core_Memory_Space_Map_Changed"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Experimental</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj);</pre><p>
</p></dd>
</dl><p></p></section><section class="page" id="__rm_hap_core_mode_change.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_core_mode_change.html:__rm_hap_Core_Mode_Change">Core_Mode_Change</a></h1>
<p>

<a id="__rm_hap_core_mode_change.html:Core_Mode_Change"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered when a processor changes privilege mode for whatever reason; usually an exception or return from an exception. The hap occurs after the processor has changed mode but before any instructions have been executed in the new mode.
<p>
For x86 processors, the modes are Sim_CPU_Mode_User for CPL 3, and Sim_CPU_Mode_Supervisor for CPL 0-2.
</p><p>
For other processors, the modes are Sim_CPU_Mode_User or Sim_CPU_Mode_Supervisor. Some processors also has the Sim_CPU_Mode_Hypervisor mode.</p></dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj, int64 old_mode, 
         int64 new_mode);</pre><p>
</p></dd>
</dl><p></p></section><section class="page" id="__rm_hap_core_module_loaded.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_core_module_loaded.html:__rm_hap_Core_Module_Loaded">Core_Module_Loaded</a></h1>
<p>

<a id="__rm_hap_core_module_loaded.html:Core_Module_Loaded"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered when a module is loaded into Simics. Called in Global Context.</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj, char *module_name);</pre><p>
</p></dd>
</dl><p></p></section><section class="page" id="__rm_hap_core_multicore_acceleration_changed.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_core_multicore_acceleration_changed.html:__rm_hap_Core_Multicore_Acceleration_Changed">Core_Multicore_Acceleration_Changed</a></h1>
<p>

<a id="__rm_hap_core_multicore_acceleration_changed.html:Core_Multicore_Acceleration_Changed"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered when the multicore-accelerator feature is enabled or disabled.</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj, int on/off);</pre><p>
</p></dd>
</dl><p></p></section><section class="page" id="__rm_hap_core_multithreading_changed.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_core_multithreading_changed.html:__rm_hap_Core_Multithreading_Changed">Core_Multithreading_Changed</a></h1>
<p>

<a id="__rm_hap_core_multithreading_changed.html:Core_Multithreading_Changed"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered when multithreaded simulation is enabled or disabled.</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj, int on/off);</pre><p>
</p></dd>
</dl><p></p></section><section class="page" id="__rm_hap_core_not_implemented.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_core_not_implemented.html:__rm_hap_Core_Not_Implemented">Core_Not_Implemented</a></h1>
<p>

<a id="__rm_hap_core_not_implemented.html:Core_Not_Implemented"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered when the simulator encounters unimplemented functionality.</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj, int line, char *file, 
         char *rcsid, char *message, int64 data);</pre><p>
</p></dd>
</dl><p></p></section><section class="page" id="__rm_hap_core_preferences_changed.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_core_preferences_changed.html:__rm_hap_Core_Preferences_Changed">Core_Preferences_Changed</a></h1>
<p>

<a id="__rm_hap_core_preferences_changed.html:Core_Preferences_Changed"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered when an attribute in the prefs object is written. Called in Global Context.</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj);</pre><p>
</p></dd>
</dl><p></p></section><section class="page" id="__rm_hap_core_processor_schedule_changed.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_core_processor_schedule_changed.html:__rm_hap_Core_Processor_Schedule_Changed">Core_Processor_Schedule_Changed</a></h1>
<p>

<a id="__rm_hap_core_processor_schedule_changed.html:Core_Processor_Schedule_Changed"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered when the scheduling order of the processors has changed. Called in Global Context.</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj);</pre><p>
</p></dd>
</dl><p></p></section><section class="page" id="__rm_hap_core_project_changed.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_core_project_changed.html:__rm_hap_Core_Project_Changed">Core_Project_Changed</a></h1>
<p>

<a id="__rm_hap_core_project_changed.html:Core_Project_Changed"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered when a new Simics project directory is selected. Called in Global Context.</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj);</pre><p>
</p></dd>
</dl><p></p></section><section class="page" id="__rm_hap_core_simulation_mode_change.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_core_simulation_mode_change.html:__rm_hap_Core_Simulation_Mode_Change">Core_Simulation_Mode_Change</a></h1>
<p>

<a id="__rm_hap_core_simulation_mode_change.html:Core_Simulation_Mode_Change"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered when the simulation mode for the processor has changed.</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj, int simulation_mode);</pre><p>
</p></dd>
<dt class="jdocu_descitem"><b>Index</b></dt><dd class="jdocu_descitem">simulation_mode</dd>
</dl><p></p></section><section class="page" id="__rm_hap_core_simulation_stopped.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_core_simulation_stopped.html:__rm_hap_Core_Simulation_Stopped">Core_Simulation_Stopped</a></h1>
<p>

<a id="__rm_hap_core_simulation_stopped.html:Core_Simulation_Stopped"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered when the simulation stops. The <i>exception</i> argument will always be <code>SimExc_No_Exception</code>, and <i>error_string</i> will always be NULL. After this hap, simulation will not advance (triggering <code>Core_Continuation</code>) until <b><i>SIM_continue</i></b> is called again. Callbacks are called in Global Context.</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj, int64 exception, 
         char *error_string);</pre><p>
</p></dd>
<dt class="jdocu_descitem"><b>Index</b></dt><dd class="jdocu_descitem">exception</dd>
</dl><p></p></section><section class="page" id="__rm_hap_core_sync_instruction.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_core_sync_instruction.html:__rm_hap_Core_Sync_Instruction">Core_Sync_Instruction</a></h1>
<p>

<a id="__rm_hap_core_sync_instruction.html:Core_Sync_Instruction"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered when an synchronizing instruction is executed. The <i>type</i> parameter describe what kind of instruction is executing. Its encoding is specific to each architecture.
<p>
For SH, this hap is triggered when a <code>synco</code> instruction is executed. The type contains 0.
</p><p>
For SPARC-V9, this hap is triggered when a <code>membar</code> or <code>stbar</code> instruction is executed. For <code>membar</code>, the type contains the 7-bit field cmask|mmask specified in the instruction. For stbar, the type is 8 (equivalent to <code>membar #StoreStore</code>).
</p><p>
For x86, this hap is triggered when a <code>fence</code> instruction is executed. The type is set from the list provided by the <code>x86_sync_instruction_type_t</code> enum.</p></dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj, int64 type);</pre><p>
</p></dd>
<dt class="jdocu_descitem"><b>Index</b></dt><dd class="jdocu_descitem">type</dd>
</dl><p></p></section><section class="page" id="__rm_hap_core_timing_model_change.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_core_timing_model_change.html:__rm_hap_Core_Timing_Model_Change">Core_Timing_Model_Change</a></h1>
<p>

<a id="__rm_hap_core_timing_model_change.html:Core_Timing_Model_Change"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered on an object when a timing model or snoop device is inserted, deleted, or changed.</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj);</pre><p>
</p></dd>
</dl><p></p></section><section class="page" id="__rm_hap_core_user_comments_changed.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_core_user_comments_changed.html:__rm_hap_Core_User_Comments_Changed">Core_User_Comments_Changed</a></h1>
<p>

<a id="__rm_hap_core_user_comments_changed.html:Core_User_Comments_Changed"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered when the list of user comments for a session has changed</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj);</pre><p>
</p></dd>
</dl><p></p></section><section class="page" id="__rm_hap_eth_injector_pcap_eof.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_eth_injector_pcap_eof.html:__rm_hap_Eth_Injector_Pcap_Eof">Eth_Injector_Pcap_Eof</a></h1>
<p>

<a id="__rm_hap_eth_injector_pcap_eof.html:Eth_Injector_Pcap_Eof"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered by the <b>eth_injector</b> object when all contents of the pcap file has been sent. The callback function will have the pcap file name, next packet index, total number of packets in the pcap file, and auto-restart as arguments.</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj, char *pcap_file, 
         int num_injected, int pcap_num_pkgs, 
         int auto_restart);</pre><p>
</p></dd>
</dl><p></p></section><section class="page" id="__rm_hap_firewire_reset.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_firewire_reset.html:__rm_hap_Firewire_Reset">Firewire_Reset</a></h1>
<p>

<a id="__rm_hap_firewire_reset.html:Firewire_Reset"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered when the bus is reset. It is invoked after calculating the default topology. During the hap the self_ids attribute can be used to change the self id packets sent to the devices on the bus. The connected_devices attribute can also be changed to modify the mapping from physical id to device.</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj);</pre><p>
</p></dd>
</dl><p></p></section><section class="page" id="__rm_hap_firewire_transfer.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_firewire_transfer.html:__rm_hap_Firewire_Transfer">Firewire_Transfer</a></h1>
<p>

<a id="__rm_hap_firewire_transfer.html:Firewire_Transfer"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered when an packet travels through a firewire bus. During the hap handler the current_transfer attribute of the bus can be used to inspect and/or change the current transfer. If you set it to NULL the transfer is aborted and Firewire_V2_Ack_No_Ack is returned to the initiator of the transfer.</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj);</pre><p>
</p></dd>
</dl><p></p></section><section class="page" id="__rm_hap_gfx_break.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_gfx_break.html:__rm_hap_Gfx_Break">Gfx_Break</a></h1>
<p>

<a id="__rm_hap_gfx_break.html:Gfx_Break"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered when a graphical breakpoint matches the screen. <i>break_id</i> is the number returned when a breakpoint is set.</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj, int64 gfx_break);</pre><p>
</p></dd>
<dt class="jdocu_descitem"><b>Index</b></dt><dd class="jdocu_descitem">break_id</dd>
</dl><p></p></section><section class="page" id="__rm_hap_internal_break_io.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_internal_break_io.html:__rm_hap_Internal_Break_IO">Internal_Break_IO</a></h1>
<p>

<a id="__rm_hap_internal_break_io.html:Internal_Break_IO"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Simics internal. Triggered on a break-io access.</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj, int break-id);</pre><p>
</p></dd>
</dl><p></p></section><section class="page" id="__rm_hap_internal_device_reg_access.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_internal_device_reg_access.html:__rm_hap_Internal_Device_Reg_Access">Internal_Device_Reg_Access</a></h1>
<p>

<a id="__rm_hap_internal_device_reg_access.html:Internal_Device_Reg_Access"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Simics internal. Triggered on an access to a device register traced with <b>trace-io</b> command.</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj, 
         generic_transaction_t *memop, char *port, int idx, 
         int func, int64 offset);</pre><p>
</p></dd>
</dl><p></p></section><section class="page" id="__rm_hap_internal_sb_wait.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_internal_sb_wait.html:__rm_hap_Internal_SB_Wait">Internal_SB_Wait</a></h1>
<p>

<a id="__rm_hap_internal_sb_wait.html:Internal_SB_Wait"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Simics internal</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj);</pre><p>
</p></dd>
<dt class="jdocu_descitem"><b>Index</b></dt><dd class="jdocu_descitem">id</dd>
</dl><p></p></section><section class="page" id="__rm_hap_internal_time_quantum_changed.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_internal_time_quantum_changed.html:__rm_hap_Internal_Time_Quantum_Changed">Internal_Time_Quantum_Changed</a></h1>
<p>

<a id="__rm_hap_internal_time_quantum_changed.html:Internal_Time_Quantum_Changed"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Simics internal. Triggered when the time quantum has changed. The hap is supported in Simics 5 even though it is marked as internal.</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj);</pre><p>
</p></dd>
</dl><p></p></section><section class="page" id="__rm_hap_realtime_enabled.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_realtime_enabled.html:__rm_hap_Realtime_Enabled">Realtime_Enabled</a></h1>
<p>

<a id="__rm_hap_realtime_enabled.html:Realtime_Enabled"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Internal: Notifies change of realtime enabled status</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj, int enabled);</pre><p>
</p></dd>
</dl><p></p></section><section class="page" id="__rm_hap_rtc_nvram_update.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_rtc_nvram_update.html:__rm_hap_RTC_Nvram_Update">RTC_Nvram_Update</a></h1>
<p>

<a id="__rm_hap_rtc_nvram_update.html:RTC_Nvram_Update"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This hap is triggered when the DS12887-c NVRAM memory is changed.</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj, int64 index, 
         int64 old_value, int64 new_value);</pre><p>
</p></dd>
<dt class="jdocu_descitem"><b>Index</b></dt><dd class="jdocu_descitem">index</dd>
</dl><p></p></section><section class="page" id="__rm_hap_scsi_disk_command.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_scsi_disk_command.html:__rm_hap_SCSI_Disk_Command">SCSI_Disk_Command</a></h1>
<p>

<a id="__rm_hap_scsi_disk_command.html:SCSI_Disk_Command"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered when a SCSI command is received by a SCSI device. The parameters <i>start</i> and <i>len</i> are only used for read and write commands.</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj, int64 command_number, 
         int64 start, int64 len);</pre><p>
</p></dd>
<dt class="jdocu_descitem"><b>Index</b></dt><dd class="jdocu_descitem">command_number</dd>
</dl><p></p></section><section class="page" id="__rm_hap_sn_napt_enabled.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_sn_napt_enabled.html:__rm_hap_SN_NAPT_Enabled">SN_NAPT_Enabled</a></h1>
<p>

<a id="__rm_hap_sn_napt_enabled.html:SN_NAPT_Enabled"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered when NAPT is enabled or disabled in a service-node.The argument is 0 when disabled and 1 when enabled.</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj, int enabled);</pre><p>
</p></dd>
</dl><p></p></section><section class="page" id="__rm_hap_tlb_fill_data.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_tlb_fill_data.html:__rm_hap_TLB_Fill_Data">TLB_Fill_Data</a></h1>
<p>

<a id="__rm_hap_tlb_fill_data.html:TLB_Fill_Data"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered when a TLB entry is filled after a table walk. Page size encoding: 0==4k, 1==2M, 2==4M, 3==1G.</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj, int64 linear, 
         int64 physical, int64 page_size);</pre><p>
</p></dd>
<dt class="jdocu_descitem"><b>Index</b></dt><dd class="jdocu_descitem">page_size</dd>
</dl><p></p></section><section class="page" id="__rm_hap_tlb_fill_instruction.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_tlb_fill_instruction.html:__rm_hap_TLB_Fill_Instruction">TLB_Fill_Instruction</a></h1>
<p>

<a id="__rm_hap_tlb_fill_instruction.html:TLB_Fill_Instruction"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered when a TLB entry is filled after a table walk. Page size encoding: 0==4k, 1==2M, 2==4M, 3==1G.</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj, int64 linear, 
         int64 physical, int64 page_size);</pre><p>
</p></dd>
<dt class="jdocu_descitem"><b>Index</b></dt><dd class="jdocu_descitem">page_size</dd>
</dl><p></p></section><section class="page" id="__rm_hap_tlb_invalidate_data.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_tlb_invalidate_data.html:__rm_hap_TLB_Invalidate_Data">TLB_Invalidate_Data</a></h1>
<p>

<a id="__rm_hap_tlb_invalidate_data.html:TLB_Invalidate_Data"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered when a TLB entry is invalidated. The invalidation can be caused by an INVLPG instruction, a write to CR3, or by changes to paging bits in CR0 and CR4. Page size encoding: 0==4k, 1==2M, 2==4M, 3==1G.</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj, int64 linear, 
         int64 physical, int64 page_size);</pre><p>
</p></dd>
<dt class="jdocu_descitem"><b>Index</b></dt><dd class="jdocu_descitem">page_size</dd>
</dl><p></p></section><section class="page" id="__rm_hap_tlb_invalidate_instruction.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_tlb_invalidate_instruction.html:__rm_hap_TLB_Invalidate_Instruction">TLB_Invalidate_Instruction</a></h1>
<p>

<a id="__rm_hap_tlb_invalidate_instruction.html:TLB_Invalidate_Instruction"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered when a TLB entry is invalidated. The invalidation can be caused by an INVLPG instruction, a write to CR3, or by changes to paging bits in CR0 and CR4. Page size encoding: 0==4k, 1==2M, 2==4M, 3==1G.</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj, int64 linear, 
         int64 physical, int64 page_size);</pre><p>
</p></dd>
<dt class="jdocu_descitem"><b>Index</b></dt><dd class="jdocu_descitem">page_size</dd>
</dl><p></p></section><section class="page" id="__rm_hap_tlb_miss_data.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_tlb_miss_data.html:__rm_hap_TLB_Miss_Data">TLB_Miss_Data</a></h1>
<p>

<a id="__rm_hap_tlb_miss_data.html:TLB_Miss_Data"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered when a DTLB miss occurs.</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj, int64 linear_address);</pre><p>
</p></dd>
<dt class="jdocu_descitem"><b>Index</b></dt><dd class="jdocu_descitem">linear_address</dd>
</dl><p></p></section><section class="page" id="__rm_hap_tlb_miss_instruction.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_tlb_miss_instruction.html:__rm_hap_TLB_Miss_Instruction">TLB_Miss_Instruction</a></h1>
<p>

<a id="__rm_hap_tlb_miss_instruction.html:TLB_Miss_Instruction"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered when an ITLB miss occurs.</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj, int64 linear_address);</pre><p>
</p></dd>
<dt class="jdocu_descitem"><b>Index</b></dt><dd class="jdocu_descitem">linear_address</dd>
</dl><p></p></section><section class="page" id="__rm_hap_tlb_replace_data.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_tlb_replace_data.html:__rm_hap_TLB_Replace_Data">TLB_Replace_Data</a></h1>
<p>

<a id="__rm_hap_tlb_replace_data.html:TLB_Replace_Data"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This hap is triggered when a TLB entry is replaced by another. The parameters relate to the old entry, and the insertion of the new entry will trigger a fill hap. Page size encoding: 0==4k, 1==2M, 2==4M, 3==1G.</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj, int64 linear, 
         int64 physical, int64 page_size);</pre><p>
</p></dd>
<dt class="jdocu_descitem"><b>Index</b></dt><dd class="jdocu_descitem">page_size</dd>
</dl><p></p></section><section class="page" id="__rm_hap_tlb_replace_instruction.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_tlb_replace_instruction.html:__rm_hap_TLB_Replace_Instruction">TLB_Replace_Instruction</a></h1>
<p>

<a id="__rm_hap_tlb_replace_instruction.html:TLB_Replace_Instruction"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">This hap is triggered when a TLB entry is replaced by another. The parameters relate to the old entry, and the insertion of the new entry will trigger a fill hap. Page size encoding: 0==4k, 1==2M, 2==4M, 3==1G.</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj, int64 linear, 
         int64 physical, int64 page_size);</pre><p>
</p></dd>
<dt class="jdocu_descitem"><b>Index</b></dt><dd class="jdocu_descitem">page_size</dd>
</dl><p></p></section><section class="page" id="__rm_hap_ui_run_state_changed.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_ui_run_state_changed.html:__rm_hap_UI_Run_State_Changed">UI_Run_State_Changed</a></h1>
<p>

<a id="__rm_hap_ui_run_state_changed.html:UI_Run_State_Changed"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered when the run state changes; not triggered in batch mode. The argument is one of:<dl><dt id="__rm_hap_ui_run_state_changed.html:dt:stopped"><a href="#__rm_hap_ui_run_state_changed.html:dt:stopped"><b><code>"Stopped"</code></b></a></dt><dd>simulation stopped and may not run</dd><dt id="__rm_hap_ui_run_state_changed.html:dt:stopped_fwd"><a href="#__rm_hap_ui_run_state_changed.html:dt:stopped_fwd"><b><code>"Stopped_Fwd"</code></b></a></dt><dd>stopped and may run forward</dd><dt id="__rm_hap_ui_run_state_changed.html:dt:forwarding"><a href="#__rm_hap_ui_run_state_changed.html:dt:forwarding"><b><code>"Forwarding"</code></b></a></dt><dd>simulation is running forward</dd></dl><p></p></dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj, char *state);</pre><p>
</p></dd>
</dl><p></p></section><section class="page" id="__rm_hap_vga_refresh_triggered.html"><h1 class="jdocu"><a class="not-numbered" id="__rm_hap_vga_refresh_triggered.html:__rm_hap_Vga_Refresh_Triggered">Vga_Refresh_Triggered</a></h1>
<p>

<a id="__rm_hap_vga_refresh_triggered.html:Vga_Refresh_Triggered"></a></p><dl class="jdocu_di">
<dt class="jdocu_descitem">Description</dt><dd class="jdocu_descitem">Triggered before picture on screen is updated</dd>
<dt class="jdocu_descitem"><b>Callback Type</b></dt><dd class="jdocu_descitem"><pre class="jdocu_small">void (*)(lang_void *callback_data, 
         conf_object_t *trigger_obj);</pre><p>
</p></dd>
</dl><p></p></section>